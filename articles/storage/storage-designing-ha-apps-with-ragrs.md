---
title: "Azure-írásvédett Georedundáns tárolás (RA-GRS) használatával magas rendelkezésre álló alkalmazások aaaDesigning |} Microsoft Docs"
description: "Hogyan toouse Azure-RA-GRS tárolási tooarchitect egy magas rendelkezésre állású rugalmas alkalmazás elég toohandle kimaradások esetén."
services: storage
documentationcenter: .net
author: robinsh
manager: timlt
editor: tysonn
ms.assetid: 8f040b0f-8926-4831-ac07-79f646f31926
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: dotnet
ms.topic: article
ms.date: 1/19/2017
ms.author: robinsh
ms.openlocfilehash: e4a9fe7ef33eecd894408b3c1ef59920a248d1bd
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 10/06/2017
---
# <a name="designing-highly-available-applications-using-ra-grs"></a><span data-ttu-id="73bad-103">RA-GRS használatával magas rendelkezésre álló alkalmazások megtervezése</span><span class="sxs-lookup"><span data-stu-id="73bad-103">Designing Highly Available Applications using RA-GRS</span></span>

<span data-ttu-id="73bad-104">A felhőalapú infrastruktúrák közös szolgáltatása a magas rendelkezésre állású platform biztosítják az alkalmazások tárolására szolgáló.</span><span class="sxs-lookup"><span data-stu-id="73bad-104">A common feature of cloud-based infrastructures is that they provide a highly available platform for hosting applications.</span></span> <span data-ttu-id="73bad-105">A felhőalapú alkalmazások fejlesztők figyelembe kell vennie gondosan hogyan tooleverage a platform toodeliver magas rendelkezésre állású alkalmazások tootheir felhasználók.</span><span class="sxs-lookup"><span data-stu-id="73bad-105">Developers of cloud-based applications must consider carefully how tooleverage this platform toodeliver highly available applications tootheir users.</span></span> <span data-ttu-id="73bad-106">Ez a cikk kifejezetten a fejlesztők használatát hello Azure Storage írásvédett Georedundáns redundáns tárolás (RA-GRS) toomake foglalkozik a több elérhető alkalmazások.</span><span class="sxs-lookup"><span data-stu-id="73bad-106">This article focuses specifically on how developers can use hello Azure Storage Read Access Geo Redundant Storage (RA-GRS) toomake their applications more available.</span></span>

<span data-ttu-id="73bad-107">A redundancia érdekében – LRS (helyileg redundáns tárolás), a zrs-t (zóna redundáns tárolás), a GRS (Georedundáns tárolás) és az RA-GRS (írásvédett Georedundáns tárolás) négy lehetősége van.</span><span class="sxs-lookup"><span data-stu-id="73bad-107">There are four choices for redundancy – LRS (Locally Redundant Storage), ZRS (Zone Redundant Storage), GRS (Geo-Redundant Storage), and RA-GRS (Read Access Geo-Redundant Storage).</span></span> <span data-ttu-id="73bad-108">Toodiscuss GRS és az RA-GRS ebben a cikkben fogjuk.</span><span class="sxs-lookup"><span data-stu-id="73bad-108">We are going toodiscuss GRS and RA-GRS in this article.</span></span> <span data-ttu-id="73bad-109">A GRS az adatok három példányban tárolják hello storage-fiók beállítása során kiválasztott hello elsődleges régióban.</span><span class="sxs-lookup"><span data-stu-id="73bad-109">With GRS, three copies of your data are kept in hello primary region you selected when setting up hello storage account.</span></span> <span data-ttu-id="73bad-110">Három további másolatokat aszinkron módon karbantartása az Azure által megadott másodlagos régióba.</span><span class="sxs-lookup"><span data-stu-id="73bad-110">Three additional copies are maintained asynchronously in a secondary region specified by Azure.</span></span> <span data-ttu-id="73bad-111">RA-GRS van hello ugyanaz, mint a Georedundáns, azzal a különbséggel, hogy a felhasználó rendelkezik olvasási jogosultsággal toohello másodlagos másolatával.</span><span class="sxs-lookup"><span data-stu-id="73bad-111">RA-GRS is hello same thing as GRS except that you have read access toohello secondary copy.</span></span> <span data-ttu-id="73bad-112">Hello különböző Azure Storage redundancia beállításokkal kapcsolatos további információkért lásd: [Azure Storage replikációs](https://docs.microsoft.com/en-us/azure/storage/storage-redundancy).</span><span class="sxs-lookup"><span data-stu-id="73bad-112">For more information about hello different Azure Storage redundancy options, see [Azure Storage replication](https://docs.microsoft.com/en-us/azure/storage/storage-redundancy).</span></span> <span data-ttu-id="73bad-113">hello replikációs cikket is hello párosítása hello elsődleges és másodlagos régiók jeleníti meg.</span><span class="sxs-lookup"><span data-stu-id="73bad-113">hello replication article also shows hello pairings of hello primary and secondary regions.</span></span>

<span data-ttu-id="73bad-114">Nincsenek kódtöredékek szerepelni fog ebben a cikkben, és egy hivatkozás tooa teljes mintát, töltse le, és futtassa hello végén.</span><span class="sxs-lookup"><span data-stu-id="73bad-114">There are code snippets included in this article, and a link tooa complete sample at hello end that you can download and run.</span></span>

## <a name="key-features-of-ra-grs"></a><span data-ttu-id="73bad-115">RA-GRS a kulcsfontosságú szolgáltatásokat</span><span class="sxs-lookup"><span data-stu-id="73bad-115">Key features of RA-GRS</span></span>

<span data-ttu-id="73bad-116">Előtt kapcsolatos döntésről toouse RA-GRS storage most szolgáltatással kapcsolatban a tulajdonságok és viselkedését.</span><span class="sxs-lookup"><span data-stu-id="73bad-116">Before we talk about how toouse RA-GRS storage, let's talk about its properties and behavior.</span></span>

* <span data-ttu-id="73bad-117">Az Azure Storage fenntart egy csak olvasható hello adatokat tárolja, az elsődleges régió egy másodlagos régióban; a fentiek szerint hello társzolgáltatás hello másodlagos régióba hello helyét határozza meg.</span><span class="sxs-lookup"><span data-stu-id="73bad-117">Azure Storage maintains a read-only copy of hello data you store in your primary region in a secondary region; as noted above, hello storage service determines hello location of hello secondary region.</span></span>

* <span data-ttu-id="73bad-118">hello írásvédett másolat [idővel konzisztenssé](https://en.wikipedia.org/wiki/Eventual_consistency) hello elsődleges régióban hello adatokkal.</span><span class="sxs-lookup"><span data-stu-id="73bad-118">hello read-only copy is [eventually consistent](https://en.wikipedia.org/wiki/Eventual_consistency) with hello data in hello primary region.</span></span>

* <span data-ttu-id="73bad-119">A blobot, táblát és üzenetsort, másodlagos régió hello lekérheti a *utolsó szinkronizálás* érték, amely jelzi, hogy mikor történt a legutóbbi replikáció hello hello elsődleges toohello másodlagos régióba.</span><span class="sxs-lookup"><span data-stu-id="73bad-119">For blobs, tables, and queues, you can query hello secondary region for a *Last Sync Time* value that tells you when hello last replication from hello primary toohello secondary region occurred.</span></span> <span data-ttu-id="73bad-120">(Ez nem támogatott az Azure File storage, amely jelenleg nem rendelkezik az RA-GRS redundancia.)</span><span class="sxs-lookup"><span data-stu-id="73bad-120">(This is not supported for Azure File storage, which doesn't have RA-GRS redundancy at this time.)</span></span>

* <span data-ttu-id="73bad-121">A Storage ügyféloldali kódtára toointeract hello vagy hello elsődleges vagy másodlagos régióban hello adatokkal is használhatja.</span><span class="sxs-lookup"><span data-stu-id="73bad-121">You can use hello Storage Client Library toointeract with hello data in either hello primary or secondary region.</span></span> <span data-ttu-id="73bad-122">Is átirányíthatja olvasási kérések automatikusan toohello másodlagos régióba Ha egy olvasási kérést toohello elsődleges régió időkorlátja lejár.</span><span class="sxs-lookup"><span data-stu-id="73bad-122">You can also redirect read requests automatically toohello secondary region if a read request toohello primary region times out.</span></span>

* <span data-ttu-id="73bad-123">Egy hello kisegítő hello adatok hello elsődleges régióban érintő jelentős probléma esetén hello Azure csapata indíthatnak földrajzi-feladatátvétel, amikor hello DNS-bejegyzések toohello elsődleges régió mutató lesz módosított toopoint toohello másodlagos régióba.</span><span class="sxs-lookup"><span data-stu-id="73bad-123">If there is a major issue affecting hello accessibility of hello data in hello primary region, hello Azure team may trigger a geo-failover, at which point hello DNS entries pointing toohello primary region will be changed toopoint toohello secondary region.</span></span>

* <span data-ttu-id="73bad-124">Egy földrajzi feladatátvétel esetén Azure lesz jelöljön ki egy új másodlagos helyet hello adatok toothat helyre replikálni, majd hello másodlagos DNS-bejegyzések tooit mutasson.</span><span class="sxs-lookup"><span data-stu-id="73bad-124">If a geo-failover occurs, Azure will select a new secondary location and replicate hello data toothat location, then point hello secondary DNS entries tooit.</span></span> <span data-ttu-id="73bad-125">hello másodlagos végpont nem érhető el, amíg hello tárfiók replikálása befejeződött.</span><span class="sxs-lookup"><span data-stu-id="73bad-125">hello secondary endpoint will be unavailable until hello storage account has finished replicating.</span></span> <span data-ttu-id="73bad-126">További információkért lásd: [egy Azure Storage tervezett kimaradás esetén milyen toodo](https://docs.microsoft.com/en-us/azure/storage/storage-disaster-recovery-guidance).</span><span class="sxs-lookup"><span data-stu-id="73bad-126">For more information, please see [What toodo if an Azure Storage outage occurs](https://docs.microsoft.com/en-us/azure/storage/storage-disaster-recovery-guidance).</span></span>

## <a name="application-design-considerations-when-using-ra-grs"></a><span data-ttu-id="73bad-127">RA-GRS használatakor alkalmazás kialakítási szempontok</span><span class="sxs-lookup"><span data-stu-id="73bad-127">Application design considerations when using RA-GRS</span></span>

<span data-ttu-id="73bad-128">Ez a cikk hello fő célja tooshow, hogyan toodesign toofunction továbbra is (bár a korlátozott kapacitás) még akkor is, az elsődleges adatok hello jelentős katasztrófa következik hello esemény alkalmazás center.</span><span class="sxs-lookup"><span data-stu-id="73bad-128">hello main purpose of this article is tooshow you how toodesign an application that will continue toofunction (albeit in a limited capacity) even in hello event of a major disaster at hello primary data center.</span></span> <span data-ttu-id="73bad-129">Ehhez az alkalmazás toohandle átmeneti vagy hosszú futású problémák rendelkező hello másodlagos régióban való váltás tooread, ha probléma van, és mód visszakapcsolását hello elsődleges régióban elérhető esetén újra.</span><span class="sxs-lookup"><span data-stu-id="73bad-129">You do this by having your application toohandle transient or long-running issues by switching tooread from hello secondary region while there is a problem, and switching back when hello primary region is available again.</span></span>

### <a name="using-eventually-consistent-data"></a><span data-ttu-id="73bad-130">Idővel konzisztenssé adatok használata</span><span class="sxs-lookup"><span data-stu-id="73bad-130">Using eventually consistent data</span></span>

<span data-ttu-id="73bad-131">Ez a javasolt megoldás feltételezi, hogy azt rendben tooreturn mi elavult adat toohello hívó alkalmazás lehet.</span><span class="sxs-lookup"><span data-stu-id="73bad-131">This proposed solution assumes that it is okay tooreturn what could be stale data toohello calling application.</span></span> <span data-ttu-id="73bad-132">Mivel hello másodlagos adatok idővel konzisztenssé, akkor előfordulhat, hogy hello adatok bejegyzésre kerültek-toohello elsődleges, de hello frissítés toohello másodlagos kellett nem fejezte be a replikálása, amikor elsődleges régió hello elérhetetlenné vált.</span><span class="sxs-lookup"><span data-stu-id="73bad-132">Because hello secondary data is eventually consistent, it is possible that hello data was written toohello primary but hello update toohello secondary had not finished replicating when hello primary region became inaccessible.</span></span>

<span data-ttu-id="73bad-133">Például az ügyfél sikerült elküldeni a sikeres frissítést, és elsődleges hello sikerült folytassa hello frissítés csak másodlagos propagált toohello.</span><span class="sxs-lookup"><span data-stu-id="73bad-133">For example, your customer could submit an update that is successful, and then hello primary could go down before hello update is propagated toohello secondary.</span></span> <span data-ttu-id="73bad-134">Ebben az esetben hello ügyfél kéri tooread hello vissza adatokat, részesül hello elavult adat frissítése hello adatok helyett.</span><span class="sxs-lookup"><span data-stu-id="73bad-134">In this case, if hello customer then asks tooread hello data back, he receives hello stale data instead of hello updated data.</span></span> <span data-ttu-id="73bad-135">Döntse el, ha ez elfogadható, és ha igen, hogyan hello ügyfél fog üzenet.</span><span class="sxs-lookup"><span data-stu-id="73bad-135">You must decide if this is acceptable, and if so, how you will message hello customer.</span></span> <span data-ttu-id="73bad-136">Láthatja, hogyan toocheck hello utolsó szinkronizálás hello másodlagos lévő adatokon, később ezen cikk toosee másodlagos hello naprakész esetén is.</span><span class="sxs-lookup"><span data-stu-id="73bad-136">You'll see how toocheck hello Last Sync Time on hello secondary data later in this article toosee if hello secondary is up-to-date.</span></span>

### <a name="handling-services-separately-or-all-together"></a><span data-ttu-id="73bad-137">Kezelési szolgáltatások, külön-külön vagy együtt</span><span class="sxs-lookup"><span data-stu-id="73bad-137">Handling services separately or all together</span></span>

<span data-ttu-id="73bad-138">Amíg nem valószínű, lehetőség egy szolgáltatás toobecome nem érhető el a míg hello más szolgáltatások továbbra is teljes körűen működik.</span><span class="sxs-lookup"><span data-stu-id="73bad-138">While not likely, it is possible for one service toobecome unavailable while hello other services are still fully functional.</span></span> <span data-ttu-id="73bad-139">Akkor is leíró hello újrapróbálkozások és írásvédett módban az egyes szolgáltatási külön-külön (BLOB, üzenetsorok, táblák), vagy minden hello tárolási szolgáltatások általános újrapróbálásainak együtt kezelheti.</span><span class="sxs-lookup"><span data-stu-id="73bad-139">You can handle hello retries and read-only mode for each service separately (blobs, queues, tables), or you can handle retries generically for all hello storage services together.</span></span>

<span data-ttu-id="73bad-140">Például ha az alkalmazás üzenetsorokat és blobokat használ, dönthet külön kódot toohandle Újrapróbálkozást lehetővé tevő hibák tooput minden egyes.</span><span class="sxs-lookup"><span data-stu-id="73bad-140">For example, if you use queues and blobs in your application, you may decide tooput in separate code toohandle retryable errors for each of these.</span></span> <span data-ttu-id="73bad-141">Majd ha ismételt próbálkozással lekérni hello blob szolgáltatástól, de hello queue szolgáltatás továbbra is működik, az alkalmazás, amely kezeli a blobok csak hello részét csökkenhet.</span><span class="sxs-lookup"><span data-stu-id="73bad-141">Then if you get a retry from hello blob service, but hello queue service is still working, only hello part of your application that handles blobs will be impacted.</span></span> <span data-ttu-id="73bad-142">Ha úgy dönt, minden társzolgáltatás újrapróbálja általános toohandle és egy hívás toohello blob szolgáltatás egy újrapróbálkozást lehetővé tevő hibát ad vissza, majd kérelmek tooboth hello blob és hello várólista szolgáltatás csökkenhet.</span><span class="sxs-lookup"><span data-stu-id="73bad-142">If you decide toohandle all storage service retries generically and a call toohello blob service returns a retryable error, then requests tooboth hello blob service and hello queue service will be impacted.</span></span>

<span data-ttu-id="73bad-143">Végül Ez függ az alkalmazás hello összetettsége.</span><span class="sxs-lookup"><span data-stu-id="73bad-143">Ultimately, this depends on hello complexity of your application.</span></span> <span data-ttu-id="73bad-144">Nem toohandle hello hibák szolgáltatás döntse el, de ehelyett tooredirect olvasási kérések összes tárolási szolgáltatások toohello másodlagos régióba és hello alkalmazás futtatásához csak olvasható módban, ha névváltozást észlel a társzolgáltatás probléma hello elsődleges régióban.</span><span class="sxs-lookup"><span data-stu-id="73bad-144">You may decide not toohandle hello failures by service, but instead tooredirect read requests for all storage services toohello secondary region and run hello application in read-only mode when you detect a problem with any storage service in hello primary region.</span></span>

### <a name="other-considerations"></a><span data-ttu-id="73bad-145">Egyéb szempontok</span><span class="sxs-lookup"><span data-stu-id="73bad-145">Other considerations</span></span>

<span data-ttu-id="73bad-146">A rendszer hello egyéb szempontok, ez a cikk többi hello ismertetik.</span><span class="sxs-lookup"><span data-stu-id="73bad-146">These are hello other considerations we will discuss in hello rest of this article.</span></span>

*   <span data-ttu-id="73bad-147">Az olvasási kérések hello áramköri megszakító minta használatával újrapróbálkozások kezelése</span><span class="sxs-lookup"><span data-stu-id="73bad-147">Handling retries of read requests using hello Circuit Breaker pattern</span></span>

*   <span data-ttu-id="73bad-148">Idővel konzisztenssé adatok és hello utolsó szinkronizálás</span><span class="sxs-lookup"><span data-stu-id="73bad-148">Eventually-consistent data and hello Last Sync Time</span></span>

*   <span data-ttu-id="73bad-149">Tesztelés</span><span class="sxs-lookup"><span data-stu-id="73bad-149">Testing</span></span>

## <a name="running-your-application-in-read-only-mode"></a><span data-ttu-id="73bad-150">Az alkalmazás csak olvasható módban fut</span><span class="sxs-lookup"><span data-stu-id="73bad-150">Running your application in read-only mode</span></span>

<span data-ttu-id="73bad-151">toouse RA-GRS tárolási, képes toohandle mindkét sikertelen olvasási kéréseket kell lenniük, és nem sikerült a frissítési kérelmek (ebben az esetben a beszúrások, a frissítések és törlések tehát frissítés).</span><span class="sxs-lookup"><span data-stu-id="73bad-151">toouse RA-GRS storage, you must be able toohandle both failed read requests and failed update requests (with update in this case meaning inserts, updates, and deletions).</span></span> <span data-ttu-id="73bad-152">Ha hello elsődleges data center meghiúsul, olvassa el a kérelmek lehet átirányított toohello másodlagos adatközpont, de a frissítési kérelmek nem lehetséges, mert hello másodlagos csak olvasható.</span><span class="sxs-lookup"><span data-stu-id="73bad-152">If hello primary data center fails, read requests can be redirected toohello secondary data center, but update requests cannot because hello secondary is read only.</span></span> <span data-ttu-id="73bad-153">Emiatt kell néhány módon toorun az alkalmazás csak olvasható módban.</span><span class="sxs-lookup"><span data-stu-id="73bad-153">For this reason, you need some way toorun your application in read-only mode.</span></span>

<span data-ttu-id="73bad-154">Megadhatja például, hogy a jelzőt, amely minden frissítési kérelmek toohello társzolgáltatás elküldés előtt ellenőrizni kell.</span><span class="sxs-lookup"><span data-stu-id="73bad-154">For example, you can set a flag that will be checked before submitting any update requests toohello storage service.</span></span> <span data-ttu-id="73bad-155">Ha egy hello frissítési kérelmek, hagyja ki, és térjen vissza az ügyfél egy megfelelő választ toohello.</span><span class="sxs-lookup"><span data-stu-id="73bad-155">When one of hello update requests comes through, you can skip it and return an appropriate response toohello customer.</span></span> <span data-ttu-id="73bad-156">Akkor is szeretné, hogy toodisable bizonyos funkciók elemet hello probléma megoldásáig, és értesítse a felhasználókat, hogy ezek nem átmenetileg nem érhető el.</span><span class="sxs-lookup"><span data-stu-id="73bad-156">You may even want toodisable certain features altogether until hello problem is resolved and notify users that those features are temporarily unavailable.</span></span>

<span data-ttu-id="73bad-157">Ha külön-külön toohandle hibák az egyes szolgáltatásokhoz, is szüksége lesz toohandle hello képességét toorun az alkalmazás csak olvasható módban szolgáltatás.</span><span class="sxs-lookup"><span data-stu-id="73bad-157">If you decide toohandle errors for each service separately, you will also need toohandle hello ability toorun your application in read-only mode by service.</span></span> <span data-ttu-id="73bad-158">Csak olvasható jelzők minden egyes szolgáltatás engedélyezhető legyen, és le van tiltva, és kezelni hello megfelelő jelző hello megfelelő helyen, a kódban.</span><span class="sxs-lookup"><span data-stu-id="73bad-158">You could have read-only flags for each service that can be enabled and disabled and handle hello appropriate flag in hello appropriate places in your code.</span></span>

<span data-ttu-id="73bad-159">Képes toorun alatt az alkalmazás csak olvasható módban van egy másik oldalán juttatás – biztosít hello képességét tooensure korlátozott üzemmódban a súlyos alkalmazás frissítése során.</span><span class="sxs-lookup"><span data-stu-id="73bad-159">Being able toorun your application in read-only mode has another side benefit – it gives you hello ability tooensure limited functionality during a major application upgrade.</span></span> <span data-ttu-id="73bad-160">Indíthat el az alkalmazás toorun csak olvasható módban és pont toohello másodlagos adatközpont, biztosítva, hogy senki sem adataihoz fér hozzá hello hello elsődleges régió frissítések létrehozása idejére.</span><span class="sxs-lookup"><span data-stu-id="73bad-160">You can trigger your application toorun in read-only mode and point toohello secondary data center, ensuring nobody is accessing hello data in hello primary region while you're making upgrades.</span></span>

## <a name="handling-updates-when-running-in-read-only-mode"></a><span data-ttu-id="73bad-161">Frissítések kezelése, csak olvasható módban történő futtatásakor</span><span class="sxs-lookup"><span data-stu-id="73bad-161">Handling updates when running in read-only mode</span></span>

<span data-ttu-id="73bad-162">Számos módon toohandle frissítési kérelmek csak olvasható módban történő futtatásakor.</span><span class="sxs-lookup"><span data-stu-id="73bad-162">There are many ways toohandle update requests when running in read-only mode.</span></span> <span data-ttu-id="73bad-163">Átfogó azt ne fedje ez, de általában többféle annak a figyelembe venni.</span><span class="sxs-lookup"><span data-stu-id="73bad-163">We won't cover this comprehensively, but generally, there are a couple of patterns that you consider.</span></span>

1.  <span data-ttu-id="73bad-164">Tooyour felhasználói válaszol, és közölje vele, jelenleg nem elfogadja frissítések.</span><span class="sxs-lookup"><span data-stu-id="73bad-164">You can respond tooyour user and tell them you are not currently accepting updates.</span></span> <span data-ttu-id="73bad-165">Például a kapcsolattartási rendszer sikerült engedélyezése az ügyfelek tooaccess kapcsolattartási adatokat, de nem a módosításokat.</span><span class="sxs-lookup"><span data-stu-id="73bad-165">For example, a contact management system could enable customers tooaccess contact information but not make updates.</span></span>

2.  <span data-ttu-id="73bad-166">A frissítések, egy másik régióban is sorba helyezni.</span><span class="sxs-lookup"><span data-stu-id="73bad-166">You can enqueue your updates in another region.</span></span> <span data-ttu-id="73bad-167">Ebben az esetben, ehhez írja be a függőben lévő frissítési kérelmek tooa sor egy másik régióban található, és már rendelkezik egy módon tooprocess ezeket a kérelmeket, miután újra online állapotba hello elsődleges adatközpont kerül.</span><span class="sxs-lookup"><span data-stu-id="73bad-167">In this case, you would write your pending update requests tooa queue in a different region, and then have a way tooprocess those requests after hello primary data center comes online again.</span></span> <span data-ttu-id="73bad-168">Ha ebben a forgatókönyvben hagyja, hello ügyfél tudja, hogy a kért hello update várakozik későbbi feldolgozás céljából.</span><span class="sxs-lookup"><span data-stu-id="73bad-168">In this scenario, you should let hello customer know that hello update requested is queued for later processing.</span></span>

3.  <span data-ttu-id="73bad-169">Írhat a frissítések tooa tárfiók más régióban.</span><span class="sxs-lookup"><span data-stu-id="73bad-169">You can write your updates tooa storage account in another region.</span></span> <span data-ttu-id="73bad-170">Majd ha hello elsődleges adatközpont ismét online elérhető lesz, akkor egy módon toomerge hello elsődleges adatokká, attól függően, hogy hello adatok szerkezete hello frissítések.</span><span class="sxs-lookup"><span data-stu-id="73bad-170">Then when hello primary data center comes back online, you can have a way toomerge those updates into hello primary data, depending on hello structure of hello data.</span></span> <span data-ttu-id="73bad-171">Például külön fájlok hello nevét egy dátum-/ időbélyeg létrehozásakor, másolhatja ezen fájlok hátsó toohello elsődleges régióban.</span><span class="sxs-lookup"><span data-stu-id="73bad-171">For example, if you are creating separate files with a date/time stamp in hello name, you can copy those files back toohello primary region.</span></span> <span data-ttu-id="73bad-172">Ez a módszer egyes munkaterhelések, például a naplózás és az iOT.</span><span class="sxs-lookup"><span data-stu-id="73bad-172">This works for some workloads such as logging and iOT data.</span></span>

## <a name="handling-retries"></a><span data-ttu-id="73bad-173">Az újrapróbálkozások kezelése</span><span class="sxs-lookup"><span data-stu-id="73bad-173">Handling retries</span></span>

<span data-ttu-id="73bad-174">Hogyan tudja megállapítani, mely hibák Újrapróbálkozást lehetővé tevő?</span><span class="sxs-lookup"><span data-stu-id="73bad-174">How do you know which errors are retryable?</span></span> <span data-ttu-id="73bad-175">Ez határozza meg hello a storage ügyféloldali kódtára.</span><span class="sxs-lookup"><span data-stu-id="73bad-175">This is determined by hello storage client library.</span></span> <span data-ttu-id="73bad-176">Például 404 hibaüzenetet (az erőforrás nem található) nincs Újrapróbálkozást lehetővé tevő mert újrapróbálkozás, nem valószínű tooresult a sikeres.</span><span class="sxs-lookup"><span data-stu-id="73bad-176">For example, a 404 error (resource not found) is not retryable because retrying it is not likely tooresult in success.</span></span> <span data-ttu-id="73bad-177">A hello, ugyanakkor 500 hiba oka az újrapróbálkozást lehetővé tevő kiszolgálóhiba, és egyszerűen lehet, hogy átmeneti jellegű probléma.</span><span class="sxs-lookup"><span data-stu-id="73bad-177">On hello other hand, a 500 error is retryable because it is a server error, and it may simply be a transient issue.</span></span> <span data-ttu-id="73bad-178">További részletekért tekintse meg a hello [nyissa meg a hello ExponentialRetry osztály forráskódja](https://github.com/Azure/azure-storage-net/blob/87b84b3d5ee884c7adc10e494e2c7060956515d0/Lib/Common/RetryPolicies/ExponentialRetry.cs) hello .NET a storage ügyféloldali kódtára a.</span><span class="sxs-lookup"><span data-stu-id="73bad-178">For more details, check out hello [open source code for hello ExponentialRetry class](https://github.com/Azure/azure-storage-net/blob/87b84b3d5ee884c7adc10e494e2c7060956515d0/Lib/Common/RetryPolicies/ExponentialRetry.cs) in hello .NET storage client library.</span></span> <span data-ttu-id="73bad-179">(Hello ShouldRetry metódus keressen.)</span><span class="sxs-lookup"><span data-stu-id="73bad-179">(Look for hello ShouldRetry method.)</span></span>

### <a name="read-requests"></a><span data-ttu-id="73bad-180">Olvasási kérések</span><span class="sxs-lookup"><span data-stu-id="73bad-180">Read requests</span></span>

<span data-ttu-id="73bad-181">Olvasási kérések lehet átirányított toosecondary tárolási, ha az elsődleges storage probléma van.</span><span class="sxs-lookup"><span data-stu-id="73bad-181">Read requests can be redirected toosecondary storage if there is a problem with primary storage.</span></span> <span data-ttu-id="73bad-182">Szerint azt a fentiekben leírtuk a [idővel azonos adatokat használó](#using-eventually-consistent-data), azt kell elfogadható az alkalmazás toopotentially elavult adatokat olvasni.</span><span class="sxs-lookup"><span data-stu-id="73bad-182">As noted above in [Using Eventually Consistent Data](#using-eventually-consistent-data), it must be acceptable for your application toopotentially read stale data.</span></span> <span data-ttu-id="73bad-183">Ha hello tárolási ügyfél könyvtár tooaccess RA-GRS adatokat használ, hello újrapróbálási viselkedése olvasási kérelem hello értékének beállításával megadhatja **LocationMode** tulajdonság tooone hello alábbi:</span><span class="sxs-lookup"><span data-stu-id="73bad-183">If you are using hello storage client library tooaccess RA-GRS data, you can specify hello retry behavior of a read request by setting a value for hello **LocationMode** property tooone of hello following:</span></span>

*   <span data-ttu-id="73bad-184">**PrimaryOnly** (hello alapértelmezett)</span><span class="sxs-lookup"><span data-stu-id="73bad-184">**PrimaryOnly** (hello default)</span></span>

*   <span data-ttu-id="73bad-185">**PrimaryThenSecondary**</span><span class="sxs-lookup"><span data-stu-id="73bad-185">**PrimaryThenSecondary**</span></span>

*   <span data-ttu-id="73bad-186">**SecondaryOnly**</span><span class="sxs-lookup"><span data-stu-id="73bad-186">**SecondaryOnly**</span></span>

*   <span data-ttu-id="73bad-187">**SecondaryThenPrimary**</span><span class="sxs-lookup"><span data-stu-id="73bad-187">**SecondaryThenPrimary**</span></span>

<span data-ttu-id="73bad-188">Hello beállításakor **LocationMode** túl**PrimaryThenSecondary**, ha hello kezdeti olvasási kérelem toohello elsődleges végpont Újrapróbálkozást lehetővé tevő hiba miatt nem sikerül, akkor hello ügyfél automatikusan lehetővé teszi egy másik olvasása másodlagos végponti toohello kérelmet.</span><span class="sxs-lookup"><span data-stu-id="73bad-188">When you set hello **LocationMode** too**PrimaryThenSecondary**, if hello initial read request toohello primary endpoint fails with a retryable error, hello client automatically makes another read request toohello secondary endpoint.</span></span> <span data-ttu-id="73bad-189">Ha hello hiba: a kiszolgáló időkorlátja, majd hello ügyfél lesz a hello időtúllépés tooexpire toowait előtt hello szolgáltatás megkapja a Újrapróbálkozást lehetővé tevő hiba.</span><span class="sxs-lookup"><span data-stu-id="73bad-189">If hello error is a server timeout, then hello client will have toowait for hello timeout tooexpire before it receives a retryable error from hello service.</span></span>

<span data-ttu-id="73bad-190">Amikor arról dönt van alapvetően két esetben tooconsider hogyan toorespond tooa Újrapróbálkozást lehetővé tevő hiba:</span><span class="sxs-lookup"><span data-stu-id="73bad-190">There are basically two scenarios tooconsider when you are deciding how toorespond tooa retryable error:</span></span>

*   <span data-ttu-id="73bad-191">Ez egy elkülönített probléma és kérelmeknél toohello elsődleges végpont nem ad vissza egy újrapróbálkozást lehetővé tevő hiba.</span><span class="sxs-lookup"><span data-stu-id="73bad-191">This is an isolated problem and subsequent requests toohello primary endpoint will not return a retryable error.</span></span> <span data-ttu-id="73bad-192">Egy példa, ahol ez akkor fordulhat elő, amikor egy átmeneti hálózati hiba.</span><span class="sxs-lookup"><span data-stu-id="73bad-192">An example of where this might happen is when there is a transient network error.</span></span>

    <span data-ttu-id="73bad-193">Ilyen esetben van nincs jelentős teljesítményét rendelkező **LocationMode** túl beállítása**PrimaryThenSecondary** , ez csak akkor fordul elő ritkán.</span><span class="sxs-lookup"><span data-stu-id="73bad-193">In this scenario, there is no significant performance penalty in having **LocationMode** set too**PrimaryThenSecondary** as this only happens infrequently.</span></span>

*   <span data-ttu-id="73bad-194">A probléma legalább egy hello tárolószolgáltatások hello elsődleges régióban és minden későbbi kérelmeket toothat szolgáltatás hello elsődleges régióban valószínűleg tooreturn Újrapróbálkozást lehetővé tevő hibák egy ideig.</span><span class="sxs-lookup"><span data-stu-id="73bad-194">This is a problem with at least one of hello storage services in hello primary region and all subsequent requests toothat service in hello primary region are likely tooreturn retryable errors for a period of time.</span></span> <span data-ttu-id="73bad-195">Egy példa erre, ha hello elsődleges régió nem teljesen érhető el.</span><span class="sxs-lookup"><span data-stu-id="73bad-195">An example of this is if hello primary region is completely inaccessible.</span></span>

    <span data-ttu-id="73bad-196">Ebben a forgatókönyvben nincs rendszer teljesítményét, mert az olvasási kéréseket fog előbb a hello elsődleges végpont, hello időtúllépés tooexpire várja meg, majd toohello másodlagos végponti váltani.</span><span class="sxs-lookup"><span data-stu-id="73bad-196">In this scenario, there is a performance penalty because all your read requests will try hello primary endpoint first, wait for hello timeout tooexpire, then switch toohello secondary endpoint.</span></span>

<span data-ttu-id="73bad-197">Ezek a forgatókönyvek esetén meg kell határoznia, amely nincs hello elsődleges végpont folyamatban lévő problémát, és küldése az összes olvasási kérések közvetlen toohello másodlagos végpont úgy, hogy hello **LocationMode** tulajdonság túl **SecondaryOnly**.</span><span class="sxs-lookup"><span data-stu-id="73bad-197">For these scenarios, you should identify that there is an ongoing issue with hello primary endpoint and send all read requests directly toohello secondary endpoint by setting hello **LocationMode** property too**SecondaryOnly**.</span></span> <span data-ttu-id="73bad-198">Ilyenkor meg kell változtatni hello alkalmazás toorun csak olvasható módban is.</span><span class="sxs-lookup"><span data-stu-id="73bad-198">At this time, you should also change hello application toorun in read-only mode.</span></span> <span data-ttu-id="73bad-199">Ezt a módszert nevezik hello [áramköri megszakító mintát](https://msdn.microsoft.com/library/dn589784.aspx).</span><span class="sxs-lookup"><span data-stu-id="73bad-199">This approach is known as hello [Circuit Breaker Pattern](https://msdn.microsoft.com/library/dn589784.aspx).</span></span>

### <a name="update-requests"></a><span data-ttu-id="73bad-200">Frissítési kérelmek</span><span class="sxs-lookup"><span data-stu-id="73bad-200">Update requests</span></span>

<span data-ttu-id="73bad-201">hello áramköri megszakító mintát alkalmazott tooupdate kérelmeket is lehet.</span><span class="sxs-lookup"><span data-stu-id="73bad-201">hello Circuit Breaker pattern can also be applied tooupdate requests.</span></span> <span data-ttu-id="73bad-202">Azonban a frissítési kérelmet nem lehet átirányított toosecondary tárolóról, ami csak olvasható.</span><span class="sxs-lookup"><span data-stu-id="73bad-202">However, update requests cannot be redirected toosecondary storage, which is read-only.</span></span> <span data-ttu-id="73bad-203">Ezeket a kéréseket a hello hagyja **LocationMode** tulajdonsága túl**PrimaryOnly** (hello alapértelmezett).</span><span class="sxs-lookup"><span data-stu-id="73bad-203">For these requests, you should leave hello **LocationMode** property set too**PrimaryOnly** (hello default).</span></span> <span data-ttu-id="73bad-204">toohandle ezeket a hibákat a metrika toothese kérések – például olyan sorok esetén – 10 hibák alkalmazni, és a küszöbérték teljesülésekor váltás hello alkalmazás csak olvasható módba.</span><span class="sxs-lookup"><span data-stu-id="73bad-204">toohandle these errors, you can apply a metric toothese requests – such as 10 failures in a row – and when your threshold is met, switch hello application into read-only mode.</span></span> <span data-ttu-id="73bad-205">Használhat hello ugyanazokat a módszereket tooupdate üzemmódban, mint a következő szakaszban hello hello áramköri megszakító mintát kapcsolatos az alábbiakban visszaküldésére használatos.</span><span class="sxs-lookup"><span data-stu-id="73bad-205">You can use hello same methods for returning tooupdate mode as those described below in hello next section about hello Circuit Breaker pattern.</span></span>

## <a name="circuit-breaker-pattern"></a><span data-ttu-id="73bad-206">Áramköri megszakító minta</span><span class="sxs-lookup"><span data-stu-id="73bad-206">Circuit Breaker pattern</span></span>

<span data-ttu-id="73bad-207">Hello áramköri megszakító minta használatával az alkalmazás képes megakadályozni azt egy művelet várható toofail ismételten megpróbálná.</span><span class="sxs-lookup"><span data-stu-id="73bad-207">Using hello Circuit Breaker pattern in your application can prevent it from retrying an operation that is likely toofail repeatedly.</span></span> <span data-ttu-id="73bad-208">Ezen idő foglalnak, amíg hello műveletet a rendszer ismét megkísérli exponenciálisan helyett hello alkalmazás toocontinue toorun lehetővé teszi.</span><span class="sxs-lookup"><span data-stu-id="73bad-208">It allows hello application toocontinue toorun rather than taking up time while hello operation is retried exponentially.</span></span> <span data-ttu-id="73bad-209">Azt is észleli, ha hello hiba kijavítása, amelynél hello alkalmazása próbálkozhat hello műveletet.</span><span class="sxs-lookup"><span data-stu-id="73bad-209">It also detects when hello fault has been fixed, at which time hello application can try hello operation again.</span></span>

### <a name="how-tooimplement-hello-circuit-breaker-pattern"></a><span data-ttu-id="73bad-210">Hogyan tooimplement hello áramköri megszakító minta</span><span class="sxs-lookup"><span data-stu-id="73bad-210">How tooimplement hello circuit breaker pattern</span></span>

<span data-ttu-id="73bad-211">tooidentify elsődleges végpont folyamatban lévő hibát, a figyelheti, hogy milyen gyakran hello ügyfél Újrapróbálkozást lehetővé tevő hibát észlel.</span><span class="sxs-lookup"><span data-stu-id="73bad-211">tooidentify that there is an ongoing problem with a primary endpoint, you can monitor how frequently hello client encounters retryable errors.</span></span> <span data-ttu-id="73bad-212">Mivel minden egyes eset különböző, hogy rendelkezik-e toodecide hello küszöbérték a toouse szánt hello döntési tooswitch toohello másodlagos végponti és hello alkalmazás futtatásához csak olvasható módban.</span><span class="sxs-lookup"><span data-stu-id="73bad-212">Because each case is different, you have toodecide on hello threshold you want toouse for hello decision tooswitch toohello secondary endpoint and run hello application in read-only mode.</span></span> <span data-ttu-id="73bad-213">Például sikertelen eldöntheti, tooperform hello kapcsoló Ha 10 hibák szerepel egy nem sikeres rendelkező sor.</span><span class="sxs-lookup"><span data-stu-id="73bad-213">For example, you could decide tooperform hello switch if there are 10 failures in a row with no successes.</span></span> <span data-ttu-id="73bad-214">Egy másik példa tooswitch esetén 90 %-a 2 perces időtartamra hello kérelem nem.</span><span class="sxs-lookup"><span data-stu-id="73bad-214">Another example is tooswitch if 90% of hello requests in a 2-minute period fail.</span></span>

<span data-ttu-id="73bad-215">A hello első esetben egyszerűen egy hello hibáinak száma tárolhatja, és ha elérése előtt sikeres hello maximális, beállíthatja hello száma hátsó toozero.</span><span class="sxs-lookup"><span data-stu-id="73bad-215">For hello first scenario, you can simply keep a count of hello failures, and if there is a success before reaching hello maximum, set hello count back toozero.</span></span> <span data-ttu-id="73bad-216">Hello a második forgatókönyvben toouse egyirányú tooimplement hello MemoryCache objektumban (.NET).</span><span class="sxs-lookup"><span data-stu-id="73bad-216">For hello second scenario, one way tooimplement it is toouse hello MemoryCache object (in .NET).</span></span> <span data-ttu-id="73bad-217">Az egyes kérelmek CacheItem toohello gyorsítótár hozzáadása, hello érték toosuccess (1) beállítása sikertelen (0), illetve hello lejárati idő too2 perc beállítása most (vagy bármilyen az időkorlát).</span><span class="sxs-lookup"><span data-stu-id="73bad-217">For each request, add a CacheItem toohello cache, set hello value toosuccess (1) or fail (0), and set hello expiration time too2 minutes from now (or whatever your time constraint is).</span></span> <span data-ttu-id="73bad-218">Egy bejegyzést lejárati idő elérésekor a rendszer automatikusan eltávolította a hello bejegyzést.</span><span class="sxs-lookup"><span data-stu-id="73bad-218">When an entry's expiration time is reached, hello entry is automatically removed.</span></span> <span data-ttu-id="73bad-219">Ez biztosítja a működés közbeni 2 perces ablak.</span><span class="sxs-lookup"><span data-stu-id="73bad-219">This will give you a rolling 2-minute window.</span></span> <span data-ttu-id="73bad-220">Minden egyes kérelem toohello tárolási szolgáltatásként, akkor először használja a Linq lekérdezés hello MemoryCache objektum toocalculate hello százalékos sikerességi hello értékek megengedő és hello számát elosztjuk.</span><span class="sxs-lookup"><span data-stu-id="73bad-220">Each time you make a request toohello storage service, you first use a Linq query across hello MemoryCache object toocalculate hello percent success by summing hello values and dividing by hello count.</span></span> <span data-ttu-id="73bad-221">Amikor hello százalékos sikerességi bizonyos küszöb (például 10 %) alá csökken, állítsa be a hello **LocationMode** tulajdonsága túl az olvasási kérésekre**SecondaryOnly** és váltás hello alkalmazás csak olvasható módba előtt a folytatás.</span><span class="sxs-lookup"><span data-stu-id="73bad-221">When hello percent success drops below some threshold (such as 10%), set hello **LocationMode** property for read requests too**SecondaryOnly** and switch hello application into read-only mode before continuing.</span></span>

<span data-ttu-id="73bad-222">hibák hello küszöbértéket toodetermine használatos toomake hello kapcsoló eltérőek lehetnek az alkalmazás szolgáltatási tooservice, érdemes lehet minősítené konfigurálható paraméterek.</span><span class="sxs-lookup"><span data-stu-id="73bad-222">hello threshold of errors used toodetermine when toomake hello switch may vary from service tooservice in your application, so you should consider making them configurable parameters.</span></span> <span data-ttu-id="73bad-223">Ez akkor is, ha úgy dönt, toohandle Újrapróbálkozást lehetővé tevő észlelt hibákat az egyes szolgáltatások külön vagy számít, korábban bemutatott.</span><span class="sxs-lookup"><span data-stu-id="73bad-223">This is also where you decide toohandle retryable errors from each service separately or as one, as discussed previously.</span></span>

<span data-ttu-id="73bad-224">Meg kell vizsgálni, hogyan toohandle több példányát egy alkalmazást, és milyen toodo, ha észleli a Újrapróbálkozást lehetővé tevő hibákat minden egyes példányában.</span><span class="sxs-lookup"><span data-stu-id="73bad-224">Another consideration is how toohandle multiple instances of an application, and what toodo when you detect retryable errors in each instance.</span></span> <span data-ttu-id="73bad-225">Például előfordulhat, hogy fut az alkalmazás betöltése hello 20 virtuális gép.</span><span class="sxs-lookup"><span data-stu-id="73bad-225">For example, you may have 20 VMs running with hello same application loaded.</span></span> <span data-ttu-id="73bad-226">Tegye mindegyik példány külön-külön kezeli?</span><span class="sxs-lookup"><span data-stu-id="73bad-226">Do you handle each instance separately?</span></span> <span data-ttu-id="73bad-227">Ha egy példány indításakor problémák, így szeretné toolimit hello válasz toojust egy példányhoz, vagy az tootry toohave összes példányát a válaszolnak hello azonos módon, ha probléma van egy példány?</span><span class="sxs-lookup"><span data-stu-id="73bad-227">If one instance starts having problems, do you want toolimit hello response toojust that one instance, or do you want tootry toohave all instances respond in hello same way when one instance has a problem?</span></span> <span data-ttu-id="73bad-228">Hello példányok külön kezelése sokkal egyszerűbb, mint a toocoordinate hello válasz közben ezek között, de ennek módja az alkalmazás architektúra függ.</span><span class="sxs-lookup"><span data-stu-id="73bad-228">Handling hello instances separately is much simpler than trying toocoordinate hello response across them, but how you do this depends on your application's architecture.</span></span>

### <a name="options-for-monitoring-hello-error-frequency"></a><span data-ttu-id="73bad-229">Figyelheti hello hiba gyakorisága</span><span class="sxs-lookup"><span data-stu-id="73bad-229">Options for monitoring hello error frequency</span></span>

<span data-ttu-id="73bad-230">A sorrend toodetermine hello elsődleges régióban újrapróbálkozások gyakorisága hello figyelésre, amikor tooswitch keresztül toohello másodlagos régióban, és módosítsa az alkalmazás toorun csak olvasható módban hello három fő lehetőség van.</span><span class="sxs-lookup"><span data-stu-id="73bad-230">You have three main options for monitoring hello frequency of retries in hello primary region in order toodetermine when tooswitch over toohello secondary region and change hello application toorun in read-only mode.</span></span>

*   <span data-ttu-id="73bad-231">Adja hozzá a kezelőt hello [ **újrapróbálkozás** ](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.retrying.aspx) esemény a hello [ **OperationContext** ](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.aspx) tooyour tárolási kérelmeket át – Ez a hello objektum módszer jelenik meg ebben a cikkben, és a minta kísérő hello.</span><span class="sxs-lookup"><span data-stu-id="73bad-231">Add a handler for hello [**Retrying**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.retrying.aspx) event on hello [**OperationContext**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.aspx) object you pass tooyour storage requests – this is hello method displayed in this article and used in hello accompanying sample.</span></span> <span data-ttu-id="73bad-232">Ezek az események érvényesítést, amikor hello ügyfél kérelmet újrapróbálkozik, így már milyen gyakran tootrack hello ügyfél elsődleges végpont Újrapróbálkozást lehetővé tevő hibát észlel.</span><span class="sxs-lookup"><span data-stu-id="73bad-232">These events fire whenever hello client retries a request, enabling you tootrack how often hello client encounters retryable errors on a primary endpoint.</span></span>

    ```csharp 
    operationContext.Retrying += (sender, arguments) =>
    {
        // Retrying in hello primary region
        if (arguments.Request.Host == primaryhostname)
            ...
    };
    ```

*   <span data-ttu-id="73bad-233">A hello [ **Evaluate** ](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.retrypolicies.iextendedretrypolicy.evaluate.aspx) egyéni újrapróbálkozási házirendje metódust, bármikor futtatható, egyéni kód ha ismételt próbálkozással kerül sor.</span><span class="sxs-lookup"><span data-stu-id="73bad-233">In hello [**Evaluate**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.retrypolicies.iextendedretrypolicy.evaluate.aspx) method in a custom retry policy, you can run custom code whenever a retry takes place.</span></span> <span data-ttu-id="73bad-234">Ha ismételt próbálkozással történik, is által biztosított lehetőséget toomodify az újrapróbálási viselkedése hello hozzáadása toorecording a.</span><span class="sxs-lookup"><span data-stu-id="73bad-234">In addition toorecording when a retry happens, this also gives you hello opportunity toomodify your retry behavior.</span></span>

    ```csharp 
    public RetryInfo Evaluate(RetryContext retryContext,
    OperationContext operationContext)
    {
        var statusCode = retryContext.LastRequestResult.HttpStatusCode;
        if (retryContext.CurrentRetryCount >= this.maximumAttempts
        || ((statusCode &gt;= 300 && statusCode &lt; 500 && statusCode != 408)
        || statusCode == 501 // Not Implemented
        || statusCode == 505 // Version Not Supported
            ))
        {
        // Do not retry
            return null;
        }

        // Monitor retries in hello primary location
        ...

        // Determine RetryInterval and TargetLocation
        RetryInfo info =
            CreateRetryInfo(retryContext.CurrentRetryCount);

        return info;
    }
    ```

*   <span data-ttu-id="73bad-235">hello harmadik módszer olyan egyéni figyelő-összetevőt az alkalmazás, amely folyamatosan Pingeli az elsődleges tárolási végpont helyőrző tooimplement kérések (például Olvasás kis blob) toodetermine állapotára olvassa.</span><span class="sxs-lookup"><span data-stu-id="73bad-235">hello third approach is tooimplement a custom monitoring component in your application that continually pings your primary storage endpoint with dummy read requests (such as reading a small blob) toodetermine its health.</span></span> <span data-ttu-id="73bad-236">A volna tarthat néhány forrás, de nem jelentős időt.</span><span class="sxs-lookup"><span data-stu-id="73bad-236">This would take up some resources, but not a significant amount.</span></span> <span data-ttu-id="73bad-237">Ha a probléma, amely eléri a küszöbérték felderített, majd elvégeznie hello kapcsoló túl**SecondaryOnly** és írásvédett módban.</span><span class="sxs-lookup"><span data-stu-id="73bad-237">When a problem is discovered that reaches your threshold, you would then perform hello switch too**SecondaryOnly** and read-only mode.</span></span>

<span data-ttu-id="73bad-238">Egy bizonyos ponton érdemes tooswitch hátsó toousing hello elsődleges végpont és a frissítések engedélyezése.</span><span class="sxs-lookup"><span data-stu-id="73bad-238">At some point, you will want tooswitch back toousing hello primary endpoint and allowing updates.</span></span> <span data-ttu-id="73bad-239">Ha a fent felsorolt hello első két módszer egyikével, sikerült egyszerűen át hátsó toohello elsődleges végpont, és frissítési mód engedélyezése tetszőlegesen kiválasztott mennyi idő vagy a műveletek végrehajtását követően.</span><span class="sxs-lookup"><span data-stu-id="73bad-239">If using one of hello first two methods listed above, you could simply switch back toohello primary endpoint and enable update mode after an arbitrarily selected amount of time or number of operations has been performed.</span></span> <span data-ttu-id="73bad-240">Majd engedélyezheti azt keresztül hello újrapróbálkozási logika nyissa meg újra.</span><span class="sxs-lookup"><span data-stu-id="73bad-240">You can then let it go through hello retry logic again.</span></span> <span data-ttu-id="73bad-241">Ha hello ki lett javítva, akkor lesz toouse hello elsődleges végpont továbbra is, és frissítések engedélyezése.</span><span class="sxs-lookup"><span data-stu-id="73bad-241">If hello problem has been fixed, it will continue toouse hello primary endpoint and allow updates.</span></span> <span data-ttu-id="73bad-242">Ha a probléma továbbra is van, akkor még egyszer vált vissza toohello másodlagos végponti és írásvédett módban után hello feltételek beállítása sikertelen.</span><span class="sxs-lookup"><span data-stu-id="73bad-242">If there is still a problem, it will once more switch back toohello secondary endpoint and read-only mode after failing hello criteria you've set.</span></span>

<span data-ttu-id="73bad-243">Hello harmadik forgatókönyv, ha a pingelés hello elsődleges tárolási végpont válik sikeres újra, indíthat el hello visszaváltás túl**PrimaryOnly** , és folytassa a frissítések engedélyezése.</span><span class="sxs-lookup"><span data-stu-id="73bad-243">For hello third scenario, when pinging hello primary storage endpoint becomes successful again, you can trigger hello switch back too**PrimaryOnly** and continue allowing updates.</span></span>

## <a name="handling-eventually-consistent-data"></a><span data-ttu-id="73bad-244">Idővel konzisztenssé adatok kezelése</span><span class="sxs-lookup"><span data-stu-id="73bad-244">Handling eventually consistent data</span></span>

<span data-ttu-id="73bad-245">RA-GRS működését tekintve a tranzakciók replikálásához hello elsődleges toohello másodlagos régióba.</span><span class="sxs-lookup"><span data-stu-id="73bad-245">RA-GRS works by replicating transactions from hello primary toohello secondary region.</span></span> <span data-ttu-id="73bad-246">A replikálási folyamat biztosítja, hogy a másodlagos régióban hello hello adatok *idővel konzisztenssé*.</span><span class="sxs-lookup"><span data-stu-id="73bad-246">This replication process guarantees that hello data in hello secondary region is *eventually consistent*.</span></span> <span data-ttu-id="73bad-247">Ez azt jelenti, hogy az összes hello tranzakció hello elsődleges régióban végül megjelennek a hello másodlagos régióban, de lehet egy lag csak akkor jelennek meg, és, hogy nincs garancia hello tranzakciók érkeznek hello azonos sorrendben, mint a hello másodlagos régióban ahol eredetileg kérelmezték, hello elsődleges régióban.</span><span class="sxs-lookup"><span data-stu-id="73bad-247">This means that all hello transactions in hello primary region will eventually appear in hello secondary region, but that there may be a lag before they appear, and that there is no guarantee hello transactions arrive in hello secondary region in hello same order as that in which they were originally applied in hello primary region.</span></span> <span data-ttu-id="73bad-248">Ha a tranzakciók hello másodlagos régióban, sorrendje nem érkeznek meg *előfordulhat, hogy* fontolja meg az adatok hello másodlagos régióba toobe inkonzisztens állapotban, amíg hello szolgáltatás ki.</span><span class="sxs-lookup"><span data-stu-id="73bad-248">If your transactions arrive in hello secondary region out of order, you *may* consider your data in hello secondary region toobe in an inconsistent state until hello service catches up.</span></span>

<span data-ttu-id="73bad-249">hello alábbi táblázat szemlélteti, mi történne akkor, amikor egy alkalmazott toomake hello részleteit frissíti rá, hogy hello tagja *rendszergazdák* szerepkör.</span><span class="sxs-lookup"><span data-stu-id="73bad-249">hello following table shows an example of what might happen when you update hello details of an employee toomake her a member of hello *administrators* role.</span></span> <span data-ttu-id="73bad-250">Hello szakét ebben a példában, az ehhez szükséges frissítenie hello **alkalmazott** entitás és a frissítés egy **rendszergazdai szerepkör** entitás rendszergazdák hello száma számaival együtt.</span><span class="sxs-lookup"><span data-stu-id="73bad-250">For hello sake of this example, this requires you update hello **employee** entity and update an **administrator role** entity with a count of hello total number of administrators.</span></span> <span data-ttu-id="73bad-251">Figyelje meg, hogyan hello frissítéseket alkalmazza a rendszer nem megfelelő sorrendben hello másodlagos régióban.</span><span class="sxs-lookup"><span data-stu-id="73bad-251">Notice how hello updates are applied out of order in hello secondary region.</span></span>

| <span data-ttu-id="73bad-252">**Idő**</span><span class="sxs-lookup"><span data-stu-id="73bad-252">**Time**</span></span> | <span data-ttu-id="73bad-253">**Tranzakció**</span><span class="sxs-lookup"><span data-stu-id="73bad-253">**Transaction**</span></span>                                            | <span data-ttu-id="73bad-254">**Replikáció**</span><span class="sxs-lookup"><span data-stu-id="73bad-254">**Replication**</span></span>                       | <span data-ttu-id="73bad-255">**Utolsó szinkronizálás**</span><span class="sxs-lookup"><span data-stu-id="73bad-255">**Last Sync Time**</span></span> | <span data-ttu-id="73bad-256">**Eredménye**</span><span class="sxs-lookup"><span data-stu-id="73bad-256">**Result**</span></span> |
|----------|------------------------------------------------------------|---------------------------------------|--------------------|------------| 
| <span data-ttu-id="73bad-257">T0</span><span class="sxs-lookup"><span data-stu-id="73bad-257">T0</span></span>       | <span data-ttu-id="73bad-258">Tranzakció A:</span><span class="sxs-lookup"><span data-stu-id="73bad-258">Transaction A:</span></span> <br> <span data-ttu-id="73bad-259">Alkalmazott beszúrása</span><span class="sxs-lookup"><span data-stu-id="73bad-259">Insert employee</span></span> <br> <span data-ttu-id="73bad-260">az elsődleges entitás</span><span class="sxs-lookup"><span data-stu-id="73bad-260">entity in primary</span></span> |                                   |                    | <span data-ttu-id="73bad-261">A tranzakció tooprimary, szúrja be.</span><span class="sxs-lookup"><span data-stu-id="73bad-261">Transaction A inserted tooprimary,</span></span><br> <span data-ttu-id="73bad-262">még nem replikált.</span><span class="sxs-lookup"><span data-stu-id="73bad-262">not replicated yet.</span></span> |
| <span data-ttu-id="73bad-263">A T1</span><span class="sxs-lookup"><span data-stu-id="73bad-263">T1</span></span>       |                                                            | <span data-ttu-id="73bad-264">A tranzakció</span><span class="sxs-lookup"><span data-stu-id="73bad-264">Transaction A</span></span> <br> <span data-ttu-id="73bad-265">replikált</span><span class="sxs-lookup"><span data-stu-id="73bad-265">replicated to</span></span><br> <span data-ttu-id="73bad-266">másodlagos</span><span class="sxs-lookup"><span data-stu-id="73bad-266">secondary</span></span> | <span data-ttu-id="73bad-267">A T1</span><span class="sxs-lookup"><span data-stu-id="73bad-267">T1</span></span> | <span data-ttu-id="73bad-268">A tranzakció toosecondary replikálja.</span><span class="sxs-lookup"><span data-stu-id="73bad-268">Transaction A replicated toosecondary.</span></span> <br><span data-ttu-id="73bad-269">Utolsó szinkronizálás ideje frissíteni.</span><span class="sxs-lookup"><span data-stu-id="73bad-269">Last Sync Time updated.</span></span>    |
| <span data-ttu-id="73bad-270">T2</span><span class="sxs-lookup"><span data-stu-id="73bad-270">T2</span></span>       | <span data-ttu-id="73bad-271">B tranzakció</span><span class="sxs-lookup"><span data-stu-id="73bad-271">Transaction B:</span></span><br><span data-ttu-id="73bad-272">Frissítés</span><span class="sxs-lookup"><span data-stu-id="73bad-272">Update</span></span><br> <span data-ttu-id="73bad-273">alkalmazott entitás</span><span class="sxs-lookup"><span data-stu-id="73bad-273">employee entity</span></span><br> <span data-ttu-id="73bad-274">az elsődleges</span><span class="sxs-lookup"><span data-stu-id="73bad-274">in primary</span></span>  |                                | <span data-ttu-id="73bad-275">A T1</span><span class="sxs-lookup"><span data-stu-id="73bad-275">T1</span></span>                 | <span data-ttu-id="73bad-276">Tranzakció B tooprimary, írása</span><span class="sxs-lookup"><span data-stu-id="73bad-276">Transaction B written tooprimary,</span></span><br> <span data-ttu-id="73bad-277">még nem replikált.</span><span class="sxs-lookup"><span data-stu-id="73bad-277">not replicated yet.</span></span>  |
| <span data-ttu-id="73bad-278">A T3</span><span class="sxs-lookup"><span data-stu-id="73bad-278">T3</span></span>       | <span data-ttu-id="73bad-279">Tranzakció C:</span><span class="sxs-lookup"><span data-stu-id="73bad-279">Transaction C:</span></span><br> <span data-ttu-id="73bad-280">Frissítés</span><span class="sxs-lookup"><span data-stu-id="73bad-280">Update</span></span> <br><span data-ttu-id="73bad-281">Rendszergazda</span><span class="sxs-lookup"><span data-stu-id="73bad-281">administrator</span></span><br><span data-ttu-id="73bad-282">a szerepkör entitás</span><span class="sxs-lookup"><span data-stu-id="73bad-282">role entity in</span></span><br><span data-ttu-id="73bad-283">elsődleges</span><span class="sxs-lookup"><span data-stu-id="73bad-283">primary</span></span> |                    | <span data-ttu-id="73bad-284">A T1</span><span class="sxs-lookup"><span data-stu-id="73bad-284">T1</span></span>                 | <span data-ttu-id="73bad-285">Tranzakció tooprimary, írása C</span><span class="sxs-lookup"><span data-stu-id="73bad-285">Transaction C written tooprimary,</span></span><br> <span data-ttu-id="73bad-286">még nem replikált.</span><span class="sxs-lookup"><span data-stu-id="73bad-286">not replicated yet.</span></span>  |
| <span data-ttu-id="73bad-287">*T4*</span><span class="sxs-lookup"><span data-stu-id="73bad-287">*T4*</span></span>     |                                                       | <span data-ttu-id="73bad-288">Tranzakció C</span><span class="sxs-lookup"><span data-stu-id="73bad-288">Transaction C</span></span> <br><span data-ttu-id="73bad-289">replikált</span><span class="sxs-lookup"><span data-stu-id="73bad-289">replicated to</span></span><br> <span data-ttu-id="73bad-290">másodlagos</span><span class="sxs-lookup"><span data-stu-id="73bad-290">secondary</span></span> | <span data-ttu-id="73bad-291">A T1</span><span class="sxs-lookup"><span data-stu-id="73bad-291">T1</span></span>         | <span data-ttu-id="73bad-292">Tranzakció C toosecondary replikálja.</span><span class="sxs-lookup"><span data-stu-id="73bad-292">Transaction C replicated toosecondary.</span></span><br><span data-ttu-id="73bad-293">Nincs frissítve, mert LastSyncTime</span><span class="sxs-lookup"><span data-stu-id="73bad-293">LastSyncTime not updated because</span></span> <br><span data-ttu-id="73bad-294">B tranzakció még nincs replikálva.</span><span class="sxs-lookup"><span data-stu-id="73bad-294">transaction B has not been replicated yet.</span></span>|
| <span data-ttu-id="73bad-295">*T5*</span><span class="sxs-lookup"><span data-stu-id="73bad-295">*T5*</span></span>     | <span data-ttu-id="73bad-296">Olvassa el az entitások</span><span class="sxs-lookup"><span data-stu-id="73bad-296">Read entities</span></span> <br><span data-ttu-id="73bad-297">másodlagos</span><span class="sxs-lookup"><span data-stu-id="73bad-297">from secondary</span></span>                           |                                  | <span data-ttu-id="73bad-298">A T1</span><span class="sxs-lookup"><span data-stu-id="73bad-298">T1</span></span>                 | <span data-ttu-id="73bad-299">Hello alkalmazott elavult értéket kap</span><span class="sxs-lookup"><span data-stu-id="73bad-299">You get hello stale value for employee</span></span> <br> <span data-ttu-id="73bad-300">entitás, mert a tranzakció B nem</span><span class="sxs-lookup"><span data-stu-id="73bad-300">entity because transaction B hasn't</span></span> <br> <span data-ttu-id="73bad-301">még replikált.</span><span class="sxs-lookup"><span data-stu-id="73bad-301">replicated yet.</span></span> <span data-ttu-id="73bad-302">Hello új értéket kap</span><span class="sxs-lookup"><span data-stu-id="73bad-302">You get hello new value for</span></span><br> <span data-ttu-id="73bad-303">rendszergazdai szerepkör entitás mert C</span><span class="sxs-lookup"><span data-stu-id="73bad-303">administrator role entity because C has</span></span><br> <span data-ttu-id="73bad-304">a rendszer replikálja.</span><span class="sxs-lookup"><span data-stu-id="73bad-304">replicated.</span></span> <span data-ttu-id="73bad-305">Utolsó szinkronizálás ideje még nem</span><span class="sxs-lookup"><span data-stu-id="73bad-305">Last Sync Time still hasn't</span></span><br> <span data-ttu-id="73bad-306">lett frissítése, mert a tranzakció B</span><span class="sxs-lookup"><span data-stu-id="73bad-306">been updated because transaction B</span></span><br> <span data-ttu-id="73bad-307">a rendszer nem replikálja.</span><span class="sxs-lookup"><span data-stu-id="73bad-307">hasn't replicated.</span></span> <span data-ttu-id="73bad-308">Beállíthatja a</span><span class="sxs-lookup"><span data-stu-id="73bad-308">You can tell the</span></span><br><span data-ttu-id="73bad-309">rendszergazdai szerepkör entitás inkonzisztens.</span><span class="sxs-lookup"><span data-stu-id="73bad-309">administrator role entity is inconsistent</span></span> <br><span data-ttu-id="73bad-310">mivel hello entitás dátum/idő után</span><span class="sxs-lookup"><span data-stu-id="73bad-310">because hello entity date/time is after</span></span> <br><span data-ttu-id="73bad-311">Utolsó szinkronizálás hello.</span><span class="sxs-lookup"><span data-stu-id="73bad-311">hello Last Sync Time.</span></span> |
| <span data-ttu-id="73bad-312">*T6*</span><span class="sxs-lookup"><span data-stu-id="73bad-312">*T6*</span></span>     |                                                      | <span data-ttu-id="73bad-313">B tranzakció</span><span class="sxs-lookup"><span data-stu-id="73bad-313">Transaction B</span></span><br> <span data-ttu-id="73bad-314">replikált</span><span class="sxs-lookup"><span data-stu-id="73bad-314">replicated to</span></span><br> <span data-ttu-id="73bad-315">másodlagos</span><span class="sxs-lookup"><span data-stu-id="73bad-315">secondary</span></span> | <span data-ttu-id="73bad-316">T6</span><span class="sxs-lookup"><span data-stu-id="73bad-316">T6</span></span>                 | <span data-ttu-id="73bad-317">*T6* – C – az összes tranzakció van</span><span class="sxs-lookup"><span data-stu-id="73bad-317">*T6* – All transactions through C have</span></span> <br><span data-ttu-id="73bad-318">van replikálva, a legutóbbi szinkronizálás ideje</span><span class="sxs-lookup"><span data-stu-id="73bad-318">been replicated, Last Sync Time</span></span><br> <span data-ttu-id="73bad-319">frissül.</span><span class="sxs-lookup"><span data-stu-id="73bad-319">is updated.</span></span> |

<span data-ttu-id="73bad-320">Ebben a példában feltételezzük hello ügyfél kapcsolók tooreading hello másodlagos régióban, T5.</span><span class="sxs-lookup"><span data-stu-id="73bad-320">In this example, assume hello client switches tooreading from hello secondary region at T5.</span></span> <span data-ttu-id="73bad-321">Akkor is sikeresen beolvasta a hello **rendszergazdai szerepkör** jelenleg entitás, de hello entitás hello rendszergazdák azon számát, amely nincs összhangban hello számú értéket tartalmaz **alkalmazott** entitások a rendszergazdák hello másodlagos régióban, amely van megjelölve, most.</span><span class="sxs-lookup"><span data-stu-id="73bad-321">It can successfully read hello **administrator role** entity at this time, but hello entity contains a value for hello count of administrators that is not consistent with hello number of **employee** entities that are marked as administrators in hello secondary region at this time.</span></span> <span data-ttu-id="73bad-322">Az ügyfél egyszerűen lehetett megjeleníteni ezt az értéket, hello kockázata, hogy a rendszer inkonzisztens adatokat.</span><span class="sxs-lookup"><span data-stu-id="73bad-322">Your client could simply display this value, with hello risk that it is inconsistent information.</span></span> <span data-ttu-id="73bad-323">Másik lehetőségként hello ügyfél kísérletet toodetermine adott hello **rendszergazdai szerepkör** hello sorrendje nem történt, és ezután megadja az hello felhasználói erről a potenciálisan inkonzisztens állapotban van.</span><span class="sxs-lookup"><span data-stu-id="73bad-323">Alternatively, hello client could attempt toodetermine that hello **administrator role** is in a potentially inconsistent state because hello updates have happened out of order, and then inform hello user of this fact.</span></span>

<span data-ttu-id="73bad-324">arról, hogy rendelkezik-e esetleg ellentmondásos adatok toorecognize, hello ügyfél használhatja hello hello értékének *utolsó szinkronizálás* , hogy kaphat a bármikor a társzolgáltatás lekérdezésével.</span><span class="sxs-lookup"><span data-stu-id="73bad-324">toorecognize that it has potentially inconsistent data, hello client can use hello value of hello *Last Sync Time* that you can get at any time by querying a storage service.</span></span> <span data-ttu-id="73bad-325">Igen, akkor hello időpontja hello adatok hello másodlagos régióban utolsó következetes és hello szolgáltatást kellett alkalmazásakor minden hello tranzakciók előzetes toothat pont időben.</span><span class="sxs-lookup"><span data-stu-id="73bad-325">This tells you hello time when hello data in hello secondary region was last consistent and when hello service had applied all hello transactions prior toothat point in time.</span></span> <span data-ttu-id="73bad-326">A hello fenti példában, miután hello szolgáltatás által a hello **alkalmazott** entitás hello másodlagos régióban, hello utolsó szinkronizálás értéke túl*T1*.</span><span class="sxs-lookup"><span data-stu-id="73bad-326">In hello example shown above, after hello service inserts hello **employee** entity in hello secondary region, hello last sync time is set too*T1*.</span></span> <span data-ttu-id="73bad-327">A leválasztást *T1* amíg hello szolgáltatás hogyan frissíti hello **alkalmazott** entitás hello másodlagos régióban, ha túl*T6*.</span><span class="sxs-lookup"><span data-stu-id="73bad-327">It remains at *T1* until hello service updates hello **employee** entity in hello secondary region when it is set too*T6*.</span></span> <span data-ttu-id="73bad-328">Ha hello ügyfél lekérdezi a hello utolsó szinkronizálási idő, amikor olvassa be a hello entitás *T5*, azt is összehasonlíthatja hello időbélyeg hello entitás.</span><span class="sxs-lookup"><span data-stu-id="73bad-328">If hello client retrieves hello last sync time when it reads hello entity at *T5*, it can compare it with hello timestamp on hello entity.</span></span> <span data-ttu-id="73bad-329">Ha hello időbélyeg hello entitás későbbre esik, mint hello időpontja, utolsó szinkronizálás majd hello entitás potenciálisan inkonzisztens állapotban van, és is igénybe vehet, függetlenül az hello megfelelő lépéseket az alkalmazás.</span><span class="sxs-lookup"><span data-stu-id="73bad-329">If hello timestamp on hello entity is later than hello last sync time, then hello entity is in a potentially inconsistent state, and you can take whatever is hello appropriate action for your application.</span></span> <span data-ttu-id="73bad-330">Ez a mező használatához arról, hogy mikor hello utolsó frissítés toohello elsődleges befejeződött.</span><span class="sxs-lookup"><span data-stu-id="73bad-330">Using this field requires that you know when hello last update toohello primary was completed.</span></span>

## <a name="testing"></a><span data-ttu-id="73bad-331">Tesztelés</span><span class="sxs-lookup"><span data-stu-id="73bad-331">Testing</span></span>

<span data-ttu-id="73bad-332">Fontos, hogy az alkalmazás Újrapróbálkozást lehetővé tevő hiba várt viselkedik tootest.</span><span class="sxs-lookup"><span data-stu-id="73bad-332">It's important tootest that your application behaves as expected when it encounters retryable errors.</span></span> <span data-ttu-id="73bad-333">Például, hogy az alkalmazás kapcsolók toohello másodlagos hello tootest van szüksége, és csak olvasható módba, ha problémát észlel, és váltás amikor hello elsődleges régió ismét elérhetővé válik.</span><span class="sxs-lookup"><span data-stu-id="73bad-333">For example, you need tootest that hello application switches toohello secondary and into read-only mode when it detects a problem, and switches back when hello primary region becomes available again.</span></span> <span data-ttu-id="73bad-334">toodo, kell egy módon toosimulate Újrapróbálkozást lehetővé tevő hibákat, és szabályozhatja, hogy milyen gyakran előforduló.</span><span class="sxs-lookup"><span data-stu-id="73bad-334">toodo this, you need a way toosimulate retryable errors and control how often they occur.</span></span>

<span data-ttu-id="73bad-335">Használhat [Fiddler](http://www.telerik.com/fiddler) toointercept, és módosítsa a parancsfájl a HTTP-válaszokat.</span><span class="sxs-lookup"><span data-stu-id="73bad-335">You can use [Fiddler](http://www.telerik.com/fiddler) toointercept and modify HTTP responses in a script.</span></span> <span data-ttu-id="73bad-336">Ez a parancsfájl azonosítsa az elsődleges végpont érkező válaszokat, és hello HTTP-állapot kódját tooone módosítása, hogy a Storage ügyféloldali kódtára felismeri Újrapróbálkozást lehetővé tevő hiba hello.</span><span class="sxs-lookup"><span data-stu-id="73bad-336">This script can identify responses that come from your primary endpoint and change hello HTTP status code tooone that hello Storage Client Library recognizes as a retryable error.</span></span> <span data-ttu-id="73bad-337">A kódrészletet mutat be egy egyszerű, amely elfogja a választ tooread kéréseket a meghatározott hello Fiddler parancsfájl **employeedata** tábla tooreturn 502 állapota:</span><span class="sxs-lookup"><span data-stu-id="73bad-337">This code snippet shows a simple example of a Fiddler script that intercepts responses tooread requests against hello **employeedata** table tooreturn a 502 status:</span></span>

```java
static function OnBeforeResponse(oSession: Session) {
    ...
    if ((oSession.hostname == "\[yourstorageaccount\].table.core.windows.net")
      && (oSession.PathAndQuery.StartsWith("/employeedata?$filter"))) {
        oSession.responseCode = 502;
    }
}
```

<span data-ttu-id="73bad-338">Nem sikerült kiterjesztése a példa toointercept kérelmek szélesebb köre, és csak a hello módosítása **responseCode** a némelyikük toobetter szimulálása egy valós forgatókönyv.</span><span class="sxs-lookup"><span data-stu-id="73bad-338">You could extend this example toointercept a wider range of requests and only change hello **responseCode** on some of them toobetter simulate a real-world scenario.</span></span> <span data-ttu-id="73bad-339">Fiddler parancsfájlok testreszabásával kapcsolatos további információkért lásd: [módosítását olyan kérésre vagy válaszra](http://docs.telerik.com/fiddler/KnowledgeBase/FiddlerScript/ModifyRequestOrResponse) hello Fiddler dokumentációjában található.</span><span class="sxs-lookup"><span data-stu-id="73bad-339">For more information about customizing Fiddler scripts, see [Modifying a Request or Response](http://docs.telerik.com/fiddler/KnowledgeBase/FiddlerScript/ModifyRequestOrResponse) in hello Fiddler documentation.</span></span>

<span data-ttu-id="73bad-340">Ha az alkalmazás csak tooread mód konfigurálható átállításához hello küszöbértékeket, könnyebben tootest hello viselkedés nem éles tranzakció kötetekkel lesz.</span><span class="sxs-lookup"><span data-stu-id="73bad-340">If you have made hello thresholds for switching your application tooread-only mode configurable, it will be easier tootest hello behavior with non-production transaction volumes.</span></span>

## <a name="next-steps"></a><span data-ttu-id="73bad-341">Következő lépések</span><span class="sxs-lookup"><span data-stu-id="73bad-341">Next Steps</span></span>

* <span data-ttu-id="73bad-342">Olvasási hozzáférés-Georedundancia kapcsolatos további információkért például hogyan hello LastSyncTime be van állítva, egy másik példát talál [Windows Azure tárolási redundancia lehetőségek és az írásvédett Georedundáns redundáns tárolás](https://blogs.msdn.microsoft.com/windowsazurestorage/2013/12/11/windows-azure-storage-redundancy-options-and-read-access-geo-redundant-storage/).</span><span class="sxs-lookup"><span data-stu-id="73bad-342">For more information about Read Access Geo-Redundancy, including another example of how hello LastSyncTime is set, please see [Windows Azure Storage Redundancy Options and Read Access Geo Redundant Storage](https://blogs.msdn.microsoft.com/windowsazurestorage/2013/12/11/windows-azure-storage-redundancy-options-and-read-access-geo-redundant-storage/).</span></span>

* <span data-ttu-id="73bad-343">Egy teljes mintát jelenít meg, hogyan toomake hello hello elsődleges és másodlagos végpontok közötti oda-vissza kapcsoló, lásd: [Azure-minták – használatával hello áramköri megszakító minta az RA-GRS tárolással rendelkező](https://github.com/Azure-Samples/storage-dotnet-circuit-breaker-pattern-ha-apps-using-ra-grs).</span><span class="sxs-lookup"><span data-stu-id="73bad-343">For a complete sample showing how toomake hello switch back and forth between hello Primary and Secondary endpoints, please see [Azure Samples – Using hello Circuit Breaker Pattern with RA-GRS storage](https://github.com/Azure-Samples/storage-dotnet-circuit-breaker-pattern-ha-apps-using-ra-grs).</span></span>
