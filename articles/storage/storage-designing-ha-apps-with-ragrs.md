---
title: "Azure-írásvédett Georedundáns tárolás (RA-GRS) használatával magas rendelkezésre álló alkalmazások megtervezése |} Microsoft Docs"
description: "Hogyan lehet Azure-RA-GRS storage segítségével tervezővel vajon elég rugalmas az kimaradások kezelni a magas rendelkezésre állású alkalmazások."
services: storage
documentationcenter: .net
author: robinsh
manager: timlt
editor: tysonn
ms.assetid: 8f040b0f-8926-4831-ac07-79f646f31926
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: dotnet
ms.topic: article
ms.date: 1/19/2017
ms.author: robinsh
ms.openlocfilehash: adc7e23d8c9f869f2951490020e3d0f1a2b2e81c
ms.sourcegitcommit: 02e69c4a9d17645633357fe3d46677c2ff22c85a
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 08/03/2017
---
# <a name="designing-highly-available-applications-using-ra-grs"></a><span data-ttu-id="7e098-103">RA-GRS használatával magas rendelkezésre álló alkalmazások megtervezése</span><span class="sxs-lookup"><span data-stu-id="7e098-103">Designing Highly Available Applications using RA-GRS</span></span>

<span data-ttu-id="7e098-104">A felhőalapú infrastruktúrák közös szolgáltatása a magas rendelkezésre állású platform biztosítják az alkalmazások tárolására szolgáló.</span><span class="sxs-lookup"><span data-stu-id="7e098-104">A common feature of cloud-based infrastructures is that they provide a highly available platform for hosting applications.</span></span> <span data-ttu-id="7e098-105">A felhőalapú alkalmazások fejlesztők kell alaposan fontolja meg, hogyan használhatók ki ezen a platformon, magas rendelkezésre állású alkalmazások a felhasználóknak való biztosítása érdekében.</span><span class="sxs-lookup"><span data-stu-id="7e098-105">Developers of cloud-based applications must consider carefully how to leverage this platform to deliver highly available applications to their users.</span></span> <span data-ttu-id="7e098-106">Ez a cikk foglalkozik, kifejezetten a fejlesztők használatát az Azure Storage írásvédett földrajzi redundáns tárolás (RA-GRS) az alkalmazások több elérhetővé.</span><span class="sxs-lookup"><span data-stu-id="7e098-106">This article focuses specifically on how developers can use the Azure Storage Read Access Geo Redundant Storage (RA-GRS) to make their applications more available.</span></span>

<span data-ttu-id="7e098-107">A redundancia érdekében – LRS (helyileg redundáns tárolás), a zrs-t (zóna redundáns tárolás), a GRS (Georedundáns tárolás) és az RA-GRS (írásvédett Georedundáns tárolás) négy lehetősége van.</span><span class="sxs-lookup"><span data-stu-id="7e098-107">There are four choices for redundancy – LRS (Locally Redundant Storage), ZRS (Zone Redundant Storage), GRS (Geo-Redundant Storage), and RA-GRS (Read Access Geo-Redundant Storage).</span></span> <span data-ttu-id="7e098-108">Ez a cikk GRS és az RA-GRS megvitatni fogjuk.</span><span class="sxs-lookup"><span data-stu-id="7e098-108">We are going to discuss GRS and RA-GRS in this article.</span></span> <span data-ttu-id="7e098-109">A GRS az adatok három példányban tárolják a storage-fiók beállítása során kiválasztott elsődleges régióban.</span><span class="sxs-lookup"><span data-stu-id="7e098-109">With GRS, three copies of your data are kept in the primary region you selected when setting up the storage account.</span></span> <span data-ttu-id="7e098-110">Három további másolatokat aszinkron módon karbantartása az Azure által megadott másodlagos régióba.</span><span class="sxs-lookup"><span data-stu-id="7e098-110">Three additional copies are maintained asynchronously in a secondary region specified by Azure.</span></span> <span data-ttu-id="7e098-111">RA-GRS ugyanaz, mint a Georedundáns, azzal a különbséggel, hogy rendelkezik olvasási hozzáféréssel a másodlagos példány.</span><span class="sxs-lookup"><span data-stu-id="7e098-111">RA-GRS is the same thing as GRS except that you have read access to the secondary copy.</span></span> <span data-ttu-id="7e098-112">Azure Storage redundancia különböző beállításokkal kapcsolatos további információkért lásd: [Azure Storage replikációs](https://docs.microsoft.com/en-us/azure/storage/storage-redundancy).</span><span class="sxs-lookup"><span data-stu-id="7e098-112">For more information about the different Azure Storage redundancy options, see [Azure Storage replication](https://docs.microsoft.com/en-us/azure/storage/storage-redundancy).</span></span> <span data-ttu-id="7e098-113">A replikációs cikk azt az elsődleges és másodlagos régiók párosítása is ismerteti.</span><span class="sxs-lookup"><span data-stu-id="7e098-113">The replication article also shows the pairings of the primary and secondary regions.</span></span>

<span data-ttu-id="7e098-114">Nincsenek kódtöredékek szerepelni fog ebben a cikkben, és egy teljes mintát, töltse le, és futtassa a végén mutató hivatkozást.</span><span class="sxs-lookup"><span data-stu-id="7e098-114">There are code snippets included in this article, and a link to a complete sample at the end that you can download and run.</span></span>

## <a name="key-features-of-ra-grs"></a><span data-ttu-id="7e098-115">RA-GRS a kulcsfontosságú szolgáltatásokat</span><span class="sxs-lookup"><span data-stu-id="7e098-115">Key features of RA-GRS</span></span>

<span data-ttu-id="7e098-116">Mielőtt döntésről RA-GRS tároló használatáról, most szolgáltatással kapcsolatban annak tulajdonságait és működését.</span><span class="sxs-lookup"><span data-stu-id="7e098-116">Before we talk about how to use RA-GRS storage, let's talk about its properties and behavior.</span></span>

* <span data-ttu-id="7e098-117">Az Azure Storage az elsődleges régióban egy másodlagos régióban; adattároló írásvédett másolatot tart fenn. a fentiek szerint a tároló szolgáltatást határozza meg a másodlagos régióba helyét.</span><span class="sxs-lookup"><span data-stu-id="7e098-117">Azure Storage maintains a read-only copy of the data you store in your primary region in a secondary region; as noted above, the storage service determines the location of the secondary region.</span></span>

* <span data-ttu-id="7e098-118">A csak olvasható másolat [idővel konzisztenssé](https://en.wikipedia.org/wiki/Eventual_consistency) az adatokat az elsődleges régióban.</span><span class="sxs-lookup"><span data-stu-id="7e098-118">The read-only copy is [eventually consistent](https://en.wikipedia.org/wiki/Eventual_consistency) with the data in the primary region.</span></span>

* <span data-ttu-id="7e098-119">A blobot, táblát és üzenetsort, a másodlagos régióba lekérheti a *utolsó szinkronizálás* érték, amely jelzi, hogy mikor történt, a legutóbbi replikáció, az elsődleges a másodlagos régióba.</span><span class="sxs-lookup"><span data-stu-id="7e098-119">For blobs, tables, and queues, you can query the secondary region for a *Last Sync Time* value that tells you when the last replication from the primary to the secondary region occurred.</span></span> <span data-ttu-id="7e098-120">(Ez nem támogatott az Azure File storage, amely jelenleg nem rendelkezik az RA-GRS redundancia.)</span><span class="sxs-lookup"><span data-stu-id="7e098-120">(This is not supported for Azure File storage, which doesn't have RA-GRS redundancy at this time.)</span></span>

* <span data-ttu-id="7e098-121">A Storage ügyféloldali kódtár segítségével az adatok az elsődleges vagy másodlagos régióban kezeléséhez.</span><span class="sxs-lookup"><span data-stu-id="7e098-121">You can use the Storage Client Library to interact with the data in either the primary or secondary region.</span></span> <span data-ttu-id="7e098-122">Átirányítani, akkor olvassa el automatikusan a másodlagos régióba kérelmeket, ha az elsődleges régióban olvasási kérelem időkorlátja lejár.</span><span class="sxs-lookup"><span data-stu-id="7e098-122">You can also redirect read requests automatically to the secondary region if a read request to the primary region times out.</span></span>

* <span data-ttu-id="7e098-123">Ha egy elsődleges régióban adatok elérhetőségét érintő jelentős probléma, az Azure-csapat indíthatnak földrajzi-feladatátvétel, amikor a DNS-bejegyzések az elsődleges régióban mutató változnak, hogy a másodlagos régióba mutasson.</span><span class="sxs-lookup"><span data-stu-id="7e098-123">If there is a major issue affecting the accessibility of the data in the primary region, the Azure team may trigger a geo-failover, at which point the DNS entries pointing to the primary region will be changed to point to the secondary region.</span></span>

* <span data-ttu-id="7e098-124">Egy földrajzi feladatátvétel esetén Azure lesz jelöljön ki egy új másodlagos helyet erre a helyre replikálja az adatokat, majd a másodlagos DNS-bejegyzések mutasson.</span><span class="sxs-lookup"><span data-stu-id="7e098-124">If a geo-failover occurs, Azure will select a new secondary location and replicate the data to that location, then point the secondary DNS entries to it.</span></span> <span data-ttu-id="7e098-125">A másodlagos végponti elérhetetlenné válik, amíg a tárfiók nem fejeződött be, replikálása.</span><span class="sxs-lookup"><span data-stu-id="7e098-125">The secondary endpoint will be unavailable until the storage account has finished replicating.</span></span> <span data-ttu-id="7e098-126">További információkért lásd: [Mi a teendő, ha egy Azure Storage esetleges leálláskor](https://docs.microsoft.com/en-us/azure/storage/storage-disaster-recovery-guidance).</span><span class="sxs-lookup"><span data-stu-id="7e098-126">For more information, please see [What to do if an Azure Storage outage occurs](https://docs.microsoft.com/en-us/azure/storage/storage-disaster-recovery-guidance).</span></span>

## <a name="application-design-considerations-when-using-ra-grs"></a><span data-ttu-id="7e098-127">RA-GRS használatakor alkalmazás kialakítási szempontok</span><span class="sxs-lookup"><span data-stu-id="7e098-127">Application design considerations when using RA-GRS</span></span>

<span data-ttu-id="7e098-128">Ez a cikk fő célja mutatjuk be, hogyan tervezhető olyan alkalmazás, amely továbbra is működnek (bár a korlátozott kapacitás), még akkor is, az elsődleges adatközpont jelentős katasztrófa esetén.</span><span class="sxs-lookup"><span data-stu-id="7e098-128">The main purpose of this article is to show you how to design an application that will continue to function (albeit in a limited capacity) even in the event of a major disaster at the primary data center.</span></span> <span data-ttu-id="7e098-129">Ehhez az alkalmazás átállítaná a másodlagos régióba olvasni, ha probléma van, és vissza az elsődleges régióban elérhető esetén újra váltás átmeneti vagy hosszú futású kapcsolatos problémák kezelésére.</span><span class="sxs-lookup"><span data-stu-id="7e098-129">You do this by having your application to handle transient or long-running issues by switching to read from the secondary region while there is a problem, and switching back when the primary region is available again.</span></span>

### <a name="using-eventually-consistent-data"></a><span data-ttu-id="7e098-130">Idővel konzisztenssé adatok használata</span><span class="sxs-lookup"><span data-stu-id="7e098-130">Using eventually consistent data</span></span>

<span data-ttu-id="7e098-131">A javasolt megoldás azt feltételezi, hogy már vissza Mi lehet a hívó alkalmazás elavult adatokat.</span><span class="sxs-lookup"><span data-stu-id="7e098-131">This proposed solution assumes that it is okay to return what could be stale data to the calling application.</span></span> <span data-ttu-id="7e098-132">Mivel a másodlagos adatok idővel konzisztenssé, akkor előfordulhat, hogy az adatok írása megtörtént az elsődleges, de a frissítést, a másodlagos kellett nem fejezte be a replikálása, amikor az elsődleges régióban elérhetetlenné vált.</span><span class="sxs-lookup"><span data-stu-id="7e098-132">Because the secondary data is eventually consistent, it is possible that the data was written to the primary but the update to the secondary had not finished replicating when the primary region became inaccessible.</span></span>

<span data-ttu-id="7e098-133">Például az ügyfél sikerült elküldeni a sikeres frissítést, és az elsődleges sikerült keresse a másodlagos propagálja a frissítés előtt.</span><span class="sxs-lookup"><span data-stu-id="7e098-133">For example, your customer could submit an update that is successful, and then the primary could go down before the update is propagated to the secondary.</span></span> <span data-ttu-id="7e098-134">Ebben az esetben ha az ügyfél kéri vissza az adatokat olvasni, részesül az elavult adatokat a frissített adatokat helyett.</span><span class="sxs-lookup"><span data-stu-id="7e098-134">In this case, if the customer then asks to read the data back, he receives the stale data instead of the updated data.</span></span> <span data-ttu-id="7e098-135">Döntse el, ha ez elfogadható, és ha igen, hogyan fogja jelenik meg az ügyfél.</span><span class="sxs-lookup"><span data-stu-id="7e098-135">You must decide if this is acceptable, and if so, how you will message the customer.</span></span> <span data-ttu-id="7e098-136">Látni fogja a legutóbbi szinkronizálás ideje a cikk későbbi részében másodlagos adatokon nem naprakész-e a másodlagos ellenőrzése.</span><span class="sxs-lookup"><span data-stu-id="7e098-136">You'll see how to check the Last Sync Time on the secondary data later in this article to see if the secondary is up-to-date.</span></span>

### <a name="handling-services-separately-or-all-together"></a><span data-ttu-id="7e098-137">Kezelési szolgáltatások, külön-külön vagy együtt</span><span class="sxs-lookup"><span data-stu-id="7e098-137">Handling services separately or all together</span></span>

<span data-ttu-id="7e098-138">Nem valószínű, miközben lehetőség egy szolgáltatás elérhetetlenné válik, amíg az egyéb szolgáltatások továbbra is teljes körűen működik.</span><span class="sxs-lookup"><span data-stu-id="7e098-138">While not likely, it is possible for one service to become unavailable while the other services are still fully functional.</span></span> <span data-ttu-id="7e098-139">Kezelheti az újrapróbálkozások és az egyes írásvédett módban szolgáltatás külön-külön (BLOB, üzenetsorok, táblák), vagy a tárolási szolgáltatások általános újrapróbálásainak együtt kezelheti.</span><span class="sxs-lookup"><span data-stu-id="7e098-139">You can handle the retries and read-only mode for each service separately (blobs, queues, tables), or you can handle retries generically for all the storage services together.</span></span>

<span data-ttu-id="7e098-140">Például ha az alkalmazás üzenetsorokat és blobokat használ, dönthet úgy, amelyre az újrapróbálkozást lehetővé tevő hibák kezelésének minden egyes külön kódban.</span><span class="sxs-lookup"><span data-stu-id="7e098-140">For example, if you use queues and blobs in your application, you may decide to put in separate code to handle retryable errors for each of these.</span></span> <span data-ttu-id="7e098-141">Majd ha ismételt próbálkozással beszerezni a blob szolgáltatás, de továbbra is működik-e a várólista-szolgáltatás, csak az alkalmazáshoz, amely kezeli a blobok részét csökkenhet.</span><span class="sxs-lookup"><span data-stu-id="7e098-141">Then if you get a retry from the blob service, but the queue service is still working, only the part of your application that handles blobs will be impacted.</span></span> <span data-ttu-id="7e098-142">Ha úgy dönt, hogy az összes tárolási szolgáltatás újrapróbálkozás általános kezeli, és vissza a blob szolgáltatás hívása Újrapróbálkozást lehetővé tevő hiba, majd a blob szolgáltatás és a queue szolgáltatás kérelmek csökkenhet.</span><span class="sxs-lookup"><span data-stu-id="7e098-142">If you decide to handle all storage service retries generically and a call to the blob service returns a retryable error, then requests to both the blob service and the queue service will be impacted.</span></span>

<span data-ttu-id="7e098-143">Végül Ez függ az alkalmazás összetettsége.</span><span class="sxs-lookup"><span data-stu-id="7e098-143">Ultimately, this depends on the complexity of your application.</span></span> <span data-ttu-id="7e098-144">Előfordulhat, hogy nem kívánja kezelni a hibák szolgáltatás, de ehelyett átirányítása kérések a másodlagos régióba tárolási szolgáltatások és az alkalmazás futtatásához csak olvasható módban, ha az elsődleges régióban bármely társzolgáltatás probléma névváltozást észlel.</span><span class="sxs-lookup"><span data-stu-id="7e098-144">You may decide not to handle the failures by service, but instead to redirect read requests for all storage services to the secondary region and run the application in read-only mode when you detect a problem with any storage service in the primary region.</span></span>

### <a name="other-considerations"></a><span data-ttu-id="7e098-145">Egyéb szempontok</span><span class="sxs-lookup"><span data-stu-id="7e098-145">Other considerations</span></span>

<span data-ttu-id="7e098-146">Ezek a más ismertetett szempontok alapján ez a cikk a többi ismertetik.</span><span class="sxs-lookup"><span data-stu-id="7e098-146">These are the other considerations we will discuss in the rest of this article.</span></span>

*   <span data-ttu-id="7e098-147">Az olvasási kérések az áramköri megszakító minta használatával újrapróbálkozások kezelése</span><span class="sxs-lookup"><span data-stu-id="7e098-147">Handling retries of read requests using the Circuit Breaker pattern</span></span>

*   <span data-ttu-id="7e098-148">Idővel konzisztenssé adatok és a legutóbbi szinkronizálás ideje</span><span class="sxs-lookup"><span data-stu-id="7e098-148">Eventually-consistent data and the Last Sync Time</span></span>

*   <span data-ttu-id="7e098-149">Tesztelés</span><span class="sxs-lookup"><span data-stu-id="7e098-149">Testing</span></span>

## <a name="running-your-application-in-read-only-mode"></a><span data-ttu-id="7e098-150">Az alkalmazás csak olvasható módban fut</span><span class="sxs-lookup"><span data-stu-id="7e098-150">Running your application in read-only mode</span></span>

<span data-ttu-id="7e098-151">RA-GRS storage használatához mindkét sikertelen olvasási kérések kezelésére is képesnek kell lennie, és nem sikerült a frissítési kérelmek (ebben az esetben a Beszúrás tehát frissítés, frissítés és törlés).</span><span class="sxs-lookup"><span data-stu-id="7e098-151">To use RA-GRS storage, you must be able to handle both failed read requests and failed update requests (with update in this case meaning inserts, updates, and deletions).</span></span> <span data-ttu-id="7e098-152">Ha az elsődleges adatközpont leáll, olvasási kérelmek átirányíthatók a másodlagos adatközpontba, de a frissítési kérelmek nem lehetséges, mert a másodlagos csak olvasható.</span><span class="sxs-lookup"><span data-stu-id="7e098-152">If the primary data center fails, read requests can be redirected to the secondary data center, but update requests cannot because the secondary is read only.</span></span> <span data-ttu-id="7e098-153">Ezért meg kell néhány csak olvasható módban az alkalmazás futtatásához.</span><span class="sxs-lookup"><span data-stu-id="7e098-153">For this reason, you need some way to run your application in read-only mode.</span></span>

<span data-ttu-id="7e098-154">Megadhatja például, hogy a jelzőt, amely a tárolási szolgáltatásba bármely frissítési kérelmek elküldése előtt ellenőrizni kell.</span><span class="sxs-lookup"><span data-stu-id="7e098-154">For example, you can set a flag that will be checked before submitting any update requests to the storage service.</span></span> <span data-ttu-id="7e098-155">Ha a frissítési kérelmek egyik, hagyja ki, és térjen vissza az ügyfél egy megfelelő választ.</span><span class="sxs-lookup"><span data-stu-id="7e098-155">When one of the update requests comes through, you can skip it and return an appropriate response to the customer.</span></span> <span data-ttu-id="7e098-156">Akkor is érdemes lehet bizonyos funkciókat tilthat le elemet, amíg a probléma megoldódott, és értesítse a felhasználókat, hogy ezek nem átmenetileg nem érhető el.</span><span class="sxs-lookup"><span data-stu-id="7e098-156">You may even want to disable certain features altogether until the problem is resolved and notify users that those features are temporarily unavailable.</span></span>

<span data-ttu-id="7e098-157">Ha úgy dönt, hogy az egyes szolgáltatásokhoz hibák kezelésének külön-külön, is szüksége lesz az alkalmazás futtatásához csak olvasható módban szolgáltatás képes kezelni.</span><span class="sxs-lookup"><span data-stu-id="7e098-157">If you decide to handle errors for each service separately, you will also need to handle the ability to run your application in read-only mode by service.</span></span> <span data-ttu-id="7e098-158">Minden szolgáltatás, amely akkor engedélyezhető, és le van tiltva, és kezelni a megfelelő helyen, a kódban a megfelelő jelző csak olvasható jelzők lehet.</span><span class="sxs-lookup"><span data-stu-id="7e098-158">You could have read-only flags for each service that can be enabled and disabled and handle the appropriate flag in the appropriate places in your code.</span></span>

<span data-ttu-id="7e098-159">Egy másik oldalán juttatás tudnak majd futtassa az alkalmazást csak olvasható módban van –, lehetővé teszi a korlátozott működésének biztosításához a súlyos alkalmazás frissítése során.</span><span class="sxs-lookup"><span data-stu-id="7e098-159">Being able to run your application in read-only mode has another side benefit – it gives you the ability to ensure limited functionality during a major application upgrade.</span></span> <span data-ttu-id="7e098-160">Az alkalmazás csak olvasható módban fusson, és a másodlagos adatközpontba ponton senki sem fér hozzá az adatokat az elsődleges régióban frissítések létrehozása idejére biztosítása elindítható.</span><span class="sxs-lookup"><span data-stu-id="7e098-160">You can trigger your application to run in read-only mode and point to the secondary data center, ensuring nobody is accessing the data in the primary region while you're making upgrades.</span></span>

## <a name="handling-updates-when-running-in-read-only-mode"></a><span data-ttu-id="7e098-161">Frissítések kezelése, csak olvasható módban történő futtatásakor</span><span class="sxs-lookup"><span data-stu-id="7e098-161">Handling updates when running in read-only mode</span></span>

<span data-ttu-id="7e098-162">Számos módon frissítés-kérelmeket kezelnek, csak olvasható módban történő futtatásakor.</span><span class="sxs-lookup"><span data-stu-id="7e098-162">There are many ways to handle update requests when running in read-only mode.</span></span> <span data-ttu-id="7e098-163">Átfogó azt ne fedje ez, de általában többféle annak a figyelembe venni.</span><span class="sxs-lookup"><span data-stu-id="7e098-163">We won't cover this comprehensively, but generally, there are a couple of patterns that you consider.</span></span>

1.  <span data-ttu-id="7e098-164">A felhasználó válaszolnak, és közölje vele, jelenleg nem elfogadja frissítések.</span><span class="sxs-lookup"><span data-stu-id="7e098-164">You can respond to your user and tell them you are not currently accepting updates.</span></span> <span data-ttu-id="7e098-165">Például a kapcsolattartási rendszer kihasználva ügyfelek számára a kapcsolattartási adatok eléréséhez, de nem módosításokat.</span><span class="sxs-lookup"><span data-stu-id="7e098-165">For example, a contact management system could enable customers to access contact information but not make updates.</span></span>

2.  <span data-ttu-id="7e098-166">A frissítések, egy másik régióban is sorba helyezni.</span><span class="sxs-lookup"><span data-stu-id="7e098-166">You can enqueue your updates in another region.</span></span> <span data-ttu-id="7e098-167">Ebben az esetben, akkor a függőben lévő frissítési kérelmek írni a várólista egy másik régióban, és majd tudja feldolgozni ezeket a kérelmeket, miután újra online állapotba az elsődleges adatközpont kerül.</span><span class="sxs-lookup"><span data-stu-id="7e098-167">In this case, you would write your pending update requests to a queue in a different region, and then have a way to process those requests after the primary data center comes online again.</span></span> <span data-ttu-id="7e098-168">Ha ebben a forgatókönyvben hagyja, az ügyfél tudja, hogy a kért frissítés várakozik későbbi feldolgozás céljából.</span><span class="sxs-lookup"><span data-stu-id="7e098-168">In this scenario, you should let the customer know that the update requested is queued for later processing.</span></span>

3.  <span data-ttu-id="7e098-169">A frissítések a tárfiók más régióban írhat.</span><span class="sxs-lookup"><span data-stu-id="7e098-169">You can write your updates to a storage account in another region.</span></span> <span data-ttu-id="7e098-170">Majd ha az elsődleges adatközpont ismét online elérhető, akkor ezek a frissítések egyesítése az elsődleges adatok, attól függően, hogy az adatok szerkezete módot.</span><span class="sxs-lookup"><span data-stu-id="7e098-170">Then when the primary data center comes back online, you can have a way to merge those updates into the primary data, depending on the structure of the data.</span></span> <span data-ttu-id="7e098-171">Például ha a név egy dátum-/ időbélyeg külön fájlt hoz létre, másolhatja azokat a fájlokat vissza az elsődleges régióban a.</span><span class="sxs-lookup"><span data-stu-id="7e098-171">For example, if you are creating separate files with a date/time stamp in the name, you can copy those files back to the primary region.</span></span> <span data-ttu-id="7e098-172">Ez a módszer egyes munkaterhelések, például a naplózás és az iOT.</span><span class="sxs-lookup"><span data-stu-id="7e098-172">This works for some workloads such as logging and iOT data.</span></span>

## <a name="handling-retries"></a><span data-ttu-id="7e098-173">Az újrapróbálkozások kezelése</span><span class="sxs-lookup"><span data-stu-id="7e098-173">Handling retries</span></span>

<span data-ttu-id="7e098-174">Hogyan tudja megállapítani, mely hibák Újrapróbálkozást lehetővé tevő?</span><span class="sxs-lookup"><span data-stu-id="7e098-174">How do you know which errors are retryable?</span></span> <span data-ttu-id="7e098-175">Ez határozza meg a storage ügyféloldali kódtára.</span><span class="sxs-lookup"><span data-stu-id="7e098-175">This is determined by the storage client library.</span></span> <span data-ttu-id="7e098-176">Például a 404-es hiba (az erőforrás nem található) nincs Újrapróbálkozást lehetővé tevő mert az újrapróbálkozás nem valószínűleg sikeres.</span><span class="sxs-lookup"><span data-stu-id="7e098-176">For example, a 404 error (resource not found) is not retryable because retrying it is not likely to result in success.</span></span> <span data-ttu-id="7e098-177">Másrészről 500 hiba nem Újrapróbálkozást lehetővé tevő, mert a kiszolgáló hibája, és egyszerűen lehet, hogy átmeneti jellegű probléma.</span><span class="sxs-lookup"><span data-stu-id="7e098-177">On the other hand, a 500 error is retryable because it is a server error, and it may simply be a transient issue.</span></span> <span data-ttu-id="7e098-178">További részletekért tekintse meg a [nyissa meg a ExponentialRetry osztály forráskódja](https://github.com/Azure/azure-storage-net/blob/87b84b3d5ee884c7adc10e494e2c7060956515d0/Lib/Common/RetryPolicies/ExponentialRetry.cs) a .NET a storage ügyféloldali kódtára a.</span><span class="sxs-lookup"><span data-stu-id="7e098-178">For more details, check out the [open source code for the ExponentialRetry class](https://github.com/Azure/azure-storage-net/blob/87b84b3d5ee884c7adc10e494e2c7060956515d0/Lib/Common/RetryPolicies/ExponentialRetry.cs) in the .NET storage client library.</span></span> <span data-ttu-id="7e098-179">(Keresse meg a ShouldRetry metódust.)</span><span class="sxs-lookup"><span data-stu-id="7e098-179">(Look for the ShouldRetry method.)</span></span>

### <a name="read-requests"></a><span data-ttu-id="7e098-180">Olvasási kérések</span><span class="sxs-lookup"><span data-stu-id="7e098-180">Read requests</span></span>

<span data-ttu-id="7e098-181">Ha az elsődleges storage probléma van a olvasási kérelmek átirányíthatók a másodlagos tárterületre.</span><span class="sxs-lookup"><span data-stu-id="7e098-181">Read requests can be redirected to secondary storage if there is a problem with primary storage.</span></span> <span data-ttu-id="7e098-182">Szerint azt a fentiekben leírtuk a [idővel azonos adatokat használó](#using-eventually-consistent-data), esetleg az elavult adatokat olvasni az alkalmazás elfogadható kell lennie.</span><span class="sxs-lookup"><span data-stu-id="7e098-182">As noted above in [Using Eventually Consistent Data](#using-eventually-consistent-data), it must be acceptable for your application to potentially read stale data.</span></span> <span data-ttu-id="7e098-183">A storage ügyféloldali kódtár használatakor RA-GRS adatok eléréséhez egy olvasási kérést újrapróbálkozási viselkedését értékének beállításával megadhatja a **LocationMode** tulajdonságot a következők egyikét:</span><span class="sxs-lookup"><span data-stu-id="7e098-183">If you are using the storage client library to access RA-GRS data, you can specify the retry behavior of a read request by setting a value for the **LocationMode** property to one of the following:</span></span>

*   <span data-ttu-id="7e098-184">**PrimaryOnly** (alapértelmezés)</span><span class="sxs-lookup"><span data-stu-id="7e098-184">**PrimaryOnly** (the default)</span></span>

*   <span data-ttu-id="7e098-185">**PrimaryThenSecondary**</span><span class="sxs-lookup"><span data-stu-id="7e098-185">**PrimaryThenSecondary**</span></span>

*   <span data-ttu-id="7e098-186">**SecondaryOnly**</span><span class="sxs-lookup"><span data-stu-id="7e098-186">**SecondaryOnly**</span></span>

*   <span data-ttu-id="7e098-187">**SecondaryThenPrimary**</span><span class="sxs-lookup"><span data-stu-id="7e098-187">**SecondaryThenPrimary**</span></span>

<span data-ttu-id="7e098-188">Ha a **LocationMode** való **PrimaryThenSecondary**, ha az elsődleges végpont nem tud Újrapróbálkozást lehetővé tevő hiba, az ügyfél számára a kezdeti olvasási kérelem automatikusan küld egy másik olvasási kérelem, hogy a másodlagos végpont.</span><span class="sxs-lookup"><span data-stu-id="7e098-188">When you set the **LocationMode** to **PrimaryThenSecondary**, if the initial read request to the primary endpoint fails with a retryable error, the client automatically makes another read request to the secondary endpoint.</span></span> <span data-ttu-id="7e098-189">Ha a hiba: a kiszolgáló időkorlátja, az ügyfél lesz Várjon, amíg az időkorlát lejár, mielőtt egy újrapróbálkozást lehetővé tevő hiba kap a szolgáltatástól.</span><span class="sxs-lookup"><span data-stu-id="7e098-189">If the error is a server timeout, then the client will have to wait for the timeout to expire before it receives a retryable error from the service.</span></span>

<span data-ttu-id="7e098-190">Alapvetően két esetben kell figyelembe venni, hogyan reagáljon a Újrapróbálkozást lehetővé tevő hiba meghatározásakor:</span><span class="sxs-lookup"><span data-stu-id="7e098-190">There are basically two scenarios to consider when you are deciding how to respond to a retryable error:</span></span>

*   <span data-ttu-id="7e098-191">Ez egy elkülönített probléma, és az elsődleges végpont későbbi kérelmek nem ad vissza egy újrapróbálkozást lehetővé tevő hiba.</span><span class="sxs-lookup"><span data-stu-id="7e098-191">This is an isolated problem and subsequent requests to the primary endpoint will not return a retryable error.</span></span> <span data-ttu-id="7e098-192">Egy példa, ahol ez akkor fordulhat elő, amikor egy átmeneti hálózati hiba.</span><span class="sxs-lookup"><span data-stu-id="7e098-192">An example of where this might happen is when there is a transient network error.</span></span>

    <span data-ttu-id="7e098-193">Ilyen esetben van nincs jelentős teljesítményét rendelkező **LocationMode** beállítása **PrimaryThenSecondary** , ez csak akkor fordul elő ritkán.</span><span class="sxs-lookup"><span data-stu-id="7e098-193">In this scenario, there is no significant performance penalty in having **LocationMode** set to **PrimaryThenSecondary** as this only happens infrequently.</span></span>

*   <span data-ttu-id="7e098-194">Ez a tárolási szolgáltatások az elsődleges régióban közül legalább egy probléma, és az adott szolgáltatáshoz, az elsődleges régióban az összes további kérelmet valószínűleg Újrapróbálkozást lehetővé tevő hibák visszaadása egy ideig.</span><span class="sxs-lookup"><span data-stu-id="7e098-194">This is a problem with at least one of the storage services in the primary region and all subsequent requests to that service in the primary region are likely to return retryable errors for a period of time.</span></span> <span data-ttu-id="7e098-195">Egy példa erre, ha az elsődleges régióban nem teljesen érhető el.</span><span class="sxs-lookup"><span data-stu-id="7e098-195">An example of this is if the primary region is completely inaccessible.</span></span>

    <span data-ttu-id="7e098-196">Ebben a forgatókönyvben nincs rendszer teljesítményét, mert az olvasási kéréseket fog először próbálja az elsődleges végpont, várjon, amíg az időkorlát lejár, és a másodlagos végponti váltani.</span><span class="sxs-lookup"><span data-stu-id="7e098-196">In this scenario, there is a performance penalty because all your read requests will try the primary endpoint first, wait for the timeout to expire, then switch to the secondary endpoint.</span></span>

<span data-ttu-id="7e098-197">Ezek a forgatókönyvek esetén meg kell határoznia, hogy nincs folyamatban lévő probléma van az elsődleges végpont és a küldési kérelmek közvetlenül a másodlagos végponti úgy, hogy olvassa a **LocationMode** tulajdonságot **SecondaryOnly** .</span><span class="sxs-lookup"><span data-stu-id="7e098-197">For these scenarios, you should identify that there is an ongoing issue with the primary endpoint and send all read requests directly to the secondary endpoint by setting the **LocationMode** property to **SecondaryOnly**.</span></span> <span data-ttu-id="7e098-198">Ilyenkor is módosítania kell az alkalmazás futtatásához csak olvasható módban.</span><span class="sxs-lookup"><span data-stu-id="7e098-198">At this time, you should also change the application to run in read-only mode.</span></span> <span data-ttu-id="7e098-199">Ezt a módszert nevezik a [áramköri megszakító mintát](https://msdn.microsoft.com/library/dn589784.aspx).</span><span class="sxs-lookup"><span data-stu-id="7e098-199">This approach is known as the [Circuit Breaker Pattern](https://msdn.microsoft.com/library/dn589784.aspx).</span></span>

### <a name="update-requests"></a><span data-ttu-id="7e098-200">Frissítési kérelmek</span><span class="sxs-lookup"><span data-stu-id="7e098-200">Update requests</span></span>

<span data-ttu-id="7e098-201">Az áramköri megszakító mintát frissítési kérelmek is alkalmazható.</span><span class="sxs-lookup"><span data-stu-id="7e098-201">The Circuit Breaker pattern can also be applied to update requests.</span></span> <span data-ttu-id="7e098-202">Azonban frissítési kérelmek nem irányítható át másodlagos tároló, amely csak olvasható.</span><span class="sxs-lookup"><span data-stu-id="7e098-202">However, update requests cannot be redirected to secondary storage, which is read-only.</span></span> <span data-ttu-id="7e098-203">Az ilyen kérelmeket, akkor hagyja a **LocationMode** tulajdonsága **PrimaryOnly** (alapértelmezett).</span><span class="sxs-lookup"><span data-stu-id="7e098-203">For these requests, you should leave the **LocationMode** property set to **PrimaryOnly** (the default).</span></span> <span data-ttu-id="7e098-204">Kezelje ezeket a hibákat, metrika vonatkoznak ezek a kérelmek – például olyan sorok esetén – 10 hibák, és amikor teljesül a küszöbérték, váltson az alkalmazás csak olvasható módba.</span><span class="sxs-lookup"><span data-stu-id="7e098-204">To handle these errors, you can apply a metric to these requests – such as 10 failures in a row – and when your threshold is met, switch the application into read-only mode.</span></span> <span data-ttu-id="7e098-205">Ugyanazokat a módszereket visszaküldésére használatos segítségével frissítési mód, mint az áramköri megszakító mintát kapcsolatban a következő szakaszban az alábbiakban.</span><span class="sxs-lookup"><span data-stu-id="7e098-205">You can use the same methods for returning to update mode as those described below in the next section about the Circuit Breaker pattern.</span></span>

## <a name="circuit-breaker-pattern"></a><span data-ttu-id="7e098-206">Áramköri megszakító minta</span><span class="sxs-lookup"><span data-stu-id="7e098-206">Circuit Breaker pattern</span></span>

<span data-ttu-id="7e098-207">Az áramköri megszakító minta az alkalmazásban használt megakadályozhatja egy művelet, amely várhatóan többszöri sikertelen.</span><span class="sxs-lookup"><span data-stu-id="7e098-207">Using the Circuit Breaker pattern in your application can prevent it from retrying an operation that is likely to fail repeatedly.</span></span> <span data-ttu-id="7e098-208">Lehetővé teszi az alkalmazás tovább futni, hanem idő, amíg a művelet fel a rendszer ismét megkísérli exponenciálisan növekszik.</span><span class="sxs-lookup"><span data-stu-id="7e098-208">It allows the application to continue to run rather than taking up time while the operation is retried exponentially.</span></span> <span data-ttu-id="7e098-209">Azt is észleli, ha a hiba kijavítása, amikor az alkalmazás képes próbálja megismételni a műveletet.</span><span class="sxs-lookup"><span data-stu-id="7e098-209">It also detects when the fault has been fixed, at which time the application can try the operation again.</span></span>

### <a name="how-to-implement-the-circuit-breaker-pattern"></a><span data-ttu-id="7e098-210">Az áramköri megszakító mintát implementálása</span><span class="sxs-lookup"><span data-stu-id="7e098-210">How to implement the circuit breaker pattern</span></span>

<span data-ttu-id="7e098-211">Azonosítására, hogy van-e az elsődleges végpont folyamatban lévő hiba, megfigyelheti, hogy milyen gyakran az ügyfél Újrapróbálkozást lehetővé tevő hibát észlel.</span><span class="sxs-lookup"><span data-stu-id="7e098-211">To identify that there is an ongoing problem with a primary endpoint, you can monitor how frequently the client encounters retryable errors.</span></span> <span data-ttu-id="7e098-212">Mivel minden egyes eset különböző, akkor adja meg a másodlagos végponti váltani, és futtassa az alkalmazást csak olvasható módban a döntést a használni kívánt küszöbértéket.</span><span class="sxs-lookup"><span data-stu-id="7e098-212">Because each case is different, you have to decide on the threshold you want to use for the decision to switch to the secondary endpoint and run the application in read-only mode.</span></span> <span data-ttu-id="7e098-213">Például sikertelen eldöntheti, hajtanak végre a kapcsolót, ha nincs sikeres tartalmazó sor 10 hibák szerepelnek.</span><span class="sxs-lookup"><span data-stu-id="7e098-213">For example, you could decide to perform the switch if there are 10 failures in a row with no successes.</span></span> <span data-ttu-id="7e098-214">Egy másik példa egy vált, ha a kérelem egy 2 perces időszak 90 %-a nem.</span><span class="sxs-lookup"><span data-stu-id="7e098-214">Another example is to switch if 90% of the requests in a 2-minute period fail.</span></span>

<span data-ttu-id="7e098-215">Az első forgatókönyvben is egyszerűen tároljuk a hibák számát, és ha sikeres a maximális elérése előtt állítsa be a count vissza.</span><span class="sxs-lookup"><span data-stu-id="7e098-215">For the first scenario, you can simply keep a count of the failures, and if there is a success before reaching the maximum, set the count back to zero.</span></span> <span data-ttu-id="7e098-216">A második forgatókönyvben egyik megvalósítása módja használni a MemoryCache objektum (.NET).</span><span class="sxs-lookup"><span data-stu-id="7e098-216">For the second scenario, one way to implement it is to use the MemoryCache object (in .NET).</span></span> <span data-ttu-id="7e098-217">Az egyes kérelmek egy CacheItem hozzá a gyorsítótárhoz, az érték beállítása sikeres állapotra (1) vagy nem sikerül (0), és a lejárati idő beállítása – 2 percet most (vagy bármilyen az időkorlát értéke).</span><span class="sxs-lookup"><span data-stu-id="7e098-217">For each request, add a CacheItem to the cache, set the value to success (1) or fail (0), and set the expiration time to 2 minutes from now (or whatever your time constraint is).</span></span> <span data-ttu-id="7e098-218">Egy bejegyzést lejárati idő elérésekor a rendszer automatikusan eltávolítja a bejegyzést.</span><span class="sxs-lookup"><span data-stu-id="7e098-218">When an entry's expiration time is reached, the entry is automatically removed.</span></span> <span data-ttu-id="7e098-219">Ez biztosítja a működés közbeni 2 perces ablak.</span><span class="sxs-lookup"><span data-stu-id="7e098-219">This will give you a rolling 2-minute window.</span></span> <span data-ttu-id="7e098-220">Minden alkalommal, amikor Ön indítson egy lekérdezést a társzolgáltatás először segítségével a Linq lekérdezés között a MemoryCache objektum számítja ki a százalékos sikerességi megengedő az értékeket, és a számát elosztjuk.</span><span class="sxs-lookup"><span data-stu-id="7e098-220">Each time you make a request to the storage service, you first use a Linq query across the MemoryCache object to calculate the percent success by summing the values and dividing by the count.</span></span> <span data-ttu-id="7e098-221">Amikor a százalékos sikerességi bizonyos küszöb (például 10 %) alá csökken, állítsa be a **LocationMode** tulajdonság olvasási kérelem **SecondaryOnly** és írásvédett módban a folytatás előtt az alkalmazást.</span><span class="sxs-lookup"><span data-stu-id="7e098-221">When the percent success drops below some threshold (such as 10%), set the **LocationMode** property for read requests to **SecondaryOnly** and switch the application into read-only mode before continuing.</span></span>

<span data-ttu-id="7e098-222">Határozza meg, hogy mikor legyen a kapcsoló hibák száma a küszöbérték service szolgáltatás eltérhetnek az alkalmazás, így érdemes lehet minősítené konfigurálható paraméterek.</span><span class="sxs-lookup"><span data-stu-id="7e098-222">The threshold of errors used to determine when to make the switch may vary from service to service in your application, so you should consider making them configurable parameters.</span></span> <span data-ttu-id="7e098-223">Ez egyben döntheti el, az egyes szolgáltatások Újrapróbálkozást lehetővé tevő hibák kezelésének külön-külön vagy egy, a korábban bemutatott módon.</span><span class="sxs-lookup"><span data-stu-id="7e098-223">This is also where you decide to handle retryable errors from each service separately or as one, as discussed previously.</span></span>

<span data-ttu-id="7e098-224">Meg kell vizsgálni, hogyan legyen kezelve az alkalmazások több példányt, és mi a teendő, ha észleli a Újrapróbálkozást lehetővé tevő hibákat minden egyes példányában.</span><span class="sxs-lookup"><span data-stu-id="7e098-224">Another consideration is how to handle multiple instances of an application, and what to do when you detect retryable errors in each instance.</span></span> <span data-ttu-id="7e098-225">Például előfordulhat, hogy 20 virtuális gép fut betöltött ugyanazt az alkalmazást.</span><span class="sxs-lookup"><span data-stu-id="7e098-225">For example, you may have 20 VMs running with the same application loaded.</span></span> <span data-ttu-id="7e098-226">Tegye mindegyik példány külön-külön kezeli?</span><span class="sxs-lookup"><span data-stu-id="7e098-226">Do you handle each instance separately?</span></span> <span data-ttu-id="7e098-227">Ha egy példány indításakor problémák, szeretné korlátozni a választ csak egy példányhoz, vagy szeretné rendelkezik megpróbálja példányainak ugyanúgy válaszol, amikor egy példány problémát észlelt?</span><span class="sxs-lookup"><span data-stu-id="7e098-227">If one instance starts having problems, do you want to limit the response to just that one instance, or do you want to try to have all instances respond in the same way when one instance has a problem?</span></span> <span data-ttu-id="7e098-228">A példányok külön kezelése sokkal egyszerűbb, mint a próbál koordinálja a választ ezek között, de ennek módja az alkalmazás architektúra függ.</span><span class="sxs-lookup"><span data-stu-id="7e098-228">Handling the instances separately is much simpler than trying to coordinate the response across them, but how you do this depends on your application's architecture.</span></span>

### <a name="options-for-monitoring-the-error-frequency"></a><span data-ttu-id="7e098-229">Figyelheti a gyakoriságát</span><span class="sxs-lookup"><span data-stu-id="7e098-229">Options for monitoring the error frequency</span></span>

<span data-ttu-id="7e098-230">Három fő lehetőség az elsődleges régióban újrapróbálkozások gyakorisága figyelés ahhoz, hogy mikor átválthat a másodlagos régióba, és módosítsa az alkalmazás futtatásához csak olvasható módban van.</span><span class="sxs-lookup"><span data-stu-id="7e098-230">You have three main options for monitoring the frequency of retries in the primary region in order to determine when to switch over to the secondary region and change the application to run in read-only mode.</span></span>

*   <span data-ttu-id="7e098-231">Adja hozzá a kezelőt a [ **újrapróbálkozás** ](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.retrying.aspx) az esemény a [ **OperationContext** ](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.aspx) objektumot adja meg a Storage-kérelmek – Ez a mód Ebben a cikkben jelenik meg, és a hozzá tartozó mintában.</span><span class="sxs-lookup"><span data-stu-id="7e098-231">Add a handler for the [**Retrying**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.retrying.aspx) event on the [**OperationContext**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.aspx) object you pass to your storage requests – this is the method displayed in this article and used in the accompanying sample.</span></span> <span data-ttu-id="7e098-232">Ezeket az eseményeket az érvényesítést, amikor az ügyfél újrapróbálkozik a kérelmet, engedélyezése, hogy nyomon kövesse, milyen gyakran az az ügyfél az elsődleges végpont Újrapróbálkozást lehetővé tevő hibát észlel.</span><span class="sxs-lookup"><span data-stu-id="7e098-232">These events fire whenever the client retries a request, enabling you to track how often the client encounters retryable errors on a primary endpoint.</span></span>

    ```csharp 
    operationContext.Retrying += (sender, arguments) =>
    {
        // Retrying in the primary region
        if (arguments.Request.Host == primaryhostname)
            ...
    };
    ```

*   <span data-ttu-id="7e098-233">Az a [ **Evaluate** ](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.retrypolicies.iextendedretrypolicy.evaluate.aspx) egyéni újrapróbálkozási házirendje metódust, bármikor futtatható, egyéni kód ha ismételt próbálkozással kerül sor.</span><span class="sxs-lookup"><span data-stu-id="7e098-233">In the [**Evaluate**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.retrypolicies.iextendedretrypolicy.evaluate.aspx) method in a custom retry policy, you can run custom code whenever a retry takes place.</span></span> <span data-ttu-id="7e098-234">Ha ismételt próbálkozással rögzítése mellett történik, ez is lehetővé teszi a újrapróbálkozásra lehetőséget.</span><span class="sxs-lookup"><span data-stu-id="7e098-234">In addition to recording when a retry happens, this also gives you the opportunity to modify your retry behavior.</span></span>

    ```csharp 
    public RetryInfo Evaluate(RetryContext retryContext,
    OperationContext operationContext)
    {
        var statusCode = retryContext.LastRequestResult.HttpStatusCode;
        if (retryContext.CurrentRetryCount >= this.maximumAttempts
        || ((statusCode &gt;= 300 && statusCode &lt; 500 && statusCode != 408)
        || statusCode == 501 // Not Implemented
        || statusCode == 505 // Version Not Supported
            ))
        {
        // Do not retry
            return null;
        }

        // Monitor retries in the primary location
        ...

        // Determine RetryInterval and TargetLocation
        RetryInfo info =
            CreateRetryInfo(retryContext.CurrentRetryCount);

        return info;
    }
    ```

*   <span data-ttu-id="7e098-235">A harmadik módszer, hogy olyan egyéni figyelő-összetevőt alkalmazza az alkalmazás, amely folyamatosan Pingeli az olvasási kérések (például Olvasás kis blob) helyőrző az elsődleges tárolási végpontjának állapotának meghatározásához.</span><span class="sxs-lookup"><span data-stu-id="7e098-235">The third approach is to implement a custom monitoring component in your application that continually pings your primary storage endpoint with dummy read requests (such as reading a small blob) to determine its health.</span></span> <span data-ttu-id="7e098-236">A volna tarthat néhány forrás, de nem jelentős időt.</span><span class="sxs-lookup"><span data-stu-id="7e098-236">This would take up some resources, but not a significant amount.</span></span> <span data-ttu-id="7e098-237">Ha a probléma, amely eléri a küszöbérték felderített, majd hajtaná végre a kapcsolót, hogy **SecondaryOnly** és írásvédett módban.</span><span class="sxs-lookup"><span data-stu-id="7e098-237">When a problem is discovered that reaches your threshold, you would then perform the switch to **SecondaryOnly** and read-only mode.</span></span>

<span data-ttu-id="7e098-238">Egy bizonyos ponton érdemes váltson vissza az elsődleges végpont használatával, és lehetővé teszi a frissítések.</span><span class="sxs-lookup"><span data-stu-id="7e098-238">At some point, you will want to switch back to using the primary endpoint and allowing updates.</span></span> <span data-ttu-id="7e098-239">Ha a fenti első két módszer egyikével sikerült egyszerűen visszavált az elsődleges végpont, engedélyezze a frissítési mód tetszőlegesen kiválasztott mennyi idő vagy a műveletek végrehajtását követően.</span><span class="sxs-lookup"><span data-stu-id="7e098-239">If using one of the first two methods listed above, you could simply switch back to the primary endpoint and enable update mode after an arbitrarily selected amount of time or number of operations has been performed.</span></span> <span data-ttu-id="7e098-240">Majd engedélyezheti azt az újrapróbálkozási logika keresztül nyissa meg újra.</span><span class="sxs-lookup"><span data-stu-id="7e098-240">You can then let it go through the retry logic again.</span></span> <span data-ttu-id="7e098-241">Ha a probléma kijavítása, továbbra is fogja használni az elsődleges végpontot, és a frissítések engedélyezése.</span><span class="sxs-lookup"><span data-stu-id="7e098-241">If the problem has been fixed, it will continue to use the primary endpoint and allow updates.</span></span> <span data-ttu-id="7e098-242">Ha a probléma továbbra is van, azt még egyszer vált vissza a másodlagos végponti és írásvédett módban után a feltételek beállítása sikertelen.</span><span class="sxs-lookup"><span data-stu-id="7e098-242">If there is still a problem, it will once more switch back to the secondary endpoint and read-only mode after failing the criteria you've set.</span></span>

<span data-ttu-id="7e098-243">A harmadik eset, ha az elsődleges tárolási végpont pingelés sikeres ismét válik, indíthat el a kapcsoló vissza **PrimaryOnly** , és folytassa a frissítések engedélyezése.</span><span class="sxs-lookup"><span data-stu-id="7e098-243">For the third scenario, when pinging the primary storage endpoint becomes successful again, you can trigger the switch back to **PrimaryOnly** and continue allowing updates.</span></span>

## <a name="handling-eventually-consistent-data"></a><span data-ttu-id="7e098-244">Idővel konzisztenssé adatok kezelése</span><span class="sxs-lookup"><span data-stu-id="7e098-244">Handling eventually consistent data</span></span>

<span data-ttu-id="7e098-245">RA-GRS működik az elsődleges tranzakciók replikálni a másodlagos régióba.</span><span class="sxs-lookup"><span data-stu-id="7e098-245">RA-GRS works by replicating transactions from the primary to the secondary region.</span></span> <span data-ttu-id="7e098-246">A replikálási folyamat biztosítja, hogy az adatok a másodlagos régióban *idővel konzisztenssé*.</span><span class="sxs-lookup"><span data-stu-id="7e098-246">This replication process guarantees that the data in the secondary region is *eventually consistent*.</span></span> <span data-ttu-id="7e098-247">Ez azt jelenti, hogy az elsődleges régióban lévő összes tranzakció végül megjelenik a másodlagos régióban, de lehet egy lag csak akkor jelennek meg, és, hogy nincs-e a tranzakciók érkeznek, ugyanabban a sorrendben, mint amelyben a másodlagos régióban garancia azok eredetileg volt alkalmazva az elsődleges régióban.</span><span class="sxs-lookup"><span data-stu-id="7e098-247">This means that all the transactions in the primary region will eventually appear in the secondary region, but that there may be a lag before they appear, and that there is no guarantee the transactions arrive in the secondary region in the same order as that in which they were originally applied in the primary region.</span></span> <span data-ttu-id="7e098-248">Ha a tranzakciók sorrendje, nem a másodlagos régióban érkeznek meg *előfordulhat, hogy* fontolja meg az adatok inkonzisztens állapotban lesz, amíg a szolgáltatás ki, hogy a másodlagos régióban.</span><span class="sxs-lookup"><span data-stu-id="7e098-248">If your transactions arrive in the secondary region out of order, you *may* consider your data in the secondary region to be in an inconsistent state until the service catches up.</span></span>

<span data-ttu-id="7e098-249">Az alábbi táblázat egy példát, hogy mi történne, ügyeljen rá, hogy tagja alkalmazotti részletek frissítésekor a *rendszergazdák* szerepkör.</span><span class="sxs-lookup"><span data-stu-id="7e098-249">The following table shows an example of what might happen when you update the details of an employee to make her a member of the *administrators* role.</span></span> <span data-ttu-id="7e098-250">Ebben a példában az ehhez szükséges frissítenie a **alkalmazott** entitás és a frissítés egy **rendszergazdai szerepkör** entitás a számával, a rendszergazdák teljes száma.</span><span class="sxs-lookup"><span data-stu-id="7e098-250">For the sake of this example, this requires you update the **employee** entity and update an **administrator role** entity with a count of the total number of administrators.</span></span> <span data-ttu-id="7e098-251">Figyelje meg, hogy a frissítések alkalmazása nem megfelelő sorrendben másodlagos régióban.</span><span class="sxs-lookup"><span data-stu-id="7e098-251">Notice how the updates are applied out of order in the secondary region.</span></span>

| <span data-ttu-id="7e098-252">**Idő**</span><span class="sxs-lookup"><span data-stu-id="7e098-252">**Time**</span></span> | <span data-ttu-id="7e098-253">**Tranzakció**</span><span class="sxs-lookup"><span data-stu-id="7e098-253">**Transaction**</span></span>                                            | <span data-ttu-id="7e098-254">**Replikáció**</span><span class="sxs-lookup"><span data-stu-id="7e098-254">**Replication**</span></span>                       | <span data-ttu-id="7e098-255">**Utolsó szinkronizálás**</span><span class="sxs-lookup"><span data-stu-id="7e098-255">**Last Sync Time**</span></span> | <span data-ttu-id="7e098-256">**Eredménye**</span><span class="sxs-lookup"><span data-stu-id="7e098-256">**Result**</span></span> |
|----------|------------------------------------------------------------|---------------------------------------|--------------------|------------| 
| <span data-ttu-id="7e098-257">T0</span><span class="sxs-lookup"><span data-stu-id="7e098-257">T0</span></span>       | <span data-ttu-id="7e098-258">Tranzakció A:</span><span class="sxs-lookup"><span data-stu-id="7e098-258">Transaction A:</span></span> <br> <span data-ttu-id="7e098-259">Alkalmazott beszúrása</span><span class="sxs-lookup"><span data-stu-id="7e098-259">Insert employee</span></span> <br> <span data-ttu-id="7e098-260">az elsődleges entitás</span><span class="sxs-lookup"><span data-stu-id="7e098-260">entity in primary</span></span> |                                   |                    | <span data-ttu-id="7e098-261">Az elsődleges, szúrja be A tranzakció</span><span class="sxs-lookup"><span data-stu-id="7e098-261">Transaction A inserted to primary,</span></span><br> <span data-ttu-id="7e098-262">még nem replikált.</span><span class="sxs-lookup"><span data-stu-id="7e098-262">not replicated yet.</span></span> |
| <span data-ttu-id="7e098-263">A T1</span><span class="sxs-lookup"><span data-stu-id="7e098-263">T1</span></span>       |                                                            | <span data-ttu-id="7e098-264">A tranzakció</span><span class="sxs-lookup"><span data-stu-id="7e098-264">Transaction A</span></span> <br> <span data-ttu-id="7e098-265">replikált</span><span class="sxs-lookup"><span data-stu-id="7e098-265">replicated to</span></span><br> <span data-ttu-id="7e098-266">másodlagos</span><span class="sxs-lookup"><span data-stu-id="7e098-266">secondary</span></span> | <span data-ttu-id="7e098-267">A T1</span><span class="sxs-lookup"><span data-stu-id="7e098-267">T1</span></span> | <span data-ttu-id="7e098-268">Tranzakció A másodlagos replikálja.</span><span class="sxs-lookup"><span data-stu-id="7e098-268">Transaction A replicated to secondary.</span></span> <br><span data-ttu-id="7e098-269">Utolsó szinkronizálás ideje frissíteni.</span><span class="sxs-lookup"><span data-stu-id="7e098-269">Last Sync Time updated.</span></span>    |
| <span data-ttu-id="7e098-270">T2</span><span class="sxs-lookup"><span data-stu-id="7e098-270">T2</span></span>       | <span data-ttu-id="7e098-271">B tranzakció</span><span class="sxs-lookup"><span data-stu-id="7e098-271">Transaction B:</span></span><br><span data-ttu-id="7e098-272">Frissítés</span><span class="sxs-lookup"><span data-stu-id="7e098-272">Update</span></span><br> <span data-ttu-id="7e098-273">alkalmazott entitás</span><span class="sxs-lookup"><span data-stu-id="7e098-273">employee entity</span></span><br> <span data-ttu-id="7e098-274">az elsődleges</span><span class="sxs-lookup"><span data-stu-id="7e098-274">in primary</span></span>  |                                | <span data-ttu-id="7e098-275">A T1</span><span class="sxs-lookup"><span data-stu-id="7e098-275">T1</span></span>                 | <span data-ttu-id="7e098-276">Tranzakció B elsődleges, írása</span><span class="sxs-lookup"><span data-stu-id="7e098-276">Transaction B written to primary,</span></span><br> <span data-ttu-id="7e098-277">még nem replikált.</span><span class="sxs-lookup"><span data-stu-id="7e098-277">not replicated yet.</span></span>  |
| <span data-ttu-id="7e098-278">A T3</span><span class="sxs-lookup"><span data-stu-id="7e098-278">T3</span></span>       | <span data-ttu-id="7e098-279">Tranzakció C:</span><span class="sxs-lookup"><span data-stu-id="7e098-279">Transaction C:</span></span><br> <span data-ttu-id="7e098-280">Frissítés</span><span class="sxs-lookup"><span data-stu-id="7e098-280">Update</span></span> <br><span data-ttu-id="7e098-281">Rendszergazda</span><span class="sxs-lookup"><span data-stu-id="7e098-281">administrator</span></span><br><span data-ttu-id="7e098-282">a szerepkör entitás</span><span class="sxs-lookup"><span data-stu-id="7e098-282">role entity in</span></span><br><span data-ttu-id="7e098-283">elsődleges</span><span class="sxs-lookup"><span data-stu-id="7e098-283">primary</span></span> |                    | <span data-ttu-id="7e098-284">A T1</span><span class="sxs-lookup"><span data-stu-id="7e098-284">T1</span></span>                 | <span data-ttu-id="7e098-285">Tranzakció elsődleges, írása C</span><span class="sxs-lookup"><span data-stu-id="7e098-285">Transaction C written to primary,</span></span><br> <span data-ttu-id="7e098-286">még nem replikált.</span><span class="sxs-lookup"><span data-stu-id="7e098-286">not replicated yet.</span></span>  |
| <span data-ttu-id="7e098-287">*T4*</span><span class="sxs-lookup"><span data-stu-id="7e098-287">*T4*</span></span>     |                                                       | <span data-ttu-id="7e098-288">Tranzakció C</span><span class="sxs-lookup"><span data-stu-id="7e098-288">Transaction C</span></span> <br><span data-ttu-id="7e098-289">replikált</span><span class="sxs-lookup"><span data-stu-id="7e098-289">replicated to</span></span><br> <span data-ttu-id="7e098-290">másodlagos</span><span class="sxs-lookup"><span data-stu-id="7e098-290">secondary</span></span> | <span data-ttu-id="7e098-291">A T1</span><span class="sxs-lookup"><span data-stu-id="7e098-291">T1</span></span>         | <span data-ttu-id="7e098-292">C másodlagos replikált tranzakció.</span><span class="sxs-lookup"><span data-stu-id="7e098-292">Transaction C replicated to secondary.</span></span><br><span data-ttu-id="7e098-293">Nincs frissítve, mert LastSyncTime</span><span class="sxs-lookup"><span data-stu-id="7e098-293">LastSyncTime not updated because</span></span> <br><span data-ttu-id="7e098-294">B tranzakció még nincs replikálva.</span><span class="sxs-lookup"><span data-stu-id="7e098-294">transaction B has not been replicated yet.</span></span>|
| <span data-ttu-id="7e098-295">*T5*</span><span class="sxs-lookup"><span data-stu-id="7e098-295">*T5*</span></span>     | <span data-ttu-id="7e098-296">Olvassa el az entitások</span><span class="sxs-lookup"><span data-stu-id="7e098-296">Read entities</span></span> <br><span data-ttu-id="7e098-297">másodlagos</span><span class="sxs-lookup"><span data-stu-id="7e098-297">from secondary</span></span>                           |                                  | <span data-ttu-id="7e098-298">A T1</span><span class="sxs-lookup"><span data-stu-id="7e098-298">T1</span></span>                 | <span data-ttu-id="7e098-299">Alkalmazott elavult értékének beolvasása</span><span class="sxs-lookup"><span data-stu-id="7e098-299">You get the stale value for employee</span></span> <br> <span data-ttu-id="7e098-300">entitás, mert a tranzakció B nem</span><span class="sxs-lookup"><span data-stu-id="7e098-300">entity because transaction B hasn't</span></span> <br> <span data-ttu-id="7e098-301">még replikált.</span><span class="sxs-lookup"><span data-stu-id="7e098-301">replicated yet.</span></span> <span data-ttu-id="7e098-302">Az új értéket kap</span><span class="sxs-lookup"><span data-stu-id="7e098-302">You get the new value for</span></span><br> <span data-ttu-id="7e098-303">rendszergazdai szerepkör entitás mert C</span><span class="sxs-lookup"><span data-stu-id="7e098-303">administrator role entity because C has</span></span><br> <span data-ttu-id="7e098-304">a rendszer replikálja.</span><span class="sxs-lookup"><span data-stu-id="7e098-304">replicated.</span></span> <span data-ttu-id="7e098-305">Utolsó szinkronizálás ideje még nem</span><span class="sxs-lookup"><span data-stu-id="7e098-305">Last Sync Time still hasn't</span></span><br> <span data-ttu-id="7e098-306">lett frissítése, mert a tranzakció B</span><span class="sxs-lookup"><span data-stu-id="7e098-306">been updated because transaction B</span></span><br> <span data-ttu-id="7e098-307">a rendszer nem replikálja.</span><span class="sxs-lookup"><span data-stu-id="7e098-307">hasn't replicated.</span></span> <span data-ttu-id="7e098-308">Beállíthatja a</span><span class="sxs-lookup"><span data-stu-id="7e098-308">You can tell the</span></span><br><span data-ttu-id="7e098-309">rendszergazdai szerepkör entitás inkonzisztens.</span><span class="sxs-lookup"><span data-stu-id="7e098-309">administrator role entity is inconsistent</span></span> <br><span data-ttu-id="7e098-310">mivel az entitás dátum/idő után</span><span class="sxs-lookup"><span data-stu-id="7e098-310">because the entity date/time is after</span></span> <br><span data-ttu-id="7e098-311">a legutóbbi szinkronizálás ideje.</span><span class="sxs-lookup"><span data-stu-id="7e098-311">the Last Sync Time.</span></span> |
| <span data-ttu-id="7e098-312">*T6*</span><span class="sxs-lookup"><span data-stu-id="7e098-312">*T6*</span></span>     |                                                      | <span data-ttu-id="7e098-313">B tranzakció</span><span class="sxs-lookup"><span data-stu-id="7e098-313">Transaction B</span></span><br> <span data-ttu-id="7e098-314">replikált</span><span class="sxs-lookup"><span data-stu-id="7e098-314">replicated to</span></span><br> <span data-ttu-id="7e098-315">másodlagos</span><span class="sxs-lookup"><span data-stu-id="7e098-315">secondary</span></span> | <span data-ttu-id="7e098-316">T6</span><span class="sxs-lookup"><span data-stu-id="7e098-316">T6</span></span>                 | <span data-ttu-id="7e098-317">*T6* – C – az összes tranzakció van</span><span class="sxs-lookup"><span data-stu-id="7e098-317">*T6* – All transactions through C have</span></span> <br><span data-ttu-id="7e098-318">van replikálva, a legutóbbi szinkronizálás ideje</span><span class="sxs-lookup"><span data-stu-id="7e098-318">been replicated, Last Sync Time</span></span><br> <span data-ttu-id="7e098-319">frissül.</span><span class="sxs-lookup"><span data-stu-id="7e098-319">is updated.</span></span> |

<span data-ttu-id="7e098-320">Ebben a példában feltételezzük, T5 másodlagos régióban olvasási vált az ügyfél.</span><span class="sxs-lookup"><span data-stu-id="7e098-320">In this example, assume the client switches to reading from the secondary region at T5.</span></span> <span data-ttu-id="7e098-321">Sikeresen tudja olvasni a **rendszergazdai szerepkör** jelenleg entitás, de az entitást a rendszergazdák számát, amely nem megfelelő számú értéket tartalmaz **alkalmazott** , amelyek entitások a másodlagos régióban rendszergazdák jelölésű most.</span><span class="sxs-lookup"><span data-stu-id="7e098-321">It can successfully read the **administrator role** entity at this time, but the entity contains a value for the count of administrators that is not consistent with the number of **employee** entities that are marked as administrators in the secondary region at this time.</span></span> <span data-ttu-id="7e098-322">Az ügyfél az értéket, és annak kockázata, hogy a rendszer inkonzisztens adatokat egyszerűen jeleníti meg.</span><span class="sxs-lookup"><span data-stu-id="7e098-322">Your client could simply display this value, with the risk that it is inconsistent information.</span></span> <span data-ttu-id="7e098-323">Alternatív megoldásként az ügyfél kísérletet határozza meg, amely a **rendszergazdai szerepkör** a potenciálisan inkonzisztens állapotban van, mert a frissítések sorrendje nem történt, és ezután megadja az erről a felhasználó.</span><span class="sxs-lookup"><span data-stu-id="7e098-323">Alternatively, the client could attempt to determine that the **administrator role** is in a potentially inconsistent state because the updates have happened out of order, and then inform the user of this fact.</span></span>

<span data-ttu-id="7e098-324">Ismeri fel, hogy vélhetően ellentmondó adatokat tartalmaz, az ügyfél által használt értékének a *utolsó szinkronizálás* , hogy kaphat a bármikor a társzolgáltatás lekérdezésével.</span><span class="sxs-lookup"><span data-stu-id="7e098-324">To recognize that it has potentially inconsistent data, the client can use the value of the *Last Sync Time* that you can get at any time by querying a storage service.</span></span> <span data-ttu-id="7e098-325">Igen, akkor a időpontja az adatokat a másodlagos régióban utolsó konzisztens, és ha a szolgáltatás kellett alkalmazni előtt, az adott pont a tranzakciók időben.</span><span class="sxs-lookup"><span data-stu-id="7e098-325">This tells you the time when the data in the secondary region was last consistent and when the service had applied all the transactions prior to that point in time.</span></span> <span data-ttu-id="7e098-326">A fenti példában, miután a szolgáltatás által a a **alkalmazott** másodlagos régióban, a legutóbbi szinkronizálás ideje entitás értéke *T1*.</span><span class="sxs-lookup"><span data-stu-id="7e098-326">In the example shown above, after the service inserts the **employee** entity in the secondary region, the last sync time is set to *T1*.</span></span> <span data-ttu-id="7e098-327">Az értéken marad *T1* csak a szolgáltatásfrissítések a **alkalmazott** a másodlagos régióban, ha entitás *T6*.</span><span class="sxs-lookup"><span data-stu-id="7e098-327">It remains at *T1* until the service updates the **employee** entity in the secondary region when it is set to *T6*.</span></span> <span data-ttu-id="7e098-328">Ha az ügyfél lekéri a legutóbbi szinkronizálás ideje, ha olvassa be a következő entitás *T5*, azt is összehasonlíthatja az entitás időbélyegzőjét.</span><span class="sxs-lookup"><span data-stu-id="7e098-328">If the client retrieves the last sync time when it reads the entity at *T5*, it can compare it with the timestamp on the entity.</span></span> <span data-ttu-id="7e098-329">Az entitás időbélyegzőjét későbbre esik, mint a legutóbbi szinkronizálás ideje, ha az entitás potenciálisan inkonzisztens állapotban van, majd, és is igénybe vehet, függetlenül a az alkalmazás megfelelő művelet.</span><span class="sxs-lookup"><span data-stu-id="7e098-329">If the timestamp on the entity is later than the last sync time, then the entity is in a potentially inconsistent state, and you can take whatever is the appropriate action for your application.</span></span> <span data-ttu-id="7e098-330">Ez a mező használatához arról, hogy ha az elsődleges az utolsó frissítés befejeződött.</span><span class="sxs-lookup"><span data-stu-id="7e098-330">Using this field requires that you know when the last update to the primary was completed.</span></span>

## <a name="testing"></a><span data-ttu-id="7e098-331">Tesztelés</span><span class="sxs-lookup"><span data-stu-id="7e098-331">Testing</span></span>

<span data-ttu-id="7e098-332">Fontos, hogy az alkalmazás viselkedik-e a várt Újrapróbálkozást lehetővé tevő hiba teszteléséhez.</span><span class="sxs-lookup"><span data-stu-id="7e098-332">It's important to test that your application behaves as expected when it encounters retryable errors.</span></span> <span data-ttu-id="7e098-333">Például tesztelni kell, hogy az alkalmazás a másodlagos, és csak olvasható módban, ha problémát észlel, és vált, váltás amikor ismét elérhetővé az elsődleges régióban válik.</span><span class="sxs-lookup"><span data-stu-id="7e098-333">For example, you need to test that the application switches to the secondary and into read-only mode when it detects a problem, and switches back when the primary region becomes available again.</span></span> <span data-ttu-id="7e098-334">Ehhez meg kell egy újrapróbálkozást lehetővé tevő hibák, és milyen gyakran előforduló vezérlő szimulálásához.</span><span class="sxs-lookup"><span data-stu-id="7e098-334">To do this, you need a way to simulate retryable errors and control how often they occur.</span></span>

<span data-ttu-id="7e098-335">Használhat [Fiddler](http://www.telerik.com/fiddler) elfogására és módosítsa a parancsfájl a HTTP-válaszokat.</span><span class="sxs-lookup"><span data-stu-id="7e098-335">You can use [Fiddler](http://www.telerik.com/fiddler) to intercept and modify HTTP responses in a script.</span></span> <span data-ttu-id="7e098-336">A parancsfájl azonosítsa az elsődleges végpont érkező válaszokat, és a HTTP-állapotkód módosítása, amely a Storage ügyféloldali kódtár – Újrapróbálkozást lehetővé tevő hiba felismeri.</span><span class="sxs-lookup"><span data-stu-id="7e098-336">This script can identify responses that come from your primary endpoint and change the HTTP status code to one that the Storage Client Library recognizes as a retryable error.</span></span> <span data-ttu-id="7e098-337">A kódrészletet mutat be egy egyszerű a Fiddler parancsfájlt, amely elfogja a válaszok az olvasási kérésekre szemben a **employeedata** tábla visszatérési 502 állapotot:</span><span class="sxs-lookup"><span data-stu-id="7e098-337">This code snippet shows a simple example of a Fiddler script that intercepts responses to read requests against the **employeedata** table to return a 502 status:</span></span>

```java
static function OnBeforeResponse(oSession: Session) {
    ...
    if ((oSession.hostname == "\[yourstorageaccount\].table.core.windows.net")
      && (oSession.PathAndQuery.StartsWith("/employeedata?$filter"))) {
        oSession.responseCode = 502;
    }
}
```

<span data-ttu-id="7e098-338">Ebben a példában a kérelmek szélesebb körének elfogására és annak csak módosítása lehetett bővíteni a **responseCode** néhány olyan valós forgatókönyv jobban szimulálása.</span><span class="sxs-lookup"><span data-stu-id="7e098-338">You could extend this example to intercept a wider range of requests and only change the **responseCode** on some of them to better simulate a real-world scenario.</span></span> <span data-ttu-id="7e098-339">Fiddler parancsfájlok testreszabásával kapcsolatos további információkért lásd: [módosítását olyan kérésre vagy válaszra](http://docs.telerik.com/fiddler/KnowledgeBase/FiddlerScript/ModifyRequestOrResponse) a Fiddler dokumentációjában.</span><span class="sxs-lookup"><span data-stu-id="7e098-339">For more information about customizing Fiddler scripts, see [Modifying a Request or Response](http://docs.telerik.com/fiddler/KnowledgeBase/FiddlerScript/ModifyRequestOrResponse) in the Fiddler documentation.</span></span>

<span data-ttu-id="7e098-340">Amennyiben végrehajtotta az alkalmazás konfigurálható csak olvasható módra vált küszöbértékeit, akkor könnyebb lesz a viselkedés nem éles tranzakció kötetekkel tesztelése.</span><span class="sxs-lookup"><span data-stu-id="7e098-340">If you have made the thresholds for switching your application to read-only mode configurable, it will be easier to test the behavior with non-production transaction volumes.</span></span>

## <a name="next-steps"></a><span data-ttu-id="7e098-341">Következő lépések</span><span class="sxs-lookup"><span data-stu-id="7e098-341">Next Steps</span></span>

* <span data-ttu-id="7e098-342">Olvasási hozzáférés-Georedundancia kapcsolatos további információkért egy másik példa lehet megadni a LastSyncTime, beleértve talál [Windows Azure tárolási redundancia lehetőségek és az írásvédett Georedundáns redundáns tárolás](https://blogs.msdn.microsoft.com/windowsazurestorage/2013/12/11/windows-azure-storage-redundancy-options-and-read-access-geo-redundant-storage/).</span><span class="sxs-lookup"><span data-stu-id="7e098-342">For more information about Read Access Geo-Redundancy, including another example of how the LastSyncTime is set, please see [Windows Azure Storage Redundancy Options and Read Access Geo Redundant Storage](https://blogs.msdn.microsoft.com/windowsazurestorage/2013/12/11/windows-azure-storage-redundancy-options-and-read-access-geo-redundant-storage/).</span></span>

* <span data-ttu-id="7e098-343">Egy teljes mintát, hogyan végezheti el a kapcsoló oda-vissza az elsődleges és másodlagos végpontok közötti megjelenítő, lásd: [Azure-minták – az áramköri megszakító minta használatával az RA-GRS tárolással rendelkező](https://github.com/Azure-Samples/storage-dotnet-circuit-breaker-pattern-ha-apps-using-ra-grs).</span><span class="sxs-lookup"><span data-stu-id="7e098-343">For a complete sample showing how to make the switch back and forth between the Primary and Secondary endpoints, please see [Azure Samples – Using the Circuit Breaker Pattern with RA-GRS storage](https://github.com/Azure-Samples/storage-dotnet-circuit-breaker-pattern-ha-apps-using-ra-grs).</span></span>
