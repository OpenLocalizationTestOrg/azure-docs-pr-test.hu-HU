---
title: "aaaAzure tárolási tábla tervezési útmutatója |} Microsoft Docs"
description: "A Tervező méretezhető és Performant táblák Azure Table Storage-ban"
services: storage
documentationcenter: na
author: jasonnewyork
manager: tadb
editor: tysonn
ms.assetid: 8e228b0c-2998-4462-8101-9f16517393ca
ms.service: storage
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: storage
ms.date: 02/28/2017
ms.author: jahogg
ms.openlocfilehash: bbac5e83fe994c1ba1408dd43367fbcfca6a2148
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 10/06/2017
---
# <a name="azure-storage-table-design-guide-designing-scalable-and-performant-tables"></a><span data-ttu-id="bfbad-103">Az Azure Storage táblázat kialakítási Útmutató: Méretezhető tervezésével és Performant táblák</span><span class="sxs-lookup"><span data-stu-id="bfbad-103">Azure Storage Table Design Guide: Designing Scalable and Performant Tables</span></span>
[!INCLUDE [storage-table-cosmos-db-tip-include](../../includes/storage-table-cosmos-db-tip-include.md)]

<span data-ttu-id="bfbad-104">méretezhető toodesign és performant táblák, például a teljesítmény, méretezhetőség és költség tényező figyelembe kell vennie.</span><span class="sxs-lookup"><span data-stu-id="bfbad-104">toodesign scalable and performant tables you must consider a number of factors such as performance, scalability, and cost.</span></span> <span data-ttu-id="bfbad-105">Korábban létrehozott sémák a relációs adatbázisok, ha ezeket a szempontokat kell-e a megszokott tooyou, de amíg vannak bizonyos az hello Azure Table storage modell és a relációs modellek közötti Hasonlóságok, is számos fontos eltéréseket.</span><span class="sxs-lookup"><span data-stu-id="bfbad-105">If you have previously designed schemas for relational databases, these considerations will be familiar tooyou, but while there are some similarities between hello Azure Table service storage model and relational models, there are also many important differences.</span></span> <span data-ttu-id="bfbad-106">Ezek a különbségek általában toovery különböző kialakításokról, előfordulhat, hogy ismeri a relációs adatbázisok counter-intuitive vagy rossz toosomeone keresse meg, de amelyek tegye célszerű jó egy NoSQL kulcs-érték tároló hello Azure Table szolgáltatás például tervezésekor vezethet.</span><span class="sxs-lookup"><span data-stu-id="bfbad-106">These differences typically lead toovery different designs that may look counter-intuitive or wrong toosomeone familiar with relational databases, but which do make good sense if you are designing for a NoSQL key/value store such as hello Azure Table service.</span></span> <span data-ttu-id="bfbad-107">A Tervező különbségek számos módon változik meg hello arra, hogy hello Table szolgáltatás, amely tartalmazhat egy entitások (relációs adatbázis-terminológia sorainak) az adatok, vagy olyan adatkészletekhez, amelyek támogatnia kell a nagyon nagy tervezett toosupport felhőméretű alkalmazások tranzakció kötetek: így kell toothink másképp kapcsolatos hogyan tárolja az adatait, és hello Table szolgáltatás működésének megismerése.</span><span class="sxs-lookup"><span data-stu-id="bfbad-107">Many of your design differences will reflect hello fact that hello Table service is designed toosupport cloud-scale applications that can contain billions of entities (rows in relational database terminology) of data or for datasets that must support very high transaction volumes: therefore, you need toothink differently about how you store your data and understand how hello Table service works.</span></span> <span data-ttu-id="bfbad-108">Egy jól kidolgozott NoSQL-adattár engedélyezheti a megoldás tooscale sokkal tovább (és alacsonyabb költségekkel) mint olyan megoldás, amely egy relációs adatbázist használ.</span><span class="sxs-lookup"><span data-stu-id="bfbad-108">A well designed NoSQL data store can enable your solution tooscale much further (and at a lower cost) than a solution that uses a relational database.</span></span> <span data-ttu-id="bfbad-109">Az útmutató az alábbi témakörök segítségével.</span><span class="sxs-lookup"><span data-stu-id="bfbad-109">This guide helps you with these topics.</span></span>  

## <a name="about-hello-azure-table-service"></a><span data-ttu-id="bfbad-110">Kapcsolatos hello Azure Table szolgáltatás</span><span class="sxs-lookup"><span data-stu-id="bfbad-110">About hello Azure Table service</span></span>
<span data-ttu-id="bfbad-111">Ez a szakasz néhány hello fő szolgáltatásainak hello Table szolgáltatás teljesítményének és méretezhetőségének különösen fontos toodesigning mutatja be.</span><span class="sxs-lookup"><span data-stu-id="bfbad-111">This section highlights some of hello key features of hello Table service that are especially relevant toodesigning for performance and scalability.</span></span> <span data-ttu-id="bfbad-112">Ha új tooAzure tárolási és hello Table szolgáltatás, elolvashatja [Azure Storage bemutatása tooMicrosoft](storage-introduction.md) és [Ismerkedés az Azure Table Storage használatának .NET](storage-dotnet-how-to-use-tables.md) hello többi elolvasása előtt a cikk.</span><span class="sxs-lookup"><span data-stu-id="bfbad-112">If you are new tooAzure Storage and hello Table service, first read [Introduction tooMicrosoft Azure Storage](storage-introduction.md) and [Get started with Azure Table Storage using .NET](storage-dotnet-how-to-use-tables.md) before reading hello remainder of this article.</span></span> <span data-ttu-id="bfbad-113">Hello Ez az útmutató elsősorban hello Table szolgáltatás, bár ez magában foglalja a néhány leírását az Azure Queue hello Blob, és szolgáltatások hogyan használhatja őket a megoldás a Table szolgáltatás hello együtt.</span><span class="sxs-lookup"><span data-stu-id="bfbad-113">Although hello focus of this guide is on hello Table service, it will include some discussion of hello Azure Queue and Blob services, and how you might use them along with hello Table service in a solution.</span></span>  

<span data-ttu-id="bfbad-114">Mi az az hello Table szolgáltatás?</span><span class="sxs-lookup"><span data-stu-id="bfbad-114">What is hello Table service?</span></span> <span data-ttu-id="bfbad-115">Hello neve alapján várt, módon hello Table szolgáltatás használ a toostore táblázatos formátumú adatok.</span><span class="sxs-lookup"><span data-stu-id="bfbad-115">As you might expect from hello name, hello Table service uses a tabular format toostore data.</span></span> <span data-ttu-id="bfbad-116">Hello ismertetésében hello tábla minden egyes sorára entitás jelöli, és hello oszlopok tároló hello adott entitás tulajdonságait.</span><span class="sxs-lookup"><span data-stu-id="bfbad-116">In hello standard terminology, each row of hello table represents an entity, and hello columns store hello various properties of that entity.</span></span> <span data-ttu-id="bfbad-117">Minden entitás rendelkezik kulcsok toouniquely két azonosítását, és egy Timestamp típusú oszlop, amely a Table szolgáltatás hello tootrack használja, amikor hello entitás utolsó frissítésének (Ez automatikusan megtörténik, és adjon meg egy tetszőleges értéket nem lehet felülírni hello időbélyeg manuálisan).</span><span class="sxs-lookup"><span data-stu-id="bfbad-117">Every entity has a pair of keys toouniquely identify it, and a timestamp column that hello Table service uses tootrack when hello entity was last updated (this happens automatically and you cannot manually overwrite hello timestamp with an arbitrary value).</span></span> <span data-ttu-id="bfbad-118">Table szolgáltatás hello a last-modified időbélyeg (LMT) toomanage egyidejű hozzáférések optimista használja.</span><span class="sxs-lookup"><span data-stu-id="bfbad-118">hello Table service uses this last-modified timestamp (LMT) toomanage optimistic concurrency.</span></span>  

> [!NOTE]
> <span data-ttu-id="bfbad-119">hello tábla szolgáltatás REST API-műveleteket is vissza egy **ETag** osztályból származik hello last-modified időbélyeg (LMT) értéket.</span><span class="sxs-lookup"><span data-stu-id="bfbad-119">hello Table service REST API operations also return an **ETag** value that it derives from hello last-modified timestamp (LMT).</span></span> <span data-ttu-id="bfbad-120">Ebben a dokumentumban használjuk hello kifejezések ETag és LMT azonos értelemben mert toohello vonatkoznak ugyanazt az alapul szolgáló adatokat.</span><span class="sxs-lookup"><span data-stu-id="bfbad-120">In this document we will use hello terms ETag and LMT interchangeably because they refer toohello same underlying data.</span></span>  
> 
> 

<span data-ttu-id="bfbad-121">hello alábbi példában egy egyszerű táblázat kialakítási toostore alkalmazott és részleg entitásokat.</span><span class="sxs-lookup"><span data-stu-id="bfbad-121">hello following example shows a simple table design toostore employee and department entities.</span></span> <span data-ttu-id="bfbad-122">Ez a kialakítás egyszerű hello példák az útmutató későbbi részében látható számos alapul.</span><span class="sxs-lookup"><span data-stu-id="bfbad-122">Many of hello examples shown later in this guide are based on this simple design.</span></span>  

<table>
<tr>
<th><span data-ttu-id="bfbad-123">PartitionKey</span><span class="sxs-lookup"><span data-stu-id="bfbad-123">PartitionKey</span></span></th>
<th><span data-ttu-id="bfbad-124">RowKey</span><span class="sxs-lookup"><span data-stu-id="bfbad-124">RowKey</span></span></th>
<th><span data-ttu-id="bfbad-125">időbélyeg</span><span class="sxs-lookup"><span data-stu-id="bfbad-125">Timestamp</span></span></th>
<th></th>
</tr>
<tr>
<td><span data-ttu-id="bfbad-126">Marketing</span><span class="sxs-lookup"><span data-stu-id="bfbad-126">Marketing</span></span></td>
<td><span data-ttu-id="bfbad-127">00001</span><span class="sxs-lookup"><span data-stu-id="bfbad-127">00001</span></span></td>
<td><span data-ttu-id="bfbad-128">2014-08-22T00:50:32Z</span><span class="sxs-lookup"><span data-stu-id="bfbad-128">2014-08-22T00:50:32Z</span></span></td>
<td>
<table>
<tr>
<th><span data-ttu-id="bfbad-129">Utónév</span><span class="sxs-lookup"><span data-stu-id="bfbad-129">FirstName</span></span></th>
<th><span data-ttu-id="bfbad-130">Vezetéknév</span><span class="sxs-lookup"><span data-stu-id="bfbad-130">LastName</span></span></th>
<th><span data-ttu-id="bfbad-131">Kor</span><span class="sxs-lookup"><span data-stu-id="bfbad-131">Age</span></span></th>
<th><span data-ttu-id="bfbad-132">E-mail cím</span><span class="sxs-lookup"><span data-stu-id="bfbad-132">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="bfbad-133">Nincs</span><span class="sxs-lookup"><span data-stu-id="bfbad-133">Don</span></span></td>
<td><span data-ttu-id="bfbad-134">Hall</span><span class="sxs-lookup"><span data-stu-id="bfbad-134">Hall</span></span></td>
<td><span data-ttu-id="bfbad-135">34</span><span class="sxs-lookup"><span data-stu-id="bfbad-135">34</span></span></td>
<td>donh@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td><span data-ttu-id="bfbad-136">Marketing</span><span class="sxs-lookup"><span data-stu-id="bfbad-136">Marketing</span></span></td>
<td><span data-ttu-id="bfbad-137">00002</span><span class="sxs-lookup"><span data-stu-id="bfbad-137">00002</span></span></td>
<td><span data-ttu-id="bfbad-138">2014-08-22T00:50:34Z</span><span class="sxs-lookup"><span data-stu-id="bfbad-138">2014-08-22T00:50:34Z</span></span></td>
<td>
<table>
<tr>
<th><span data-ttu-id="bfbad-139">Utónév</span><span class="sxs-lookup"><span data-stu-id="bfbad-139">FirstName</span></span></th>
<th><span data-ttu-id="bfbad-140">Vezetéknév</span><span class="sxs-lookup"><span data-stu-id="bfbad-140">LastName</span></span></th>
<th><span data-ttu-id="bfbad-141">Kor</span><span class="sxs-lookup"><span data-stu-id="bfbad-141">Age</span></span></th>
<th><span data-ttu-id="bfbad-142">E-mail cím</span><span class="sxs-lookup"><span data-stu-id="bfbad-142">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="bfbad-143">Jún</span><span class="sxs-lookup"><span data-stu-id="bfbad-143">Jun</span></span></td>
<td><span data-ttu-id="bfbad-144">CaO</span><span class="sxs-lookup"><span data-stu-id="bfbad-144">Cao</span></span></td>
<td><span data-ttu-id="bfbad-145">47</span><span class="sxs-lookup"><span data-stu-id="bfbad-145">47</span></span></td>
<td>junc@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td><span data-ttu-id="bfbad-146">Marketing</span><span class="sxs-lookup"><span data-stu-id="bfbad-146">Marketing</span></span></td>
<td><span data-ttu-id="bfbad-147">Szervezeti egység</span><span class="sxs-lookup"><span data-stu-id="bfbad-147">Department</span></span></td>
<td><span data-ttu-id="bfbad-148">2014-08-22T00:50:30Z</span><span class="sxs-lookup"><span data-stu-id="bfbad-148">2014-08-22T00:50:30Z</span></span></td>
<td>
<table>
<tr>
<th><span data-ttu-id="bfbad-149">departmentname nevű</span><span class="sxs-lookup"><span data-stu-id="bfbad-149">DepartmentName</span></span></th>
<th><span data-ttu-id="bfbad-150">EmployeeCount</span><span class="sxs-lookup"><span data-stu-id="bfbad-150">EmployeeCount</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="bfbad-151">Marketing</span><span class="sxs-lookup"><span data-stu-id="bfbad-151">Marketing</span></span></td>
<td><span data-ttu-id="bfbad-152">153</span><span class="sxs-lookup"><span data-stu-id="bfbad-152">153</span></span></td>
</tr>
</table>
</td>
</tr>
<tr>
<td><span data-ttu-id="bfbad-153">Értékesítés</span><span class="sxs-lookup"><span data-stu-id="bfbad-153">Sales</span></span></td>
<td><span data-ttu-id="bfbad-154">00010</span><span class="sxs-lookup"><span data-stu-id="bfbad-154">00010</span></span></td>
<td><span data-ttu-id="bfbad-155">2014-08-22T00:50:44Z</span><span class="sxs-lookup"><span data-stu-id="bfbad-155">2014-08-22T00:50:44Z</span></span></td>
<td>
<table>
<tr>
<th><span data-ttu-id="bfbad-156">Utónév</span><span class="sxs-lookup"><span data-stu-id="bfbad-156">FirstName</span></span></th>
<th><span data-ttu-id="bfbad-157">Vezetéknév</span><span class="sxs-lookup"><span data-stu-id="bfbad-157">LastName</span></span></th>
<th><span data-ttu-id="bfbad-158">Kor</span><span class="sxs-lookup"><span data-stu-id="bfbad-158">Age</span></span></th>
<th><span data-ttu-id="bfbad-159">E-mail cím</span><span class="sxs-lookup"><span data-stu-id="bfbad-159">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="bfbad-160">Ken</span><span class="sxs-lookup"><span data-stu-id="bfbad-160">Ken</span></span></td>
<td><span data-ttu-id="bfbad-161">Kwok</span><span class="sxs-lookup"><span data-stu-id="bfbad-161">Kwok</span></span></td>
<td><span data-ttu-id="bfbad-162">23</span><span class="sxs-lookup"><span data-stu-id="bfbad-162">23</span></span></td>
<td>kenk@contoso.com</td>
</tr>
</table>
</td>
</tr>
</table>


<span data-ttu-id="bfbad-163">Az eddigi ez keresése nagyon hasonló tooa tábla egy relációs adatbázisban hello kulcs eltérésekkel alatt hello kötelező oszlopok és hello képességét toostore több entitás típusok a hello ugyanabban a táblában.</span><span class="sxs-lookup"><span data-stu-id="bfbad-163">So far, this looks very similar tooa table in a relational database with hello key differences being hello mandatory columns, and hello ability toostore multiple entity types in hello same table.</span></span> <span data-ttu-id="bfbad-164">Emellett egyes hello felhasználói tulajdonságok például **Keresztnév** vagy **kora** adattípusú, például az egész szám vagy karakterlánc, csak, például egy relációs adatbázisban oszlop.</span><span class="sxs-lookup"><span data-stu-id="bfbad-164">In addition, each of hello user-defined properties such as **FirstName** or **Age** has a data type, such as integer or string, just like a column in a relational database.</span></span> <span data-ttu-id="bfbad-165">Bár eltérően egy relációs adatbázisban, hello séma nélküli jellege hello tábla szolgáltatás azt jelenti, hogy a tulajdonság nem szükséges hello azonos adattípus minden entitáshoz.</span><span class="sxs-lookup"><span data-stu-id="bfbad-165">Although unlike in a relational database, hello schema-less nature of hello Table service means that a property need not have hello same data type on each entity.</span></span> <span data-ttu-id="bfbad-166">toostore összetett adattípusú egyetlen tulajdonsággal, például a JSON- vagy XML-szerializált formátum kell használnia.</span><span class="sxs-lookup"><span data-stu-id="bfbad-166">toostore complex data types in a single property, you must use a serialized format such as JSON or XML.</span></span> <span data-ttu-id="bfbad-167">Hello tábla szolgáltatás például a támogatott adattípusok, támogatott dátumtartományok, elnevezési szabályok és mérete megkötések kapcsolatos további információkért lásd: [ismertetése hello tábla szolgáltatás adatmodell](http://msdn.microsoft.com/library/azure/dd179338.aspx).</span><span class="sxs-lookup"><span data-stu-id="bfbad-167">For more information about hello table service such as supported data types, supported date ranges, naming rules, and size constraints, see [Understanding hello Table Service Data Model](http://msdn.microsoft.com/library/azure/dd179338.aspx).</span></span>

<span data-ttu-id="bfbad-168">Mivel látni fogja, a választott **PartitionKey** és **RowKey** alapvető toogood Táblatervezés van.</span><span class="sxs-lookup"><span data-stu-id="bfbad-168">As you will see, your choice of **PartitionKey** and **RowKey** is fundamental toogood table design.</span></span> <span data-ttu-id="bfbad-169">Minden entitás egy táblázatban tárolja rendelkeznie kell egy egyedi kombinációja **PartitionKey** és **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="bfbad-169">Every entity stored in a table must have a unique combination of **PartitionKey** and **RowKey**.</span></span> <span data-ttu-id="bfbad-170">Csakúgy, mint a kulcsokat egy relációs adatbázis tábláinak, hello **PartitionKey** és **RowKey** értékei indexelt toocreate egy fürtözött indexet, amely lehetővé teszi, hogy a gyors look-ups; azonban hello Table szolgáltatás nem hoz létre bármelyik másodlagos indexek, így ezek a hello csak két indexelt tulajdonságok (néhány későbbi hello minták megjelenítése hogyan oldható meg a nyilvánvaló korlátozás).</span><span class="sxs-lookup"><span data-stu-id="bfbad-170">As with keys in a relational database table, hello **PartitionKey** and **RowKey** values are indexed toocreate a clustered index that enables fast look-ups; however, hello Table service does not create any secondary indexes so these are hello only two indexed properties (some of hello patterns described later show how you can work around this apparent limitation).</span></span>  

<span data-ttu-id="bfbad-171">Egy tábla egy vagy több partíció épül fel, és mivel látni fogja, hello számos tervezési döntések körül megfelelő választás lehet lesz **PartitionKey** és **RowKey** toooptimize a megoldás.</span><span class="sxs-lookup"><span data-stu-id="bfbad-171">A table is made up of one or more partitions, and as you will see, many of hello design decisions you make will be around choosing a suitable **PartitionKey** and **RowKey** toooptimize your solution.</span></span> <span data-ttu-id="bfbad-172">A megoldás csak egyetlen tábla összes, a partíciók szervezve entitásokat tartalmazó sikerült alkotják, de általában egy megoldás több táblák esetében.</span><span class="sxs-lookup"><span data-stu-id="bfbad-172">A solution could consist of just a single table that contains all your entities organized into partitions, but typically a solution will have multiple tables.</span></span> <span data-ttu-id="bfbad-173">Táblázatok segítséget toologically rendezheti az entitások, amelyekkel kezelheti a hozzáférést toohello használatával végzett hozzáférés-vezérlési listák és egyetlen tárolási művelettel teljes táblázat elvetné.</span><span class="sxs-lookup"><span data-stu-id="bfbad-173">Tables help you toologically organize your entities, help you manage access toohello data using access control lists, and you can drop an entire table using a single storage operation.</span></span>  

### <a name="table-partitions"></a><span data-ttu-id="bfbad-174">Táblapartíciók</span><span class="sxs-lookup"><span data-stu-id="bfbad-174">Table partitions</span></span>
<span data-ttu-id="bfbad-175">hello fiók nevét, a tábla neve és **PartitionKey** hello partíción belül hol tárolja az hello table szolgáltatás a hello entitás hello társzolgáltatás együtt azonosításához.</span><span class="sxs-lookup"><span data-stu-id="bfbad-175">hello account name, table name and **PartitionKey** together identify hello partition within hello storage service where hello table service stores hello entity.</span></span> <span data-ttu-id="bfbad-176">Amellett, hogy a címzési séma entitások hello részét, partíciók tranzakciók hatókör meghatározása (lásd: [entitás csoport tranzakciók](#entity-group-transactions) alább), és hogyan hello table szolgáltatás méretezi űrlap hello alapját.</span><span class="sxs-lookup"><span data-stu-id="bfbad-176">As well as being part of hello addressing scheme for entities, partitions define a scope for transactions (see [Entity Group Transactions](#entity-group-transactions) below), and form hello basis of how hello table service scales.</span></span> <span data-ttu-id="bfbad-177">További információk a partíciókon: [Azure Storage méretezhetőségi és teljesítménycéloknak](storage-scalability-targets.md).</span><span class="sxs-lookup"><span data-stu-id="bfbad-177">For more information on partitions see [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span></span>  

<span data-ttu-id="bfbad-178">A Table szolgáltatás hello, az egyes csomópontok szolgáltatások egyik, vagy több partíció befejeződését, és méretezik service dinamikus terheléselosztás hello partíciók csomópontjai között.</span><span class="sxs-lookup"><span data-stu-id="bfbad-178">In hello Table service, an individual node services one or more complete partitions and hello service scales by dynamically load-balancing partitions across nodes.</span></span> <span data-ttu-id="bfbad-179">Ha egy csomópont terhelésnek van kitéve, hello table szolgáltatás is *vágási* partíciók hello számos különböző csomópontokon, a csomópont által kiszolgált; forgalom enyhül, amikor hello szolgáltatást is *egyesítési* hello partíció találhatók csendes csomópontok biztonsági alakzatot egyetlen csomópont.</span><span class="sxs-lookup"><span data-stu-id="bfbad-179">If a node is under load, hello table service can *split* hello range of partitions serviced by that node onto different nodes; when traffic subsides, hello service can *merge* hello partition ranges from quiet nodes back onto a single node.</span></span>  

<span data-ttu-id="bfbad-180">További információ a hello hello belső részleteit Table szolgáltatás, és különösen hello szolgáltatás kezeli a partíciókat, hogy olvassa hello papír [Microsoft Azure Storage: A magas rendelkezésre álló felhőalapú tárolási szolgáltatásba az erős konzisztencia](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx).</span><span class="sxs-lookup"><span data-stu-id="bfbad-180">For more information about hello internal details of hello Table service, and in particular how hello service manages partitions, see hello paper [Microsoft Azure Storage: A Highly Available Cloud Storage Service with Strong Consistency](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx).</span></span>  

### <a name="entity-group-transactions"></a><span data-ttu-id="bfbad-181">Entitás csoport tranzakciók</span><span class="sxs-lookup"><span data-stu-id="bfbad-181">Entity Group Transactions</span></span>
<span data-ttu-id="bfbad-182">A Table szolgáltatás hello entitás csoport tranzakciók (EGTs) csak beépített mechanizmus hello atomi frissítések végrehajtásához a több egység közötti.</span><span class="sxs-lookup"><span data-stu-id="bfbad-182">In hello Table service, Entity Group Transactions (EGTs) are hello only built-in mechanism for performing atomic updates across multiple entities.</span></span> <span data-ttu-id="bfbad-183">EGTs megtalálhatók hivatkozott tooas *kötegelt tranzakciókat* bizonyos dokumentációkban.</span><span class="sxs-lookup"><span data-stu-id="bfbad-183">EGTs are also referred tooas *batch transactions* in some documentation.</span></span> <span data-ttu-id="bfbad-184">EGTs csak működhessenek hello tárolt entitásokat tartalmazó partícióra (megosztás hello egy adott táblában azonos partíciós kulcs), így bármikor atomi tranzakciós viselkedés szüksége több egység közötti tartozó entitásokból hello tooensure kell egyazon partícióra kerüljenek.</span><span class="sxs-lookup"><span data-stu-id="bfbad-184">EGTs can only operate on entities stored in hello same partition (share hello same partition key in a given table), so anytime you need atomic transactional behavior across multiple entities you need tooensure that those entities are in hello same partition.</span></span> <span data-ttu-id="bfbad-185">Ez gyakran az több entitástípusok megőrzi hello azonos tábla (és particionálhatja) található, és több tábla nem használ másik entitástípusok okát.</span><span class="sxs-lookup"><span data-stu-id="bfbad-185">This is often a reason for keeping multiple entity types in hello same table (and partition) and not using multiple tables for different entity types.</span></span> <span data-ttu-id="bfbad-186">Egyetlen EGT legfeljebb 100 entitást is működik.</span><span class="sxs-lookup"><span data-stu-id="bfbad-186">A single EGT can operate on at most 100 entities.</span></span>  <span data-ttu-id="bfbad-187">Ha több egyidejű EGTs fontos tooensure feldolgozása van e EGTs nem működik, amelyek közösek a EGTs között, mivel ellenkező esetben feldolgozása késleltethető entitások.</span><span class="sxs-lookup"><span data-stu-id="bfbad-187">If you submit multiple concurrent EGTs for processing it is important tooensure  those EGTs do not operate on entities that are common across EGTs as otherwise processing can be delayed.</span></span>

<span data-ttu-id="bfbad-188">EGTs is vezethet a potenciális kompromisszum a tooevaluate kialakításában: több partíciót használata megnöveli a hello méretezhetőség, az alkalmazás Azure-csomópontokon keresztüli kérelmek terheléselosztási további lehetőségekkel rendelkezik, de ez korlátozhatja a hello az alkalmazás tooperform atomi tranzakciók azon képessége, és erős konzisztenciát biztosít az adatok karbantartása.</span><span class="sxs-lookup"><span data-stu-id="bfbad-188">EGTs also introduce a potential trade-off for you tooevaluate in your design: using more partitions will increase hello scalability of your application because Azure has more opportunities for load balancing requests across nodes, but this might limit hello ability of your application tooperform atomic transactions and maintain strong consistency for your data.</span></span> <span data-ttu-id="bfbad-189">Emellett nincsenek egyedi méretezhetőségi célok javasoljuk, hogy előfordulhat, hogy korlátozza az egyetlen csomópont számíthat tranzakciók hello átviteli szintű hello: További információ az Azure storage-fiókok és hello tábla hello méretezhetőségi célok szolgáltatás című [Azure Storage méretezhetőségi és teljesítménycéloknak](storage-scalability-targets.md).</span><span class="sxs-lookup"><span data-stu-id="bfbad-189">Furthermore, there are specific scalability targets at hello level of a partition that might limit hello throughput of transactions you can expect for a single node: for more information about hello scalability targets for Azure storage accounts and hello table service, see [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span></span> <span data-ttu-id="bfbad-190">A jelen útmutató későbbi szakaszok tárgyalják különböző kialakítási stratégiák, amelyek segítenek kezelni például ez kompromisszumot és ismertetik, hogyan lehet a legjobban toochoose a partíciós kulcs hello meghatározott követelmények alapján az ügyfélalkalmazás.</span><span class="sxs-lookup"><span data-stu-id="bfbad-190">Later sections of this guide discuss various design strategies that help you manage trade-offs such as this one, and discuss how best toochoose your partition key based on hello specific requirements of your client application.</span></span>  

### <a name="capacity-considerations"></a><span data-ttu-id="bfbad-191">A kapacitás kapcsolatos szempontok</span><span class="sxs-lookup"><span data-stu-id="bfbad-191">Capacity considerations</span></span>
<span data-ttu-id="bfbad-192">hello alábbi táblázat tartalmaz néhány hello kulcsértékei toobe tudomást amikor tervezésekor a Table szolgáltatás megoldás:</span><span class="sxs-lookup"><span data-stu-id="bfbad-192">hello following table includes some of hello key values toobe aware of when you are designing a Table service solution:</span></span>  

| <span data-ttu-id="bfbad-193">Az Azure storage-fiók teljes kapacitás</span><span class="sxs-lookup"><span data-stu-id="bfbad-193">Total capacity of an Azure storage account</span></span> | <span data-ttu-id="bfbad-194">500 TB</span><span class="sxs-lookup"><span data-stu-id="bfbad-194">500 TB</span></span> |
| --- | --- |
| <span data-ttu-id="bfbad-195">Egy Azure storage-fiókot a táblák száma</span><span class="sxs-lookup"><span data-stu-id="bfbad-195">Number of tables in an Azure storage account</span></span> |<span data-ttu-id="bfbad-196">Csak hello tárfiók hello kapacitásának korlátozva</span><span class="sxs-lookup"><span data-stu-id="bfbad-196">Limited only by hello capacity of hello storage account</span></span> |
| <span data-ttu-id="bfbad-197">Egy tábla partíciók száma</span><span class="sxs-lookup"><span data-stu-id="bfbad-197">Number of partitions in a table</span></span> |<span data-ttu-id="bfbad-198">Csak hello tárfiók hello kapacitásának korlátozva</span><span class="sxs-lookup"><span data-stu-id="bfbad-198">Limited only by hello capacity of hello storage account</span></span> |
| <span data-ttu-id="bfbad-199">Partíció entitástartományának száma</span><span class="sxs-lookup"><span data-stu-id="bfbad-199">Number of entities in a partition</span></span> |<span data-ttu-id="bfbad-200">Csak hello tárfiók hello kapacitásának korlátozva</span><span class="sxs-lookup"><span data-stu-id="bfbad-200">Limited only by hello capacity of hello storage account</span></span> |
| <span data-ttu-id="bfbad-201">Az egyes entitás mérete</span><span class="sxs-lookup"><span data-stu-id="bfbad-201">Size of an individual entity</span></span> |<span data-ttu-id="bfbad-202">Legfeljebb 255 tulajdonságok legfeljebb too1 MB (beleértve a hello **PartitionKey**, **RowKey**, és **időbélyeg**)</span><span class="sxs-lookup"><span data-stu-id="bfbad-202">Up too1 MB with a maximum of 255 properties (including hello **PartitionKey**, **RowKey**, and **Timestamp**)</span></span> |
| <span data-ttu-id="bfbad-203">Hello mérete **PartitionKey**</span><span class="sxs-lookup"><span data-stu-id="bfbad-203">Size of hello **PartitionKey**</span></span> |<span data-ttu-id="bfbad-204">Egy karakterlánc too1 KB méretű mentése</span><span class="sxs-lookup"><span data-stu-id="bfbad-204">A string up too1 KB in size</span></span> |
| <span data-ttu-id="bfbad-205">Hello mérete **RowKey**</span><span class="sxs-lookup"><span data-stu-id="bfbad-205">Size of hello **RowKey**</span></span> |<span data-ttu-id="bfbad-206">Egy karakterlánc too1 KB méretű mentése</span><span class="sxs-lookup"><span data-stu-id="bfbad-206">A string up too1 KB in size</span></span> |
| <span data-ttu-id="bfbad-207">Egy entitás csoport tranzakció mérete</span><span class="sxs-lookup"><span data-stu-id="bfbad-207">Size of an Entity Group Transaction</span></span> |<span data-ttu-id="bfbad-208">Egy tranzakció legfeljebb 100 entitást tartalmazhat, és hello hasznos lehet kisebb, mint 4 MB-nál.</span><span class="sxs-lookup"><span data-stu-id="bfbad-208">A transaction can include at most 100 entities and hello payload must be less than 4 MB in size.</span></span> <span data-ttu-id="bfbad-209">Egy EGT csak frissíthető entitás egyszer.</span><span class="sxs-lookup"><span data-stu-id="bfbad-209">An EGT can only update an entity once.</span></span> |

<span data-ttu-id="bfbad-210">További információkért lásd: [ismertetése hello tábla szolgáltatás adatmodell](http://msdn.microsoft.com/library/azure/dd179338.aspx).</span><span class="sxs-lookup"><span data-stu-id="bfbad-210">For more information, see [Understanding hello Table Service Data Model](http://msdn.microsoft.com/library/azure/dd179338.aspx).</span></span>  

### <a name="cost-considerations"></a><span data-ttu-id="bfbad-211">Költség kapcsolatos szempontok</span><span class="sxs-lookup"><span data-stu-id="bfbad-211">Cost considerations</span></span>
<span data-ttu-id="bfbad-212">A TABLE storage költségei viszonylag alacsonyak, de költség becslése mindkét kapacitás használati és hello tranzakciók mennyisége a hello Table szolgáltatás használó megoldások próbaidőszakában részeként tartalmaznia kell.</span><span class="sxs-lookup"><span data-stu-id="bfbad-212">Table storage is relatively inexpensive, but you should include cost estimates for both capacity usage and hello quantity of transactions as part of your evaluation of any solution that uses hello Table service.</span></span> <span data-ttu-id="bfbad-213">Azonban számos forgatókönyvben denormalizált vagy ismétlődő adatok tárolását rendelés tooimprove hello teljesítmény vagy a méretezhetőség miatt a megoldás nem egy érvényes megközelítés tootake.</span><span class="sxs-lookup"><span data-stu-id="bfbad-213">However, in many scenarios storing denormalized or duplicate data in order tooimprove hello performance or scalability of your solution is a valid approach tootake.</span></span> <span data-ttu-id="bfbad-214">Az árazással kapcsolatos további információkért lásd: [Azure Storage szolgáltatás díjszabása](https://azure.microsoft.com/pricing/details/storage/).</span><span class="sxs-lookup"><span data-stu-id="bfbad-214">For more information about pricing, see [Azure Storage Pricing](https://azure.microsoft.com/pricing/details/storage/).</span></span>  

## <a name="guidelines-for-table-design"></a><span data-ttu-id="bfbad-215">Táblatervezés vonatkozó irányelvek</span><span class="sxs-lookup"><span data-stu-id="bfbad-215">Guidelines for table design</span></span>
<span data-ttu-id="bfbad-216">A listák összesítésének néhány hello kulcs irányelveket kell figyelembe venni a táblák tervezése során, és ez az útmutató foglalkozni fog velük az összes későbbi részében részletesebben.</span><span class="sxs-lookup"><span data-stu-id="bfbad-216">These lists summarize some of hello key guidelines you should keep in mind when you are designing your tables, and this guide will address them all in more detail later in.</span></span> <span data-ttu-id="bfbad-217">Ezeket az irányelveket nagyon eltérnek általában végrehajtania a relációs adatbázis-tervező hello irányelveket.</span><span class="sxs-lookup"><span data-stu-id="bfbad-217">These guidelines are very different from hello guidelines you would typically follow for relational database design.</span></span>  

<span data-ttu-id="bfbad-218">A Table szolgáltatás megoldás toobe tervezése *olvasási* hatékony:</span><span class="sxs-lookup"><span data-stu-id="bfbad-218">Designing your Table service solution toobe *read* efficient:</span></span>

* <span data-ttu-id="bfbad-219">***Tervezze meg az olvasási műveleteket alkalmazásokban lekérdezése.***</span><span class="sxs-lookup"><span data-stu-id="bfbad-219">***Design for querying in read-heavy applications.***</span></span> <span data-ttu-id="bfbad-220">A táblák tervezésekor gondolniuk hello lekérdezéseket (különösen hello késés bizalmas is), amely, végrehajtja a véleménye hogyan frissíti az entitások előtt.</span><span class="sxs-lookup"><span data-stu-id="bfbad-220">When you are designing your tables, think about hello queries (especially hello latency sensitive ones) that you will execute before you think about how you will update your entities.</span></span> <span data-ttu-id="bfbad-221">Ez általában annak az eredménye a hatékony és performant megoldás.</span><span class="sxs-lookup"><span data-stu-id="bfbad-221">This typically results in an efficient and performant solution.</span></span>  
* <span data-ttu-id="bfbad-222">***Adja meg a lekérdezések PartitionKey és RowKey is.***</span><span class="sxs-lookup"><span data-stu-id="bfbad-222">***Specify both PartitionKey and RowKey in your queries.***</span></span> <span data-ttu-id="bfbad-223">*Mutasson a lekérdezések* például ezek a hello leghatékonyabb tábla szolgáltatás lekérdezéseket.</span><span class="sxs-lookup"><span data-stu-id="bfbad-223">*Point queries* such as these are hello most efficient table service queries.</span></span>  
* <span data-ttu-id="bfbad-224">***Érdemes tárolni a duplikált entitásokat.***</span><span class="sxs-lookup"><span data-stu-id="bfbad-224">***Consider storing duplicate copies of entities.***</span></span> <span data-ttu-id="bfbad-225">A TABLE storage olcsó ezért fontolja meg több alkalommal (különböző kulccsal rendelkező) ugyanaz az entitás tárolása hello tooenable hatékonyabb lekérdezések.</span><span class="sxs-lookup"><span data-stu-id="bfbad-225">Table storage is cheap so consider storing hello same entity multiple times (with different keys) tooenable more efficient queries.</span></span>  
* <span data-ttu-id="bfbad-226">***Vegye figyelembe az adatok denormalizing.***</span><span class="sxs-lookup"><span data-stu-id="bfbad-226">***Consider denormalizing your data.***</span></span> <span data-ttu-id="bfbad-227">A TABLE storage olcsó ezért fontolja meg az adatok denormalizing.</span><span class="sxs-lookup"><span data-stu-id="bfbad-227">Table storage is cheap so consider denormalizing your data.</span></span> <span data-ttu-id="bfbad-228">Összegző entitások például tárolja, hogy a lekérdezések összesített adatok csak egyetlen entitáshoz tooaccess kell.</span><span class="sxs-lookup"><span data-stu-id="bfbad-228">For example, store summary entities so that queries for aggregate data only need tooaccess a single entity.</span></span>  
* <span data-ttu-id="bfbad-229">***Használja az összetett kulcs értékeket.***</span><span class="sxs-lookup"><span data-stu-id="bfbad-229">***Use compound key values.***</span></span> <span data-ttu-id="bfbad-230">hello csak akkor kulcsokban **PartitionKey** és **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="bfbad-230">hello only keys you have are **PartitionKey** and **RowKey**.</span></span> <span data-ttu-id="bfbad-231">Például használja az összetett kulcs értékeket tooenable másodlagos kulccsal elérési útvonalak tooentities.</span><span class="sxs-lookup"><span data-stu-id="bfbad-231">For example, use compound key values tooenable alternate keyed access paths tooentities.</span></span>  
* <span data-ttu-id="bfbad-232">***Lekérdezés vetítéshez használni.***</span><span class="sxs-lookup"><span data-stu-id="bfbad-232">***Use query projection.***</span></span> <span data-ttu-id="bfbad-233">Válassza ki a csak a szükséges mezők hello lekérdezésekkel hello hálózati átvitel adatok mennyisége hello csökkentése érdekében.</span><span class="sxs-lookup"><span data-stu-id="bfbad-233">You can reduce hello amount of data that you transfer over hello network by using queries that select just hello fields you need.</span></span>  

<span data-ttu-id="bfbad-234">A Table szolgáltatás megoldás toobe tervezése *írási* hatékony:</span><span class="sxs-lookup"><span data-stu-id="bfbad-234">Designing your Table service solution toobe *write* efficient:</span></span>  

* <span data-ttu-id="bfbad-235">***Ne hozzon létre a gyakran használt adatok partíciókat.***</span><span class="sxs-lookup"><span data-stu-id="bfbad-235">***Do not create hot partitions.***</span></span> <span data-ttu-id="bfbad-236">Válassza ki, amelyek lehetővé teszik toospread kulcsok a kérelmek közötti idő minden helyen több partíciót.</span><span class="sxs-lookup"><span data-stu-id="bfbad-236">Choose keys that enable you toospread your requests across multiple partitions at any point of time.</span></span>  
* <span data-ttu-id="bfbad-237">***Kerülje a forgalmat a teljesítményt.***</span><span class="sxs-lookup"><span data-stu-id="bfbad-237">***Avoid spikes in traffic.***</span></span> <span data-ttu-id="bfbad-238">Hello forgalom sima ésszerű meghatározott időtartam során rendelkezésre, és elkerülheti a forgalmat a teljesítményt.</span><span class="sxs-lookup"><span data-stu-id="bfbad-238">Smooth hello traffic over a reasonable period of time and avoid spikes in traffic.</span></span>
* <span data-ttu-id="bfbad-239">***Feltétlenül ne hozzon létre egy külön táblázat az egyes entitás.***</span><span class="sxs-lookup"><span data-stu-id="bfbad-239">***Don't necessarily create a separate table for each type of entity.***</span></span> <span data-ttu-id="bfbad-240">Ha atomi tranzakciók entitástípusok között, tárolhat több entitás típusaival azonos hello partíciójához hello ugyanabban a táblában.</span><span class="sxs-lookup"><span data-stu-id="bfbad-240">When you require atomic transactions across entity types, you can store these multiple entity types in hello same partition in hello same table.</span></span>
* <span data-ttu-id="bfbad-241">***Vegye figyelembe a hello maximális átviteli sebesség kell elérni.***</span><span class="sxs-lookup"><span data-stu-id="bfbad-241">***Consider hello maximum throughput you must achieve.***</span></span> <span data-ttu-id="bfbad-242">Kell figyelembe vennie a Table szolgáltatás hello hello méretezhetőségi célok, és győződjön meg arról, hogy a tervező nem miatt a tooexceed őket.</span><span class="sxs-lookup"><span data-stu-id="bfbad-242">You must be aware of hello scalability targets for hello Table service and ensure that your design will not cause you tooexceed them.</span></span>  

<span data-ttu-id="bfbad-243">Ez az útmutató olvasás példák, amelyek a gyakorlatban az összes alapelvek jelenik meg.</span><span class="sxs-lookup"><span data-stu-id="bfbad-243">As you read this guide, you will see examples that put all of these principles into practice.</span></span>  

## <a name="design-for-querying"></a><span data-ttu-id="bfbad-244">Tervezési lekérdezése</span><span class="sxs-lookup"><span data-stu-id="bfbad-244">Design for querying</span></span>
<span data-ttu-id="bfbad-245">TABLE szolgáltatási megoldások intenzív, írási intenzív vagy hello két vegyesen olvashatók.</span><span class="sxs-lookup"><span data-stu-id="bfbad-245">Table service solutions may be read intensive, write intensive, or a mix of hello two.</span></span> <span data-ttu-id="bfbad-246">Ez a szakasz összpontosít hello dolgot toobear szem előtt, a Table szolgáltatás toosupport hatékonyan olvasási műveletek tervezése során.</span><span class="sxs-lookup"><span data-stu-id="bfbad-246">This section focuses on hello things toobear in mind when you are designing your Table service toosupport read operations efficiently.</span></span> <span data-ttu-id="bfbad-247">A Tervező, támogatja a hatékony olvassa el az operations általában is hatékony az írási műveletek.</span><span class="sxs-lookup"><span data-stu-id="bfbad-247">Typically, a design that supports read operations efficiently is also efficient for write operations.</span></span> <span data-ttu-id="bfbad-248">Van azonban további szempontok toobear figyelembe amikor designing toosupport írási műveleteket, hello a következő szakaszban tárgyalt [adatmódosítás kialakítása](#design-for-data-modification).</span><span class="sxs-lookup"><span data-stu-id="bfbad-248">However, there are additional considerations toobear in mind when designing toosupport write operations, discussed in hello next section, [Design for data modification](#design-for-data-modification).</span></span>

<span data-ttu-id="bfbad-249">A Table szolgáltatás megoldás tooenable tervezéséhez jó kiindulási pont tooread adatok hatékonyan tooask "milyen lekérdezések fogja a szükséges tooexecute tooretrieve hello alkalmazásadatok a Table szolgáltatás hello kell?"</span><span class="sxs-lookup"><span data-stu-id="bfbad-249">A good starting point for designing your Table service solution tooenable you tooread data efficiently is tooask "What queries will my application need tooexecute tooretrieve hello data it needs from hello Table service?"</span></span>  

> [!NOTE]
> <span data-ttu-id="bfbad-250">Table szolgáltatás hello, fontos tooget hello megfelelő kialakítás előre mert bonyolult és költséges toochange később.</span><span class="sxs-lookup"><span data-stu-id="bfbad-250">With hello Table service, it's important tooget hello design correct up front because it's difficult and expensive toochange it later.</span></span> <span data-ttu-id="bfbad-251">Például egy relációs adatbázisban, gyakran egyszerűen hozzáadásával lehetséges tooaddress teljesítményproblémák indexeli a meglévő adatbázis tooan: Ez a lehetőség nem érhető a Table szolgáltatás hello.</span><span class="sxs-lookup"><span data-stu-id="bfbad-251">For example, in a relational database it's often possible tooaddress performance issues simply by adding indexes tooan existing database: this is not an option with hello Table service.</span></span>  
> 
> 

<span data-ttu-id="bfbad-252">Ez a szakasz hello kapcsolatos problémák meg kell oldania a táblák lekérdezése tervezésekor összpontosít.</span><span class="sxs-lookup"><span data-stu-id="bfbad-252">This section focuses on hello key issues you must address when you design your tables for querying.</span></span> <span data-ttu-id="bfbad-253">Ebben a szakaszban ismertetett hello témaköröket tartalmazza:</span><span class="sxs-lookup"><span data-stu-id="bfbad-253">hello topics covered in this section include:</span></span>

* [<span data-ttu-id="bfbad-254">Hogy a választott PartitionKey és RowKey milyen hatással van a teljesítmény-küszöbérték</span><span class="sxs-lookup"><span data-stu-id="bfbad-254">How your choice of PartitionKey and RowKey impacts query performance</span></span>](#how-your-choice-of-partitionkey-and-rowkey-impacts-query-performance)
* [<span data-ttu-id="bfbad-255">Egy megfelelő PartitionKey kiválasztása</span><span class="sxs-lookup"><span data-stu-id="bfbad-255">Choosing an appropriate PartitionKey</span></span>](#choosing-an-appropriate-partitionkey)
* [<span data-ttu-id="bfbad-256">A Table szolgáltatás hello lekérdezések optimalizálása</span><span class="sxs-lookup"><span data-stu-id="bfbad-256">Optimizing queries for hello Table service</span></span>](#optimizing-queries-for-the-table-service)
* [<span data-ttu-id="bfbad-257">A Table szolgáltatás hello adatok rendezése</span><span class="sxs-lookup"><span data-stu-id="bfbad-257">Sorting data in hello Table service</span></span>](#sorting-data-in-the-table-service)

### <a name="how-your-choice-of-partitionkey-and-rowkey-impacts-query-performance"></a><span data-ttu-id="bfbad-258">Hogy a választott PartitionKey és RowKey milyen hatással van a teljesítmény-küszöbérték</span><span class="sxs-lookup"><span data-stu-id="bfbad-258">How your choice of PartitionKey and RowKey impacts query performance</span></span>
<span data-ttu-id="bfbad-259">hello alábbi példák azt feltételezik hello table szolgáltatás alkalmazott entitások tárolja a struktúra a következő hello (hello példák a legtöbb hagyja el a hello **időbélyeg** jobb érthetőség kedvéért bizonyos tulajdonság):</span><span class="sxs-lookup"><span data-stu-id="bfbad-259">hello following examples assume hello table service is storing employee entities with hello following structure (most of hello examples omit hello **Timestamp** property for clarity):</span></span>  

| <span data-ttu-id="bfbad-260">*Oszlop neve*</span><span class="sxs-lookup"><span data-stu-id="bfbad-260">*Column name*</span></span> | <span data-ttu-id="bfbad-261">*Adattípus*</span><span class="sxs-lookup"><span data-stu-id="bfbad-261">*Data type*</span></span> |
| --- | --- |
| <span data-ttu-id="bfbad-262">**PartitionKey** (részleg neve)</span><span class="sxs-lookup"><span data-stu-id="bfbad-262">**PartitionKey** (Department Name)</span></span> |<span data-ttu-id="bfbad-263">Karakterlánc</span><span class="sxs-lookup"><span data-stu-id="bfbad-263">String</span></span> |
| <span data-ttu-id="bfbad-264">**RowKey** (alkalmazott azonosítója)</span><span class="sxs-lookup"><span data-stu-id="bfbad-264">**RowKey** (Employee Id)</span></span> |<span data-ttu-id="bfbad-265">Karakterlánc</span><span class="sxs-lookup"><span data-stu-id="bfbad-265">String</span></span> |
| <span data-ttu-id="bfbad-266">**Utónév**</span><span class="sxs-lookup"><span data-stu-id="bfbad-266">**FirstName**</span></span> |<span data-ttu-id="bfbad-267">Karakterlánc</span><span class="sxs-lookup"><span data-stu-id="bfbad-267">String</span></span> |
| <span data-ttu-id="bfbad-268">**Vezetéknév**</span><span class="sxs-lookup"><span data-stu-id="bfbad-268">**LastName**</span></span> |<span data-ttu-id="bfbad-269">Karakterlánc</span><span class="sxs-lookup"><span data-stu-id="bfbad-269">String</span></span> |
| <span data-ttu-id="bfbad-270">**Kora**</span><span class="sxs-lookup"><span data-stu-id="bfbad-270">**Age**</span></span> |<span data-ttu-id="bfbad-271">Egész szám</span><span class="sxs-lookup"><span data-stu-id="bfbad-271">Integer</span></span> |
| <span data-ttu-id="bfbad-272">**E-mail cím**</span><span class="sxs-lookup"><span data-stu-id="bfbad-272">**EmailAddress**</span></span> |<span data-ttu-id="bfbad-273">Karakterlánc</span><span class="sxs-lookup"><span data-stu-id="bfbad-273">String</span></span> |

<span data-ttu-id="bfbad-274">a szakasz korábbi hello [Azure Table szolgáltatás áttekintése](#overview) néhány hello funkciói a hello Azure Table szolgáltatás, amely közvetlenül befolyásolják a lekérdezéshez tervezéséről foglalja össze.</span><span class="sxs-lookup"><span data-stu-id="bfbad-274">hello earlier section [Azure Table service overview](#overview) describes some of hello key features of hello Azure Table service that have a direct influence on designing for query.</span></span> <span data-ttu-id="bfbad-275">Ezek a következő általános irányelveket a Table szolgáltatás Lekérdezéstervezés hello eredményez.</span><span class="sxs-lookup"><span data-stu-id="bfbad-275">These result in hello following general guidelines for designing Table service queries.</span></span> <span data-ttu-id="bfbad-276">Vegye figyelembe, hogy az alábbi hello a példákban szereplő hello szűrőszintaxisának hello Table szolgáltatás REST API-t a további tudnivalókat lásd a [lekérdezés entitások](http://msdn.microsoft.com/library/azure/dd179421.aspx).</span><span class="sxs-lookup"><span data-stu-id="bfbad-276">Note that hello filter syntax used in hello examples below is from hello Table service REST API, for more information see [Query Entities](http://msdn.microsoft.com/library/azure/dd179421.aspx).</span></span>  

* <span data-ttu-id="bfbad-277">A ***pont lekérdezés*** hello leghatékonyabb keresési toouse, és nagy mennyiségű keresések vagy a legkisebb mértékű késleltetést igénylő keresések használt toobe ajánlott.</span><span class="sxs-lookup"><span data-stu-id="bfbad-277">A ***Point Query*** is hello most efficient lookup toouse and is recommended toobe used for high-volume lookups or lookups requiring lowest latency.</span></span> <span data-ttu-id="bfbad-278">Ilyen lekérdezés nagyon hatékonyan az hello indexek toolocate egyedi entitás használhatja mindkettő hello megadásával **PartitionKey** és **RowKey** értékeket.</span><span class="sxs-lookup"><span data-stu-id="bfbad-278">Such a query can use hello indexes toolocate an individual entity very efficiently by specifying both hello **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="bfbad-279">Például: $filter = (PartitionKey eq 'Értékesítés') és (RowKey eq '2')</span><span class="sxs-lookup"><span data-stu-id="bfbad-279">For example: $filter=(PartitionKey eq 'Sales') and (RowKey eq '2')</span></span>  
* <span data-ttu-id="bfbad-280">Második legjobb van egy ***értéktartomány lekérdezésének*** hello használó **PartitionKey** és a szűrők számos **RowKey** értékek tooreturn egynél több entitás.</span><span class="sxs-lookup"><span data-stu-id="bfbad-280">Second best is a ***Range Query*** that uses hello **PartitionKey** and filters on a range of **RowKey** values tooreturn more than one entity.</span></span> <span data-ttu-id="bfbad-281">Hello **PartitionKey** érték azonosítja az egy adott partícióra, és a hello **RowKey** értékek azonosítása hello entitások az adott partíció egy részét.</span><span class="sxs-lookup"><span data-stu-id="bfbad-281">hello **PartitionKey** value identifies a specific partition, and hello **RowKey** values identify a subset of hello entities in that partition.</span></span> <span data-ttu-id="bfbad-282">Például: $filter = "Értékesítési és RowKey ge" PartitionKey eq és RowKey lt jelzést "</span><span class="sxs-lookup"><span data-stu-id="bfbad-282">For example: $filter=PartitionKey eq 'Sales' and RowKey ge 'S' and RowKey lt 'T'</span></span>  
* <span data-ttu-id="bfbad-283">Harmadik legjobb van egy ***partíció vizsgálata*** hello használó **PartitionKey** és olyan nem kulcs tulajdonsága, és hogy a szűrők térhetnek vissza egy entitást.</span><span class="sxs-lookup"><span data-stu-id="bfbad-283">Third best is a ***Partition Scan*** that uses hello **PartitionKey** and filters on another non-key property and that may return more than one entity.</span></span> <span data-ttu-id="bfbad-284">Hello **PartitionKey** érték egy adott partícióra azonosítja, és hello tulajdonság értékei válassza ki az adott partíció hello entitásának egy részéhez.</span><span class="sxs-lookup"><span data-stu-id="bfbad-284">hello **PartitionKey** value identifies a specific partition, and hello property values select for a subset of hello entities in that partition.</span></span> <span data-ttu-id="bfbad-285">Például: $filter PartitionKey eq "Értékesítési" és a Vezetéknév eq 'Smith' =</span><span class="sxs-lookup"><span data-stu-id="bfbad-285">For example: $filter=PartitionKey eq 'Sales' and LastName eq 'Smith'</span></span>  
* <span data-ttu-id="bfbad-286">A ***tábla vizsgálata*** nem tartalmazza a hello **PartitionKey** és nem nagyon hatékony, mivel az összes pedig a táblázatban a megfelelő entitások hello partíciókat keresi.</span><span class="sxs-lookup"><span data-stu-id="bfbad-286">A ***Table Scan*** does not include hello **PartitionKey** and is very inefficient because it searches all of hello partitions that make up your table in turn for any matching entities.</span></span> <span data-ttu-id="bfbad-287">A táblázatbeolvasás, függetlenül attól, hogy a szűrő-e használja a hello hajtja végre **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="bfbad-287">It will perform a table scan regardless of whether or not your filter uses hello **RowKey**.</span></span> <span data-ttu-id="bfbad-288">Például: $filter Vezetéknév eq "János" =</span><span class="sxs-lookup"><span data-stu-id="bfbad-288">For example: $filter=LastName eq 'Jones'</span></span>  
* <span data-ttu-id="bfbad-289">Több entitás visszaadó lekérdezések Alapértelmezések rendezve **PartitionKey** és **RowKey** sorrendje.</span><span class="sxs-lookup"><span data-stu-id="bfbad-289">Queries that return multiple entities return them sorted in **PartitionKey** and **RowKey** order.</span></span> <span data-ttu-id="bfbad-290">tooavoid keresésére átrendezésével hello entitásának hello ügyfél, válassza ki a **RowKey** hello leggyakrabban használt rendezési sorrend meghatározó.</span><span class="sxs-lookup"><span data-stu-id="bfbad-290">tooavoid resorting hello entities in hello client, choose a **RowKey** that defines hello most common sort order.</span></span>  

<span data-ttu-id="bfbad-291">Vegye figyelembe, hogy használja az "**vagy**" szűrő alapján toospecify **RowKey** értéket egy partíció vizsgálati eredményeket, majd egy értéktartomány lekérdezésének nem számít.</span><span class="sxs-lookup"><span data-stu-id="bfbad-291">Note that using an "**or**" toospecify a filter based on **RowKey** values results in a partition scan and is not treated as a range query.</span></span> <span data-ttu-id="bfbad-292">Ezért kerülje el a lekérdezéseket, szűrők, mint amelyekkel: $filter = PartitionKey eq 'Értékesítés' és (RowKey eq "121" vagy "322" RowKey eq)</span><span class="sxs-lookup"><span data-stu-id="bfbad-292">Therefore, you should avoid queries that use filters such as: $filter=PartitionKey eq 'Sales' and (RowKey eq '121' or RowKey eq '322')</span></span>  

<span data-ttu-id="bfbad-293">Az ügyféloldali kódot hello a Storage ügyféloldali kódtára tooexecute hatékony lekérdezések használó című részben talál példákat:</span><span class="sxs-lookup"><span data-stu-id="bfbad-293">For examples of client-side code that use hello Storage Client Library tooexecute efficient queries, see:</span></span>  

* [<span data-ttu-id="bfbad-294">A Storage ügyféloldali kódtára hello segítségével pont lekérdezése</span><span class="sxs-lookup"><span data-stu-id="bfbad-294">Executing a point query using hello Storage Client Library</span></span>](#executing-a-point-query-using-the-storage-client-library)
* [<span data-ttu-id="bfbad-295">LINQ használatával több entitás beolvasásakor</span><span class="sxs-lookup"><span data-stu-id="bfbad-295">Retrieving multiple entities using LINQ</span></span>](#retrieving-multiple-entities-using-linq)
* [<span data-ttu-id="bfbad-296">Kiszolgálóoldali leképezése</span><span class="sxs-lookup"><span data-stu-id="bfbad-296">Server-side projection</span></span>](#server-side-projection)  

<span data-ttu-id="bfbad-297">Példák ügyféloldali kódot, amelyet több entitás kezelni tud a típusok tárolt hello azonos táblázatban, lásd:</span><span class="sxs-lookup"><span data-stu-id="bfbad-297">For examples of client-side code that can handle multiple entity types stored in hello same table, see:</span></span>  

* [<span data-ttu-id="bfbad-298">Heterogén entitástípusok használata</span><span class="sxs-lookup"><span data-stu-id="bfbad-298">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)  

### <a name="choosing-an-appropriate-partitionkey"></a><span data-ttu-id="bfbad-299">Egy megfelelő PartitionKey kiválasztása</span><span class="sxs-lookup"><span data-stu-id="bfbad-299">Choosing an appropriate PartitionKey</span></span>
<span data-ttu-id="bfbad-300">A választott **PartitionKey** kell egyensúlyba hello kell tooenables hello használata EGTs (tooensure konzisztencia) hello követelmény toodistribute szemben az entitások több partíciót (tooensure méretezhető megoldás).</span><span class="sxs-lookup"><span data-stu-id="bfbad-300">Your choice of **PartitionKey** should balance hello need tooenables hello use of EGTs (tooensure consistency) against hello requirement toodistribute your entities across multiple partitions (tooensure a scalable solution).</span></span>  

<span data-ttu-id="bfbad-301">Egy rendkívüli az entitások sikerült egyetlen partícióra vannak tárolva, de ez korlátozhatja a megoldás hello méretezhetőséget, és szeretné, hogy hello table szolgáltatás nem tudja tooload-egyenleg kérelmek.</span><span class="sxs-lookup"><span data-stu-id="bfbad-301">At one extreme, you could store all your entities in a single partition, but this may limit hello scalability of your solution and would prevent hello table service from being able tooload-balance requests.</span></span> <span data-ttu-id="bfbad-302">A hello más extreme tárolhatja partíciónként, amely magas szinten méretezhető lenne, és lehetővé teszi a hello tábla szolgáltatáskérések tooload elosztani a kéréseket, de amelyek akadályozzák meg entitás csoport tranzakciók használatával egy entitást.</span><span class="sxs-lookup"><span data-stu-id="bfbad-302">At hello other extreme, you could store one entity per partition, which would be highly scalable and which enables hello table service tooload-balance requests, but which would prevent you from using entity group transactions.</span></span>  

<span data-ttu-id="bfbad-303">Az ideális **PartitionKey** , amely lehetővé teszi toouse hatékony lekérdezések és a megoldás megfelelő partíciók tooensure rendelkező méretezhető.</span><span class="sxs-lookup"><span data-stu-id="bfbad-303">An ideal **PartitionKey** is one that enables you toouse efficient queries and that has sufficient partitions tooensure your solution is scalable.</span></span> <span data-ttu-id="bfbad-304">Általában találja, hogy az entitások lesz-e az entitások elosztja elegendő partíciók megfelelő tulajdonság.</span><span class="sxs-lookup"><span data-stu-id="bfbad-304">Typically, you will find that your entities will have a suitable property that distributes your entities across sufficient partitions.</span></span>

> [!NOTE]
> <span data-ttu-id="bfbad-305">A rendszer, hogy a felhasználók vagy az alkalmazottak kapcsolatos információkat tárolja, például UserID lehet egy jó PartitionKey.</span><span class="sxs-lookup"><span data-stu-id="bfbad-305">For example, in a system that stores information about users or employees, UserID may be a good PartitionKey.</span></span> <span data-ttu-id="bfbad-306">Előfordulhat, hogy több entitás, amely egy adott felhasználói azonosítóját használják hello partíciós kulcs.</span><span class="sxs-lookup"><span data-stu-id="bfbad-306">You may have several entities that use a given UserID as hello partition key.</span></span> <span data-ttu-id="bfbad-307">Minden entitás, amely a felhasználó adatait tárolja egyetlen partícióra vannak csoportosítva, és ezért ezeket az entitásokat elérhetők entitás csoport tranzakciók, miközben továbbra is magas szinten méretezhető.</span><span class="sxs-lookup"><span data-stu-id="bfbad-307">Each entity that stores data about a user is grouped into a single partition, and so these entities are accessible via entity group transactions, while still being highly scalable.</span></span>
> 
> 

<span data-ttu-id="bfbad-308">Nincsenek további szempontok a választott **PartitionKey** toohow fog beszúrási, frissítési és törlési entitások kapcsolódó: hello című [adatmódosítás kialakítása](#design-for-data-modification) alatt.</span><span class="sxs-lookup"><span data-stu-id="bfbad-308">There are additional considerations in your choice of **PartitionKey** that relate toohow you will insert, update, and delete entities: see hello section [Design for data modification](#design-for-data-modification) below.</span></span>  

### <a name="optimizing-queries-for-hello-table-service"></a><span data-ttu-id="bfbad-309">A Table szolgáltatás hello lekérdezések optimalizálása</span><span class="sxs-lookup"><span data-stu-id="bfbad-309">Optimizing queries for hello Table service</span></span>
<span data-ttu-id="bfbad-310">Table szolgáltatás hello automatikusan elvégzi az entitások hello segítségével **PartitionKey** és **RowKey** értékeket egy fürtözött index, ezért hello oka, hogy a pont lekérdezések vannak hello leghatékonyabb toouse .</span><span class="sxs-lookup"><span data-stu-id="bfbad-310">hello Table service automatically indexes your entities using hello **PartitionKey** and **RowKey** values in a single clustered index, hence hello reason that point queries are hello most efficient toouse.</span></span> <span data-ttu-id="bfbad-311">Van azonban nem fürtözött index hello hello eltérő indexei **PartitionKey** és **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="bfbad-311">However, there are no indexes other than that on hello clustered index on hello **PartitionKey** and **RowKey**.</span></span>

<span data-ttu-id="bfbad-312">Sok meg kell felelnie a követelmények tooenable keresési entitások több feltétel alapján.</span><span class="sxs-lookup"><span data-stu-id="bfbad-312">Many designs must meet requirements tooenable lookup of entities based on multiple criteria.</span></span> <span data-ttu-id="bfbad-313">Például az e-mailek alapján alkalmazott entitások keresése Alkalmazottazonosító vagy vezetéknevét.</span><span class="sxs-lookup"><span data-stu-id="bfbad-313">For example, locating employee entities based on email, employee id, or last name.</span></span> <span data-ttu-id="bfbad-314">következő hello szakasz minták hello [táblázat kialakítási minta](#table-design-patterns) követelmény az ilyen típusú cím és megkerülő megoldásának végrehajtásához hello tényt, hogy hello Table szolgáltatás nem nyújt másodlagos indexek módjait ismerteti:</span><span class="sxs-lookup"><span data-stu-id="bfbad-314">hello following patterns in hello section [Table Design Patterns](#table-design-patterns) address these types of requirement and describe ways of working around hello fact that hello Table service does not provide secondary indexes:</span></span>  

* <span data-ttu-id="bfbad-315">[Intra-partíció másodlagos index mintát](#intra-partition-secondary-index-pattern) -tárolja a több másolatot minden entitás használatával különböző **RowKey** értékek (hello a partícióra) tooenable gyors és hatékony keresést és a másodlagos rendezési sorrend rendelések használatával különböző **RowKey** értékeket.</span><span class="sxs-lookup"><span data-stu-id="bfbad-315">[Intra-partition secondary index pattern](#intra-partition-secondary-index-pattern) - Store multiple copies of each entity using different **RowKey** values (in hello same partition) tooenable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span>  
* <span data-ttu-id="bfbad-316">[Másodlagos helyek közötti partíció index mintát](#inter-partition-secondary-index-pattern) – minden értékekkel különböző RowKey külön partíciók vagy külön táblázatban tooenable gyors entitás több példányát tárolja, és a különböző rendelésekhatékonykereséstésamásodlagosrendezésisorrend**RowKey** értékeket.</span><span class="sxs-lookup"><span data-stu-id="bfbad-316">[Inter-partition secondary index pattern](#inter-partition-secondary-index-pattern) - Store multiple copies of each entity using different RowKey values in separate partitions or in separate tables tooenable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span>  
* <span data-ttu-id="bfbad-317">[Index entitások mintát](#index-entities-pattern) -index entitások tooenable hatékony keresések entitások listájának visszaadó karbantartása.</span><span class="sxs-lookup"><span data-stu-id="bfbad-317">[Index Entities Pattern](#index-entities-pattern) - Maintain index entities tooenable efficient searches that return lists of entities.</span></span>  

### <a name="sorting-data-in-hello-table-service"></a><span data-ttu-id="bfbad-318">A Table szolgáltatás hello adatok rendezése</span><span class="sxs-lookup"><span data-stu-id="bfbad-318">Sorting data in hello Table service</span></span>
<span data-ttu-id="bfbad-319">Table szolgáltatás hello növekvő sorrendben rendezve entitásokat ad vissza **PartitionKey** és a majd **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="bfbad-319">hello Table service returns entities sorted in ascending order based on **PartitionKey** and then by **RowKey**.</span></span> <span data-ttu-id="bfbad-320">Ezek a kulcsok karakterlánc-értékek és tooensure, amely numerikus érték rendezése megfelelően kell tooa rögzített hosszúságú alakíthatja át őket, és nulla kitölti őket.</span><span class="sxs-lookup"><span data-stu-id="bfbad-320">These keys are string values and tooensure that numeric values sort correctly, you should convert them tooa fixed length and pad them with zeroes.</span></span> <span data-ttu-id="bfbad-321">Például ha hello alkalmazott azonosító értékét használja hello **RowKey** megadott egész szám, alkalmazottazonosító átalakíthatja **123** túl**00000123**.</span><span class="sxs-lookup"><span data-stu-id="bfbad-321">For example, if hello employee id value you use as hello **RowKey** is an integer value, you should convert employee id **123** too**00000123**.</span></span>  

<span data-ttu-id="bfbad-322">Számos alkalmazás toouse adatok más-más sorrendben rendezve követelményekkel rendelkezik: az alkalmazottak például rendezést a neve vagy való csatlakozás dátumát.</span><span class="sxs-lookup"><span data-stu-id="bfbad-322">Many applications have requirements toouse data sorted in different orders: for example, sorting employees by name, or by joining date.</span></span> <span data-ttu-id="bfbad-323">következő hello szakasz minták hello [táblázat kialakítási minta](#table-design-patterns) hogyan tooalternate sorrendjét az entitások cím:</span><span class="sxs-lookup"><span data-stu-id="bfbad-323">hello following patterns in hello section [Table Design Patterns](#table-design-patterns) address how tooalternate sort orders for your entities:</span></span>  

* <span data-ttu-id="bfbad-324">[Intra-partíció másodlagos index mintát](#intra-partition-secondary-index-pattern) -minden különböző RowKey értékekkel entitás több példányát tárolja (hello a partícióra) tooenable gyors és hatékony keresést és a másodlagos rendezési sorrend rendelések különböző RowKey értékek használatával.</span><span class="sxs-lookup"><span data-stu-id="bfbad-324">[Intra-partition secondary index pattern](#intra-partition-secondary-index-pattern) - Store multiple copies of each entity using different RowKey values (in hello same partition) tooenable fast and efficient lookups and alternate sort orders by using different RowKey values.</span></span>  
* <span data-ttu-id="bfbad-325">[Másodlagos helyek közötti partíció index mintát](#inter-partition-secondary-index-pattern) – minden különböző RowKey érték használatát külön táblázatban tooenable külön partíciók gyors entitás több példányát tárolja, és hatékony keresést és a másodlagos rendezési sorrend rendelések különböző RowKey használatával értékek.</span><span class="sxs-lookup"><span data-stu-id="bfbad-325">[Inter-partition secondary index pattern](#inter-partition-secondary-index-pattern) - Store multiple copies of each entity using different RowKey values in separate partitions in separate tables tooenable fast and efficient lookups and alternate sort orders by using different RowKey values.</span></span>
* <span data-ttu-id="bfbad-326">[Napló végéről mintát](#log-tail-pattern) -lekérése hello  *n*  entitások legutóbb hozzáadott tooa partíció használatával egy **RowKey** érték, amely fordított dátum és idő sorrendben rendezi.</span><span class="sxs-lookup"><span data-stu-id="bfbad-326">[Log tail pattern](#log-tail-pattern) - Retrieve hello *n* entities most recently added tooa partition by using a **RowKey** value that sorts in reverse date and time order.</span></span>  

## <a name="design-for-data-modification"></a><span data-ttu-id="bfbad-327">Adatmódosítás kialakítása</span><span class="sxs-lookup"><span data-stu-id="bfbad-327">Design for data modification</span></span>
<span data-ttu-id="bfbad-328">Ez a szakasz hello kialakítási szempontjai a beszúrások, a frissítések optimalizálása összpontosít, és törli.</span><span class="sxs-lookup"><span data-stu-id="bfbad-328">This section focuses on hello design considerations for optimizing inserts, updates, and deletes.</span></span> <span data-ttu-id="bfbad-329">Néhány esetben szüksége lesz a tooevaluate hello kompromisszum közötti terveket, terveket, hasonlóan a relációs adatbázisok terveket (bár hello technikák kezelésére szolgáló hello tervezési optimalizálás adatok módosítása ellen lekérdezése optimalizálása kompromisszumot eltérő módon jelennek meg a relációs).</span><span class="sxs-lookup"><span data-stu-id="bfbad-329">In some cases, you will need tooevaluate hello trade-off between designs that optimize for querying against designs that optimize for data modification just as you do in designs for relational databases (although hello techniques for managing hello design trade-offs are different in a relational database).</span></span> <span data-ttu-id="bfbad-330">a szakasz hello [táblázat kialakítási minta](#table-design-patterns) néhány részletes tervminták hello Table szolgáltatás ismerteti, és kiemeli a néhányat ezek kompromisszumot.</span><span class="sxs-lookup"><span data-stu-id="bfbad-330">hello section [Table Design Patterns](#table-design-patterns) describes some detailed design patterns for hello Table service and highlights some these trade-offs.</span></span> <span data-ttu-id="bfbad-331">A gyakorlatban találja, hogy az entitás lekérdezése optimalizált sok tervek is alkalmas entitások módosítása.</span><span class="sxs-lookup"><span data-stu-id="bfbad-331">In practice, you will find that many designs optimized for querying entities also work well for modifying entities.</span></span>  

### <a name="optimizing-hello-performance-of-insert-update-and-delete-operations"></a><span data-ttu-id="bfbad-332">Hello teljesítmény optimalizálása a beszúrási, frissítési és törlési műveletek</span><span class="sxs-lookup"><span data-stu-id="bfbad-332">Optimizing hello performance of insert, update, and delete operations</span></span>
<span data-ttu-id="bfbad-333">tooupdate vagy törölni egy entitást, tooidentify képesnek kell lennie az hello segítségével **PartitionKey** és **RowKey** értékeket.</span><span class="sxs-lookup"><span data-stu-id="bfbad-333">tooupdate or delete an entity, you must be able tooidentify it by using hello **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="bfbad-334">Ebben a tekintetben a választott **PartitionKey** és **RowKey** entitások módosítását érdemes követnie a hasonló feltételek tooyour választott toosupport lekérdezések mutasson, mivel tooidentify szervezetek, mint a lehető leghatékonyabb módon.</span><span class="sxs-lookup"><span data-stu-id="bfbad-334">In this respect, your choice of **PartitionKey** and **RowKey** for modifying entities should follow similar criteria tooyour choice toosupport point queries because you want tooidentify entities as efficiently as possible.</span></span> <span data-ttu-id="bfbad-335">Nem szeretné, hogy egy hatékony partíció vagy tábla vizsgálat toolocate rendelés toodiscover hello egy entitás toouse **PartitionKey** és **RowKey** értékek tooupdate kell, vagy törölje azt.</span><span class="sxs-lookup"><span data-stu-id="bfbad-335">You do not want toouse an inefficient partition or table scan toolocate an entity in order toodiscover hello **PartitionKey** and **RowKey** values you need tooupdate or delete it.</span></span>  

<span data-ttu-id="bfbad-336">következő hello szakasz minták hello [táblázat kialakítási minta](#table-design-patterns) cím optimalizálás hello teljesítmény vagy a beszúrási, frissítési és törlési műveletek:</span><span class="sxs-lookup"><span data-stu-id="bfbad-336">hello following patterns in hello section [Table Design Patterns](#table-design-patterns) address optimizing hello performance or your insert, update, and delete operations:</span></span>  

* <span data-ttu-id="bfbad-337">[Nagy mennyiségű törlése mintát](#high-volume-delete-pattern) -Enable hello törlésének nagyszámú egyidejű törlésre entitásokhoz hello tárolása saját külön táblázatban entitások; hello tábla törlésével hello entitások törlésére.</span><span class="sxs-lookup"><span data-stu-id="bfbad-337">[High volume delete pattern](#high-volume-delete-pattern) - Enable hello deletion of a high volume of entities by storing all hello entities for simultaneous deletion in their own separate table; you delete hello entities by deleting hello table.</span></span>  
* <span data-ttu-id="bfbad-338">[Adatsorozat adatmintát](#data-series-pattern) -tároló teljes adatsorozat elvégezte kérelmek egyetlen entitás toominimize hello számos.</span><span class="sxs-lookup"><span data-stu-id="bfbad-338">[Data series pattern](#data-series-pattern) - Store complete data series in a single entity toominimize hello number of requests you make.</span></span>  
* <span data-ttu-id="bfbad-339">[Széles entitások mintát](#wide-entities-pattern) -több fizikai entitások toostore logikai entitás legfeljebb 252 tulajdonságot használja.</span><span class="sxs-lookup"><span data-stu-id="bfbad-339">[Wide entities pattern](#wide-entities-pattern) - Use multiple physical entities toostore logical entities with more than 252 properties.</span></span>  
* <span data-ttu-id="bfbad-340">[Nagy entitások mintát](#large-entities-pattern) -blob storage toostore nagy tulajdonság értékek használata.</span><span class="sxs-lookup"><span data-stu-id="bfbad-340">[Large entities pattern](#large-entities-pattern) - Use blob storage toostore large property values.</span></span>  

### <a name="ensuring-consistency-in-your-stored-entities"></a><span data-ttu-id="bfbad-341">A tárolt entitásokat következetes biztosítása</span><span class="sxs-lookup"><span data-stu-id="bfbad-341">Ensuring consistency in your stored entities</span></span>
<span data-ttu-id="bfbad-342">más kulcsfontosságú tényező, amely befolyásolja a kulcsokat a választott érték módosítása optimalizálása hello hogyan tooensure konzisztencia atomi tranzakciók használatával.</span><span class="sxs-lookup"><span data-stu-id="bfbad-342">hello other key factor that influences your choice of keys for optimizing data modifications is how tooensure consistency by using atomic transactions.</span></span> <span data-ttu-id="bfbad-343">Csak egy EGT toooperate használhatja hello tárolt entitásokat tartalmazó partícióra.</span><span class="sxs-lookup"><span data-stu-id="bfbad-343">You can only use an EGT toooperate on entities stored in hello same partition.</span></span>  

<span data-ttu-id="bfbad-344">következő hello szakasz minták hello [táblázat kialakítási minta](#table-design-patterns) cím konzisztencia kezelése:</span><span class="sxs-lookup"><span data-stu-id="bfbad-344">hello following patterns in hello section [Table Design Patterns](#table-design-patterns) address managing consistency:</span></span>  

* <span data-ttu-id="bfbad-345">[Intra-partíció másodlagos index mintát](#intra-partition-secondary-index-pattern) -tárolja a több másolatot minden entitás használatával különböző **RowKey** értékek (hello a partícióra) tooenable gyors és hatékony keresést és a másodlagos rendezési sorrend rendelések használatával különböző **RowKey** értékeket.</span><span class="sxs-lookup"><span data-stu-id="bfbad-345">[Intra-partition secondary index pattern](#intra-partition-secondary-index-pattern) - Store multiple copies of each entity using different **RowKey** values (in hello same partition) tooenable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span>  
* <span data-ttu-id="bfbad-346">[Másodlagos helyek közötti partíció index mintát](#inter-partition-secondary-index-pattern) – minden értékekkel különböző RowKey külön partíciók vagy külön táblázatban tooenable gyors entitás több példányát tárolja, és a különböző rendelésekhatékonykereséstésamásodlagosrendezésisorrend**RowKey** értékeket.</span><span class="sxs-lookup"><span data-stu-id="bfbad-346">[Inter-partition secondary index pattern](#inter-partition-secondary-index-pattern) - Store multiple copies of each entity using different RowKey values in separate partitions or in separate tables tooenable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span>  
* <span data-ttu-id="bfbad-347">[Idővel konzisztenssé tranzakciók mintát](#eventually-consistent-transactions-pattern) -engedélyezni a idővel konzisztenssé partícióhatárok vagy tárolási rendszer határok Azure üzenetsorok használatával.</span><span class="sxs-lookup"><span data-stu-id="bfbad-347">[Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) - Enable eventually consistent behavior across partition boundaries or storage system boundaries by using Azure queues.</span></span>
* <span data-ttu-id="bfbad-348">[Index entitások mintát](#index-entities-pattern) -index entitások tooenable hatékony keresések entitások listájának visszaadó karbantartása.</span><span class="sxs-lookup"><span data-stu-id="bfbad-348">[Index Entities Pattern](#index-entities-pattern) - Maintain index entities tooenable efficient searches that return lists of entities.</span></span>  
* <span data-ttu-id="bfbad-349">[Denormalization mintát](#denormalization-pattern) -egyesítése kapcsolódó adatok együtt egy egyetlen entitás tooenable a tooretrieve, az összes hello egyetlen pont lekérdezéssel szükséges adatokat.</span><span class="sxs-lookup"><span data-stu-id="bfbad-349">[Denormalization pattern](#denormalization-pattern) - Combine related data together in a single entity tooenable you tooretrieve all hello data you need with a single point query.</span></span>  
* <span data-ttu-id="bfbad-350">[Adatsorozat adatmintát](#data-series-pattern) -tároló teljes adatsorozat elvégezte kérelmek egyetlen entitás toominimize hello számos.</span><span class="sxs-lookup"><span data-stu-id="bfbad-350">[Data series pattern](#data-series-pattern) - Store complete data series in a single entity toominimize hello number of requests you make.</span></span>  

<span data-ttu-id="bfbad-351">Entitás csoport tranzakciókkal kapcsolatos információkért lásd: hello szakasz [entitás csoport tranzakciók](#entity-group-transactions).</span><span class="sxs-lookup"><span data-stu-id="bfbad-351">For information about entity group transactions, see hello section [Entity Group Transactions](#entity-group-transactions).</span></span>  

### <a name="ensuring-your-design-for-efficient-modifications-facilitates-efficient-queries"></a><span data-ttu-id="bfbad-352">A módosítások hatékony kialakítása biztosítása elősegíti a hatékony lekérdezések</span><span class="sxs-lookup"><span data-stu-id="bfbad-352">Ensuring your design for efficient modifications facilitates efficient queries</span></span>
<span data-ttu-id="bfbad-353">Sok esetben egy tervezési módosítások hatékony, de hatékony lekérdező eredményez kell mindig mérlegelje, hogy az adott forgatókönyv szerint hello eset.</span><span class="sxs-lookup"><span data-stu-id="bfbad-353">In many cases, a design for efficient querying results in efficient modifications, but you should always evaluate whether this is hello case for your specific scenario.</span></span> <span data-ttu-id="bfbad-354">Néhány hello minták hello szakaszban [táblázat kialakítási minta](#table-design-patterns) kérdez le, és módosítja az entitások közötti kompromisszumot explicit módon kiértékeléséhez és hello számát az egyes művelet mindig kell figyelembe.</span><span class="sxs-lookup"><span data-stu-id="bfbad-354">Some of hello patterns in hello section [Table Design Patterns](#table-design-patterns) explicitly evaluate trade-offs between querying and modifying entities, and you should always take into account hello number of each type of operation.</span></span>  

<span data-ttu-id="bfbad-355">következő hello szakasz minták hello [táblázat kialakítási minta](#table-design-patterns) hatékony lekérdezések tervezése és kialakítása hatékony adatok módosítása a közötti kompromisszumot cím:</span><span class="sxs-lookup"><span data-stu-id="bfbad-355">hello following patterns in hello section [Table Design Patterns](#table-design-patterns) address trade-offs between designing for efficient queries and designing for efficient data modification:</span></span>  

* <span data-ttu-id="bfbad-356">[Összetett kulcs mintát](#compound-key-pattern) – használható összetett **RowKey** értékek tooenable egy ügyfél toolookup kapcsolódó adatok egyetlen pont lekérdezéssel.</span><span class="sxs-lookup"><span data-stu-id="bfbad-356">[Compound key pattern](#compound-key-pattern) - Use compound **RowKey** values tooenable a client toolookup related data with a single point query.</span></span>  
* <span data-ttu-id="bfbad-357">[Napló végéről mintát](#log-tail-pattern) -lekérése hello  *n*  entitások legutóbb hozzáadott tooa partíció használatával egy **RowKey** érték, amely fordított dátum és idő sorrendben rendezi.</span><span class="sxs-lookup"><span data-stu-id="bfbad-357">[Log tail pattern](#log-tail-pattern) - Retrieve hello *n* entities most recently added tooa partition by using a **RowKey** value that sorts in reverse date and time order.</span></span>  

## <a name="encrypting-table-data"></a><span data-ttu-id="bfbad-358">Tábla adatok titkosítása</span><span class="sxs-lookup"><span data-stu-id="bfbad-358">Encrypting Table Data</span></span>
<span data-ttu-id="bfbad-359">hello .NET Azure Storage ügyféloldali kódtár által támogatott titkosítási insert karakterlánc entitás tulajdonságait, és cserélje le a műveleteket.</span><span class="sxs-lookup"><span data-stu-id="bfbad-359">hello .NET Azure Storage Client Library supports encryption of string entity properties for insert and replace operations.</span></span> <span data-ttu-id="bfbad-360">Titkosított hello karakterláncok bináris tulajdonságként hello szolgáltatásban tárolja, és a visszafejtés után hátsó toostrings telepítésekké lesznek átalakítva.</span><span class="sxs-lookup"><span data-stu-id="bfbad-360">hello encrypted strings are stored on hello service as binary properties, and they are converted back toostrings after decryption.</span></span>    

<span data-ttu-id="bfbad-361">A táblák, továbbá toohello titkosítási házirendnek, felhasználók meg kell adnia hello tulajdonságok toobe titkosítva.</span><span class="sxs-lookup"><span data-stu-id="bfbad-361">For tables, in addition toohello encryption policy, users must specify hello properties toobe encrypted.</span></span> <span data-ttu-id="bfbad-362">Ezt megteheti megadásával vagy (az POCO entitások, amelyek a TableEntity) [EncryptProperty] attribútum vagy egy titkosítási feloldó lehetőségek.</span><span class="sxs-lookup"><span data-stu-id="bfbad-362">This can be done by either specifying an [EncryptProperty] attribute (for POCO entities that derive from TableEntity) or an encryption resolver in request options.</span></span> <span data-ttu-id="bfbad-363">Egy titkosítási feloldó egy delegált veszi a partíciós kulcs, sorkulcsot és tulajdonság nevét, és logikai érték beolvasása, amely jelzi, hogy a tulajdonság titkosítani kell-e.</span><span class="sxs-lookup"><span data-stu-id="bfbad-363">An encryption resolver is a delegate that takes a partition key, row key, and property name and returns a Boolean that indicates whether that property should be encrypted.</span></span> <span data-ttu-id="bfbad-364">Titkosítás során hello ügyféloldali kódtár fogja használni a információk toodecide e tulajdonság titkosítani toohello vezetékes írása közben.</span><span class="sxs-lookup"><span data-stu-id="bfbad-364">During encryption, hello client library will use this information toodecide whether a property should be encrypted while writing toohello wire.</span></span> <span data-ttu-id="bfbad-365">hello delegált is körül hogyan tulajdonságok vannak titkosítva logika hello lehetőségét biztosítja.</span><span class="sxs-lookup"><span data-stu-id="bfbad-365">hello delegate also provides for hello possibility of logic around how properties are encrypted.</span></span> <span data-ttu-id="bfbad-366">(Például, ha X, majd titkosítása A tulajdonság; ellenkező esetben a Tulajdonságok A és b titkosítása) Vegye figyelembe, hogy az nem szükséges tooprovide ezen információ olvasása vagy entitás lekérdezése közben.</span><span class="sxs-lookup"><span data-stu-id="bfbad-366">(For example, if X, then encrypt property A; otherwise encrypt properties A and B.) Note that it is not necessary tooprovide this information while reading or querying entities.</span></span>

<span data-ttu-id="bfbad-367">Vegye figyelembe, hogy a merge jelenleg nem támogatott.</span><span class="sxs-lookup"><span data-stu-id="bfbad-367">Note that merge is not currently supported.</span></span> <span data-ttu-id="bfbad-368">Mivel a Tulajdonságok részhalmazát, előfordulhat, hogy korábban használatával titkosított egy másik kulcsot, egyszerűen hello új tulajdonságok egyesítése és hello metaadatainak frissítése adatok elvesztését eredményezi.</span><span class="sxs-lookup"><span data-stu-id="bfbad-368">Since a subset of properties may have been encrypted previously using a different key, simply merging hello new properties and updating hello metadata will result in data loss.</span></span> <span data-ttu-id="bfbad-369">Így további service hívásai tooread hello már meglévő entitás hello szolgáltatást, vagy tulajdonságonként egy új kulcsot használ, amelyek mindegyikét nem alkalmasak a teljesítményre vonatkozó megfontolásból vagy egyesítés van szükség.</span><span class="sxs-lookup"><span data-stu-id="bfbad-369">Merging either requires making extra service calls tooread hello pre-existing entity from hello service, or using a new key per property, both of which are not suitable for performance reasons.</span></span>     

<span data-ttu-id="bfbad-370">További információ a táblabeli adatok titkosítása: [ügyféloldali titkosítás és a Microsoft Azure tárolás az Azure Key Vault](storage-client-side-encryption.md).</span><span class="sxs-lookup"><span data-stu-id="bfbad-370">For information about encrypting table data, see [Client-Side Encryption and Azure Key Vault for Microsoft Azure Storage](storage-client-side-encryption.md).</span></span>  

## <a name="modelling-relationships"></a><span data-ttu-id="bfbad-371">Kapcsolatok modellezésére</span><span class="sxs-lookup"><span data-stu-id="bfbad-371">Modelling relationships</span></span>
<span data-ttu-id="bfbad-372">Összetett rendszerek hello tervezési kulcsfontosságú lépés létrehozási modelleket tartomány.</span><span class="sxs-lookup"><span data-stu-id="bfbad-372">Building domain models is a key step in hello design of complex systems.</span></span> <span data-ttu-id="bfbad-373">Általában folyamat tooidentify entitások modellezés hello használata, hello kapcsolatai őket egy módon toounderstand hello üzleti tartományhoz, majd értesíteni kell a hello tervezési a rendszer.</span><span class="sxs-lookup"><span data-stu-id="bfbad-373">Typically, you use hello modelling process tooidentify entities and hello relationships between them as a way toounderstand hello business domain and inform hello design of your system.</span></span> <span data-ttu-id="bfbad-374">Ez a szakasz összpontosít hogyan tudja lefordítani néhány hello közös kapcsolattípusok tartomány modellek toodesigns a Table szolgáltatás hello található.</span><span class="sxs-lookup"><span data-stu-id="bfbad-374">This section focuses on how you can translate some of hello common relationship types found in domain models toodesigns for hello Table service.</span></span> <span data-ttu-id="bfbad-375">egy logikai adatmodell tooa fizikai alapú NoSQL-adatmodell-leképezés hello folyamat nagyon eltér a relációs tervezése során használt.</span><span class="sxs-lookup"><span data-stu-id="bfbad-375">hello process of mapping from a logical data-model tooa physical NoSQL based data-model is very different from that used when designing a relational database.</span></span> <span data-ttu-id="bfbad-376">Relációs adatbázisok terv általában azt feltételezi, hogy a normalizálási adatfeldolgozás minimalizálja a redundancia – és egy deklaratív lekérdező képesség, amely a kivonatok hogyan hello hello adatbázis működésének végrehajtásának optimalizálva.</span><span class="sxs-lookup"><span data-stu-id="bfbad-376">Relational databases design typically assumes a data normalization process optimized for minimizing redundancy – and a declarative querying capability that abstracts how hello implementation of how hello database works.</span></span>  

### <a name="one-to-many-relationships"></a><span data-ttu-id="bfbad-377">Egy-a-többhöz kapcsolatok</span><span class="sxs-lookup"><span data-stu-id="bfbad-377">One-to-many relationships</span></span>
<span data-ttu-id="bfbad-378">Egy-a-többhöz kapcsolatok üzleti tartomány objektumok közötti nagyon gyakran előfordulnak: például egy részleg rendelkezik sok alkalmazott.</span><span class="sxs-lookup"><span data-stu-id="bfbad-378">One-to-many relationships between business domain objects occur very frequently: for example, one department has many employees.</span></span> <span data-ttu-id="bfbad-379">Hello tábla minden egyes rendelkező szolgáltatás előnyei és hátrányai, lehet, hogy megfelelő toohello adott forgatókönyv számos módon tooimplement egy-a-többhöz kapcsolatok találhatók.</span><span class="sxs-lookup"><span data-stu-id="bfbad-379">There are several ways tooimplement one-to-many relationships in hello Table service each with pros and cons that may be relevant toohello particular scenario.</span></span>  

<span data-ttu-id="bfbad-380">Vegye figyelembe a hello példa egy nagy több nemzeti vállalat osztályai és ahol minden részlege rendelkezik sok alkalmazott, és minden alkalmazott, egy adott részleg társított alkalmazott entitások tízezreit tartalmazó.</span><span class="sxs-lookup"><span data-stu-id="bfbad-380">Consider hello example of a large multi-national corporation with tens of thousands of departments and employee entities where every department has many employees and each employee as associated with one specific department.</span></span> <span data-ttu-id="bfbad-381">Egy megoldás, toostore külön részleg és az alkalmazott entitások, például ezek:</span><span class="sxs-lookup"><span data-stu-id="bfbad-381">One approach is toostore separate department and employee entities such as these:</span></span>  

![][1]

<span data-ttu-id="bfbad-382">Ez a példa bemutatja egy implicit egy-a-többhöz kapcsolat hello alapján hello típus között **PartitionKey** érték.</span><span class="sxs-lookup"><span data-stu-id="bfbad-382">This example shows an implicit one-to-many relationship between hello types based on hello **PartitionKey** value.</span></span> <span data-ttu-id="bfbad-383">Minden részleghez rendelkezhet sok alkalmazott.</span><span class="sxs-lookup"><span data-stu-id="bfbad-383">Each department can have many employees.</span></span>  

<span data-ttu-id="bfbad-384">Ebben a példában is látható egy szervezeti egység és a kapcsolódó alkalmazott entitásának hello egyazon partícióra kerüljenek.</span><span class="sxs-lookup"><span data-stu-id="bfbad-384">This example also shows a department entity and its related employee entities in hello same partition.</span></span> <span data-ttu-id="bfbad-385">Megadhatja, hogy toouse különböző partíciók, táblák vagy hello különböző entitástípusok még tárfiókját.</span><span class="sxs-lookup"><span data-stu-id="bfbad-385">You could choose toouse different partitions, tables, or even storage accounts for hello different entity types.</span></span>  

<span data-ttu-id="bfbad-386">Egy másik módszert is van, az adatok és áruházbeli csak alkalmazott entitások denormalizált részleg adatokkal toodenormalize vagy hello a következő példában látható.</span><span class="sxs-lookup"><span data-stu-id="bfbad-386">An alternative approach is toodenormalize your data and store only employee entities with denormalized department data as shown in hello following example.</span></span> <span data-ttu-id="bfbad-387">Adott esetben ez a megközelítés denormalizált nem lehet ajánlott hello Ha egy követelmény toobe képes toochange hello részleteit a részleg vezetője mivel toodo ez tooupdate minden alkalmazott hello részleg van szüksége.</span><span class="sxs-lookup"><span data-stu-id="bfbad-387">In this particular scenario, this denormalized approach may not be hello best if you have a requirement toobe able toochange hello details of a department manager because toodo this you need tooupdate every employee in hello department.</span></span>  

![][2]

<span data-ttu-id="bfbad-388">További információkért lásd: hello [Denormalization mintát](#denormalization-pattern) című útmutatóban.</span><span class="sxs-lookup"><span data-stu-id="bfbad-388">For more information, see hello [Denormalization pattern](#denormalization-pattern) later in this guide.</span></span>  

<span data-ttu-id="bfbad-389">hello következő táblázat összefoglalja hello előnyei és hátrányai minden alkalmazott, és a részleg entitások, amelyek egy-a-többhöz tárolását a fent vázolt hello módszerekkel.</span><span class="sxs-lookup"><span data-stu-id="bfbad-389">hello following table summarizes hello pros and cons of each of hello approaches outlined above for storing employee and department entities that have a one-to-many relationship.</span></span> <span data-ttu-id="bfbad-390">Érdemes azt is, hogy várhatóan milyen gyakran tooperform különféle műveletek: lehet, hogy elfogadható toohave, olcsóbbá műveletet tartalmaz, ha ez a művelet csak akkor fordul elő, a ritkán kialakítást.</span><span class="sxs-lookup"><span data-stu-id="bfbad-390">You should also consider how often you expect tooperform various operations: it may be acceptable toohave a design that includes an expensive operation if that operation only happens infrequently.</span></span>  

<table>
<tr>
<th><span data-ttu-id="bfbad-391">Módszer</span><span class="sxs-lookup"><span data-stu-id="bfbad-391">Approach</span></span></th>
<th><span data-ttu-id="bfbad-392">Informatikai szakemberek</span><span class="sxs-lookup"><span data-stu-id="bfbad-392">Pros</span></span></th>
<th><span data-ttu-id="bfbad-393">Hátrányok</span><span class="sxs-lookup"><span data-stu-id="bfbad-393">Cons</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="bfbad-394">Külön entitástípusok, egyazon partícióra kerüljenek, ugyanahhoz a táblához</span><span class="sxs-lookup"><span data-stu-id="bfbad-394">Separate entity types, same partition, same table</span></span></td>
<td>
<ul>
<li><span data-ttu-id="bfbad-395">A részleg entitás egyetlen művelettel frissítheti.</span><span class="sxs-lookup"><span data-stu-id="bfbad-395">You can update a department entity with a single operation.</span></span></li>
<li><span data-ttu-id="bfbad-396">Egy EGT toomaintain konzisztencia használhatja, ha egy követelmény toomodify egy részleg entitás amikor Ön frissítés/Beszúrás/törlés alkalmazott entitás.</span><span class="sxs-lookup"><span data-stu-id="bfbad-396">You can use an EGT toomaintain consistency if you have a requirement toomodify a department entity whenever you update/insert/delete an employee entity.</span></span> <span data-ttu-id="bfbad-397">Például ha a részlegszintű alkalmazott száma minden részleg számára.</span><span class="sxs-lookup"><span data-stu-id="bfbad-397">For example if you maintain a departmental employee count for each department.</span></span></li>
</ul>
</td>
<td>
<ul>
<li><span data-ttu-id="bfbad-398">Szükség lehet tooretrieve mind az alkalmazott, és a részleg entitás bizonyos ügyfél tevékenységek.</span><span class="sxs-lookup"><span data-stu-id="bfbad-398">You may need tooretrieve both an employee and a department entity for some client activities.</span></span></li>
<li><span data-ttu-id="bfbad-399">Tárolási műveletekre kerül sor a hello azonos partíció.</span><span class="sxs-lookup"><span data-stu-id="bfbad-399">Storage operations happen in hello same partition.</span></span> <span data-ttu-id="bfbad-400">A magas tranzakció kötetek Ez azt eredményezheti, interaktív terület.</span><span class="sxs-lookup"><span data-stu-id="bfbad-400">At high transaction volumes, this may result in a hotspot.</span></span></li>
<li><span data-ttu-id="bfbad-401">Egy alkalmazott tooa új osztály használatával egy EGT nem helyezhető át.</span><span class="sxs-lookup"><span data-stu-id="bfbad-401">You cannot move an employee tooa new department using an EGT.</span></span></li>
</ul>
</td>
</tr>
<tr>
<td><span data-ttu-id="bfbad-402">Külön entitástípusok, a különböző partíciók vagy a táblák vagy a storage-fiókok</span><span class="sxs-lookup"><span data-stu-id="bfbad-402">Separate entity types, different partitions or tables or storage accounts</span></span></td>
<td>
<ul>
<li><span data-ttu-id="bfbad-403">A részleg entitás vagy az alkalmazott entitás egyetlen művelettel frissítheti.</span><span class="sxs-lookup"><span data-stu-id="bfbad-403">You can update a department entity or employee entity with a single operation.</span></span></li>
<li><span data-ttu-id="bfbad-404">A magas tranzakció kötetek, ez segíthet terjedésének hello betöltése között több partíciót.</span><span class="sxs-lookup"><span data-stu-id="bfbad-404">At high transaction volumes, this may help spread hello load across more partitions.</span></span></li>
</ul>
</td>
<td>
<ul>
<li><span data-ttu-id="bfbad-405">Szükség lehet tooretrieve mind az alkalmazott, és a részleg entitás bizonyos ügyfél tevékenységek.</span><span class="sxs-lookup"><span data-stu-id="bfbad-405">You may need tooretrieve both an employee and a department entity for some client activities.</span></span></li>
<li><span data-ttu-id="bfbad-406">Nem használhat EGTs toomaintain konzisztencia amikor Ön frissítés/Beszúrás/Törlés az alkalmazottak és a frissítési részleget.</span><span class="sxs-lookup"><span data-stu-id="bfbad-406">You cannot use EGTs toomaintain consistency when you update/insert/delete an employee and update a department.</span></span> <span data-ttu-id="bfbad-407">Például frissítése folyamatban van egy szervezeti egységben egy alkalmazott száma.</span><span class="sxs-lookup"><span data-stu-id="bfbad-407">For example, updating an employee count in a department entity.</span></span></li>
<li><span data-ttu-id="bfbad-408">Egy alkalmazott tooa új osztály használatával egy EGT nem helyezhető át.</span><span class="sxs-lookup"><span data-stu-id="bfbad-408">You cannot move an employee tooa new department using an EGT.</span></span></li>
</ul>
</td>
</tr>
<tr>
<td><span data-ttu-id="bfbad-409">Az egyetlen entitás típusa denormalize</span><span class="sxs-lookup"><span data-stu-id="bfbad-409">Denormalize into single entity type</span></span></td>
<td>
<ul>
<li><span data-ttu-id="bfbad-410">Az egy kérelemhez szükséges összes hello információkat kérheti le.</span><span class="sxs-lookup"><span data-stu-id="bfbad-410">You can retrieve all hello information you need with a single request.</span></span></li>
</ul>
</td>
<td>
<ul>
<li><span data-ttu-id="bfbad-411">Költséges toomaintain konzisztencia lehet, ha (Ez igényelnének, tooupdate egy osztály összes hello alkalmazott) tooupdate részleg információra van szüksége.</span><span class="sxs-lookup"><span data-stu-id="bfbad-411">It may be expensive toomaintain consistency if you need tooupdate department information (this would require you tooupdate all hello employees in a department).</span></span></li>
</ul>
</td>
</tr>
</table>

<span data-ttu-id="bfbad-412">Hogyan választja, ezeket a beállításokat, és amely hello szakemberek között, és hátrányának legjelentősebb, amelyek az adott alkalmazás forgatókönyvek függ.</span><span class="sxs-lookup"><span data-stu-id="bfbad-412">How you choose between these options, and which of hello pros and cons are most significant, depends on your specific application scenarios.</span></span> <span data-ttu-id="bfbad-413">Például milyen gyakran tegye módosítása részleg entitások; szükség van hello kiegészítő részlegre vonatkozó információkat; az alkalmazott lekérdezés milyen közel vannak, a partíciók vagy a tárfiók toohello méretezhetőségének korlátai?</span><span class="sxs-lookup"><span data-stu-id="bfbad-413">For example, how often do you modify department entities; do all your employee queries need hello additional departmental information; how close are you toohello scalability limits on your partitions or your storage account?</span></span>  

### <a name="one-to-one-relationships"></a><span data-ttu-id="bfbad-414">-Az-egyhez kapcsolat</span><span class="sxs-lookup"><span data-stu-id="bfbad-414">One-to-one relationships</span></span>
<span data-ttu-id="bfbad-415">Tartomány modellek egy az egyhez típusú entitások közötti kapcsolatok is tartalmazhat.</span><span class="sxs-lookup"><span data-stu-id="bfbad-415">Domain models may include one-to-one relationships between entities.</span></span> <span data-ttu-id="bfbad-416">Ha egy az egyhez kapcsolat a Table szolgáltatás hello tooimplement van szüksége, is választania kell hogyan toolink hello-e két kapcsolódó entitás újból tooretrieve is.</span><span class="sxs-lookup"><span data-stu-id="bfbad-416">If you need tooimplement a one-to-one relationship in hello Table service, you must also choose how toolink hello two related entities when you need tooretrieve them both.</span></span> <span data-ttu-id="bfbad-417">Ez a hivatkozás lehet implicit, egy egyezmény hello értékek alapján, vagy explicit hivatkozás tárolása hello formája **PartitionKey** és **RowKey** minden entitás tooits szereplő értékek kapcsolódó entitás.</span><span class="sxs-lookup"><span data-stu-id="bfbad-417">This link can be either implicit, based on a convention in hello key values, or explicit by storing a link in hello form of **PartitionKey** and **RowKey** values in each entity tooits related entity.</span></span> <span data-ttu-id="bfbad-418">E hello tárolja az információt a kapcsolódó entitás a hello partícióra, hello című [egy-a-többhöz kapcsolatok](#one-to-many-relationships).</span><span class="sxs-lookup"><span data-stu-id="bfbad-418">For a discussion of whether you should store hello related entities in hello same partition, see hello section [One-to-many relationships](#one-to-many-relationships).</span></span>  

<span data-ttu-id="bfbad-419">Vegye figyelembe, hogy nincsenek-e is vezethet, tooimplement-az-egyhez kapcsolat hello tábla szolgáltatás megvalósítási szempontot:</span><span class="sxs-lookup"><span data-stu-id="bfbad-419">Note that there are also implementation considerations that might lead you tooimplement one-to-one relationships in hello Table service:</span></span>  

* <span data-ttu-id="bfbad-420">Nagy entitások kezelése (további információkért lásd: [nagy entitások mintát](#large-entities-pattern)).</span><span class="sxs-lookup"><span data-stu-id="bfbad-420">Handling large entities (for more information, see [Large Entities Pattern](#large-entities-pattern)).</span></span>  
* <span data-ttu-id="bfbad-421">A végrehajtási hozzáférés-vezérlést (további információkért lásd: [megosztott hozzáférési aláírásokkal-hozzáférés szabályozásáról](#controlling-access-with-shared-access-signatures)).</span><span class="sxs-lookup"><span data-stu-id="bfbad-421">Implementing access controls (for more information, see [Controlling access with Shared Access Signatures](#controlling-access-with-shared-access-signatures)).</span></span>  

### <a name="join-in-hello-client"></a><span data-ttu-id="bfbad-422">Hello ügyfél csatlakozott</span><span class="sxs-lookup"><span data-stu-id="bfbad-422">Join in hello client</span></span>
<span data-ttu-id="bfbad-423">Bár a Table szolgáltatás hello módon toomodel kapcsolatokat, kell nem elfelejti, hogy hello két elsődleges hello Table szolgáltatás használatára vonatkozó okai méretezhetőséget és teljesítményt nyújt.</span><span class="sxs-lookup"><span data-stu-id="bfbad-423">Although there are ways toomodel relationships in hello Table service, you should not forget that hello two prime reasons for using hello Table service are scalability and performance.</span></span> <span data-ttu-id="bfbad-424">Ha meg vannak modellezés több kapcsolatot, amelyek veszélyeztetik hello teljesítményét és méretezhetőségét, a megoldás, kérdezze meg saját kezűleg szükséges toobuild esetén az összes hello adatok kapcsolatok tábla rendszerbe.</span><span class="sxs-lookup"><span data-stu-id="bfbad-424">If you find you are modelling many relationships that compromise hello performance and scalability of your solution, you should ask yourself if it is necessary toobuild all hello data relationships into your table design.</span></span> <span data-ttu-id="bfbad-425">Előfordulhat, hogy képes toosimplify hello tervezési kell és hello méretezhetőség és a megoldás teljesítményének javítása, ha az ügyfélalkalmazást, hajtsa végre a szükséges illesztések.</span><span class="sxs-lookup"><span data-stu-id="bfbad-425">You may be able toosimplify hello design and improve hello scalability and performance of your solution if you let your client application perform any necessary joins.</span></span>  

<span data-ttu-id="bfbad-426">Például ha adatokat tartalmaznak, amelyek nem változik gyakran nagyon kis táblákhoz, majd után lekérdezhetik ezeket az adatokat többször is hello ügyfélen gyorsítótárazása azt.</span><span class="sxs-lookup"><span data-stu-id="bfbad-426">For example, if you have small tables that contain data that does not change very often, then you can retrieve this data once and cache it on hello client.</span></span> <span data-ttu-id="bfbad-427">Ennek elkerülése érdekében ismételt használatával tooretrieve hello ugyanazokat az adatokat.</span><span class="sxs-lookup"><span data-stu-id="bfbad-427">This can avoid repeated roundtrips tooretrieve hello same data.</span></span> <span data-ttu-id="bfbad-428">Azt kell venni, a jelen útmutató hello példákban hello kis szervezet szervezeti egységek lesz valószínűleg toobe kis és ritkán így egy jó jelölt az ügyfélalkalmazás tölthetik le egyszer adatok és a gyorsítótár, keresse meg a adatok módosítása.</span><span class="sxs-lookup"><span data-stu-id="bfbad-428">In hello examples we have looked at in this guide, hello set of departments in a small organization is likely toobe small and change infrequently making it a good candidate for data that client application can download once and cache as look up data.</span></span>  

### <a name="inheritance-relationships"></a><span data-ttu-id="bfbad-429">Öröklődés kapcsolatok</span><span class="sxs-lookup"><span data-stu-id="bfbad-429">Inheritance relationships</span></span>
<span data-ttu-id="bfbad-430">Ha az ügyfél alkalmazás osztályok az öröklési kapcsolat toorepresent üzleti entitásokat részét alkotó készlete, egyszerűen a ezeket a Table szolgáltatás hello entitások maradnak meg.</span><span class="sxs-lookup"><span data-stu-id="bfbad-430">If your client application uses a set of classes that form part of an inheritance relationship toorepresent business entities, you can easily persist those entities in hello Table service.</span></span> <span data-ttu-id="bfbad-431">Például lehetséges, hogy az ügyfél alkalmazásban megadott készlete a következő hello ahol **személy** absztrakt osztály.</span><span class="sxs-lookup"><span data-stu-id="bfbad-431">For example, you might have hello following set of classes defined in your client application where **Person** is an abstract class.</span></span>

![][3]

<span data-ttu-id="bfbad-432">A Table szolgáltatás segítségével, hogy a hely egyetlen személy tábla használatával hello tényleges osztály két hello példányai is továbbra is fennáll:</span><span class="sxs-lookup"><span data-stu-id="bfbad-432">You can persist instances of hello two concrete classes in hello Table service using a single Person table using entities in that look like this:</span></span>  

![][4]

<span data-ttu-id="bfbad-433">Ugyanaz a tábla az Ügyfélkód hello több entitástípusok kezelésével kapcsolatos további információkért lásd: hello szakasz [használata heterogén entitástípusok](#working-with-heterogeneous-entity-types) című útmutatóban.</span><span class="sxs-lookup"><span data-stu-id="bfbad-433">For more information about working with multiple entity types in hello same table in client code, see hello section [Working with heterogeneous entity types](#working-with-heterogeneous-entity-types) later in this guide.</span></span> <span data-ttu-id="bfbad-434">Ez példákat hogyan toorecognize hello az Ügyfélkód entity Type típusként.</span><span class="sxs-lookup"><span data-stu-id="bfbad-434">This provides examples of how toorecognize hello entity type in client code.</span></span>  

## <a name="table-design-patterns"></a><span data-ttu-id="bfbad-435">Táblázat kialakítási minták</span><span class="sxs-lookup"><span data-stu-id="bfbad-435">Table Design Patterns</span></span>
<span data-ttu-id="bfbad-436">A korábbi szakaszokban néhány hogyan toooptimize a táblázat kialakítási mindkét lekérése entitás adatok lekérdezésekkel és beszúrni, frissítése és törlése Entitásadatok kapcsolatos részletes beszélgetéseket láthatta.</span><span class="sxs-lookup"><span data-stu-id="bfbad-436">In previous sections, you have seen some detailed discussions about how toooptimize your table design for both retrieving entity data using queries and for inserting, updating, and deleting entity data.</span></span> <span data-ttu-id="bfbad-437">Ez a szakasz ismerteti az egyes mintázatok megfelelő Table szolgáltatási megoldások való használatra.</span><span class="sxs-lookup"><span data-stu-id="bfbad-437">This section describes some patterns appropriate for use with Table service solutions.</span></span> <span data-ttu-id="bfbad-438">Ezenkívül láthatja, hogyan meg is gyakorlatilag cím egyes hello problémák és kompromisszumot alakítson ki az útmutatóban korábban következik be.</span><span class="sxs-lookup"><span data-stu-id="bfbad-438">In addition, you will see how you can practically address some of hello issues and trade-offs raised previously in this guide.</span></span> <span data-ttu-id="bfbad-439">hello következő diagram foglalja hello kapcsolatai hello különböző minták:</span><span class="sxs-lookup"><span data-stu-id="bfbad-439">hello following diagram summarizes hello relationships between hello different patterns:</span></span>  

![][5]

<span data-ttu-id="bfbad-440">hello mintát térkép fent néhány minták (kék) és a jelen útmutatóban leírt elleni minták (narancs) közötti kapcsolatokat mutatja be.</span><span class="sxs-lookup"><span data-stu-id="bfbad-440">hello pattern map above highlights some relationships between patterns (blue) and anti-patterns (orange) that are documented in this guide.</span></span> <span data-ttu-id="bfbad-441">Természetesen nincsenek sok más mintákat, amelyek érdemes figyelembe véve.</span><span class="sxs-lookup"><span data-stu-id="bfbad-441">There are of course many other patterns that are worth considering.</span></span> <span data-ttu-id="bfbad-442">Például hello főbb forgatókönyvek a Table szolgáltatás egyik toouse hello [materializált nézet mintát](https://msdn.microsoft.com/library/azure/dn589782.aspx) a hello [parancs lekérdezés felelősségi elkülönítése (CQRS)](https://msdn.microsoft.com/library/azure/jj554200.aspx) mintát.</span><span class="sxs-lookup"><span data-stu-id="bfbad-442">For example, one of hello key scenarios for Table Service is toouse hello [Materialized View Pattern](https://msdn.microsoft.com/library/azure/dn589782.aspx) from hello [Command Query Responsibility Segregation (CQRS)](https://msdn.microsoft.com/library/azure/jj554200.aspx) pattern.</span></span>  

### <a name="intra-partition-secondary-index-pattern"></a><span data-ttu-id="bfbad-443">Helyen belüli-partíció másodlagos index minta</span><span class="sxs-lookup"><span data-stu-id="bfbad-443">Intra-partition secondary index pattern</span></span>
<span data-ttu-id="bfbad-444">Több másolatot minden entitás használatával különböző tárolására **RowKey** értékek (hello a partícióra) segítségével különböző rendelések tooenable gyors és hatékony keresést és a másodlagos rendezési sorrend **RowKey** értékek.</span><span class="sxs-lookup"><span data-stu-id="bfbad-444">Store multiple copies of each entity using different **RowKey** values (in hello same partition) tooenable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span> <span data-ttu-id="bfbad-445">Példányok közötti frissítéseket is konzisztens EGT tartozó használatával.</span><span class="sxs-lookup"><span data-stu-id="bfbad-445">Updates between copies can be kept consistent using EGT's.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="bfbad-446">A környezetben, és probléma</span><span class="sxs-lookup"><span data-stu-id="bfbad-446">Context and problem</span></span>
<span data-ttu-id="bfbad-447">Table szolgáltatás hello automatikusan elvégzi a hello segítségével **PartitionKey** és **RowKey** értékeket.</span><span class="sxs-lookup"><span data-stu-id="bfbad-447">hello Table service automatically indexes entities using hello **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="bfbad-448">Ez lehetővé teszi, hogy egy ügyfél alkalmazás tooretrieve egy entitás hatékonyan végez ezeket az értékeket.</span><span class="sxs-lookup"><span data-stu-id="bfbad-448">This enables a client application tooretrieve an entity efficiently using these values.</span></span> <span data-ttu-id="bfbad-449">Például a lent látható módon hello táblaszerkezet, ügyfélalkalmazás használatával egy pont lekérdezés tooretrieve alkalmazott entitás hello részleg neve és hello alkalmazott azonosítója (hello **PartitionKey** és  **RowKey** értékek).</span><span class="sxs-lookup"><span data-stu-id="bfbad-449">For example, using hello table structure shown below, a client application can use a point query tooretrieve an individual employee entity by using hello department name and hello employee id (hello **PartitionKey** and **RowKey** values).</span></span> <span data-ttu-id="bfbad-450">Egy ügyfél is kérje le az entitásokat alkalmazottazonosító belül minden részleg szerint rendezve.</span><span class="sxs-lookup"><span data-stu-id="bfbad-450">A client can also retrieve entities sorted by employee id within each department.</span></span>

![][6]

<span data-ttu-id="bfbad-451">Ha szeretné, hogy toobe képes toofind hello egy másik tulajdonság értéke, például az e-mail cím alapján alkalmazott entitás egy kevésbé hatékony partíció vizsgálat toofind egyezés kell használnia.</span><span class="sxs-lookup"><span data-stu-id="bfbad-451">If you also want toobe able toofind an employee entity based on hello value of another property, such as email address, you must use a less efficient partition scan toofind a match.</span></span> <span data-ttu-id="bfbad-452">Ennek az az oka hello table szolgáltatás nem biztosít a másodlagos kulcsot.</span><span class="sxs-lookup"><span data-stu-id="bfbad-452">This is because hello table service does not provide secondary indexes.</span></span> <span data-ttu-id="bfbad-453">Emellett nincs nincs lehetőség toorequest az alkalmazottakat, mint egy másik sorrendbe rendezve **RowKey** sorrendje.</span><span class="sxs-lookup"><span data-stu-id="bfbad-453">In addition, there is no option toorequest a list of employees sorted in a different order than **RowKey** order.</span></span>  

#### <a name="solution"></a><span data-ttu-id="bfbad-454">Megoldás</span><span class="sxs-lookup"><span data-stu-id="bfbad-454">Solution</span></span>
<span data-ttu-id="bfbad-455">másodlagos indexek hello hiánya körül toowork, minden egyes másolataihoz, a különböző entitás több példányát tárolhatja **RowKey** érték.</span><span class="sxs-lookup"><span data-stu-id="bfbad-455">toowork around hello lack of secondary indexes, you can store multiple copies of each entity with each copy using a different **RowKey** value.</span></span> <span data-ttu-id="bfbad-456">Ha egy entitás tárolja az alább látható hello struktúrák, e-mail cím vagy az alkalmazott azonosítója alapján alkalmazott entitások hatékonyan kérheti le. hello előtag értékeinek hello **RowKey**, "empid_" és "email_" lehetővé teszik a tooquery egyetlen alkalmazott vagy alkalmazottak számos e-mail címek vagy alkalmazott azonosítók használatával.</span><span class="sxs-lookup"><span data-stu-id="bfbad-456">If you store an entity with hello structures shown below, you can efficiently retrieve employee entities based on email address or employee id. hello prefix values for hello **RowKey**, "empid_" and "email_" enable you tooquery for a single employee or a range of employees by using a range of email addresses or employee ids.</span></span>  

![][7]

<span data-ttu-id="bfbad-457">a következő két szűrési feltételeket (egy keresésekor által alkalmazott azonosítója, a másik e-mail cím alapján keresése) hello is adja meg a pont lekérdezéseket:</span><span class="sxs-lookup"><span data-stu-id="bfbad-457">hello following two filter criteria (one looking up by employee id and one looking up by email address) both specify point queries:</span></span>  

* <span data-ttu-id="bfbad-458">$filter = (PartitionKey eq 'Értékesítés') és (RowKey eq "empid_000223")</span><span class="sxs-lookup"><span data-stu-id="bfbad-458">$filter=(PartitionKey eq 'Sales') and (RowKey eq 'empid_000223')</span></span>  
* <span data-ttu-id="bfbad-459">$filter = (PartitionKey eq 'Értékesítés') és (RowKey eq 'email_jonesj@contoso.com")</span><span class="sxs-lookup"><span data-stu-id="bfbad-459">$filter=(PartitionKey eq 'Sales') and (RowKey eq 'email_jonesj@contoso.com')</span></span>  

<span data-ttu-id="bfbad-460">Ha alkalmazott entitástartományának kérdezze le, megadhatja a alkalmazott azonosítója sorrendbe rendezve tartománya vagy egy tartományt a hello hello a megfelelő előtaggal rendelkező entitások lekérdezésével e-mail cím sorrendbe rendezve **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="bfbad-460">If you query for a range of employee entities, you can specify a range sorted in employee id order, or a range sorted in email address order by querying for entities with hello appropriate prefix in hello **RowKey**.</span></span>  

* <span data-ttu-id="bfbad-461">toofind összes hello hello értékesítési részleg a hello tartomány 000100 too000199 alkalmazott azonosítójú munkavállalók: $filter = (PartitionKey eq 'Értékesítés') és (RowKey ge "empid_000100") és (RowKey le "empid_000199")</span><span class="sxs-lookup"><span data-stu-id="bfbad-461">toofind all hello employees in hello Sales department with an employee id in hello range 000100 too000199 use: $filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000100') and (RowKey le 'empid_000199')</span></span>  
* <span data-ttu-id="bfbad-462">összes hello értékesítési osztályon dolgozók hello hello kezdve e-mail címmel rendelkező toofind levél "a" használja: $filter = (PartitionKey eq 'Értékesítés') és (RowKey ge "email_a") és (RowKey lt "email_b")</span><span class="sxs-lookup"><span data-stu-id="bfbad-462">toofind all hello employees in hello Sales department with an email address starting with hello letter 'a' use: $filter=(PartitionKey eq 'Sales') and (RowKey ge 'email_a') and (RowKey lt 'email_b')</span></span>  
  
  <span data-ttu-id="bfbad-463">Vegye figyelembe, hogy a fenti példákban hello használt hello szűrőszintaxisának hello Table szolgáltatás REST API-t a további tudnivalókat lásd a [lekérdezés entitások](http://msdn.microsoft.com/library/azure/dd179421.aspx).</span><span class="sxs-lookup"><span data-stu-id="bfbad-463">Note that hello filter syntax used in hello examples above is from hello Table service REST API, for more information see [Query Entities](http://msdn.microsoft.com/library/azure/dd179421.aspx).</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="bfbad-464">Problémákat és szempontok</span><span class="sxs-lookup"><span data-stu-id="bfbad-464">Issues and considerations</span></span>
<span data-ttu-id="bfbad-465">Vegye figyelembe a következő pontok meghatározásakor hello hogyan tooimplement ebben a mintában:</span><span class="sxs-lookup"><span data-stu-id="bfbad-465">Consider hello following points when deciding how tooimplement this pattern:</span></span>  

* <span data-ttu-id="bfbad-466">A TABLE storage viszonylag olcsó toouse, így a terhelést növelni az ismétlődő adatok tárolására költség hello nem lehet fő szempont.</span><span class="sxs-lookup"><span data-stu-id="bfbad-466">Table storage is relatively cheap toouse so hello cost overhead of storing duplicate data should not be a major concern.</span></span> <span data-ttu-id="bfbad-467">Azonban kell kiértékelésének eredménye mindig a várható tárolási szükségletek előkészítését hello költség, és csak hozzá kettős bejegyzés toosupport hello lekérdezések végrehajtja az ügyfélalkalmazást.</span><span class="sxs-lookup"><span data-stu-id="bfbad-467">However, you should always evaluate hello cost of your design based on your anticipated storage requirements and only add duplicate entities toosupport hello queries your client application will execute.</span></span>  
* <span data-ttu-id="bfbad-468">Mivel hello másodlagos index entitások hello azonos hello eredeti entitásként partíció található, ellenőrizze, hogy nem haladhatja meg a hello méretezhetőségi célok az egyes partíciók.</span><span class="sxs-lookup"><span data-stu-id="bfbad-468">Because hello secondary index entities are stored in hello same partition as hello original entities, you should ensure that you do not exceed hello scalability targets for an individual partition.</span></span>  
* <span data-ttu-id="bfbad-469">Beállíthatja, hogy az ismétlődő entitások egymással konzisztenssé EGTs tooupdate hello két példányban hello entitás i használatával.</span><span class="sxs-lookup"><span data-stu-id="bfbad-469">You can keep your duplicate entities consistent with each other by using EGTs tooupdate hello two copies of hello entity atomically.</span></span> <span data-ttu-id="bfbad-470">Ez azt jelenti, hogy egy entitás összes másolatát tárolja hello egyazon partícióra kerüljenek.</span><span class="sxs-lookup"><span data-stu-id="bfbad-470">This implies that you should store all copies of an entity in hello same partition.</span></span> <span data-ttu-id="bfbad-471">További információkért lásd: hello szakasz [entitás csoport tranzakciók használatával](#entity-group-transactions).</span><span class="sxs-lookup"><span data-stu-id="bfbad-471">For more information, see hello section [Using Entity Group Transactions](#entity-group-transactions).</span></span>  
* <span data-ttu-id="bfbad-472">hello használt érték hello **RowKey** minden egyes entitásnál egyedinek kell lennie.</span><span class="sxs-lookup"><span data-stu-id="bfbad-472">hello value used for hello **RowKey** must be unique for each entity.</span></span> <span data-ttu-id="bfbad-473">Érdemes lehet összetett kulcs értékeket.</span><span class="sxs-lookup"><span data-stu-id="bfbad-473">Consider using compound key values.</span></span>  
* <span data-ttu-id="bfbad-474">Kitöltési hello szerepel benne numerikus érték **RowKey** (például hello alkalmazottazonosító 000223), lehetővé teszi, hogy javítsa ki, rendezési és szűrési alapján felső és alsó határait.</span><span class="sxs-lookup"><span data-stu-id="bfbad-474">Padding numeric values in hello **RowKey** (for example, hello employee id 000223), enables correct sorting and filtering based on upper and lower bounds.</span></span>  
* <span data-ttu-id="bfbad-475">Nem feltétlenül kell tooduplicate az entitás összes hello tulajdonságait.</span><span class="sxs-lookup"><span data-stu-id="bfbad-475">You do not necessarily need tooduplicate all hello properties of your entity.</span></span> <span data-ttu-id="bfbad-476">Például ha hello lekérdezéseiben, amelyeket keresési hello entitásnak hello segítségével e-mail-címre a hello **RowKey** soha nem kell hello alkalmazott életkora, ezeket az entitásokat hello struktúra a következő lehet:</span><span class="sxs-lookup"><span data-stu-id="bfbad-476">For example, if hello queries that lookup hello entities using hello email address in hello **RowKey** never need hello employee's age, these entities could have hello following structure:</span></span>

![][8]

* <span data-ttu-id="bfbad-477">Általában jobb toostore ismétlődő adatokat, és győződjön meg arról, hogy egyetlen lekérdezést a szükséges összes hello adatok kérheti le, mint toouse egy lekérdezést toolocate entitás és egy másik toolookup hello szükséges adatokat.</span><span class="sxs-lookup"><span data-stu-id="bfbad-477">It is typically better toostore duplicate data and ensure that you can retrieve all hello data you need with a single query, than toouse one query toolocate an entity and another toolookup hello required data.</span></span>  

#### <a name="when-toouse-this-pattern"></a><span data-ttu-id="bfbad-478">Ha toouse ezt a mintát</span><span class="sxs-lookup"><span data-stu-id="bfbad-478">When toouse this pattern</span></span>
<span data-ttu-id="bfbad-479">Ezt a mintát használja, ha az ügyfélalkalmazást számos különböző kulcsok használatát, ha az ügyfélnek kell eltérő rendezési sorrend tooretrieve entitásának tooretrieve entitásokat, és ahol minden entitás egyedi értékeket számos segítségével azonosíthatja.</span><span class="sxs-lookup"><span data-stu-id="bfbad-479">Use this pattern when your client application needs tooretrieve entities using a variety of different keys, when your client needs tooretrieve entities in different sort orders, and where you can identify each entity using a variety of unique values.</span></span> <span data-ttu-id="bfbad-480">Azonban ügyelnie kell, hogy Ön nem lépik túl hello partíció méretezhetőségi korlátok különböző hello segítségével entitás keresések végrehajtásakor **RowKey** értékeket.</span><span class="sxs-lookup"><span data-stu-id="bfbad-480">However, you should be sure that you do not exceed hello partition scalability limits when you are performing entity lookups using hello different **RowKey** values.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="bfbad-481">Útmutató és a kapcsolódó minták</span><span class="sxs-lookup"><span data-stu-id="bfbad-481">Related patterns and guidance</span></span>
<span data-ttu-id="bfbad-482">hello következő mintákat és útmutatókat is megfelelő ebben a mintában végrehajtása során:</span><span class="sxs-lookup"><span data-stu-id="bfbad-482">hello following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="bfbad-483">Másodlagos helyek közötti partíció index minta</span><span class="sxs-lookup"><span data-stu-id="bfbad-483">Inter-partition secondary index pattern</span></span>](#inter-partition-secondary-index-pattern)
* [<span data-ttu-id="bfbad-484">Összetett kulcs minta</span><span class="sxs-lookup"><span data-stu-id="bfbad-484">Compound key pattern</span></span>](#compound-key-pattern)
* [<span data-ttu-id="bfbad-485">Entitás csoport tranzakciók</span><span class="sxs-lookup"><span data-stu-id="bfbad-485">Entity Group Transactions</span></span>](#entity-group-transactions)
* [<span data-ttu-id="bfbad-486">Heterogén entitástípusok használata</span><span class="sxs-lookup"><span data-stu-id="bfbad-486">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)

### <a name="inter-partition-secondary-index-pattern"></a><span data-ttu-id="bfbad-487">Másodlagos helyek közötti partíció index minta</span><span class="sxs-lookup"><span data-stu-id="bfbad-487">Inter-partition secondary index pattern</span></span>
<span data-ttu-id="bfbad-488">Több másolatot minden entitás használatával különböző tárolására **RowKey** külön partíciók vagy külön táblázatban tooenable gyors és hatékony keresést és a másodlagos rendezési sorrend használatával különböző értékek **RowKey**értékeket.</span><span class="sxs-lookup"><span data-stu-id="bfbad-488">Store multiple copies of each entity using different **RowKey** values in separate partitions or in separate tables tooenable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="bfbad-489">A környezetben, és probléma</span><span class="sxs-lookup"><span data-stu-id="bfbad-489">Context and problem</span></span>
<span data-ttu-id="bfbad-490">Table szolgáltatás hello automatikusan elvégzi a hello segítségével **PartitionKey** és **RowKey** értékeket.</span><span class="sxs-lookup"><span data-stu-id="bfbad-490">hello Table service automatically indexes entities using hello **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="bfbad-491">Ez lehetővé teszi, hogy egy ügyfél alkalmazás tooretrieve egy entitás hatékonyan végez ezeket az értékeket.</span><span class="sxs-lookup"><span data-stu-id="bfbad-491">This enables a client application tooretrieve an entity efficiently using these values.</span></span> <span data-ttu-id="bfbad-492">Például a lent látható módon hello táblaszerkezet, ügyfélalkalmazás használatával egy pont lekérdezés tooretrieve alkalmazott entitás hello részleg neve és hello alkalmazott azonosítója (hello **PartitionKey** és  **RowKey** értékek).</span><span class="sxs-lookup"><span data-stu-id="bfbad-492">For example, using hello table structure shown below, a client application can use a point query tooretrieve an individual employee entity by using hello department name and hello employee id (hello **PartitionKey** and **RowKey** values).</span></span> <span data-ttu-id="bfbad-493">Egy ügyfél is kérje le az entitásokat alkalmazottazonosító belül minden részleg szerint rendezve.</span><span class="sxs-lookup"><span data-stu-id="bfbad-493">A client can also retrieve entities sorted by employee id within each department.</span></span>  

![][9]

<span data-ttu-id="bfbad-494">Ha szeretné, hogy toobe képes toofind hello egy másik tulajdonság értéke, például az e-mail cím alapján alkalmazott entitás egy kevésbé hatékony partíció vizsgálat toofind egyezés kell használnia.</span><span class="sxs-lookup"><span data-stu-id="bfbad-494">If you also want toobe able toofind an employee entity based on hello value of another property, such as email address, you must use a less efficient partition scan toofind a match.</span></span> <span data-ttu-id="bfbad-495">Ennek az az oka hello table szolgáltatás nem biztosít a másodlagos kulcsot.</span><span class="sxs-lookup"><span data-stu-id="bfbad-495">This is because hello table service does not provide secondary indexes.</span></span> <span data-ttu-id="bfbad-496">Emellett nincs nincs lehetőség toorequest az alkalmazottakat, mint egy másik sorrendbe rendezve **RowKey** sorrendje.</span><span class="sxs-lookup"><span data-stu-id="bfbad-496">In addition, there is no option toorequest a list of employees sorted in a different order than **RowKey** order.</span></span>  

<span data-ttu-id="bfbad-497">Ezeket az entitásokat tranzakciókról nagyon nagy mennyiségű rendszer előrejelző, és szeretné, hogy hello Table szolgáltatás szabályozása az ügyfél toominimize hello kockázatát.</span><span class="sxs-lookup"><span data-stu-id="bfbad-497">You are anticipating a very high volume of transactions against these entities and want toominimize hello risk of hello Table service throttling your client.</span></span>  

#### <a name="solution"></a><span data-ttu-id="bfbad-498">Megoldás</span><span class="sxs-lookup"><span data-stu-id="bfbad-498">Solution</span></span>
<span data-ttu-id="bfbad-499">másodlagos indexek hello hiánya körül toowork, több másolatot minden entitás, minden példány használatával különböző tárolhatja **PartitionKey** és **RowKey** értékeket.</span><span class="sxs-lookup"><span data-stu-id="bfbad-499">toowork around hello lack of secondary indexes, you can store multiple copies of each entity with each copy using different **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="bfbad-500">Ha egy entitás tárolja az alább látható hello struktúrák, e-mail cím vagy az alkalmazott azonosítója alapján alkalmazott entitások hatékonyan kérheti le. hello előtag értékeinek hello **PartitionKey**, "empid_" és "email_" lehetővé teszik a index, amely tooidentify toouse szeretné, hogy egy lekérdezéshez.</span><span class="sxs-lookup"><span data-stu-id="bfbad-500">If you store an entity with hello structures shown below, you can efficiently retrieve employee entities based on email address or employee id. hello prefix values for hello **PartitionKey**, "empid_" and "email_" enable you tooidentify which index you want toouse for a query.</span></span>  

![][10]

<span data-ttu-id="bfbad-501">a következő két szűrési feltételeket (egy keresésekor által alkalmazott azonosítója, a másik e-mail cím alapján keresése) hello is adja meg a pont lekérdezéseket:</span><span class="sxs-lookup"><span data-stu-id="bfbad-501">hello following two filter criteria (one looking up by employee id and one looking up by email address) both specify point queries:</span></span>  

* <span data-ttu-id="bfbad-502">$filter = (PartitionKey eq ' empid_Sales") és (RowKey eq"000223")</span><span class="sxs-lookup"><span data-stu-id="bfbad-502">$filter=(PartitionKey eq 'empid_Sales') and (RowKey eq '000223')</span></span>
* <span data-ttu-id="bfbad-503">$filter = (PartitionKey eq ' email_Sales") és (RowKey eq 'jonesj@contoso.com")</span><span class="sxs-lookup"><span data-stu-id="bfbad-503">$filter=(PartitionKey eq 'email_Sales') and (RowKey eq 'jonesj@contoso.com')</span></span>  

<span data-ttu-id="bfbad-504">Ha alkalmazott entitástartományának kérdezze le, megadhatja a alkalmazott azonosítója sorrendbe rendezve tartománya vagy egy tartományt a hello hello a megfelelő előtaggal rendelkező entitások lekérdezésével e-mail cím sorrendbe rendezve **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="bfbad-504">If you query for a range of employee entities, you can specify a range sorted in employee id order, or a range sorted in email address order by querying for entities with hello appropriate prefix in hello **RowKey**.</span></span>  

* <span data-ttu-id="bfbad-505">összes alkalmazottja hello toofind hello értékesítési részleg hello közé alkalmazott azonosítójú **000100** túl**000199** alkalmazott azonosítója sorrendben használja rendezve: $filter = (PartitionKey eq ' empid_Sales") és (RowKey ge" 000100') és (RowKey le "000199")</span><span class="sxs-lookup"><span data-stu-id="bfbad-505">toofind all hello employees in hello Sales department with an employee id in hello range **000100** too**000199** sorted in employee id order use: $filter=(PartitionKey eq 'empid_Sales') and (RowKey ge '000100') and (RowKey le '000199')</span></span>  
* <span data-ttu-id="bfbad-506">toofind hello értékesítési részleg a rendezett "a" karakterlánccal kezdődik e-mail címmel rendelkező összes hello alkalmazott e-mail cím sorrendben használja: $filter = (PartitionKey eq ' email_Sales") és (RowKey ge"a") és (RowKey lt"b")</span><span class="sxs-lookup"><span data-stu-id="bfbad-506">toofind all hello employees in hello Sales department with an email address that starts with 'a' sorted in email address order use: $filter=(PartitionKey eq 'email_Sales') and (RowKey ge 'a') and (RowKey lt 'b')</span></span>  

<span data-ttu-id="bfbad-507">Vegye figyelembe, hogy a fenti példákban hello használt hello szűrőszintaxisának hello Table szolgáltatás REST API-t a további tudnivalókat lásd a [lekérdezés entitások](http://msdn.microsoft.com/library/azure/dd179421.aspx).</span><span class="sxs-lookup"><span data-stu-id="bfbad-507">Note that hello filter syntax used in hello examples above is from hello Table service REST API, for more information see [Query Entities](http://msdn.microsoft.com/library/azure/dd179421.aspx).</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="bfbad-508">Problémákat és szempontok</span><span class="sxs-lookup"><span data-stu-id="bfbad-508">Issues and considerations</span></span>
<span data-ttu-id="bfbad-509">Vegye figyelembe a következő pontok meghatározásakor hello hogyan tooimplement ebben a mintában:</span><span class="sxs-lookup"><span data-stu-id="bfbad-509">Consider hello following points when deciding how tooimplement this pattern:</span></span>  

* <span data-ttu-id="bfbad-510">Hálózati adaptere esetében megtarthatja az ismétlődő entitások idővel konzisztenssé egymással hello segítségével [idővel konzisztenssé tranzakciók mintát](#eventually-consistent-transactions-pattern) toomaintain hello elsődleges és másodlagos index entitásokat.</span><span class="sxs-lookup"><span data-stu-id="bfbad-510">You can keep your duplicate entities eventually consistent with each other by using hello [Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) toomaintain hello primary and secondary index entities.</span></span>  
* <span data-ttu-id="bfbad-511">A TABLE storage viszonylag olcsó toouse, így a terhelést növelni az ismétlődő adatok tárolására költség hello nem lehet fő szempont.</span><span class="sxs-lookup"><span data-stu-id="bfbad-511">Table storage is relatively cheap toouse so hello cost overhead of storing duplicate data should not be a major concern.</span></span> <span data-ttu-id="bfbad-512">Azonban kell kiértékelésének eredménye mindig a várható tárolási szükségletek előkészítését hello költség, és csak hozzá kettős bejegyzés toosupport hello lekérdezések végrehajtja az ügyfélalkalmazást.</span><span class="sxs-lookup"><span data-stu-id="bfbad-512">However, you should always evaluate hello cost of your design based on your anticipated storage requirements and only add duplicate entities toosupport hello queries your client application will execute.</span></span>  
* <span data-ttu-id="bfbad-513">hello használt érték hello **RowKey** minden egyes entitásnál egyedinek kell lennie.</span><span class="sxs-lookup"><span data-stu-id="bfbad-513">hello value used for hello **RowKey** must be unique for each entity.</span></span> <span data-ttu-id="bfbad-514">Érdemes lehet összetett kulcs értékeket.</span><span class="sxs-lookup"><span data-stu-id="bfbad-514">Consider using compound key values.</span></span>  
* <span data-ttu-id="bfbad-515">Kitöltési hello szerepel benne numerikus érték **RowKey** (például hello alkalmazottazonosító 000223), lehetővé teszi, hogy javítsa ki, rendezési és szűrési alapján felső és alsó határait.</span><span class="sxs-lookup"><span data-stu-id="bfbad-515">Padding numeric values in hello **RowKey** (for example, hello employee id 000223), enables correct sorting and filtering based on upper and lower bounds.</span></span>  
* <span data-ttu-id="bfbad-516">Nem feltétlenül kell tooduplicate az entitás összes hello tulajdonságait.</span><span class="sxs-lookup"><span data-stu-id="bfbad-516">You do not necessarily need tooduplicate all hello properties of your entity.</span></span> <span data-ttu-id="bfbad-517">Például ha hello lekérdezéseiben, amelyeket keresési hello entitásnak hello segítségével e-mail-címre a hello **RowKey** soha nem kell hello alkalmazott életkora, ezeket az entitásokat hello struktúra a következő lehet:</span><span class="sxs-lookup"><span data-stu-id="bfbad-517">For example, if hello queries that lookup hello entities using hello email address in hello **RowKey** never need hello employee's age, these entities could have hello following structure:</span></span>
  
  ![][11]
* <span data-ttu-id="bfbad-518">Általában jobb toostore ismétlődő adatokat, és győződjön meg arról, hogy minden hello a szükséges adatok egyetlen lekérdezést, mint egy entitás használatával toouse egy lekérdezést toolocate hello másodlagos index kérheti le, és egy másik toolookup hello hello elsődleges index szükséges adatok.</span><span class="sxs-lookup"><span data-stu-id="bfbad-518">It is typically better toostore duplicate data and ensure that you can retrieve all hello data you need with a single query than toouse one query toolocate an entity using hello secondary index and another toolookup hello required data in hello primary index.</span></span>  

#### <a name="when-toouse-this-pattern"></a><span data-ttu-id="bfbad-519">Ha toouse ezt a mintát</span><span class="sxs-lookup"><span data-stu-id="bfbad-519">When toouse this pattern</span></span>
<span data-ttu-id="bfbad-520">Ezt a mintát használja, ha az ügyfélalkalmazást számos különböző kulcsok használatát, ha az ügyfélnek kell eltérő rendezési sorrend tooretrieve entitásának tooretrieve entitásokat, és ahol minden entitás egyedi értékeket számos segítségével azonosíthatja.</span><span class="sxs-lookup"><span data-stu-id="bfbad-520">Use this pattern when your client application needs tooretrieve entities using a variety of different keys, when your client needs tooretrieve entities in different sort orders, and where you can identify each entity using a variety of unique values.</span></span> <span data-ttu-id="bfbad-521">Ebben a mintában használja, ha azt szeretné, hogy hello partíció méretezhetőségi korlátok meghaladja a különböző hello segítségével entitás keresések végrehajtásakor tooavoid **RowKey** értékeket.</span><span class="sxs-lookup"><span data-stu-id="bfbad-521">Use this pattern when you want tooavoid exceeding hello partition scalability limits when you are performing entity lookups using hello different **RowKey** values.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="bfbad-522">Útmutató és a kapcsolódó minták</span><span class="sxs-lookup"><span data-stu-id="bfbad-522">Related patterns and guidance</span></span>
<span data-ttu-id="bfbad-523">hello következő mintákat és útmutatókat is megfelelő ebben a mintában végrehajtása során:</span><span class="sxs-lookup"><span data-stu-id="bfbad-523">hello following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="bfbad-524">Idővel konzisztenssé tranzakciók minta</span><span class="sxs-lookup"><span data-stu-id="bfbad-524">Eventually consistent transactions pattern</span></span>](#eventually-consistent-transactions-pattern)  
* [<span data-ttu-id="bfbad-525">Helyen belüli-partíció másodlagos index minta</span><span class="sxs-lookup"><span data-stu-id="bfbad-525">Intra-partition secondary index pattern</span></span>](#intra-partition-secondary-index-pattern)  
* [<span data-ttu-id="bfbad-526">Összetett kulcs minta</span><span class="sxs-lookup"><span data-stu-id="bfbad-526">Compound key pattern</span></span>](#compound-key-pattern)  
* [<span data-ttu-id="bfbad-527">Entitás csoport tranzakciók</span><span class="sxs-lookup"><span data-stu-id="bfbad-527">Entity Group Transactions</span></span>](#entity-group-transactions)  
* [<span data-ttu-id="bfbad-528">Heterogén entitástípusok használata</span><span class="sxs-lookup"><span data-stu-id="bfbad-528">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)  

### <a name="eventually-consistent-transactions-pattern"></a><span data-ttu-id="bfbad-529">Idővel konzisztenssé tranzakciók minta</span><span class="sxs-lookup"><span data-stu-id="bfbad-529">Eventually consistent transactions pattern</span></span>
<span data-ttu-id="bfbad-530">Engedélyezze a idővel konzisztenssé viselkedés partícióhatárok vagy tárolási rendszer határok az Azure-üzenetsorok használatával.</span><span class="sxs-lookup"><span data-stu-id="bfbad-530">Enable eventually consistent behavior across partition boundaries or storage system boundaries by using Azure queues.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="bfbad-531">A környezetben, és probléma</span><span class="sxs-lookup"><span data-stu-id="bfbad-531">Context and problem</span></span>
<span data-ttu-id="bfbad-532">EGTs atomi tranzakciók engedélyezése között, amelyek közös hello több entitás ugyanazzal a partíciókulccsal.</span><span class="sxs-lookup"><span data-stu-id="bfbad-532">EGTs enable atomic transactions across multiple entities that share hello same partition key.</span></span> <span data-ttu-id="bfbad-533">A teljesítmény és méretezhetőség érdekében dönthet úgy, hogy külön partíciók vagy egy különálló tárhelyet rendszer konzisztencia-követelményekkel rendelkező entitások toostore: ilyen esetben EGTs toomaintain konzisztencia nem használható.</span><span class="sxs-lookup"><span data-stu-id="bfbad-533">For performance and scalability reasons, you might decide toostore entities that have consistency requirements in separate partitions or in a separate storage system: in such a scenario, you cannot use EGTs toomaintain consistency.</span></span> <span data-ttu-id="bfbad-534">Például lehetséges, hogy egy követelmény toomaintain végleges konzisztencia között:</span><span class="sxs-lookup"><span data-stu-id="bfbad-534">For example, you might have a requirement toomaintain eventual consistency between:</span></span>  

* <span data-ttu-id="bfbad-535">Két különböző partíciók hello tárolt entitásokat azonos tábla, a különböző táblák, a különböző tárfiókokban.</span><span class="sxs-lookup"><span data-stu-id="bfbad-535">Entities stored in two different partitions in hello same table, in different tables, in in different storage accounts.</span></span>  
* <span data-ttu-id="bfbad-536">Egy entitás hello Table szolgáltatás tárolja, és a blob hello Blob szolgáltatásban tárolja.</span><span class="sxs-lookup"><span data-stu-id="bfbad-536">An entity stored in hello Table service and a blob stored in hello Blob service.</span></span>  
* <span data-ttu-id="bfbad-537">Egy entitás tárolt hello Table szolgáltatás és a fájl a fájlrendszerben.</span><span class="sxs-lookup"><span data-stu-id="bfbad-537">An entity stored in hello Table service and a file in a file system.</span></span>  
* <span data-ttu-id="bfbad-538">Egy entitás hello Table szolgáltatás tárolása, még indexelt hello Azure Search szolgáltatás használatával.</span><span class="sxs-lookup"><span data-stu-id="bfbad-538">An entity store in hello Table service yet indexed using hello Azure Search service.</span></span>  

#### <a name="solution"></a><span data-ttu-id="bfbad-539">Megoldás</span><span class="sxs-lookup"><span data-stu-id="bfbad-539">Solution</span></span>
<span data-ttu-id="bfbad-540">Azure üzenetsorok használata esetén alkalmazhat olyan megoldás, amely továbbítja a végleges konzisztencia két vagy több partíciót, vagy tárolási rendszerek között.</span><span class="sxs-lookup"><span data-stu-id="bfbad-540">By using Azure queues, you can implement a solution that delivers eventual consistency across two or more partitions or storage systems.</span></span>
<span data-ttu-id="bfbad-541">tooillustrate ez közelítse, során feltételezzük, hogy egy követelmény toobe képes tooarchive régi alkalmazott entitásokat.</span><span class="sxs-lookup"><span data-stu-id="bfbad-541">tooillustrate this approach, assume you have a requirement toobe able tooarchive old employee entities.</span></span> <span data-ttu-id="bfbad-542">Régi alkalmazott entitások ritkán a rendszer megkérdezi, és olyan tevékenységet, amely az aktuális alkalmazottak kezelésére ki kell zárni.</span><span class="sxs-lookup"><span data-stu-id="bfbad-542">Old employee entities are rarely queried and should be excluded from any activities that deal with current employees.</span></span> <span data-ttu-id="bfbad-543">tooimplement hello aktív tárolja ezt a követelményt **aktuális** tábla és a régi dolgozók hello **archív** tábla.</span><span class="sxs-lookup"><span data-stu-id="bfbad-543">tooimplement this requirement you store active employees in hello **Current** table and old employees in hello **Archive** table.</span></span> <span data-ttu-id="bfbad-544">Egy alkalmazott archiválás szükséges toodelete hello entitásának hello **aktuális** tábla, és adja hozzá a hello entitás toohello **archív** táblában, de nem használható egy EGT tooperform két művelet.</span><span class="sxs-lookup"><span data-stu-id="bfbad-544">Archiving an employee requires you toodelete hello entity from hello **Current** table and add hello entity toohello **Archive** table, but you cannot use an EGT tooperform these two operations.</span></span> <span data-ttu-id="bfbad-545">tooavoid hello kockázata, hogy hibát okoz, egy entitás tooappear mindkét vagy egyiket se táblák, hello archiválási művelet idővel konzisztenssé kell lennie.</span><span class="sxs-lookup"><span data-stu-id="bfbad-545">tooavoid hello risk that a failure causes an entity tooappear in both or neither tables, hello archive operation must be eventually consistent.</span></span> <span data-ttu-id="bfbad-546">hello következő Szekvenciadiagram lépéseit sorolja fel hello ebben a műveletben.</span><span class="sxs-lookup"><span data-stu-id="bfbad-546">hello following sequence diagram outlines hello steps in this operation.</span></span> <span data-ttu-id="bfbad-547">Kivétel elérési utak, a következő hello szöveg biztosított további információkhoz juthat.</span><span class="sxs-lookup"><span data-stu-id="bfbad-547">More detail is provided for exception paths in hello text following.</span></span>  

![][12]

<span data-ttu-id="bfbad-548">Egy Azure-üzenetsorba, ez például tooarchive alkalmazotti #456 helyez el egy üzenetet az ügyfél hello archiválási művelet kezdeményez.</span><span class="sxs-lookup"><span data-stu-id="bfbad-548">A client initiates hello archive operation by placing a message on an Azure queue, in this example tooarchive employee #456.</span></span> <span data-ttu-id="bfbad-549">A feldolgozói szerepkör kérdezze le az új üzenetek; hello várólista Ha talál egyet, üdvözlőüzenetére olvas, és hagyja rejtett másolatot hello a várakozási.</span><span class="sxs-lookup"><span data-stu-id="bfbad-549">A worker role polls hello queue for new messages; when it finds one, it reads hello message and leaves a hidden copy on hello queue.</span></span> <span data-ttu-id="bfbad-550">hello feldolgozói szerepkör ezután lekéri hello entitás másolatát hello **aktuális** table, szúrja be a másolási hello **archív** tábla, és törli hello hello az eredeti **aktuális**tábla.</span><span class="sxs-lookup"><span data-stu-id="bfbad-550">hello worker role next fetches a copy of hello entity from hello **Current** table, inserts a copy in hello **Archive** table, and then deletes hello original from hello **Current** table.</span></span> <span data-ttu-id="bfbad-551">Végül ha nincs hiba hello előző lépéseiből, hello feldolgozói szerepkör törli rejtett üdvözlőüzenetére hello üzenetsorból.</span><span class="sxs-lookup"><span data-stu-id="bfbad-551">Finally, if there were no errors from hello previous steps, hello worker role deletes hello hidden message from hello queue.</span></span>  

<span data-ttu-id="bfbad-552">Ebben a példában a 4. lépés hello alkalmazott illeszt hello **archív** tábla.</span><span class="sxs-lookup"><span data-stu-id="bfbad-552">In this example, step 4 inserts hello employee into hello **Archive** table.</span></span> <span data-ttu-id="bfbad-553">Hello alkalmazott tooa blob a Blob szolgáltatás hello vagy annak egy fájljához hozzáadhatja, a fájlrendszer.</span><span class="sxs-lookup"><span data-stu-id="bfbad-553">It could add hello employee tooa blob in hello Blob service or a file in a file system.</span></span>  

#### <a name="recovering-from-failures"></a><span data-ttu-id="bfbad-554">Végezze el a hibák</span><span class="sxs-lookup"><span data-stu-id="bfbad-554">Recovering from failures</span></span>
<span data-ttu-id="bfbad-555">Fontos, hogy hello lépéseket az operations **4** és **5** kell lennie *idempotent* abban az esetben hello feldolgozói szerepkör kell toorestart hello archiválási művelet.</span><span class="sxs-lookup"><span data-stu-id="bfbad-555">It is important that hello operations in steps **4** and **5** must be *idempotent* in case hello worker role needs toorestart hello archive operation.</span></span> <span data-ttu-id="bfbad-556">Ha hello Table szolgáltatás lépés az **4** kell használnia az "insert vagy cserélje le a" művelet; lépés **5** kell használnia egy "törlése, ha létezik-e" hello ügyféloldali kódtár használata a műveletet.</span><span class="sxs-lookup"><span data-stu-id="bfbad-556">If you are using hello Table service, for step **4** you should use an "insert or replace" operation; for step **5** you should use a "delete if exists" operation in hello client library you are using.</span></span> <span data-ttu-id="bfbad-557">Ha egy másik tárolási rendszert használ, egy megfelelő idempotent műveletet kell használnia.</span><span class="sxs-lookup"><span data-stu-id="bfbad-557">If you are using another storage system, you must use an appropriate idempotent operation.</span></span>  

<span data-ttu-id="bfbad-558">Ha hello feldolgozói szerepkör soha nem fejeződik be a lépés **6**, majd hello időtúllépési üzenet ismét megjelenik, hello várólista után készen áll a hello feldolgozói szerepkör tootry tooreprocess azt.</span><span class="sxs-lookup"><span data-stu-id="bfbad-558">If hello worker role never completes step **6**, then after a timeout hello message reappears on hello queue ready for hello worker role tootry tooreprocess it.</span></span> <span data-ttu-id="bfbad-559">hello feldolgozói szerepkör ellenőrizheti egy hello várólista olvasták futtatásainak számát, és szükség esetén egy "poison" üzenetet, hogy meg lehessen vizsgálni tooa elküldésével jelző külön várólista.</span><span class="sxs-lookup"><span data-stu-id="bfbad-559">hello worker role can check how many times a message on hello queue has been read and, if necessary, flag it is a "poison" message for investigation by sending it tooa separate queue.</span></span> <span data-ttu-id="bfbad-560">További információ az üzenetek olvasásakor és hello ellenőrzése created száma, lásd: [üzeneteket beolvasni](https://msdn.microsoft.com/library/azure/dd179474.aspx).</span><span class="sxs-lookup"><span data-stu-id="bfbad-560">For more information about reading queue messages and checking hello dequeue count, see [Get Messages](https://msdn.microsoft.com/library/azure/dd179474.aspx).</span></span>  

<span data-ttu-id="bfbad-561">Bizonyos hibák hello tábla és a Queue szolgáltatások átmeneti hibák, és az ügyfélalkalmazás tartalmaznia kell a megfelelő újrapróbálkozási logika toohandle őket.</span><span class="sxs-lookup"><span data-stu-id="bfbad-561">Some errors from hello Table and Queue services are transient errors, and your client application should include suitable retry logic toohandle them.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="bfbad-562">Problémákat és szempontok</span><span class="sxs-lookup"><span data-stu-id="bfbad-562">Issues and considerations</span></span>
<span data-ttu-id="bfbad-563">Vegye figyelembe a következő pontok meghatározásakor hello hogyan tooimplement ebben a mintában:</span><span class="sxs-lookup"><span data-stu-id="bfbad-563">Consider hello following points when deciding how tooimplement this pattern:</span></span>  

* <span data-ttu-id="bfbad-564">Ez a megoldás elkülönítési tranzakció nem ad meg.</span><span class="sxs-lookup"><span data-stu-id="bfbad-564">This solution does not provide for transaction isolation.</span></span> <span data-ttu-id="bfbad-565">Például egy ügyfél olvasható hello **aktuális** és **archív** állapotában hello feldolgozói szerepkör lépések között táblák **4** és **5**, és tekintse meg egy hello adatok inkonzisztens nézetét.</span><span class="sxs-lookup"><span data-stu-id="bfbad-565">For example, a client could read hello **Current** and **Archive** tables when hello worker role was between steps **4** and **5**, and see an inconsistent view of hello data.</span></span> <span data-ttu-id="bfbad-566">Vegye figyelembe, hogy hello adatok konzisztens idővel.</span><span class="sxs-lookup"><span data-stu-id="bfbad-566">Note that hello data will be consistent eventually.</span></span>  
* <span data-ttu-id="bfbad-567">Meg arról, hogy 4. és 5 rendelés tooensure végleges konzisztencia az idempotent kell lennie.</span><span class="sxs-lookup"><span data-stu-id="bfbad-567">You must be sure that steps 4 and 5 are idempotent in order tooensure eventual consistency.</span></span>  
* <span data-ttu-id="bfbad-568">Több várólisták és feldolgozópéldányok szerepkör segítségével méretezhető hello megoldás.</span><span class="sxs-lookup"><span data-stu-id="bfbad-568">You can scale hello solution by using multiple queues and worker role instances.</span></span>  

#### <a name="when-toouse-this-pattern"></a><span data-ttu-id="bfbad-569">Ha toouse ezt a mintát</span><span class="sxs-lookup"><span data-stu-id="bfbad-569">When toouse this pattern</span></span>
<span data-ttu-id="bfbad-570">Ezt a mintát használja, ha azt szeretné, hogy a végleges konzisztencia tooguarantee entitás, amely szerepel a különböző partíciók, illetve olyan táblázatok között.</span><span class="sxs-lookup"><span data-stu-id="bfbad-570">Use this pattern when you want tooguarantee eventual consistency between entities that exist in different partitions or tables.</span></span> <span data-ttu-id="bfbad-571">A minta tooensure végleges konzisztencia műveletekhez kiterjesztése hello tábla és hello Blob szolgáltatás és más Azure Storage adatforrások, például az adatbázis vagy hello fájlrendszer.</span><span class="sxs-lookup"><span data-stu-id="bfbad-571">You can extend this pattern tooensure eventual consistency for operations across hello Table service and hello Blob service and other non-Azure Storage data sources such as database or hello file system.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="bfbad-572">Útmutató és a kapcsolódó minták</span><span class="sxs-lookup"><span data-stu-id="bfbad-572">Related patterns and guidance</span></span>
<span data-ttu-id="bfbad-573">hello következő mintákat és útmutatókat is megfelelő ebben a mintában végrehajtása során:</span><span class="sxs-lookup"><span data-stu-id="bfbad-573">hello following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="bfbad-574">Entitás csoport tranzakciók</span><span class="sxs-lookup"><span data-stu-id="bfbad-574">Entity Group Transactions</span></span>](#entity-group-transactions)  
* [<span data-ttu-id="bfbad-575">Egyesítés vagy cseréje</span><span class="sxs-lookup"><span data-stu-id="bfbad-575">Merge or replace</span></span>](#merge-or-replace)  

> [!NOTE]
> <span data-ttu-id="bfbad-576">Ha a tranzakció elkülönítési fontos tooyour megoldás, érdemes lehet a táblák tooenable újratervezése toouse EGTs meg.</span><span class="sxs-lookup"><span data-stu-id="bfbad-576">If transaction isolation is important tooyour solution, you should consider redesigning your tables tooenable you toouse EGTs.</span></span>  
> 
> 

### <a name="index-entities-pattern"></a><span data-ttu-id="bfbad-577">Index entitások minta</span><span class="sxs-lookup"><span data-stu-id="bfbad-577">Index Entities Pattern</span></span>
<span data-ttu-id="bfbad-578">Index entitások tooenable hatékony keresések entitások listájának visszaadó karbantartása.</span><span class="sxs-lookup"><span data-stu-id="bfbad-578">Maintain index entities tooenable efficient searches that return lists of entities.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="bfbad-579">A környezetben, és probléma</span><span class="sxs-lookup"><span data-stu-id="bfbad-579">Context and problem</span></span>
<span data-ttu-id="bfbad-580">Table szolgáltatás hello automatikusan elvégzi a hello segítségével **PartitionKey** és **RowKey** értékeket.</span><span class="sxs-lookup"><span data-stu-id="bfbad-580">hello Table service automatically indexes entities using hello **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="bfbad-581">Ez lehetővé teszi, hogy egy ügyfél alkalmazás tooretrieve hatékonyan pont lekérdezéssel entitás.</span><span class="sxs-lookup"><span data-stu-id="bfbad-581">This enables a client application tooretrieve an entity efficiently using a point query.</span></span> <span data-ttu-id="bfbad-582">Például alább látható hello táblaszerkezet használ, egy ügyfélalkalmazás hatékonyan alkalmazott entitás használatával lekérhető hello részleg neve és hello alkalmazott azonosítója (hello **PartitionKey** és **RowKey** ).</span><span class="sxs-lookup"><span data-stu-id="bfbad-582">For example, using hello table structure shown below, a client application can efficiently retrieve an individual employee entity by using hello department name and hello employee id (hello **PartitionKey** and **RowKey**).</span></span>  

![][13]

<span data-ttu-id="bfbad-583">Ha toobe képes tooretrieve alkalmazott entitások listájának hello egy másik nem egyedi tulajdonság értéke, például a vezetéknevét, alapján is érdemes használnia kell a kevésbé hatékony partíció toofind egyező vizsgálata helyett egy index toolook azokat fel közvetlenül.</span><span class="sxs-lookup"><span data-stu-id="bfbad-583">If you also want toobe able tooretrieve a list of employee entities based on hello value of another non-unique property, such as their last name, you must use a less efficient partition scan toofind matches rather than using an index toolook them up directly.</span></span> <span data-ttu-id="bfbad-584">Ennek az az oka hello table szolgáltatás nem biztosít a másodlagos kulcsot.</span><span class="sxs-lookup"><span data-stu-id="bfbad-584">This is because hello table service does not provide secondary indexes.</span></span>  

#### <a name="solution"></a><span data-ttu-id="bfbad-585">Megoldás</span><span class="sxs-lookup"><span data-stu-id="bfbad-585">Solution</span></span>
<span data-ttu-id="bfbad-586">tooenable keresési alkalmazott azonosítók listájának kezelnie kell a fent látható hello entitás struktúrájú utolsó név szerint.</span><span class="sxs-lookup"><span data-stu-id="bfbad-586">tooenable lookup by last name with hello entity structure shown above, you must maintain lists of employee ids.</span></span> <span data-ttu-id="bfbad-587">Ha azt szeretné, hogy tooretrieve hello alkalmazott entitások egy adott nevű utolsó, például a János, először keresse meg az alkalmazott azonosítók hello listáját János a Vezetéknév, az alkalmazottak számára, és az majd lekérheti az alkalmazott entitásokból.</span><span class="sxs-lookup"><span data-stu-id="bfbad-587">If you want tooretrieve hello employee entities with a particular last name, such as Jones, you must first locate hello list of employee ids for employees with Jones as their last name, and then retrieve those employee entities.</span></span> <span data-ttu-id="bfbad-588">Hello alkalmazott azonosítók listájának tárolására három fő lehetőség áll rendelkezésre:</span><span class="sxs-lookup"><span data-stu-id="bfbad-588">There are three main options for storing hello lists of employee ids:</span></span>  

* <span data-ttu-id="bfbad-589">A blob storage használata.</span><span class="sxs-lookup"><span data-stu-id="bfbad-589">Use blob storage.</span></span>  
* <span data-ttu-id="bfbad-590">Hozzon létre indexet entitások azonos partícióazonosító hello alkalmazott entitásként hello.</span><span class="sxs-lookup"><span data-stu-id="bfbad-590">Create index entities in hello same partition as hello employee entities.</span></span>  
* <span data-ttu-id="bfbad-591">Hozzon létre indexet entitások külön partíció vagy tábla.</span><span class="sxs-lookup"><span data-stu-id="bfbad-591">Create index entities in a separate partition or table.</span></span>  

<span data-ttu-id="bfbad-592"><u>#1. lehetőség: Használja a blob storage</u></span><span class="sxs-lookup"><span data-stu-id="bfbad-592"><u>Option #1: Use blob storage</u></span></span>  

<span data-ttu-id="bfbad-593">Hello első lehetőség, létrehoz egy blob minden egyedi Vezetéknév, és minden egyes blob tárolóban hello listája **PartitionKey** (osztály) és **RowKey** (alkalmazott azonosítója) értékeit, amely utoljára rendelkező alkalmazottak név.</span><span class="sxs-lookup"><span data-stu-id="bfbad-593">For hello first option, you create a blob for every unique last name, and in each blob store a list of hello **PartitionKey** (department) and **RowKey** (employee id) values for employees that have that last name.</span></span> <span data-ttu-id="bfbad-594">Adja hozzá, vagy egy alkalmazott törlésekor biztosítania kell, hogy hello hello vonatkozó blob tartalma idővel konzisztenssé váljanak hello alkalmazott entitásokat.</span><span class="sxs-lookup"><span data-stu-id="bfbad-594">When you add or delete an employee you should ensure that hello content of hello relevant blob is eventually consistent with hello employee entities.</span></span>  

<span data-ttu-id="bfbad-595"><u>#2. lehetőség:</u> a Create index entitásokat tartalmazó partícióra hello</span><span class="sxs-lookup"><span data-stu-id="bfbad-595"><u>Option #2:</u> Create index entities in hello same partition</span></span>  

<span data-ttu-id="bfbad-596">Hello második lehetőség használja a következő adatok hello tárolására szolgáló index entitás:</span><span class="sxs-lookup"><span data-stu-id="bfbad-596">For hello second option, use index entities that store hello following data:</span></span>  

![][14]

<span data-ttu-id="bfbad-597">Hello **EmployeeIDs** hello tárolt hello utolsó nevű tulajdonsága tartalmazza az alkalmazottak számára alkalmazott azonosítók listájának **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="bfbad-597">hello **EmployeeIDs** property contains a list of employee ids for employees with hello last name stored in hello **RowKey**.</span></span>  

<span data-ttu-id="bfbad-598">hello lépései hello folyamat felvételekor új alkalmazott hello második lehetőség használata ajánlott.</span><span class="sxs-lookup"><span data-stu-id="bfbad-598">hello following steps outline hello process you should follow when you are adding a new employee if you are using hello second option.</span></span> <span data-ttu-id="bfbad-599">Ebben a példában azt ad hozzá egy alkalmazott azonosítója 000152 és a Vezetéknév János hello értékesítési részleg:</span><span class="sxs-lookup"><span data-stu-id="bfbad-599">In this example, we are adding an employee with Id 000152 and a last name Jones in hello Sales department:</span></span>  

1. <span data-ttu-id="bfbad-600">Hello index entitás beolvasni egy **PartitionKey** érték az "Értékesítési" és a hello **RowKey** érték "János."</span><span class="sxs-lookup"><span data-stu-id="bfbad-600">Retrieve hello index entity with a **PartitionKey** value "Sales" and hello **RowKey** value "Jones."</span></span> <span data-ttu-id="bfbad-601">Ez entity toouse az ETag hello mentése a 2.</span><span class="sxs-lookup"><span data-stu-id="bfbad-601">Save hello ETag of this entity toouse in step 2.</span></span>  
2. <span data-ttu-id="bfbad-602">Hozzon létre egy entitás csoport tranzakció (Ez azt jelenti, hogy a kötegelt művelet) hello új alkalmazott entitás beszúrása (**PartitionKey** "Értékesítési" érték és **RowKey** "000152" értéket), és a frissítések hello index entitás ( **PartitionKey** "Értékesítési" érték és **RowKey** "János" értékre) hello EmployeeIDs mezőben hello új alkalmazott azonosítója toohello lista hozzáadásával.</span><span class="sxs-lookup"><span data-stu-id="bfbad-602">Create an entity group transaction (that is, a batch operation) that inserts hello new employee entity (**PartitionKey** value "Sales" and **RowKey** value "000152"), and updates hello index entity (**PartitionKey** value "Sales" and **RowKey** value "Jones") by adding hello new employee id toohello list in hello EmployeeIDs field.</span></span> <span data-ttu-id="bfbad-603">Entitás csoport tranzakciókkal kapcsolatos további információkért lásd: [entitás csoport tranzakciók](#entity-group-transactions).</span><span class="sxs-lookup"><span data-stu-id="bfbad-603">For more information about entity group transactions, see [Entity Group Transactions](#entity-group-transactions).</span></span>  
3. <span data-ttu-id="bfbad-604">Ha hello entitás csoport tranzakció (valaki más csak módosította hello index entitás) egyidejű hozzáférések optimista hiba miatt nem sikerül, akkor szüksége toostart keresztül 1. lépés: újra.</span><span class="sxs-lookup"><span data-stu-id="bfbad-604">If hello entity group transaction fails because of an optimistic concurrency error (someone else has just modified hello index entity), then you need toostart over at step 1 again.</span></span>  

<span data-ttu-id="bfbad-605">Használhat egy hasonló megközelítés toodeleting egy alkalmazott hello második lehetőség használata.</span><span class="sxs-lookup"><span data-stu-id="bfbad-605">You can use a similar approach toodeleting an employee if you are using hello second option.</span></span> <span data-ttu-id="bfbad-606">Egy alkalmazott Vezetéknév módosítása nem kicsit bonyolultabb, mert szüksége lesz egy entitás csoport tranzakció, amely három entitások frissíti tooexecute: hello alkalmazott entitás hello index entitás hello régi Vezetéknév és hello index entitás hello új utolsó neve.</span><span class="sxs-lookup"><span data-stu-id="bfbad-606">Changing an employee's last name is slightly more complex because you will need tooexecute an entity group transaction that updates three entities: hello employee entity, hello index entity for hello old last name, and hello index entity for hello new last name.</span></span> <span data-ttu-id="bfbad-607">Minden entitás módosítása előtt sorrendben tooretrieve hello ETag érték majd használható tooperform hello frissítések optimista konkurenciát alkalmazott be kell olvasni.</span><span class="sxs-lookup"><span data-stu-id="bfbad-607">You must retrieve each entity before making any changes in order tooretrieve hello ETag values that you can then use tooperform hello updates using optimistic concurrency.</span></span>  

<span data-ttu-id="bfbad-608">hello lépései hello folyamat, ha egy osztály adott utolsó nevű alkalmazottait hello toolook hello második lehetőség használata ajánlott.</span><span class="sxs-lookup"><span data-stu-id="bfbad-608">hello following steps outline hello process you should follow when you need toolook up all hello employees with a given last name in a department if you are using hello second option.</span></span> <span data-ttu-id="bfbad-609">Ebben a példában is szívesen látjuk hello értékesítési részleg utolsó nevű János alkalmazottait hello:</span><span class="sxs-lookup"><span data-stu-id="bfbad-609">In this example, we are looking up all hello employees with last name Jones in hello Sales department:</span></span>  

1. <span data-ttu-id="bfbad-610">Hello index entitás beolvasni egy **PartitionKey** érték az "Értékesítési" és a hello **RowKey** érték "János."</span><span class="sxs-lookup"><span data-stu-id="bfbad-610">Retrieve hello index entity with a **PartitionKey** value "Sales" and hello **RowKey** value "Jones."</span></span>  
2. <span data-ttu-id="bfbad-611">Elemezni hello alkalmazott hello EmployeeIDs mezőben azonosítók listáját.</span><span class="sxs-lookup"><span data-stu-id="bfbad-611">Parse hello list of employee Ids in hello EmployeeIDs field.</span></span>  
3. <span data-ttu-id="bfbad-612">Ha további információ az egyes ezeknek a dolgozóknak (például az e-mail címmel) van szüksége, lekéri az egyes hello alkalmazott entitások használatával **PartitionKey** "Értékesítési" értéket, és **RowKey** közötti értéket 2. lépésben beolvasott alkalmazottak hello listája.</span><span class="sxs-lookup"><span data-stu-id="bfbad-612">If you need additional information about each of these employees (such as their email addresses), retrieve each of hello employee entities using **PartitionKey** value "Sales" and **RowKey** values from hello list of employees you obtained in step 2.</span></span>  

<span data-ttu-id="bfbad-613"><u>#3. lehetőség:</u> index entitások külön partíció vagy tábla létrehozása</span><span class="sxs-lookup"><span data-stu-id="bfbad-613"><u>Option #3:</u> Create index entities in a separate partition or table</span></span>  

<span data-ttu-id="bfbad-614">Hello harmadik beállítás használja a következő adatok hello tárolására szolgáló index entitás:</span><span class="sxs-lookup"><span data-stu-id="bfbad-614">For hello third option, use index entities that store hello following data:</span></span>  

![][15]

<span data-ttu-id="bfbad-615">Hello **EmployeeIDs** hello tárolt hello utolsó nevű tulajdonsága tartalmazza az alkalmazottak számára alkalmazott azonosítók listájának **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="bfbad-615">hello **EmployeeIDs** property contains a list of employee ids for employees with hello last name stored in hello **RowKey**.</span></span>  

<span data-ttu-id="bfbad-616">Hello harmadik beállítás EGTs toomaintain konzisztencia nem használható, mert a hello alkalmazott entitásokból külön partícióra vannak hello index entitásokat.</span><span class="sxs-lookup"><span data-stu-id="bfbad-616">With hello third option, you cannot use EGTs toomaintain consistency because hello index entities are in a separate partition from hello employee entities.</span></span> <span data-ttu-id="bfbad-617">Ellenőrizze, hogy idővel konzisztenssé váljanak hello alkalmazott entitások-e hello index entitásokat.</span><span class="sxs-lookup"><span data-stu-id="bfbad-617">You should ensure that hello index entities are eventually consistent with hello employee entities.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="bfbad-618">Problémákat és szempontok</span><span class="sxs-lookup"><span data-stu-id="bfbad-618">Issues and considerations</span></span>
<span data-ttu-id="bfbad-619">Vegye figyelembe a következő pontok meghatározásakor hello hogyan tooimplement ebben a mintában:</span><span class="sxs-lookup"><span data-stu-id="bfbad-619">Consider hello following points when deciding how tooimplement this pattern:</span></span>  

* <span data-ttu-id="bfbad-620">Ehhez a megoldáshoz szükségesek entitások megfelelő legalább két lekérdezést tooretrieve: egy tooquery hello index entitások tooobtain hello listája **RowKey** értéket, majd ezután lekérdezi tooretrieve hello listán szereplő minden egyes entitásnál.</span><span class="sxs-lookup"><span data-stu-id="bfbad-620">This solution requires at least two queries tooretrieve matching entities: one tooquery hello index entities tooobtain hello list of **RowKey** values, and then queries tooretrieve each entity in hello list.</span></span>  
* <span data-ttu-id="bfbad-621">Fényében, hogy egyes entitás a maximális méret 1 MB, #2. lehetőség van, és a #3. lehetőség hello megoldásban azt feltételezik, hogy hello listája bármely adott Vezetéknév alkalmazott azonosítóinak mindig 1 MB-nál nagyobb.</span><span class="sxs-lookup"><span data-stu-id="bfbad-621">Given that an individual entity has a maximum size of 1 MB, option #2 and option #3 in hello solution assume that hello list of employee ids for any given last name is never greater than 1 MB.</span></span> <span data-ttu-id="bfbad-622">Ha alkalmazott azonosítók listáját hello 1 MB-nál nagyobb valószínűséggel toobe, #1. lehetőség és hello index adatokat a blob Storage tárolóban tárolja.</span><span class="sxs-lookup"><span data-stu-id="bfbad-622">If hello list of employee ids is likely toobe greater than 1 MB in size, use option #1 and store hello index data in blob storage.</span></span>  
* <span data-ttu-id="bfbad-623">#2. beállítás (EGTs toohandle hozzáadása és az alkalmazottak törlése és módosítása az alkalmazott Vezetéknév használatával) ki kell értékelnie, ha tranzakciók mennyisége hello megközelítést alkalmaz majd hello méretezhetőségi korlátok egy adott partíció.</span><span class="sxs-lookup"><span data-stu-id="bfbad-623">If you use option #2 (using EGTs toohandle adding and deleting employees, and changing an employee's last name) you must evaluate if hello volume of transactions will approach hello scalability limits in a given partition.</span></span> <span data-ttu-id="bfbad-624">Ha ez helyzet hello, fontolja meg egy idővel konzisztenssé (#1. lehetőség vagy #3. lehetőség) által használt megoldás várólisták toohandle hello frissítés kér, és lehetővé teszi, hogy a hogy toostore az index entitások a hello alkalmazott entitásokból külön partícióra.</span><span class="sxs-lookup"><span data-stu-id="bfbad-624">If this is hello case, you should consider an eventually consistent solution (option #1 or option #3) that uses queues toohandle hello update requests and enables you toostore your index entities in a separate partition from hello employee entities.</span></span>  
* <span data-ttu-id="bfbad-625">#2. lehetőség a megoldás feltételezi, hogy toolook fel egy részleg utolsó nevű: például azt szeretné, hogy tooretrieve az alkalmazottak a Vezetéknév János hello értékesítési részleg listáját.</span><span class="sxs-lookup"><span data-stu-id="bfbad-625">Option #2 in this solution assumes that you want toolook up by last name within a department: for example, you want tooretrieve a list of employees with a last name Jones in hello Sales department.</span></span> <span data-ttu-id="bfbad-626">Ha azt szeretné, hogy képes toolook toobe hello alkalmazottait nevű utolsó János hello teljes szervezeten belül, #1. lehetőség vagy a #3. lehetőség használatával.</span><span class="sxs-lookup"><span data-stu-id="bfbad-626">If you want toobe able toolook up all hello employees with a last name Jones across hello whole organization, use either option #1 or option #3.</span></span>
* <span data-ttu-id="bfbad-627">Megvalósíthat egy várólista-alapú megoldás, amely a végleges konzisztencia biztosítja (lásd: hello [idővel konzisztenssé tranzakciók mintát](#eventually-consistent-transactions-pattern) további részletekért).</span><span class="sxs-lookup"><span data-stu-id="bfbad-627">You can implement a queue-based solution that delivers eventual consistency (see hello [Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) for more details).</span></span>  

#### <a name="when-toouse-this-pattern"></a><span data-ttu-id="bfbad-628">Ha toouse ezt a mintát</span><span class="sxs-lookup"><span data-stu-id="bfbad-628">When toouse this pattern</span></span>
<span data-ttu-id="bfbad-629">Ezt a mintát használja, ha azt szeretné, hogy az, hogy minden közös közös tulajdonság értéke, például minden alkalmazott Vezetéknév hello János a entitások készletének toolookup.</span><span class="sxs-lookup"><span data-stu-id="bfbad-629">Use this pattern when you want toolookup a set of entities that all share a common property value, such as all employees with hello last name Jones.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="bfbad-630">Útmutató és a kapcsolódó minták</span><span class="sxs-lookup"><span data-stu-id="bfbad-630">Related patterns and guidance</span></span>
<span data-ttu-id="bfbad-631">hello következő mintákat és útmutatókat is megfelelő ebben a mintában végrehajtása során:</span><span class="sxs-lookup"><span data-stu-id="bfbad-631">hello following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="bfbad-632">Összetett kulcs minta</span><span class="sxs-lookup"><span data-stu-id="bfbad-632">Compound key pattern</span></span>](#compound-key-pattern)  
* [<span data-ttu-id="bfbad-633">Idővel konzisztenssé tranzakciók minta</span><span class="sxs-lookup"><span data-stu-id="bfbad-633">Eventually consistent transactions pattern</span></span>](#eventually-consistent-transactions-pattern)  
* [<span data-ttu-id="bfbad-634">Entitás csoport tranzakciók</span><span class="sxs-lookup"><span data-stu-id="bfbad-634">Entity Group Transactions</span></span>](#entity-group-transactions)  
* [<span data-ttu-id="bfbad-635">Heterogén entitástípusok használata</span><span class="sxs-lookup"><span data-stu-id="bfbad-635">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)  

### <a name="denormalization-pattern"></a><span data-ttu-id="bfbad-636">Denormalization minta</span><span class="sxs-lookup"><span data-stu-id="bfbad-636">Denormalization pattern</span></span>
<span data-ttu-id="bfbad-637">Egyesíthet egy egyetlen entitás tooenable együtt a kapcsolódó adatokat tooretrieve, az összes hello egyetlen pont lekérdezéssel szükséges adatokat.</span><span class="sxs-lookup"><span data-stu-id="bfbad-637">Combine related data together in a single entity tooenable you tooretrieve all hello data you need with a single point query.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="bfbad-638">A környezetben, és probléma</span><span class="sxs-lookup"><span data-stu-id="bfbad-638">Context and problem</span></span>
<span data-ttu-id="bfbad-639">Egy relációs adatbázisban akkor általában szabványosíthatja a lekérdezéseiben, amelyeket adatainak lekérése több táblából származó adatok tooremove ismétlődést.</span><span class="sxs-lookup"><span data-stu-id="bfbad-639">In a relational database, you typically normalize data tooremove duplication resulting in queries that retrieve data from multiple tables.</span></span> <span data-ttu-id="bfbad-640">Ha normalizálása az adatok Azure-táblákban, meg kell nyitnia a hello ügyfél toohello server tooretrieve több kiszolgálókkal való adatváltások számát a kapcsolódó adatokat.</span><span class="sxs-lookup"><span data-stu-id="bfbad-640">If you normalize your data in Azure tables, you must make multiple round trips from hello client toohello server tooretrieve your related data.</span></span> <span data-ttu-id="bfbad-641">Például az alábbi értékekre, akkor hello táblaszerkezet kell két kerekíteni utazgatással tooretrieve hello részleteit egy részleg: egy toofetch hello részleg entitás, amely tartalmazza egy alkalmazott hello kezelő azonosítója, és a majd egy másik kérelem toofetch hello kezelő részletek az entitás.</span><span class="sxs-lookup"><span data-stu-id="bfbad-641">For example, with hello table structure shown below you need two round trips tooretrieve hello details for a department: one toofetch hello department entity that includes hello manager's id, and then another request toofetch hello manager's details in an employee entity.</span></span>  

![][16]

#### <a name="solution"></a><span data-ttu-id="bfbad-642">Megoldás</span><span class="sxs-lookup"><span data-stu-id="bfbad-642">Solution</span></span>
<span data-ttu-id="bfbad-643">Helyett két külön entitás hello adatok tárolását, denormalize hello adatokat, és megőrzi hello manager részletei hello részleg entitásban.</span><span class="sxs-lookup"><span data-stu-id="bfbad-643">Instead of storing hello data in two separate entities, denormalize hello data and keep a copy of hello manager's details in hello department entity.</span></span> <span data-ttu-id="bfbad-644">Példa:</span><span class="sxs-lookup"><span data-stu-id="bfbad-644">For example:</span></span>  

![][17]

<span data-ttu-id="bfbad-645">Ezekkel a tulajdonságokkal tárolt részleg entitásokkal kapcsolatos pont lekérdezéssel részleget szükséges összes hello információt most le.</span><span class="sxs-lookup"><span data-stu-id="bfbad-645">With department entities stored with these properties, you can now retrieve all hello details you need about a department using a point query.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="bfbad-646">Problémákat és szempontok</span><span class="sxs-lookup"><span data-stu-id="bfbad-646">Issues and considerations</span></span>
<span data-ttu-id="bfbad-647">Vegye figyelembe a következő pontok meghatározásakor hello hogyan tooimplement ebben a mintában:</span><span class="sxs-lookup"><span data-stu-id="bfbad-647">Consider hello following points when deciding how tooimplement this pattern:</span></span>  

* <span data-ttu-id="bfbad-648">Van néhány költsége terhet kétszer néhány adatainak tárolásához.</span><span class="sxs-lookup"><span data-stu-id="bfbad-648">There is some cost overhead associated with storing some data twice.</span></span> <span data-ttu-id="bfbad-649">hello teljesítménynövekedést (kevesebb kérelmek toohello társzolgáltatás eredő) általában ez fontosabb, mint hello marginális növekedése tárolási költségek (és az ehhez kapcsolódó költséget részben az eltolás tranzakciók száma hello csökkenése toofetch hello részletek megkövetelése a részleg).</span><span class="sxs-lookup"><span data-stu-id="bfbad-649">hello performance benefit (resulting from fewer requests toohello storage service) typically outweighs hello marginal increase in storage costs (and this cost is partially offset by a reduction in hello number of transactions you require toofetch hello details of a department).</span></span>  
* <span data-ttu-id="bfbad-650">Meg kell egységesíthetők hello hello két entitások kezelők adatainak tárolására.</span><span class="sxs-lookup"><span data-stu-id="bfbad-650">You must maintain hello consistency of hello two entities that store information about managers.</span></span> <span data-ttu-id="bfbad-651">Kezelheti hello konzisztencia probléma EGTs tooupdate használatával egy atomi tranzakción belül több entitás: Ebben az esetben hello részleg entitás és hello alkalmazott entitás hello részleg Manager tárolja hello egyazon partícióra kerüljenek.</span><span class="sxs-lookup"><span data-stu-id="bfbad-651">You can handle hello consistency issue by using EGTs tooupdate multiple entities in a single atomic transaction: in this case, hello department entity, and hello employee entity for hello department manager are stored in hello same partition.</span></span>  

#### <a name="when-toouse-this-pattern"></a><span data-ttu-id="bfbad-652">Ha toouse ezt a mintát</span><span class="sxs-lookup"><span data-stu-id="bfbad-652">When toouse this pattern</span></span>
<span data-ttu-id="bfbad-653">Ebben a mintában akkor használja, ha gyakran kell toolook kapcsolódó adatokat.</span><span class="sxs-lookup"><span data-stu-id="bfbad-653">Use this pattern when you frequently need toolook up related information.</span></span> <span data-ttu-id="bfbad-654">Ebben a mintában csökkenti az ügyfél biztosítsa tooretrieve hello adatokat igényel lekérdezések hello száma.</span><span class="sxs-lookup"><span data-stu-id="bfbad-654">This pattern reduces hello number of queries your client must make tooretrieve hello data it requires.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="bfbad-655">Útmutató és a kapcsolódó minták</span><span class="sxs-lookup"><span data-stu-id="bfbad-655">Related patterns and guidance</span></span>
<span data-ttu-id="bfbad-656">hello következő mintákat és útmutatókat is megfelelő ebben a mintában végrehajtása során:</span><span class="sxs-lookup"><span data-stu-id="bfbad-656">hello following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="bfbad-657">Összetett kulcs minta</span><span class="sxs-lookup"><span data-stu-id="bfbad-657">Compound key pattern</span></span>](#compound-key-pattern)  
* [<span data-ttu-id="bfbad-658">Entitás csoport tranzakciók</span><span class="sxs-lookup"><span data-stu-id="bfbad-658">Entity Group Transactions</span></span>](#entity-group-transactions)  
* [<span data-ttu-id="bfbad-659">Heterogén entitástípusok használata</span><span class="sxs-lookup"><span data-stu-id="bfbad-659">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)

### <a name="compound-key-pattern"></a><span data-ttu-id="bfbad-660">Összetett kulcs minta</span><span class="sxs-lookup"><span data-stu-id="bfbad-660">Compound key pattern</span></span>
<span data-ttu-id="bfbad-661">Használjon összetett **RowKey** értékek tooenable egy ügyfél toolookup kapcsolódó adatok egyetlen pont lekérdezéssel.</span><span class="sxs-lookup"><span data-stu-id="bfbad-661">Use compound **RowKey** values tooenable a client toolookup related data with a single point query.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="bfbad-662">A környezetben, és probléma</span><span class="sxs-lookup"><span data-stu-id="bfbad-662">Context and problem</span></span>
<span data-ttu-id="bfbad-663">Egy relációs adatbázisban elég természetes toouse illesztések lekérdezésekben tooreturn kapcsolatos adatok toohello ügyfél egyetlen lekérdezést adatot.</span><span class="sxs-lookup"><span data-stu-id="bfbad-663">In a relational database, it is quite natural toouse joins in queries tooreturn related pieces of data toohello client in a single query.</span></span> <span data-ttu-id="bfbad-664">Például használhatja a hello alkalmazott azonosítója toolook kapcsolódó entitásokból, melyek teljesítményét, és tekintse át az adatokat azt listája.</span><span class="sxs-lookup"><span data-stu-id="bfbad-664">For example, you might use hello employee id toolook up a list of related entities that contain performance and review data for that employee.</span></span>  

<span data-ttu-id="bfbad-665">Tegyük fel, alkalmazott entitások hello Table szolgáltatás a következő struktúra hello segítségével tárolja:</span><span class="sxs-lookup"><span data-stu-id="bfbad-665">Assume you are storing employee entities in hello Table service using hello following structure:</span></span>  

![][18]

<span data-ttu-id="bfbad-666">Szükség toostore előzményadatokat tooreviews vonatkozó és teljesítmény minden év hello alkalmazott működött a szervezet számára, és toobe képes tooaccess évente ezekre az információkra szüksége.</span><span class="sxs-lookup"><span data-stu-id="bfbad-666">You also need toostore historical data relating tooreviews and performance for each year hello employee has worked for your organization and you need toobe able tooaccess this information by year.</span></span> <span data-ttu-id="bfbad-667">Egy beállítás toocreate van egy másik tábla entitások tárolja a struktúra a következő hello:</span><span class="sxs-lookup"><span data-stu-id="bfbad-667">One option is toocreate another table that stores entities with hello following structure:</span></span>  

![][19]

<span data-ttu-id="bfbad-668">Figyelje meg, hogy ennek közelítse meg dönthet tooduplicate egyes információk (például a Keresztnév és Vezetéknév) hello új entitás tooenable meg tooretrieve az adatok egy kérelemhez.</span><span class="sxs-lookup"><span data-stu-id="bfbad-668">Notice that with this approach you may decide tooduplicate some information (such as first name and last name) in hello new entity tooenable you tooretrieve your data with a single request.</span></span> <span data-ttu-id="bfbad-669">Azonban az erős konzisztencia nem fenntartása, mivel egy EGT tooupdate hello két entitás i nem használható.</span><span class="sxs-lookup"><span data-stu-id="bfbad-669">However, you cannot maintain strong consistency because you cannot use an EGT tooupdate hello two entities atomically.</span></span>  

#### <a name="solution"></a><span data-ttu-id="bfbad-670">Megoldás</span><span class="sxs-lookup"><span data-stu-id="bfbad-670">Solution</span></span>
<span data-ttu-id="bfbad-671">Egy új entitástípus tárolása az eredeti entitások használata hello struktúra a következő táblában:</span><span class="sxs-lookup"><span data-stu-id="bfbad-671">Store a new entity type in your original table using entities with hello following structure:</span></span>  

![][20]

<span data-ttu-id="bfbad-672">Figyelje meg, hogyan hello **RowKey** most egy összetett kulcs áll hello alkalmazott- és hello év, amely lehetővé teszi hello felülvizsgálati adatok tooretrieve hello alkalmazott teljesítményét, és ellenőrizze az adatokat egyetlen entitás egyetlen kérelmet tartalmazó.</span><span class="sxs-lookup"><span data-stu-id="bfbad-672">Notice how hello **RowKey** is now a compound key made up of hello employee id and hello year of hello review data that enables you tooretrieve hello employee's performance and review data with a single request for a single entity.</span></span>  

<span data-ttu-id="bfbad-673">hello a következő példa bemutatja, hogyan kérheti le minden hello felülvizsgálati adatokat (például alkalmazott 000123 hello kereskedelmi osztály) egy alkalmazott:</span><span class="sxs-lookup"><span data-stu-id="bfbad-673">hello following example outlines how you can retrieve all hello review data for a particular employee (such as employee 000123 in hello Sales department):</span></span>  

<span data-ttu-id="bfbad-674">$filter = (PartitionKey eq 'Értékesítés') és (RowKey ge "empid_000123") és (RowKey lt "empid_000124") & $select = RowKey, Manager értékelése, társ értékelése, megjegyzések</span><span class="sxs-lookup"><span data-stu-id="bfbad-674">$filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000123') and (RowKey lt 'empid_000124')&$select=RowKey,Manager Rating,Peer Rating,Comments</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="bfbad-675">Problémákat és szempontok</span><span class="sxs-lookup"><span data-stu-id="bfbad-675">Issues and considerations</span></span>
<span data-ttu-id="bfbad-676">Vegye figyelembe a következő pontok meghatározásakor hello hogyan tooimplement ebben a mintában:</span><span class="sxs-lookup"><span data-stu-id="bfbad-676">Consider hello following points when deciding how tooimplement this pattern:</span></span>  

* <span data-ttu-id="bfbad-677">Így könnyen tooparse hello megfelelő elválasztó karaktert kell használnia **RowKey** érték: például **000123_2012**.</span><span class="sxs-lookup"><span data-stu-id="bfbad-677">You should use a suitable separator character that makes it easy tooparse hello **RowKey** value: for example, **000123_2012**.</span></span>  
* <span data-ttu-id="bfbad-678">Ehhez az entitáshoz is tárolja hello megegyezik más személyként hello kapcsolódó adatok tartalmazó partíció ugyanaz az alkalmazott, ami azt jelenti, EGTs toomaintain az erős konzisztencia is használhatja.</span><span class="sxs-lookup"><span data-stu-id="bfbad-678">You are also storing this entity in hello same partition as other entities that contain related data for hello same employee, which means you can use EGTs toomaintain strong consistency.</span></span>
* <span data-ttu-id="bfbad-679">Akkor érdemes megfontolni, hogy milyen gyakran fogja kérdezni hello adatok toodetermine, hogy megfelelő-e ezt a mintát.</span><span class="sxs-lookup"><span data-stu-id="bfbad-679">You should consider how frequently you will query hello data toodetermine whether this pattern is appropriate.</span></span>  <span data-ttu-id="bfbad-680">Például ha éri el ritkán hello tekintse át adatokat, és hello fő alkalmazott adatok gyakran külön entitásokként kell tárolni.</span><span class="sxs-lookup"><span data-stu-id="bfbad-680">For example, if you will access hello review data infrequently and hello main employee data often you should keep them as separate entities.</span></span>  

#### <a name="when-toouse-this-pattern"></a><span data-ttu-id="bfbad-681">Ha toouse ezt a mintát</span><span class="sxs-lookup"><span data-stu-id="bfbad-681">When toouse this pattern</span></span>
<span data-ttu-id="bfbad-682">Ebben a mintában használatára kell toostore egy vagy több kapcsolódó entitások lekérdezett gyakran.</span><span class="sxs-lookup"><span data-stu-id="bfbad-682">Use this pattern when you need toostore one or more related entities that you query frequently.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="bfbad-683">Útmutató és a kapcsolódó minták</span><span class="sxs-lookup"><span data-stu-id="bfbad-683">Related patterns and guidance</span></span>
<span data-ttu-id="bfbad-684">hello következő mintákat és útmutatókat is megfelelő ebben a mintában végrehajtása során:</span><span class="sxs-lookup"><span data-stu-id="bfbad-684">hello following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="bfbad-685">Entitás csoport tranzakciók</span><span class="sxs-lookup"><span data-stu-id="bfbad-685">Entity Group Transactions</span></span>](#entity-group-transactions)  
* [<span data-ttu-id="bfbad-686">Heterogén entitástípusok használata</span><span class="sxs-lookup"><span data-stu-id="bfbad-686">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)  
* [<span data-ttu-id="bfbad-687">Idővel konzisztenssé tranzakciók minta</span><span class="sxs-lookup"><span data-stu-id="bfbad-687">Eventually consistent transactions pattern</span></span>](#eventually-consistent-transactions-pattern)  

### <a name="log-tail-pattern"></a><span data-ttu-id="bfbad-688">Napló végéről minta</span><span class="sxs-lookup"><span data-stu-id="bfbad-688">Log tail pattern</span></span>
<span data-ttu-id="bfbad-689">Hello beolvasása  *n*  entitások legutóbb hozzáadott tooa partíció használatával egy **RowKey** érték, amely fordított dátum és idő sorrendben rendezi.</span><span class="sxs-lookup"><span data-stu-id="bfbad-689">Retrieve hello *n* entities most recently added tooa partition by using a **RowKey** value that sorts in reverse date and time order.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="bfbad-690">A környezetben, és probléma</span><span class="sxs-lookup"><span data-stu-id="bfbad-690">Context and problem</span></span>
<span data-ttu-id="bfbad-691">A közös vonatkozó követelmény akkor kell tudni tooretrieve utoljára létrehozott hello entitások, például hello tíz legújabb kiadás jogcímek az alkalmazottak által küldött.</span><span class="sxs-lookup"><span data-stu-id="bfbad-691">A common requirement is be able tooretrieve hello most recently created entities, for example hello ten most recent expense claims submitted by an employee.</span></span> <span data-ttu-id="bfbad-692">Táblázat a támogatási lekérdezi egy **$top** először lekérdezési művelet tooreturn hello  *n*  egy entitás: nincs egyenértékű lekérdezési művelet tooreturn hello utolsó n entitások van egy.</span><span class="sxs-lookup"><span data-stu-id="bfbad-692">Table queries support a **$top** query operation tooreturn hello first *n* entities from a set: there is no equivalent query operation tooreturn hello last n entities in a set.</span></span>  

#### <a name="solution"></a><span data-ttu-id="bfbad-693">Megoldás</span><span class="sxs-lookup"><span data-stu-id="bfbad-693">Solution</span></span>
<span data-ttu-id="bfbad-694">Tároló hello entitások használatával egy **RowKey** , hogy természetes névkeresési rendezések dátum/idő rendelés használatával, ezért a legutóbbi bejegyzés hello mindig hello hello táblázat első szerkezetével.</span><span class="sxs-lookup"><span data-stu-id="bfbad-694">Store hello entities using a **RowKey** that naturally sorts in reverse date/time order by using so hello most recent entry is always hello first one in hello table.</span></span>  

<span data-ttu-id="bfbad-695">Például toobe képes tooretrieve hello által alkalmazott tíz legújabb kiadás jogcímeket, egy fordított osztásjelek származó értékkel hello aktuális dátum és idő is használhatja.</span><span class="sxs-lookup"><span data-stu-id="bfbad-695">For example, toobe able tooretrieve hello ten most recent expense claims submitted by an employee, you can use a reverse tick value derived from hello current date/time.</span></span> <span data-ttu-id="bfbad-696">hello alábbi C# kódminta látható egyirányú toocreate megfelelő "fordított ticks" értéket egy **RowKey** , hogy a legrégebbi hello legutóbbi toohello rendezi:</span><span class="sxs-lookup"><span data-stu-id="bfbad-696">hello following C# code sample shows one way toocreate a suitable "inverted ticks" value for a **RowKey** that sorts from hello most recent toohello oldest:</span></span>  

`string invertedTicks = string.Format("{0:D19}", DateTime.MaxValue.Ticks - DateTime.UtcNow.Ticks);`  

<span data-ttu-id="bfbad-697">Is vissza toohello dátum idő érték a következő kód hello használata:</span><span class="sxs-lookup"><span data-stu-id="bfbad-697">You can get back toohello date time value using hello following code:</span></span>  

`DateTime dt = new DateTime(DateTime.MaxValue.Ticks - Int64.Parse(invertedTicks));`  

<span data-ttu-id="bfbad-698">hello lekérdezés így néz ki:</span><span class="sxs-lookup"><span data-stu-id="bfbad-698">hello table query looks like this:</span></span>  

`https://myaccount.table.core.windows.net/EmployeeExpense(PartitionKey='empid')?$top=10`  

#### <a name="issues-and-considerations"></a><span data-ttu-id="bfbad-699">Problémákat és szempontok</span><span class="sxs-lookup"><span data-stu-id="bfbad-699">Issues and considerations</span></span>
<span data-ttu-id="bfbad-700">Vegye figyelembe a következő pontok meghatározásakor hello hogyan tooimplement ebben a mintában:</span><span class="sxs-lookup"><span data-stu-id="bfbad-700">Consider hello following points when deciding how tooimplement this pattern:</span></span>  

* <span data-ttu-id="bfbad-701">Kell írni, hello fordított osztásjelek érték nullából vezető tooensure hello karakterláncértéket rendezi a várt módon.</span><span class="sxs-lookup"><span data-stu-id="bfbad-701">You must pad hello reverse tick value with leading zeroes tooensure hello string value sorts as expected.</span></span>  
* <span data-ttu-id="bfbad-702">Hello méretezhetőségi célok partíció hello szinten tisztában kell lennie.</span><span class="sxs-lookup"><span data-stu-id="bfbad-702">You must be aware of hello scalability targets at hello level of a partition.</span></span> <span data-ttu-id="bfbad-703">Legyen óvatos nem interaktív terület partíciókat.</span><span class="sxs-lookup"><span data-stu-id="bfbad-703">Be careful not create hot spot partitions.</span></span>  

#### <a name="when-toouse-this-pattern"></a><span data-ttu-id="bfbad-704">Ha toouse ezt a mintát</span><span class="sxs-lookup"><span data-stu-id="bfbad-704">When toouse this pattern</span></span>
<span data-ttu-id="bfbad-705">Használja ezt a mintát Ha tooaccess entitások fordított dátum/idő sorrendben kell, vagy ha tooaccess hello legutóbb kell entitások hozzá.</span><span class="sxs-lookup"><span data-stu-id="bfbad-705">Use this pattern when you need tooaccess entities in reverse date/time order or when you need tooaccess hello most recently added entities.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="bfbad-706">Útmutató és a kapcsolódó minták</span><span class="sxs-lookup"><span data-stu-id="bfbad-706">Related patterns and guidance</span></span>
<span data-ttu-id="bfbad-707">hello következő mintákat és útmutatókat is megfelelő ebben a mintában végrehajtása során:</span><span class="sxs-lookup"><span data-stu-id="bfbad-707">hello following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="bfbad-708">Illesztenie elleni mintát hozzáfűzése</span><span class="sxs-lookup"><span data-stu-id="bfbad-708">Prepend / append anti-pattern</span></span>](#prepend-append-anti-pattern)  
* [<span data-ttu-id="bfbad-709">Entitások beolvasása</span><span class="sxs-lookup"><span data-stu-id="bfbad-709">Retrieving entities</span></span>](#retrieving-entities)  

### <a name="high-volume-delete-pattern"></a><span data-ttu-id="bfbad-710">Nagy mennyiségű delete minta</span><span class="sxs-lookup"><span data-stu-id="bfbad-710">High volume delete pattern</span></span>
<span data-ttu-id="bfbad-711">A saját külön táblázatban szereplő összes hello entitás egyidejű törlésre elhelyezésével nagyszámú entitások hello törlésének engedélyezése hello entitások hello tábla törlésével törli.</span><span class="sxs-lookup"><span data-stu-id="bfbad-711">Enable hello deletion of a high volume of entities by storing all hello entities for simultaneous deletion in their own separate table; you delete hello entities by deleting hello table.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="bfbad-712">A környezetben, és probléma</span><span class="sxs-lookup"><span data-stu-id="bfbad-712">Context and problem</span></span>
<span data-ttu-id="bfbad-713">Számos alkalmazás törölje a régi adatokat, amelyek már nincs szüksége a toobe elérhető tooa ügyfélalkalmazást, vagy hello alkalmazás rendelkezik archivált tooanother adathordozóra.</span><span class="sxs-lookup"><span data-stu-id="bfbad-713">Many applications delete old data which no longer needs toobe available tooa client application, or that hello application has archived tooanother storage medium.</span></span> <span data-ttu-id="bfbad-714">Általában azonosíthatja az ilyen adatokat a dátum: például, hogy egy követelmény toodelete rögzíti, amelyek több mint 60 napos bejelentkezési kérelmek.</span><span class="sxs-lookup"><span data-stu-id="bfbad-714">You typically identify such data by a date: for example, you have a requirement toodelete records of all login requests that are more than 60 days old.</span></span>  

<span data-ttu-id="bfbad-715">Egy lehetséges tervezési toouse hello dátuma és időpontja hello bejelentkezési kérelem hello **RowKey**:</span><span class="sxs-lookup"><span data-stu-id="bfbad-715">One possible design is toouse hello date and time of hello login request in hello **RowKey**:</span></span>  

![][21]

<span data-ttu-id="bfbad-716">Ez a megközelítés partíció elérési pontokhoz való elkerülhető, mert hello alkalmazás beszúrása, és minden felhasználóhoz külön partícióra bejelentkezési entitások törlésére.</span><span class="sxs-lookup"><span data-stu-id="bfbad-716">This approach avoids partition hotspots because hello application can insert and delete login entities for each user in a separate partition.</span></span> <span data-ttu-id="bfbad-717">Azonban előfordulhat, hogy ez a megközelítés költséges és sok időt vesz igénybe Ha sok entitást mivel tooperform először egy tábla vizsgálata a rendelés tooidentify összes hello entitások toodelete, és törölnie kell minden egyes régi entitás.</span><span class="sxs-lookup"><span data-stu-id="bfbad-717">However, this approach may be costly and time consuming if you have a large number of entities because first you need tooperform a table scan in order tooidentify all hello entities toodelete, and then you must delete each old entity.</span></span> <span data-ttu-id="bfbad-718">Vegye figyelembe, hogy csökkentheti hello adatváltások toohello szükséges kiszolgáló toodelete hello régi entitások száma több törlési kérelmek kötegelés EGTs be.</span><span class="sxs-lookup"><span data-stu-id="bfbad-718">Note that you can reduce hello number of round trips toohello server required toodelete hello old entities by batching multiple delete requests into EGTs.</span></span>  

#### <a name="solution"></a><span data-ttu-id="bfbad-719">Megoldás</span><span class="sxs-lookup"><span data-stu-id="bfbad-719">Solution</span></span>
<span data-ttu-id="bfbad-720">Egy külön táblázattal minden nap a bejelentkezési kísérletek.</span><span class="sxs-lookup"><span data-stu-id="bfbad-720">Use a separate table for each day of login attempts.</span></span> <span data-ttu-id="bfbad-721">Használhatja a hello entitás tervezési fent tooavoid elérési pontokhoz való beszúrt entitásokat, és most már egyszerűen törlése egy tábla minden nap adott esetben régi entitások törlése (egyetlen tárhelyművelettel) keresése és több száz és több ezer törlése helyett Egyéni bejelentkezési entitások minden nap.</span><span class="sxs-lookup"><span data-stu-id="bfbad-721">You can use hello entity design above tooavoid hotspots when you are inserting entities, and deleting old entities is now simply a question of deleting one table every day (a single storage operation) instead of finding and deleting hundreds and thousands of individual login entities every day.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="bfbad-722">Problémákat és szempontok</span><span class="sxs-lookup"><span data-stu-id="bfbad-722">Issues and considerations</span></span>
<span data-ttu-id="bfbad-723">Vegye figyelembe a következő pontok meghatározásakor hello hogyan tooimplement ebben a mintában:</span><span class="sxs-lookup"><span data-stu-id="bfbad-723">Consider hello following points when deciding how tooimplement this pattern:</span></span>  

* <span data-ttu-id="bfbad-724">Támogatja a Tervező más módszereket, az alkalmazás fogja hello adatok, például az adott entitások kapcsolódik-e más adatok, vagy előállítása összesített adatát keresésekor?</span><span class="sxs-lookup"><span data-stu-id="bfbad-724">Does your design support other ways your application will use hello data such as looking up specific entities, linking with other data, or generating aggregate information?</span></span>  
* <span data-ttu-id="bfbad-725">Nem a Tervező elkerülése interaktív területek új entitások beszúráskor?</span><span class="sxs-lookup"><span data-stu-id="bfbad-725">Does your design avoid hot spots when you are inserting new entities?</span></span>  
* <span data-ttu-id="bfbad-726">A késleltetés, ha azt szeretné, hogy tooreuse hello azonos várt azt törlését követően a tábla neve.</span><span class="sxs-lookup"><span data-stu-id="bfbad-726">Expect a delay if you want tooreuse hello same table name after deleting it.</span></span> <span data-ttu-id="bfbad-727">Jobb tooalways használjon egyedi tábla neve is.</span><span class="sxs-lookup"><span data-stu-id="bfbad-727">It's better tooalways use unique table names.</span></span>  
* <span data-ttu-id="bfbad-728">Várt néhány szabályozás első használata alkalmával érdemes egy új tábla hello Table szolgáltatás hello hozzáférési minták megtanulja, és hello partíciók elosztja a csomópontok között.</span><span class="sxs-lookup"><span data-stu-id="bfbad-728">Expect some throttling when you first use a new table while hello Table service learns hello access patterns and distributes hello partitions across nodes.</span></span> <span data-ttu-id="bfbad-729">Meg kell figyelembe vennie, milyen gyakran toocreate új táblákat.</span><span class="sxs-lookup"><span data-stu-id="bfbad-729">You should consider how frequently you need toocreate new tables.</span></span>  

#### <a name="when-toouse-this-pattern"></a><span data-ttu-id="bfbad-730">Ha toouse ezt a mintát</span><span class="sxs-lookup"><span data-stu-id="bfbad-730">When toouse this pattern</span></span>
<span data-ttu-id="bfbad-731">Ebben a mintában használni, ha nagyszámú törölnie kell a hello entitások ugyanannyi időt vesz igénybe.</span><span class="sxs-lookup"><span data-stu-id="bfbad-731">Use this pattern when you have a high volume of entities that you must delete at hello same time.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="bfbad-732">Útmutató és a kapcsolódó minták</span><span class="sxs-lookup"><span data-stu-id="bfbad-732">Related patterns and guidance</span></span>
<span data-ttu-id="bfbad-733">hello következő mintákat és útmutatókat is megfelelő ebben a mintában végrehajtása során:</span><span class="sxs-lookup"><span data-stu-id="bfbad-733">hello following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="bfbad-734">Entitás csoport tranzakciók</span><span class="sxs-lookup"><span data-stu-id="bfbad-734">Entity Group Transactions</span></span>](#entity-group-transactions)
* [<span data-ttu-id="bfbad-735">Entitások módosítása</span><span class="sxs-lookup"><span data-stu-id="bfbad-735">Modifying entities</span></span>](#modifying-entities)  

### <a name="data-series-pattern"></a><span data-ttu-id="bfbad-736">Adatsorozat adatmintát</span><span class="sxs-lookup"><span data-stu-id="bfbad-736">Data series pattern</span></span>
<span data-ttu-id="bfbad-737">Tároló teljes adatsorok egy egyetlen entitás toominimize hello kérelemszámot elvégezte.</span><span class="sxs-lookup"><span data-stu-id="bfbad-737">Store complete data series in a single entity toominimize hello number of requests you make.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="bfbad-738">A környezetben, és probléma</span><span class="sxs-lookup"><span data-stu-id="bfbad-738">Context and problem</span></span>
<span data-ttu-id="bfbad-739">Egy általános forgatókönyv egy alkalmazás toostore adatokat, hogy általában tooretrieve egyszerre több.</span><span class="sxs-lookup"><span data-stu-id="bfbad-739">A common scenario is for an application toostore a series of data that it typically needs tooretrieve all at once.</span></span> <span data-ttu-id="bfbad-740">Például az alkalmazás előfordulhat, hogy minden alkalmazott óránként küld hány Csevegési üzeneteket rögzíti, és aztán a információk tooplot minden felhasználó keresztül küldött üzenetek számának hello előző 24 óra.</span><span class="sxs-lookup"><span data-stu-id="bfbad-740">For example, your application might record how many IM messages each employee sends every hour, and then use this information tooplot how many messages each user sent over hello preceding 24 hours.</span></span> <span data-ttu-id="bfbad-741">Lehet, hogy egy Tervező toostore 24 entitások minden alkalmazott számára:</span><span class="sxs-lookup"><span data-stu-id="bfbad-741">One design might be toostore 24 entities for each employee:</span></span>  

![][22]

<span data-ttu-id="bfbad-742">Ezzel a kialakítással egyszerűen keresse meg és hello entitás tooupdate hello alkalmazásnak kell tooupdate hello üzenet számérték minden alkalmazott frissítésére.</span><span class="sxs-lookup"><span data-stu-id="bfbad-742">With this design, you can easily locate and update hello entity tooupdate for each employee whenever hello application needs tooupdate hello message count value.</span></span> <span data-ttu-id="bfbad-743">Azonban tooretrieve hello információk tooplot előző 24 óra hello hello tevékenységét diagramot, 24 entitások be kell olvasni.</span><span class="sxs-lookup"><span data-stu-id="bfbad-743">However, tooretrieve hello information tooplot a chart of hello activity for hello preceding 24 hours, you must retrieve 24 entities.</span></span>  

#### <a name="solution"></a><span data-ttu-id="bfbad-744">Megoldás</span><span class="sxs-lookup"><span data-stu-id="bfbad-744">Solution</span></span>
<span data-ttu-id="bfbad-745">Tervezési egy külön tulajdonság toostore hello üzenetek száma a következő minden hello használata:</span><span class="sxs-lookup"><span data-stu-id="bfbad-745">Use hello following design with a separate property toostore hello message count for each hour:</span></span>  

![][23]

<span data-ttu-id="bfbad-746">Ezzel a kialakítással használható egy merge művelet tooupdate hello üzenetek száma egy alkalmazott egy adott egy óra.</span><span class="sxs-lookup"><span data-stu-id="bfbad-746">With this design, you can use a merge operation tooupdate hello message count for an employee for a specific hour.</span></span> <span data-ttu-id="bfbad-747">Most tooplot hello diagram kérelmet használatával egyetlen entitás szükséges összes hello információkat kérheti le.</span><span class="sxs-lookup"><span data-stu-id="bfbad-747">Now, you can retrieve all hello information you need tooplot hello chart using a request for a single entity.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="bfbad-748">Problémákat és szempontok</span><span class="sxs-lookup"><span data-stu-id="bfbad-748">Issues and considerations</span></span>
<span data-ttu-id="bfbad-749">Vegye figyelembe a következő pontok meghatározásakor hello hogyan tooimplement ebben a mintában:</span><span class="sxs-lookup"><span data-stu-id="bfbad-749">Consider hello following points when deciding how tooimplement this pattern:</span></span>  

* <span data-ttu-id="bfbad-750">Ha a teljes adatsor nem fér el egyetlen entitás (a egy entitás legfeljebb too252 tulajdonságok tartalmazhat), például blob alternatív adattár használata.</span><span class="sxs-lookup"><span data-stu-id="bfbad-750">If your complete data series does not fit into a single entity (an entity can have up too252 properties), use an alternative data store such as a blob.</span></span>  
* <span data-ttu-id="bfbad-751">Ha egy entitás frissítése egyszerre több ügyfélnek, szüksége lesz a toouse hello **ETag** tooimplement egyidejű hozzáférések optimista.</span><span class="sxs-lookup"><span data-stu-id="bfbad-751">If you have multiple clients updating an entity simultaneously, you will need toouse hello **ETag** tooimplement optimistic concurrency.</span></span> <span data-ttu-id="bfbad-752">Ha sok ügyfél, magas versengés tapasztalhatja.</span><span class="sxs-lookup"><span data-stu-id="bfbad-752">If you have many clients, you may experience high contention.</span></span>  

#### <a name="when-toouse-this-pattern"></a><span data-ttu-id="bfbad-753">Ha toouse ezt a mintát</span><span class="sxs-lookup"><span data-stu-id="bfbad-753">When toouse this pattern</span></span>
<span data-ttu-id="bfbad-754">Használja ezt a mintát, ha a tooupdate kell, és az egyes entitáshoz kapcsolódó adatsor beolvasása.</span><span class="sxs-lookup"><span data-stu-id="bfbad-754">Use this pattern when you need tooupdate and retrieve a data series associated with an individual entity.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="bfbad-755">Útmutató és a kapcsolódó minták</span><span class="sxs-lookup"><span data-stu-id="bfbad-755">Related patterns and guidance</span></span>
<span data-ttu-id="bfbad-756">hello következő mintákat és útmutatókat is megfelelő ebben a mintában végrehajtása során:</span><span class="sxs-lookup"><span data-stu-id="bfbad-756">hello following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="bfbad-757">Nagy entitások minta</span><span class="sxs-lookup"><span data-stu-id="bfbad-757">Large entities pattern</span></span>](#large-entities-pattern)  
* [<span data-ttu-id="bfbad-758">Egyesítés vagy cseréje</span><span class="sxs-lookup"><span data-stu-id="bfbad-758">Merge or replace</span></span>](#merge-or-replace)  
* <span data-ttu-id="bfbad-759">[Idővel konzisztenssé tranzakciók mintát](#eventually-consistent-transactions-pattern) (ha tárolja hello adatsorozat blob)</span><span class="sxs-lookup"><span data-stu-id="bfbad-759">[Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) (if you are storing hello data series in a blob)</span></span>  

### <a name="wide-entities-pattern"></a><span data-ttu-id="bfbad-760">Széles entitások minta</span><span class="sxs-lookup"><span data-stu-id="bfbad-760">Wide entities pattern</span></span>
<span data-ttu-id="bfbad-761">Több fizikai entitások toostore logikai entitás legfeljebb 252 tulajdonságot használja.</span><span class="sxs-lookup"><span data-stu-id="bfbad-761">Use multiple physical entities toostore logical entities with more than 252 properties.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="bfbad-762">A környezetben, és probléma</span><span class="sxs-lookup"><span data-stu-id="bfbad-762">Context and problem</span></span>
<span data-ttu-id="bfbad-763">Egyes entitás legfeljebb 252 tulajdonságot (kivéve a hello kötelező Rendszertulajdonságok) állhat, és nem 1 MB-nál több adat tárolása összesen.</span><span class="sxs-lookup"><span data-stu-id="bfbad-763">An individual entity can have no more than 252 properties (excluding hello mandatory system properties) and cannot store more than 1 MB of data in total.</span></span> <span data-ttu-id="bfbad-764">Egy relációs adatbázisban általában számíthat round bármely sor mérete hello vonatkozó korlátozások hozzáadása egy új tábla és a közöttük 1-1 kapcsolatot.</span><span class="sxs-lookup"><span data-stu-id="bfbad-764">In a relational database, you would typically get round any limits on hello size of a row by adding a new table and enforcing a 1-to-1 relationship between them.</span></span>  

#### <a name="solution"></a><span data-ttu-id="bfbad-765">Megoldás</span><span class="sxs-lookup"><span data-stu-id="bfbad-765">Solution</span></span>
<span data-ttu-id="bfbad-766">Hello Table szolgáltatás használ, több entitások toorepresent legfeljebb 252 tulajdonságot az egyetlen nagy üzleti objektumot is tárolhatók.</span><span class="sxs-lookup"><span data-stu-id="bfbad-766">Using hello Table service, you can store multiple entities toorepresent a single large business object with more than 252 properties.</span></span> <span data-ttu-id="bfbad-767">Például ha azt szeretné, hogy toostore hello IM üzenetek száma küld minden alkalmazott hello az elmúlt 365 napban számát, a következő kialakítás ezért más sémák használ, két olyan entitásra hello használhatja:</span><span class="sxs-lookup"><span data-stu-id="bfbad-767">For example, if you want toostore a count of hello number of IM messages sent by each employee for hello last 365 days, you could use hello following design that uses two entities with different schemas:</span></span>  

![][24]

<span data-ttu-id="bfbad-768">Ha van szüksége, amely mindkét entitások tookeep őket szinkronizálja egymással frissíteni kell az toomake egy EGT is használhatja.</span><span class="sxs-lookup"><span data-stu-id="bfbad-768">If you need toomake a change that requires updating both entities tookeep them synchronized with each other you can use an EGT.</span></span> <span data-ttu-id="bfbad-769">Ellenkező esetben egy adott napon egy egyetlen egyesítési művelet tooupdate hello üzenetek száma is használhatja.</span><span class="sxs-lookup"><span data-stu-id="bfbad-769">Otherwise, you can use a single merge operation tooupdate hello message count for a specific day.</span></span> <span data-ttu-id="bfbad-770">be kell olvasni mindkét entitások, amely egyaránt két hatékony kérelmek teheti adott alkalmazott összes hello adatok tooretrieve egy **PartitionKey** és egy **RowKey** érték.</span><span class="sxs-lookup"><span data-stu-id="bfbad-770">tooretrieve all hello data for an individual employee you must retrieve both entities, which you can do with two efficient requests that use both a **PartitionKey** and a **RowKey** value.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="bfbad-771">Problémákat és szempontok</span><span class="sxs-lookup"><span data-stu-id="bfbad-771">Issues and considerations</span></span>
<span data-ttu-id="bfbad-772">Vegye figyelembe a következő pontok meghatározásakor hello hogyan tooimplement ebben a mintában:</span><span class="sxs-lookup"><span data-stu-id="bfbad-772">Consider hello following points when deciding how tooimplement this pattern:</span></span>  

* <span data-ttu-id="bfbad-773">A teljes logikai entitás beolvasásakor magában foglalja a legalább két storage-tranzakció: egy tooretrieve fizikai entitás.</span><span class="sxs-lookup"><span data-stu-id="bfbad-773">Retrieving a complete logical entity involves at least two storage transactions: one tooretrieve each physical entity.</span></span>  

#### <a name="when-toouse-this-pattern"></a><span data-ttu-id="bfbad-774">Ha toouse ezt a mintát</span><span class="sxs-lookup"><span data-stu-id="bfbad-774">When toouse this pattern</span></span>
<span data-ttu-id="bfbad-775">Használja ezt a mintát, ha a szükséges toostore entitások, amelynek méretét vagy a tulajdonságok száma meghaladja a hello korlátok hello található egyes entitás Table szolgáltatás.</span><span class="sxs-lookup"><span data-stu-id="bfbad-775">Use this pattern when  need toostore entities whose size or number of properties exceeds hello limits for an individual entity in hello Table service.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="bfbad-776">Útmutató és a kapcsolódó minták</span><span class="sxs-lookup"><span data-stu-id="bfbad-776">Related patterns and guidance</span></span>
<span data-ttu-id="bfbad-777">hello következő mintákat és útmutatókat is megfelelő ebben a mintában végrehajtása során:</span><span class="sxs-lookup"><span data-stu-id="bfbad-777">hello following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="bfbad-778">Entitás csoport tranzakciók</span><span class="sxs-lookup"><span data-stu-id="bfbad-778">Entity Group Transactions</span></span>](#entity-group-transactions)
* [<span data-ttu-id="bfbad-779">Egyesítés vagy cseréje</span><span class="sxs-lookup"><span data-stu-id="bfbad-779">Merge or replace</span></span>](#merge-or-replace)

### <a name="large-entities-pattern"></a><span data-ttu-id="bfbad-780">Nagy entitások minta</span><span class="sxs-lookup"><span data-stu-id="bfbad-780">Large entities pattern</span></span>
<span data-ttu-id="bfbad-781">A blob storage toostore nagy tulajdonságértékek használja.</span><span class="sxs-lookup"><span data-stu-id="bfbad-781">Use blob storage toostore large property values.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="bfbad-782">A környezetben, és probléma</span><span class="sxs-lookup"><span data-stu-id="bfbad-782">Context and problem</span></span>
<span data-ttu-id="bfbad-783">Egyes entitás nem 1 MB-nál több adat tárolása összesen.</span><span class="sxs-lookup"><span data-stu-id="bfbad-783">An individual entity cannot store more than 1 MB of data in total.</span></span> <span data-ttu-id="bfbad-784">Ha egy vagy több, a tulajdonság tárolja az értékeket, amelyeket az entitás tooexceed hello teljes mérete okozza ezt az értéket, a Table szolgáltatás hello hello teljes entitás nem tárolhat.</span><span class="sxs-lookup"><span data-stu-id="bfbad-784">If one or several of your properties store values that cause hello total size of your entity tooexceed this value, you cannot store hello entire entity in hello Table service.</span></span>  

#### <a name="solution"></a><span data-ttu-id="bfbad-785">Megoldás</span><span class="sxs-lookup"><span data-stu-id="bfbad-785">Solution</span></span>
<span data-ttu-id="bfbad-786">Az entitás meghaladja mérete 1 MB, mert egy vagy több tulajdonságának nagy mennyiségű adatot tartalmaz, ha a Blob szolgáltatás hello tárolják az adatokat és tárolására is használható majd hello blob hello címe hello entitásban tulajdonsággal.</span><span class="sxs-lookup"><span data-stu-id="bfbad-786">If your entity exceeds 1 MB in size because one or more properties contain a large amount of data, you can store data in hello Blob service and then store hello address of hello blob in a property in hello entity.</span></span> <span data-ttu-id="bfbad-787">Például egy alkalmazott hello fénykép tárolni a blob Storage tárolóban, és hivatkozás toohello fénykép tárolása hello **fénykép** tulajdonság az alkalmazott entitás:</span><span class="sxs-lookup"><span data-stu-id="bfbad-787">For example, you can store hello photo of an employee in blob storage and store a link toohello photo in hello **Photo** property of your employee entity:</span></span>  

![][25]

#### <a name="issues-and-considerations"></a><span data-ttu-id="bfbad-788">Problémákat és szempontok</span><span class="sxs-lookup"><span data-stu-id="bfbad-788">Issues and considerations</span></span>
<span data-ttu-id="bfbad-789">Vegye figyelembe a következő pontok meghatározásakor hello hogyan tooimplement ebben a mintában:</span><span class="sxs-lookup"><span data-stu-id="bfbad-789">Consider hello following points when deciding how tooimplement this pattern:</span></span>  

* <span data-ttu-id="bfbad-790">hello adatok hello Blob szolgáltatás, és a Table szolgáltatás hello hello entitás közötti toomaintain a végleges konzisztencia hello használata [idővel konzisztenssé tranzakciók mintát](#eventually-consistent-transactions-pattern) toomaintain az entitások.</span><span class="sxs-lookup"><span data-stu-id="bfbad-790">toomaintain eventual consistency between hello entity in hello Table service and hello data in hello Blob service, use hello [Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) toomaintain your entities.</span></span>
* <span data-ttu-id="bfbad-791">Legalább két storage-tranzakció teljes entitásnak beolvasása foglalja magában: egy tooretrieve hello entitás és egy tooretrieve hello blob-adatokat.</span><span class="sxs-lookup"><span data-stu-id="bfbad-791">Retrieving a complete entity involves at least two storage transactions: one tooretrieve hello entity and one tooretrieve hello blob data.</span></span>  

#### <a name="when-toouse-this-pattern"></a><span data-ttu-id="bfbad-792">Ha toouse ezt a mintát</span><span class="sxs-lookup"><span data-stu-id="bfbad-792">When toouse this pattern</span></span>
<span data-ttu-id="bfbad-793">Használja ezt a mintát, ha a toostore entitások, amelyek mérete meghaladja a hello korlátok hello Table szolgáltatás található egyes entitás van szüksége.</span><span class="sxs-lookup"><span data-stu-id="bfbad-793">Use this pattern when you need toostore entities whose size exceeds hello limits for an individual entity in hello Table service.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="bfbad-794">Útmutató és a kapcsolódó minták</span><span class="sxs-lookup"><span data-stu-id="bfbad-794">Related patterns and guidance</span></span>
<span data-ttu-id="bfbad-795">hello következő mintákat és útmutatókat is megfelelő ebben a mintában végrehajtása során:</span><span class="sxs-lookup"><span data-stu-id="bfbad-795">hello following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="bfbad-796">Idővel konzisztenssé tranzakciók minta</span><span class="sxs-lookup"><span data-stu-id="bfbad-796">Eventually consistent transactions pattern</span></span>](#eventually-consistent-transactions-pattern)  
* [<span data-ttu-id="bfbad-797">Széles entitások minta</span><span class="sxs-lookup"><span data-stu-id="bfbad-797">Wide entities pattern</span></span>](#wide-entities-pattern)

<a name="prepend-append-anti-pattern"></a>

### <a name="prependappend-anti-pattern"></a><span data-ttu-id="bfbad-798">Víruskereső mintát illesztenie hozzáfűzése</span><span class="sxs-lookup"><span data-stu-id="bfbad-798">Prepend/append anti-pattern</span></span>
<span data-ttu-id="bfbad-799">Méretezhetőség javítása, ha nagyszámú Beszúrások által hello Beszúrások több partíciót keresztül terjednek.</span><span class="sxs-lookup"><span data-stu-id="bfbad-799">Increase scalability when you have a high volume of inserts by spreading hello inserts across multiple partitions.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="bfbad-800">A környezetben, és probléma</span><span class="sxs-lookup"><span data-stu-id="bfbad-800">Context and problem</span></span>
<span data-ttu-id="bfbad-801">Fertőző vagy entitások tooyour tárolt entitásokat általában fűznek eredményezi hello alkalmazás új entitások toohello először hozzáadásával vagy a partíciók több partíció utolsó.</span><span class="sxs-lookup"><span data-stu-id="bfbad-801">Prepending or appending entities tooyour stored entities typically results in hello application adding new entities toohello first or last partition of a sequence of partitions.</span></span> <span data-ttu-id="bfbad-802">Ebben az esetben hello beszúrása egy adott időpontban mind a hello létrehozása, amely megakadályozza, hogy a table szolgáltatás hello terheléselosztás interaktív terület partícióra beszúrása több csomópont között zajló, és ami miatt a kérelem toohit hello méretezhetőség célok partíció.</span><span class="sxs-lookup"><span data-stu-id="bfbad-802">In this case, all of hello inserts at any given time are taking place in hello same partition, creating a hotspot that prevents hello table service from load balancing inserts across multiple nodes, and possibly causing your application toohit hello scalability targets for partition.</span></span> <span data-ttu-id="bfbad-803">Például ha egy alkalmazásnál naplók hálózati és az erőforrás elérhető alkalmazottai, majd egy entitás struktúra alább látható módon eredményezhet hello jelenlegi órán partíció egy interaktív terület váljon, ha hello tranzakciók mennyisége eléri hello méretezhetőség célja az egyes partíció:</span><span class="sxs-lookup"><span data-stu-id="bfbad-803">For example, if you have an application that logs network and resource access by employees, then an entity structure as shown below could result in hello current hour's partition becoming a hotspot if hello volume of transactions reaches hello scalability target for an individual partition:</span></span>  

![][26]

#### <a name="solution"></a><span data-ttu-id="bfbad-804">Megoldás</span><span class="sxs-lookup"><span data-stu-id="bfbad-804">Solution</span></span>
<span data-ttu-id="bfbad-805">hello következő alternatív entitás struktúra elkerülhető bármely adott partíció interaktív terület hello alkalmazás naplók eseményként is:</span><span class="sxs-lookup"><span data-stu-id="bfbad-805">hello following alternative entity structure avoids a hotspot on any particular partition as hello application logs events:</span></span>  

![][27]

<span data-ttu-id="bfbad-806">Az ebben a példában láthatja, hogyan mindkét hello **PartitionKey** és **RowKey** összetett kulcs.</span><span class="sxs-lookup"><span data-stu-id="bfbad-806">Notice with this example how both hello **PartitionKey** and **RowKey** are compound keys.</span></span> <span data-ttu-id="bfbad-807">Hello **PartitionKey** használ hello részleg és az alkalmazott azonosítója toodistribute hello naplózási egyszerre több partíciót.</span><span class="sxs-lookup"><span data-stu-id="bfbad-807">hello **PartitionKey** uses both hello department and employee id toodistribute hello logging across multiple partitions.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="bfbad-808">Problémákat és szempontok</span><span class="sxs-lookup"><span data-stu-id="bfbad-808">Issues and considerations</span></span>
<span data-ttu-id="bfbad-809">Vegye figyelembe a következő pontok meghatározásakor hello hogyan tooimplement ebben a mintában:</span><span class="sxs-lookup"><span data-stu-id="bfbad-809">Consider hello following points when deciding how tooimplement this pattern:</span></span>  

* <span data-ttu-id="bfbad-810">Biztosítja hello alternatív struktúra, amellyel elkerülhető a gyakran használt adatok partíciók beszúrása a hatékony támogatási hello lekérdezések létrehozásáról az ügyfélalkalmazást lesz?</span><span class="sxs-lookup"><span data-stu-id="bfbad-810">Does hello alternative key structure that avoids creating hot partitions on inserts efficiently support hello queries your client application makes?</span></span>  
* <span data-ttu-id="bfbad-811">A tranzakciók várható mennyisége azt jelenti, hogy valószínűleg tooreach hello méretezhetőségi célok az egyes partíciók és hello tároló szolgáltatás által szabályozott kell?</span><span class="sxs-lookup"><span data-stu-id="bfbad-811">Does your anticipated volume of transactions mean that you are likely tooreach hello scalability targets for an individual partition and be throttled by hello storage service?</span></span>  

#### <a name="when-toouse-this-pattern"></a><span data-ttu-id="bfbad-812">Ha toouse ezt a mintát</span><span class="sxs-lookup"><span data-stu-id="bfbad-812">When toouse this pattern</span></span>
<span data-ttu-id="bfbad-813">A tranzakciók mennyisége esetén a sávszélesség-szabályozás hello tároló szolgáltatás által a gyakran használt adatok partíció elérésekor valószínűleg tooresult, ne hello illesztenie hozzáfűzése elleni mintát.</span><span class="sxs-lookup"><span data-stu-id="bfbad-813">Avoid hello prepend/append anti-pattern when your volume of transactions is likely tooresult in throttling by hello storage service when you access a hot partition.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="bfbad-814">Útmutató és a kapcsolódó minták</span><span class="sxs-lookup"><span data-stu-id="bfbad-814">Related patterns and guidance</span></span>
<span data-ttu-id="bfbad-815">hello következő mintákat és útmutatókat is megfelelő ebben a mintában végrehajtása során:</span><span class="sxs-lookup"><span data-stu-id="bfbad-815">hello following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="bfbad-816">Összetett kulcs minta</span><span class="sxs-lookup"><span data-stu-id="bfbad-816">Compound key pattern</span></span>](#compound-key-pattern)  
* [<span data-ttu-id="bfbad-817">Napló végéről minta</span><span class="sxs-lookup"><span data-stu-id="bfbad-817">Log tail pattern</span></span>](#log-tail-pattern)  
* [<span data-ttu-id="bfbad-818">Entitások módosítása</span><span class="sxs-lookup"><span data-stu-id="bfbad-818">Modifying entities</span></span>](#modifying-entities)  

### <a name="log-data-anti-pattern"></a><span data-ttu-id="bfbad-819">Napló elleni adatmintát</span><span class="sxs-lookup"><span data-stu-id="bfbad-819">Log data anti-pattern</span></span>
<span data-ttu-id="bfbad-820">Hello Blob szolgáltatás általában helyett hello tábla toostore Szolgáltatásnapló-adatait kell használni.</span><span class="sxs-lookup"><span data-stu-id="bfbad-820">Typically, you should use hello Blob service instead of hello Table service toostore log data.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="bfbad-821">A környezetben, és probléma</span><span class="sxs-lookup"><span data-stu-id="bfbad-821">Context and problem</span></span>
<span data-ttu-id="bfbad-822">Egy közös használati eset, a naplóadatok tooretrieve a kijelölt naplóbejegyzések adott dátum/idő köre: például azt szeretné, hogy az összes hiba és a kritikus üzeneteihez, az alkalmazás a rendszer 15:04 és 15:06 egy adott dátumon közötti hello toofind.</span><span class="sxs-lookup"><span data-stu-id="bfbad-822">A common use case for log data is tooretrieve a selection of log entries for a specific date/time range: for example, you want toofind all hello error and critical messages that your application logged between 15:04 and 15:06 on a specific date.</span></span> <span data-ttu-id="bfbad-823">Nem szeretné, hogy toouse hello dátum és idő hello napló üzenet toodetermine hello partíció napló entitásokat mentése:, hogy a működés közbeni partíció eredményez, mert az adott időpontban hello napló entitásokhoz aliashoz hello azonos **PartitionKey** érték (hello című [elleni mintát Prepend hozzáfűzése](#prepend-append-anti-pattern)).</span><span class="sxs-lookup"><span data-stu-id="bfbad-823">You do not want toouse hello date and time of hello log message toodetermine hello partition you save log entities to: that results in a hot partition because at any given time, all hello log entities will share hello same **PartitionKey** value (see hello section [Prepend/append anti-pattern](#prepend-append-anti-pattern)).</span></span> <span data-ttu-id="bfbad-824">Például a következő entitás sémája egy naplófájlüzenetre hello okozza, a működés közbeni partíció hello alkalmazás írja az összes naplóüzenetek toohello partíció az aktuális dátumot és az óra hello:</span><span class="sxs-lookup"><span data-stu-id="bfbad-824">For example, hello following entity schema for a log message results in a hot partition because hello application writes all log messages toohello partition for hello current date and hour:</span></span>  

![][28]

<span data-ttu-id="bfbad-825">Ebben a példában hello **RowKey** tartalmazza hello dátuma és időpontja hello napló üzenet tooensure, hogy naplóüzenetek kell tárolni, dátum/idő sorrendbe rendezve, és egy üzenetazonosítója abban az esetben, ha több naplóüzenetek megosztása hello azonos dátum és idő.</span><span class="sxs-lookup"><span data-stu-id="bfbad-825">In this example, hello **RowKey** includes hello date and time of hello log message tooensure that log messages are stored sorted in date/time order, and includes a message id in case multiple log messages share hello same date and time.</span></span>  

<span data-ttu-id="bfbad-826">Egy másik megoldás, toouse egy **PartitionKey** , amely biztosítja, hogy hello alkalmazás írja az üzenetek között számos különböző partíciókat.</span><span class="sxs-lookup"><span data-stu-id="bfbad-826">Another approach is toouse a **PartitionKey** that ensures that hello application writes messages across a range of partitions.</span></span> <span data-ttu-id="bfbad-827">Például hello forrás hello naplóüzenet lehetővé teszi az olyan módon toodistribute üzenetek sok partíciót, használhatja a következő entitás séma hello:</span><span class="sxs-lookup"><span data-stu-id="bfbad-827">For example, if hello source of hello log message provides a way toodistribute messages across many partitions, you could use hello following entity schema:</span></span>  

![][29]

<span data-ttu-id="bfbad-828">Ebben a sémában hello probléma azonban, hogy az összes naplózott üzeneteket az adott időtartama kell megkeresni hello tooretrieve minden partíció hello táblában.</span><span class="sxs-lookup"><span data-stu-id="bfbad-828">However, hello problem with this schema is that tooretrieve all hello log messages for a specific time span you must search every partition in hello table.</span></span>

#### <a name="solution"></a><span data-ttu-id="bfbad-829">Megoldás</span><span class="sxs-lookup"><span data-stu-id="bfbad-829">Solution</span></span>
<span data-ttu-id="bfbad-830">hello előző szakasz kiemelt hello probléma toouse közben a Table szolgáltatás toostore naplóbejegyzések hello és javasolt két, nem megfelelő, tervez.</span><span class="sxs-lookup"><span data-stu-id="bfbad-830">hello previous section highlighted hello problem of trying toouse hello Table service toostore log entries and suggested two, unsatisfactory, designs.</span></span> <span data-ttu-id="bfbad-831">Egy megoldás vezetett tooa működés közbeni partíció hello kockázata, gyenge teljesítményt naplóüzenetek; írása hello más megoldás, így gyenge lekérdezési teljesítmény miatt hello követelmény tooscan minden partíció hello tábla tooretrieve naplózott üzeneteket az adott időtartama.</span><span class="sxs-lookup"><span data-stu-id="bfbad-831">One solution led tooa hot partition with hello risk of poor performance writing log messages; hello other solution resulted in poor query performance because of hello requirement tooscan every partition in hello table tooretrieve log messages for a specific time span.</span></span> <span data-ttu-id="bfbad-832">A BLOB storage ilyen esetben jobb megoldást kínál, és az Azure Storage Analytics tárolók hello naplóadatokat összegyűjti.</span><span class="sxs-lookup"><span data-stu-id="bfbad-832">Blob storage offers a better solution for this type of scenario and this is how Azure Storage Analytics stores hello log data it collects.</span></span>  

<span data-ttu-id="bfbad-833">Ez a szakasz ismerteti, hogyan tárolási analitika napló adatot tárol a blob storage általában tartomány lekérdező megközelítés toostoring adatot szemléltetésére.</span><span class="sxs-lookup"><span data-stu-id="bfbad-833">This section outlines how Storage Analytics stores log data in blob storage as an illustration of this approach toostoring data that you typically query by range.</span></span>  

<span data-ttu-id="bfbad-834">Tárolási analitika naplóüzenetek több blobok tagolt formátumban tárolja.</span><span class="sxs-lookup"><span data-stu-id="bfbad-834">Storage Analytics stores log messages in a delimited format in multiple blobs.</span></span> <span data-ttu-id="bfbad-835">hello tagolt formátumú megkönnyíti, hogy az ügyfél tooparse hello alkalmazásadatok hello napló üzenetben.</span><span class="sxs-lookup"><span data-stu-id="bfbad-835">hello delimited format makes it easy for a client application tooparse hello data in hello log message.</span></span>  

<span data-ttu-id="bfbad-836">Tárolási analitika blobot, amely lehetővé teszi toolocate hello blob (vagy bináris objektumok) keres, amelynek hello üzeneteket tartalmazó elnevezési konvenciót használ.</span><span class="sxs-lookup"><span data-stu-id="bfbad-836">Storage Analytics uses a naming convention for blobs that enables you toolocate hello blob (or blobs) that contain hello log messages for which you are searching.</span></span> <span data-ttu-id="bfbad-837">Például a "queue/2014/07/31/1800/000001.log" nevű blob naplóüzenetek toohello queue szolgáltatás indítása 31 2014. július 18:00 órakor hello óráig is tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="bfbad-837">For example, a blob named "queue/2014/07/31/1800/000001.log" contains log messages that relate toohello queue service for hello hour starting at 18:00 on 31 July 2014.</span></span> <span data-ttu-id="bfbad-838">hello "000001" jelzi, hogy a hello első naplófájl ebben az időszakban.</span><span class="sxs-lookup"><span data-stu-id="bfbad-838">hello "000001" indicates that this is hello first log file for this period.</span></span> <span data-ttu-id="bfbad-839">Tárolási analitika hello időbélyegeket hello az első rögzíti, és a legutóbbi a hello blob metaadatai részeként hello fájlban tárolt üzenetek naplózása.</span><span class="sxs-lookup"><span data-stu-id="bfbad-839">Storage Analytics also records hello timestamps of hello first and last log messages stored in hello file as part of hello blob's metadata.</span></span> <span data-ttu-id="bfbad-840">a blob storage lehetővé teszi, hogy blobok keresse meg a tartománynév előtagján alapuló tároló API hello: toolocate valamennyi hello BLOB várólista tartalmazó naplózni az adatokat hello óráig 18:00-tól kezdve, használhatja a hello előtag "várólista/2014/07/31/1800."</span><span class="sxs-lookup"><span data-stu-id="bfbad-840">hello API for blob storage enables you locate blobs in a container based on a name prefix: toolocate all hello blobs that contain queue log data for hello hour starting at 18:00, you can use hello prefix "queue/2014/07/31/1800."</span></span>  

<span data-ttu-id="bfbad-841">Tárolási analitika belső napló üzeneteket pufferel, és rendszeres időközönként frissíti a megfelelő blob hello, vagy létrehoz egy új-es hello legújabb naplóbejegyzéseket a.</span><span class="sxs-lookup"><span data-stu-id="bfbad-841">Storage Analytics buffers log messages internally and then periodically updates hello appropriate blob or creates a new one with hello latest batch of log entries.</span></span> <span data-ttu-id="bfbad-842">Ez hello szám csökkenti az írások toohello blob szolgáltatás kell végrehajtania.</span><span class="sxs-lookup"><span data-stu-id="bfbad-842">This reduces hello number of writes it must perform toohello blob service.</span></span>  

<span data-ttu-id="bfbad-843">Egy hasonló megoldás webkiszolgálókból a saját alkalmazásban, meg kell fontolnia hogyan toomanage hello (írása minden naplók bejegyzés tooblob tárolásához, akkor történik) megbízhatóság és a költségek és a méretezhetőség között (frissítések pufferelés az alkalmazás és rögzíti őket tooblob tárolási kötegekben).</span><span class="sxs-lookup"><span data-stu-id="bfbad-843">If you are implementing a similar solution in your own application, you must consider how toomanage hello trade-off between reliability (writing every log entry tooblob storage as it happens) and cost and scalability (buffering updates in your application and writing them tooblob storage in batches).</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="bfbad-844">Problémákat és szempontok</span><span class="sxs-lookup"><span data-stu-id="bfbad-844">Issues and considerations</span></span>
<span data-ttu-id="bfbad-845">Hello követő pontokat, hogyan toostore naplózni meghatározásakor vegye figyelembe:</span><span class="sxs-lookup"><span data-stu-id="bfbad-845">Consider hello following points when deciding how toostore log data:</span></span>  

* <span data-ttu-id="bfbad-846">Ha létrehoz egy Táblatervezés, amellyel elkerülhető a potenciális kiemelt partíciók, előfordulhat, hogy nem férhet hozzá a naplóadatok hatékonyan.</span><span class="sxs-lookup"><span data-stu-id="bfbad-846">If you create a table design that avoids potential hot partitions, you may find that you cannot access your log data efficiently.</span></span>  
* <span data-ttu-id="bfbad-847">tooprocess adatok naplózása, az ügyfél gyakran kell tooload sok rekord.</span><span class="sxs-lookup"><span data-stu-id="bfbad-847">tooprocess log data, a client often needs tooload many records.</span></span>  
* <span data-ttu-id="bfbad-848">Bár gyakran felépítése naplóadatokat, a blob storage egy jobb megoldás lehet.</span><span class="sxs-lookup"><span data-stu-id="bfbad-848">Although log data is often structured, blob storage may be a better solution.</span></span>  

### <a name="implementation-considerations"></a><span data-ttu-id="bfbad-849">Megvalósítási kapcsolatos szempontok</span><span class="sxs-lookup"><span data-stu-id="bfbad-849">Implementation considerations</span></span>
<span data-ttu-id="bfbad-850">Ez a szakasz ismerteti néhány hello szempontok toobear figyelembe hello fentebbi szakaszokban leírt hello minták bevezetésekor.</span><span class="sxs-lookup"><span data-stu-id="bfbad-850">This section discusses some of hello considerations toobear in mind when you implement hello patterns described in hello previous sections.</span></span> <span data-ttu-id="bfbad-851">Ez a szakasz a legtöbb a Storage ügyféloldali kódtára (verzió: 4.3.0 írásának hello időpontjában) hello használó C# nyelven írt példák használja.</span><span class="sxs-lookup"><span data-stu-id="bfbad-851">Most of this section uses examples written in C# that use hello Storage Client Library (version 4.3.0 at hello time of writing).</span></span>  

### <a name="retrieving-entities"></a><span data-ttu-id="bfbad-852">Entitások beolvasása</span><span class="sxs-lookup"><span data-stu-id="bfbad-852">Retrieving entities</span></span>
<span data-ttu-id="bfbad-853">Hello szakaszban leírtaknak megfelelően [lekérdezése tervezési](#design-for-querying), hello leghatékonyabb Ez egy pont lekérdezés.</span><span class="sxs-lookup"><span data-stu-id="bfbad-853">As discussed in hello section [Design for querying](#design-for-querying), hello most efficient query is a point query.</span></span> <span data-ttu-id="bfbad-854">Azonban bizonyos esetekben szükség lehet tooretrieve több entitás.</span><span class="sxs-lookup"><span data-stu-id="bfbad-854">However, in some scenarios you may need tooretrieve multiple entities.</span></span> <span data-ttu-id="bfbad-855">Ez a témakör néhány gyakori megközelítések tooretrieving entitás hello Storage ügyféloldali kódtár segítségével.</span><span class="sxs-lookup"><span data-stu-id="bfbad-855">This section describes some common approaches tooretrieving entities using hello Storage Client Library.</span></span>  

#### <a name="executing-a-point-query-using-hello-storage-client-library"></a><span data-ttu-id="bfbad-856">A Storage ügyféloldali kódtára hello segítségével pont lekérdezése</span><span class="sxs-lookup"><span data-stu-id="bfbad-856">Executing a point query using hello Storage Client Library</span></span>
<span data-ttu-id="bfbad-857">hello legegyszerűbb módja tooexecute pont lekérdezés toouse hello **beolvasása** művelet táblázatban látható módon hello következő C# kódrészletet, amely lekéri az entitás egy **PartitionKey** érték "értékesítési" és a  **RowKey** "212" érték:</span><span class="sxs-lookup"><span data-stu-id="bfbad-857">hello easiest way tooexecute a point query is toouse hello **Retrieve** table operation as shown in hello following C# code snippet that retrieves an entity with a **PartitionKey** of value "Sales" and a **RowKey** of value "212":</span></span>  

```csharp
TableOperation retrieveOperation = TableOperation.Retrieve<EmployeeEntity>("Sales", "212");
var retrieveResult = employeeTable.Execute(retrieveOperation);
if (retrieveResult.Result != null)
{
    EmployeeEntity employee = (EmployeeEntity)retrieveResult.Result;
    ...
}  
```

<span data-ttu-id="bfbad-858">Figyelje meg, hogyan vár az ebben a példában a hello entitás lekérdezi a toobe típusú **EmployeeEntity**.</span><span class="sxs-lookup"><span data-stu-id="bfbad-858">Notice how this example expects hello entity it retrieves toobe of type **EmployeeEntity**.</span></span>  

#### <a name="retrieving-multiple-entities-using-linq"></a><span data-ttu-id="bfbad-859">LINQ használatával több entitás beolvasásakor</span><span class="sxs-lookup"><span data-stu-id="bfbad-859">Retrieving multiple entities using LINQ</span></span>
<span data-ttu-id="bfbad-860">A Storage ügyféloldali kódtára a LINQ használatával, és a lekérdezés megadásával több entitás le egy **ahol** záradékban.</span><span class="sxs-lookup"><span data-stu-id="bfbad-860">You can retrieve multiple entities by using LINQ with Storage Client Library and specifying a query with a **where** clause.</span></span> <span data-ttu-id="bfbad-861">tooavoid egy táblázatbeolvasás, meg kell adnia hello **PartitionKey** hello értéket ahol záradék, és ha lehetséges hello **RowKey** tooavoid tábla és a partíció vizsgálatok érték.</span><span class="sxs-lookup"><span data-stu-id="bfbad-861">tooavoid a table scan, you should always include hello **PartitionKey** value in hello where clause, and if possible hello **RowKey** value tooavoid table and partition scans.</span></span> <span data-ttu-id="bfbad-862">hello table szolgáltatás támogatja a korlátozott számú összehasonlító operátorok (nagyobb, mint, nagyobb vagy egyenlő, kevesebb mint, kisebb vagy egyenlő, egyenlő, és nem egyenlő) toouse hello ahol záradékban.</span><span class="sxs-lookup"><span data-stu-id="bfbad-862">hello table service supports a limited set of comparison operators (greater than, greater than or equal, less than, less than or equal, equal, and not equal) toouse in hello where clause.</span></span> <span data-ttu-id="bfbad-863">hello következő C# kódrészletet talál minden hello alkalmazott amelynek utolsó neve kezdődik, "B" (feltéve, hogy hello **RowKey** tárolók hello Vezetéknév) hello értékesítési osztályon (feltéve, hogy hello **PartitionKey** tárolja a hello részleg neve):</span><span class="sxs-lookup"><span data-stu-id="bfbad-863">hello following C# code snippet finds all hello employees whose last name starts with "B" (assuming that hello **RowKey** stores hello last name) in hello sales department (assuming hello **PartitionKey** stores hello department name):</span></span>  

```csharp
TableQuery<EmployeeEntity> employeeQuery = employeeTable.CreateQuery<EmployeeEntity>();
var query = (from employee in employeeQuery
            where employee.PartitionKey == "Sales" &&
            employee.RowKey.CompareTo("B") >= 0 &&
            employee.RowKey.CompareTo("C") < 0
            select employee).AsTableQuery();
var employees = query.Execute();  
```

<span data-ttu-id="bfbad-864">Figyelje meg, hogyan hello lekérdezés határoz meg, mindkét egy **RowKey** és egy **PartitionKey** tooensure jobb teljesítmény érdekében.</span><span class="sxs-lookup"><span data-stu-id="bfbad-864">Notice how hello query specifies both a **RowKey** and a **PartitionKey** tooensure better performance.</span></span>  

<span data-ttu-id="bfbad-865">hello alábbi példakód mutatja hello Folyékonyan beszél API-jával funkciókat (További információ a Folyékonyan beszél API-k általában: [Folyékonyan beszél API tervezéséhez gyakorlati tanácsok](http://visualstudiomagazine.com/articles/2013/12/01/best-practices-for-designing-a-fluent-api.aspx)):</span><span class="sxs-lookup"><span data-stu-id="bfbad-865">hello following code sample shows equivalent functionality using hello fluent API (for more information about fluent APIs in general, see [Best Practices for Designing a Fluent API](http://visualstudiomagazine.com/articles/2013/12/01/best-practices-for-designing-a-fluent-api.aspx)):</span></span>  

```csharp
TableQuery<EmployeeEntity> employeeQuery = new TableQuery<EmployeeEntity>().Where(
    TableQuery.CombineFilters(
    TableQuery.CombineFilters(
        TableQuery.GenerateFilterCondition(
    "PartitionKey", QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.GenerateFilterCondition(
    "RowKey", QueryComparisons.GreaterThanOrEqual, "B")
),
TableOperators.And,
TableQuery.GenerateFilterCondition("RowKey", QueryComparisons.LessThan, "C")
    )
);
var employees = employeeTable.ExecuteQuery(employeeQuery);  
```

> [!NOTE]
> <span data-ttu-id="bfbad-866">hello minta ágyazza több **CombineFilters** módszerek tooinclude hello három szűrési feltételeket.</span><span class="sxs-lookup"><span data-stu-id="bfbad-866">hello sample nests multiple **CombineFilters** methods tooinclude hello three filter conditions.</span></span>  
> 
> 

#### <a name="retrieving-large-numbers-of-entities-from-a-query"></a><span data-ttu-id="bfbad-867">Egy lekérdezés által nagyszámú entitások beolvasása</span><span class="sxs-lookup"><span data-stu-id="bfbad-867">Retrieving large numbers of entities from a query</span></span>
<span data-ttu-id="bfbad-868">Az optimális lekérdezési alapuló egyéni entitást adja vissza egy **PartitionKey** érték és egy **RowKey** érték.</span><span class="sxs-lookup"><span data-stu-id="bfbad-868">An optimal query returns an individual entity based on a **PartitionKey** value and a **RowKey** value.</span></span> <span data-ttu-id="bfbad-869">Azonban bizonyos esetekben előfordulhat, hogy egy követelmény tooreturn hello azonos particionálása, vagy akár több partícióról származó sok entitásokat.</span><span class="sxs-lookup"><span data-stu-id="bfbad-869">However, in some scenarios you may have a requirement tooreturn many entities from hello same partition or even from many partitions.</span></span>  

<span data-ttu-id="bfbad-870">Ilyen esetekben mindig teljes mértékben az alkalmazás teljesítményének hello kell tesztelni.</span><span class="sxs-lookup"><span data-stu-id="bfbad-870">You should always fully test hello performance of your application in such scenarios.</span></span>  

<span data-ttu-id="bfbad-871">Egy lekérdezést hajtanak hello table szolgáltatás térhetnek vissza egy adott időpontban legfeljebb 1000 entitásokat, és előfordulhat, hogy öt másodpercenként legfeljebb hajtható végre.</span><span class="sxs-lookup"><span data-stu-id="bfbad-871">A query against hello table service may return a maximum of 1,000 entities at one time and may execute for a maximum of five seconds.</span></span> <span data-ttu-id="bfbad-872">Ha hello eredménykészlet 1000-nél több entitásokat tartalmaz, ha hello lekérdezés nem fejeződött be 5 másodpercen belül, vagy ha hello lekérdezés áthalad hello partíció határán, Table szolgáltatás hello folytatási token tooenable hello ügyfél alkalmazás toorequest köszönésére az entitások készletének tovább.</span><span class="sxs-lookup"><span data-stu-id="bfbad-872">If hello result set contains more than 1,000 entities, if hello query did not complete within five seconds, or if hello query crosses hello partition boundary, hello Table service returns a continuation token tooenable hello client application toorequest hello next set of entities.</span></span> <span data-ttu-id="bfbad-873">Hogyan folytatási jogkivonatok munkahelyi kapcsolatos további információkért lásd: [lekérdezés időkorlátja és tördelési](http://msdn.microsoft.com/library/azure/dd135718.aspx).</span><span class="sxs-lookup"><span data-stu-id="bfbad-873">For more information about how continuation tokens work, see [Query Timeout and Pagination](http://msdn.microsoft.com/library/azure/dd135718.aspx).</span></span>  

<span data-ttu-id="bfbad-874">A Storage ügyféloldali kódtára hello használ, ha azt kezelni tud a automatikusan folytatási jogkivonatok meg, akkor ad vissza entitásokat hello Table szolgáltatás.</span><span class="sxs-lookup"><span data-stu-id="bfbad-874">If you are using hello Storage Client Library, it can automatically handle continuation tokens for you as it returns entities from hello Table service.</span></span> <span data-ttu-id="bfbad-875">hello alábbi C# kódminta hello Storage ügyféloldali kódtár segítségével automatikusan kezeli a folytatási jogkivonatok Ha hello table szolgáltatás visszaadja azokat választ:</span><span class="sxs-lookup"><span data-stu-id="bfbad-875">hello following C# code sample using hello Storage Client Library automatically handles continuation tokens if hello table service returns them in a response:</span></span>  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

var employees = employeeTable.ExecuteQuery(employeeQuery);
foreach (var emp in employees)
{
        ...
}  
```

<span data-ttu-id="bfbad-876">a következő C#-kódban hello folytatási jogkivonatok explicit módon kezeli:</span><span class="sxs-lookup"><span data-stu-id="bfbad-876">hello following C# code handles continuation tokens explicitly:</span></span>  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

TableContinuationToken continuationToken = null;

do
{
        var employees = employeeTable.ExecuteQuerySegmented(
        employeeQuery, continuationToken);
    foreach (var emp in employees)
    {
    ...
    }
    continuationToken = employees.ContinuationToken;
} while (continuationToken != null);  
```

<span data-ttu-id="bfbad-877">Jogkivonatok segítségével képes folytatási explicit módon, megadhatja, ha az alkalmazás lekéri a következő szegmens hello adatok.</span><span class="sxs-lookup"><span data-stu-id="bfbad-877">By using continuation tokens explicitly, you can control when your application retrieves hello next segment of data.</span></span> <span data-ttu-id="bfbad-878">Például ha az ügyfélalkalmazást lehetővé teszi, hogy a felhasználók toopage keresztül hello entitások egy táblázatban tárolja, a felhasználó dönthet nem keresztül, az alkalmazás csak használna a folytatási token tooretrieve hello mellett hello lekérdezés lekéri az összes hello entitások toopage szegmens befejezésekor hello felhasználói kellett hello aktuális szegmensben lévő összes hello entitás lapozást.</span><span class="sxs-lookup"><span data-stu-id="bfbad-878">For example, if your client application enables users toopage through hello entities stored in a table, a user may decide not toopage through all hello entities retrieved by hello query so your application would only use a continuation token tooretrieve hello next segment when hello user had finished paging through all hello entities in hello current segment.</span></span> <span data-ttu-id="bfbad-879">Ez a megközelítés azzal számos előnnyel jár:</span><span class="sxs-lookup"><span data-stu-id="bfbad-879">This approach has several benefits:</span></span>  

* <span data-ttu-id="bfbad-880">Lehetővé teszi a Table szolgáltatás hello adatok tooretrieve toolimit hello mennyiségét és hello hálózati átvitele.</span><span class="sxs-lookup"><span data-stu-id="bfbad-880">It enables you toolimit hello amount of data tooretrieve from hello Table service and that you move over hello network.</span></span>  
* <span data-ttu-id="bfbad-881">Ez lehetővé teszi, hogy Ön tooperform aszinkron IO a .NET.</span><span class="sxs-lookup"><span data-stu-id="bfbad-881">It enables you tooperform asynchronous IO in .NET.</span></span>  
* <span data-ttu-id="bfbad-882">Lehetővé teszi a tooserialize hello folytatási token toopersistent tárolási így hello egy alkalmazás összeomlása esetén is.</span><span class="sxs-lookup"><span data-stu-id="bfbad-882">It enables you tooserialize hello continuation token toopersistent storage so you can continue in hello event of an application crash.</span></span>  

> [!NOTE]
> <span data-ttu-id="bfbad-883">A folytatási kód általában 1000 entitásokat tartalmazó szegmens adja vissza, bár kevesebb lehet.</span><span class="sxs-lookup"><span data-stu-id="bfbad-883">A continuation token typically returns a segment containing 1,000 entities, although it may be fewer.</span></span> <span data-ttu-id="bfbad-884">Ez helyzet is hello Ha csak a lekérdezés visszaadja a bejegyzések száma hello **érvénybe** tooreturn hello első n entitások a keresési feltételeknek eleget tevő: hello table szolgáltatás térhetnek vissza egy szegmenst mentén n entitások nem lépi-e a folytatási token tooenable meg tooretrieve hello fennmaradó entitásokat.</span><span class="sxs-lookup"><span data-stu-id="bfbad-884">This is also hello case if you limit hello number of entries a query returns by using **Take** tooreturn hello first n entities that match your lookup criteria: hello table service may return a segment containing fewer than n entities along with a continuation token tooenable you tooretrieve hello remaining entities.</span></span>  
> 
> 

<span data-ttu-id="bfbad-885">hello következő C# kód bemutatja, hogyan entitások száma toomodify hello visszaadott szegmens belül:</span><span class="sxs-lookup"><span data-stu-id="bfbad-885">hello following C# code shows how toomodify hello number of entities returned inside a segment:</span></span>  

```csharp
employeeQuery.TakeCount = 50;  
```

#### <a name="server-side-projection"></a><span data-ttu-id="bfbad-886">Kiszolgálóoldali leképezése</span><span class="sxs-lookup"><span data-stu-id="bfbad-886">Server-side projection</span></span>
<span data-ttu-id="bfbad-887">Egyetlen entitás be too255 tulajdonságait és a too1 MB méretű lehet.</span><span class="sxs-lookup"><span data-stu-id="bfbad-887">A single entity can have up too255 properties and be up too1 MB in size.</span></span> <span data-ttu-id="bfbad-888">Hello tábla lekérdezése, és kérje le az entitásokat, előfordulhat, hogy nem kell minden hello tulajdonság, és elkerülheti a feleslegesen adatátvitel (toohelp késés és csökkentése költség).</span><span class="sxs-lookup"><span data-stu-id="bfbad-888">When you query hello table and retrieve entities, you may not need all hello properties and can avoid transferring data unnecessarily (toohelp reduce latency and cost).</span></span> <span data-ttu-id="bfbad-889">Kiszolgálóoldali leképezése tootransfer csak hello tulajdonságok kell használhatók.</span><span class="sxs-lookup"><span data-stu-id="bfbad-889">You can use server-side projection tootransfer just hello properties you need.</span></span> <span data-ttu-id="bfbad-890">hello következő példája lekéri csak hello **E-mail** tulajdonság (valamint **PartitionKey**, **RowKey**, **időbélyeg**, és  **ETag**) a kijelölt hello lekérdezésével hello entitásokból.</span><span class="sxs-lookup"><span data-stu-id="bfbad-890">hello following example is retrieves just hello **Email** property (along with **PartitionKey**, **RowKey**, **Timestamp**, and **ETag**) from hello entities selected by hello query.</span></span>  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
List<string> columns = new List<string>() { "Email" };
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter).Select(columns);

var entities = employeeTable.ExecuteQuery(employeeQuery);
foreach (var e in entities)
{
        Console.WriteLine("RowKey: {0}, EmployeeEmail: {1}", e.RowKey, e.Email);
}  
```

<span data-ttu-id="bfbad-891">Figyelje meg, hogyan hello **RowKey** érték érhető el annak ellenére, hogy az nem tartalmazott tulajdonságokat tooretrieve hello listája.</span><span class="sxs-lookup"><span data-stu-id="bfbad-891">Notice how hello **RowKey** value is available even though it was not included in hello list of properties tooretrieve.</span></span>  

### <a name="modifying-entities"></a><span data-ttu-id="bfbad-892">Entitások módosítása</span><span class="sxs-lookup"><span data-stu-id="bfbad-892">Modifying entities</span></span>
<span data-ttu-id="bfbad-893">a Storage ügyféloldali kódtára hello lehetővé teszi, hogy a toomodify, az entitások hello table szolgáltatás tárolva, hogy beszúrása törlés és frissítési entitások.</span><span class="sxs-lookup"><span data-stu-id="bfbad-893">hello Storage Client Library enables you toomodify your entities stored in hello table service by inserting, deleting, and updating entities.</span></span> <span data-ttu-id="bfbad-894">Több insert, update és delete művelet adatváltások száma együtt tooreduce hello szükséges, és a megoldás hello teljesítményének növelése a EGTs toobatch használható.</span><span class="sxs-lookup"><span data-stu-id="bfbad-894">You can use EGTs toobatch multiple insert, update, and delete operations together tooreduce hello number of round trips required and improve hello performance of your solution.</span></span>  

<span data-ttu-id="bfbad-895">Fontos megjegyezni, hogy a kivételek végrehajtásakor a Storage ügyféloldali kódtár hello egy EGT általában hello index hello entitás, ami miatt a hello kötegelt toofail tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="bfbad-895">Note that exceptions thrown when hello Storage Client Library executes an EGT typically include hello index of hello entity that caused hello batch toofail.</span></span> <span data-ttu-id="bfbad-896">Ez akkor hasznos, ha EGTs kód hibakeresés alatt.</span><span class="sxs-lookup"><span data-stu-id="bfbad-896">This is helpful when you are debugging code that uses EGTs.</span></span>  

<span data-ttu-id="bfbad-897">Azt is figyelembe kell venni, hogyan a kialakítás befolyásolja, miként kezeli az ügyfélalkalmazást a feldolgozási mód és a frissítési művelet.</span><span class="sxs-lookup"><span data-stu-id="bfbad-897">You should also consider how your design affects how your client application handles concurrency and update operations.</span></span>  

#### <a name="managing-concurrency"></a><span data-ttu-id="bfbad-898">Párhuzamossági kezelése</span><span class="sxs-lookup"><span data-stu-id="bfbad-898">Managing concurrency</span></span>
<span data-ttu-id="bfbad-899">Alapértelmezés szerint hello table szolgáltatás megvalósítja az optimista feldolgozási ellenőrzi az egyes entitások hello szinten **beszúrása**, **egyesítése**, és **törlése** műveletek Bár lehetséges a table szolgáltatás toobypass ellenőrzést egy ügyfél tooforce hello.</span><span class="sxs-lookup"><span data-stu-id="bfbad-899">By default, hello table service implements optimistic concurrency checks at hello level of individual entities for **Insert**, **Merge**, and **Delete** operations, although it is possible for a client tooforce hello table service toobypass these checks.</span></span> <span data-ttu-id="bfbad-900">Hogyan kezeli a hello table szolgáltatás az egyidejű kapcsolatos további információkért lásd: [egyidejűségi kezelése a Microsoft Azure Storage](storage-concurrency.md).</span><span class="sxs-lookup"><span data-stu-id="bfbad-900">For more information about how hello table service manages concurrency, see  [Managing Concurrency in Microsoft Azure Storage](storage-concurrency.md).</span></span>  

#### <a name="merge-or-replace"></a><span data-ttu-id="bfbad-901">Egyesítés vagy cseréje</span><span class="sxs-lookup"><span data-stu-id="bfbad-901">Merge or replace</span></span>
<span data-ttu-id="bfbad-902">Hello **cserélje le** hello metódusában **TableOperation** mindig a felváltja hello teljes entitásnak a Table szolgáltatás hello osztály.</span><span class="sxs-lookup"><span data-stu-id="bfbad-902">hello **Replace** method of hello **TableOperation** class always replaces hello complete entity in hello Table service.</span></span> <span data-ttu-id="bfbad-903">Ha nem adja meg a tulajdonság hello kérelem során ez a tulajdonság tárolja hello entitásban található, a hello kérelem hello tulajdonságot tárolt entitás eltávolítja.</span><span class="sxs-lookup"><span data-stu-id="bfbad-903">If you do not include a property in hello request when that property exists in hello stored entity, hello request removes that property from hello stored entity.</span></span> <span data-ttu-id="bfbad-904">Kivéve, ha azt szeretné, hogy egy tulajdonság explicit módon tárolt entitásból tooremove, meg kell adnia minden tulajdonsághoz hello kérelemben.</span><span class="sxs-lookup"><span data-stu-id="bfbad-904">Unless you want tooremove a property explicitly from a stored entity, you must include every property in hello request.</span></span>  

<span data-ttu-id="bfbad-905">Használhatja a hello **egyesítése** hello metódusában **TableOperation** osztály tooreduce hello adatmennyiséget, hogy küldjön toohello Table szolgáltatás Ha azt szeretné, hogy tooupdate entitás.</span><span class="sxs-lookup"><span data-stu-id="bfbad-905">You can use hello **Merge** method of hello **TableOperation** class tooreduce hello amount of data that you send toohello Table service when you want tooupdate an entity.</span></span> <span data-ttu-id="bfbad-906">Hello **egyesítése** metódus bármelyik tulajdonságot tárolt hello entitás cseréli a tulajdonságértékek hello entitásból hello kérelemben szereplő, de ép leaves hello bármelyik tulajdonságot tárolja hello kérelemben szereplő nem entitás.</span><span class="sxs-lookup"><span data-stu-id="bfbad-906">hello **Merge** method replaces any properties in hello stored entity with property values from hello entity included in hello request, but leaves intact any properties in hello stored entity that are not included in hello request.</span></span> <span data-ttu-id="bfbad-907">Ez akkor hasznos, ha nagy entitásokat, és csak a kérelemben tulajdonságok kis számú tooupdate kell.</span><span class="sxs-lookup"><span data-stu-id="bfbad-907">This is useful if you have large entities and only need tooupdate a small number of properties in a request.</span></span>  

> [!NOTE]
> <span data-ttu-id="bfbad-908">Hello **cserélje le** és **egyesítése** módszer sem jár sikerrel, ha hello entitás nem létezik.</span><span class="sxs-lookup"><span data-stu-id="bfbad-908">hello **Replace** and **Merge** methods fail if hello entity does not exist.</span></span> <span data-ttu-id="bfbad-909">Alternatív megoldásként használhatja hello **InsertOrReplace** és **InsertOrMerge** módszereket, amelyek új entitás létrehozása, ha még nem létezik.</span><span class="sxs-lookup"><span data-stu-id="bfbad-909">As an alternative, you can use hello **InsertOrReplace** and **InsertOrMerge** methods that create a new entity if it doesn't exist.</span></span>  
> 
> 

### <a name="working-with-heterogeneous-entity-types"></a><span data-ttu-id="bfbad-910">Heterogén entitástípusok használata</span><span class="sxs-lookup"><span data-stu-id="bfbad-910">Working with heterogeneous entity types</span></span>
<span data-ttu-id="bfbad-911">Table szolgáltatás hello van egy *séma nélküli* tábla tároló, amely azt jelenti, hogy egyetlen tábla tud tárolni a Tervező nagyfokú rugalmasságot biztosít több típusú entitásokat.</span><span class="sxs-lookup"><span data-stu-id="bfbad-911">hello Table service is a *schema-less* table store that means that a single table can store entities of multiple types providing great flexibility in your design.</span></span> <span data-ttu-id="bfbad-912">hello alábbi példában látható módon egy tábla dolgozó és a részleg entitások tárolására:</span><span class="sxs-lookup"><span data-stu-id="bfbad-912">hello following example illustrates a table storing both employee and department entities:</span></span>  

<table>
<tr>
<th><span data-ttu-id="bfbad-913">PartitionKey</span><span class="sxs-lookup"><span data-stu-id="bfbad-913">PartitionKey</span></span></th>
<th><span data-ttu-id="bfbad-914">RowKey</span><span class="sxs-lookup"><span data-stu-id="bfbad-914">RowKey</span></span></th>
<th><span data-ttu-id="bfbad-915">időbélyeg</span><span class="sxs-lookup"><span data-stu-id="bfbad-915">Timestamp</span></span></th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="bfbad-916">Utónév</span><span class="sxs-lookup"><span data-stu-id="bfbad-916">FirstName</span></span></th>
<th><span data-ttu-id="bfbad-917">Vezetéknév</span><span class="sxs-lookup"><span data-stu-id="bfbad-917">LastName</span></span></th>
<th><span data-ttu-id="bfbad-918">Kor</span><span class="sxs-lookup"><span data-stu-id="bfbad-918">Age</span></span></th>
<th><span data-ttu-id="bfbad-919">E-mail cím</span><span class="sxs-lookup"><span data-stu-id="bfbad-919">Email</span></span></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="bfbad-920">Utónév</span><span class="sxs-lookup"><span data-stu-id="bfbad-920">FirstName</span></span></th>
<th><span data-ttu-id="bfbad-921">Vezetéknév</span><span class="sxs-lookup"><span data-stu-id="bfbad-921">LastName</span></span></th>
<th><span data-ttu-id="bfbad-922">Kor</span><span class="sxs-lookup"><span data-stu-id="bfbad-922">Age</span></span></th>
<th><span data-ttu-id="bfbad-923">E-mail cím</span><span class="sxs-lookup"><span data-stu-id="bfbad-923">Email</span></span></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="bfbad-924">departmentname nevű</span><span class="sxs-lookup"><span data-stu-id="bfbad-924">DepartmentName</span></span></th>
<th><span data-ttu-id="bfbad-925">EmployeeCount</span><span class="sxs-lookup"><span data-stu-id="bfbad-925">EmployeeCount</span></span></th>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="bfbad-926">Utónév</span><span class="sxs-lookup"><span data-stu-id="bfbad-926">FirstName</span></span></th>
<th><span data-ttu-id="bfbad-927">Vezetéknév</span><span class="sxs-lookup"><span data-stu-id="bfbad-927">LastName</span></span></th>
<th><span data-ttu-id="bfbad-928">Kor</span><span class="sxs-lookup"><span data-stu-id="bfbad-928">Age</span></span></th>
<th><span data-ttu-id="bfbad-929">E-mail cím</span><span class="sxs-lookup"><span data-stu-id="bfbad-929">Email</span></span></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

<span data-ttu-id="bfbad-930">Vegye figyelembe, hogy minden egyes szervezet továbbra is rendelkeznie kell **PartitionKey**, **RowKey**, és **időbélyeg** értékeket, de rendelkezhetnek bármely tulajdonságkészletbe.</span><span class="sxs-lookup"><span data-stu-id="bfbad-930">Note that each entity must still have **PartitionKey**, **RowKey**, and **Timestamp** values, but may have any set of properties.</span></span> <span data-ttu-id="bfbad-931">Ezenkívül nincs tooindicate hello típusú entitás, kivéve, ha úgy dönt, toostore valahol ezt az információt.</span><span class="sxs-lookup"><span data-stu-id="bfbad-931">Furthermore, there is nothing tooindicate hello type of an entity unless you choose toostore that information somewhere.</span></span> <span data-ttu-id="bfbad-932">Azonosítsa a hello entitástípus két lehetőség áll rendelkezésre:</span><span class="sxs-lookup"><span data-stu-id="bfbad-932">There are two options for identifying hello entity type:</span></span>  

* <span data-ttu-id="bfbad-933">Hello entitás típusa toohello illesztenie **RowKey** (vagy valószínűleg hello **PartitionKey**).</span><span class="sxs-lookup"><span data-stu-id="bfbad-933">Prepend hello entity type toohello **RowKey** (or possibly hello **PartitionKey**).</span></span> <span data-ttu-id="bfbad-934">Például **EMPLOYEE_000123** vagy **DEPARTMENT_SALES** , **RowKey** értékeket.</span><span class="sxs-lookup"><span data-stu-id="bfbad-934">For example, **EMPLOYEE_000123** or **DEPARTMENT_SALES** as **RowKey** values.</span></span>  
* <span data-ttu-id="bfbad-935">Használjon egy külön tulajdonság toorecord hello entitástípus hello az alábbi táblázatban ismertetett módon.</span><span class="sxs-lookup"><span data-stu-id="bfbad-935">Use a separate property toorecord hello entity type as shown in hello table below.</span></span>  

<table>
<tr>
<th><span data-ttu-id="bfbad-936">PartitionKey</span><span class="sxs-lookup"><span data-stu-id="bfbad-936">PartitionKey</span></span></th>
<th><span data-ttu-id="bfbad-937">RowKey</span><span class="sxs-lookup"><span data-stu-id="bfbad-937">RowKey</span></span></th>
<th><span data-ttu-id="bfbad-938">időbélyeg</span><span class="sxs-lookup"><span data-stu-id="bfbad-938">Timestamp</span></span></th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="bfbad-939">EntityType</span><span class="sxs-lookup"><span data-stu-id="bfbad-939">EntityType</span></span></th>
<th><span data-ttu-id="bfbad-940">Utónév</span><span class="sxs-lookup"><span data-stu-id="bfbad-940">FirstName</span></span></th>
<th><span data-ttu-id="bfbad-941">Vezetéknév</span><span class="sxs-lookup"><span data-stu-id="bfbad-941">LastName</span></span></th>
<th><span data-ttu-id="bfbad-942">Kor</span><span class="sxs-lookup"><span data-stu-id="bfbad-942">Age</span></span></th>
<th><span data-ttu-id="bfbad-943">E-mail cím</span><span class="sxs-lookup"><span data-stu-id="bfbad-943">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="bfbad-944">Alkalmazott</span><span class="sxs-lookup"><span data-stu-id="bfbad-944">Employee</span></span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="bfbad-945">EntityType</span><span class="sxs-lookup"><span data-stu-id="bfbad-945">EntityType</span></span></th>
<th><span data-ttu-id="bfbad-946">Utónév</span><span class="sxs-lookup"><span data-stu-id="bfbad-946">FirstName</span></span></th>
<th><span data-ttu-id="bfbad-947">Vezetéknév</span><span class="sxs-lookup"><span data-stu-id="bfbad-947">LastName</span></span></th>
<th><span data-ttu-id="bfbad-948">Kor</span><span class="sxs-lookup"><span data-stu-id="bfbad-948">Age</span></span></th>
<th><span data-ttu-id="bfbad-949">E-mail cím</span><span class="sxs-lookup"><span data-stu-id="bfbad-949">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="bfbad-950">Alkalmazott</span><span class="sxs-lookup"><span data-stu-id="bfbad-950">Employee</span></span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="bfbad-951">EntityType</span><span class="sxs-lookup"><span data-stu-id="bfbad-951">EntityType</span></span></th>
<th><span data-ttu-id="bfbad-952">departmentname nevű</span><span class="sxs-lookup"><span data-stu-id="bfbad-952">DepartmentName</span></span></th>
<th><span data-ttu-id="bfbad-953">EmployeeCount</span><span class="sxs-lookup"><span data-stu-id="bfbad-953">EmployeeCount</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="bfbad-954">Szervezeti egység</span><span class="sxs-lookup"><span data-stu-id="bfbad-954">Department</span></span></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="bfbad-955">EntityType</span><span class="sxs-lookup"><span data-stu-id="bfbad-955">EntityType</span></span></th>
<th><span data-ttu-id="bfbad-956">Utónév</span><span class="sxs-lookup"><span data-stu-id="bfbad-956">FirstName</span></span></th>
<th><span data-ttu-id="bfbad-957">Vezetéknév</span><span class="sxs-lookup"><span data-stu-id="bfbad-957">LastName</span></span></th>
<th><span data-ttu-id="bfbad-958">Kor</span><span class="sxs-lookup"><span data-stu-id="bfbad-958">Age</span></span></th>
<th><span data-ttu-id="bfbad-959">E-mail cím</span><span class="sxs-lookup"><span data-stu-id="bfbad-959">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="bfbad-960">Alkalmazott</span><span class="sxs-lookup"><span data-stu-id="bfbad-960">Employee</span></span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

<span data-ttu-id="bfbad-961">hello első lehetőség, fertőző hello entitás típusa toohello **RowKey**, akkor hasznos, ha lehetséges, hogy két különböző típusú lehet, hogy entitásnak hello ugyanaz a kulcs értékét.</span><span class="sxs-lookup"><span data-stu-id="bfbad-961">hello first option, prepending hello entity type toohello **RowKey**, is useful if there is a possibility that two entities of different types might have hello same key value.</span></span> <span data-ttu-id="bfbad-962">Azt is csoportok hello hello partíció együtt azonos adja meg az entitásokat.</span><span class="sxs-lookup"><span data-stu-id="bfbad-962">It also groups entities of hello same type together in hello partition.</span></span>  

<span data-ttu-id="bfbad-963">hello ebben a szakaszban bemutatott eljárások különösen fontos toohello vitafórum [öröklési kapcsolatok](#inheritance-relationships) hello szakaszában az útmutató korábbi [kapcsolatok modellezésére](#modelling-relationships).</span><span class="sxs-lookup"><span data-stu-id="bfbad-963">hello techniques discussed in this section are especially relevant toohello discussion [Inheritance relationships](#inheritance-relationships) earlier in this guide in hello section [Modelling relationships](#modelling-relationships).</span></span>  

> [!NOTE]
> <span data-ttu-id="bfbad-964">Érdemes egy verziószámot hello entitás típusú érték tooenable ügyfél alkalmazások tooevolve POCO objektumok kell, és különböző verzióival működnek.</span><span class="sxs-lookup"><span data-stu-id="bfbad-964">You should consider including a version number in hello entity type value tooenable client applications tooevolve POCO objects and work with different versions.</span></span>  
> 
> 

<span data-ttu-id="bfbad-965">hello hátralévő részét ez a szakasz ismerteti, néhány hello szolgáltatást, amelyek egyszerűbbé teszik a több entitástípusok hello használata azonos hello a Storage ügyféloldali kódtára a táblában.</span><span class="sxs-lookup"><span data-stu-id="bfbad-965">hello remainder of this section describes some of hello features in hello Storage Client Library that facilitate working with multiple entity types in hello same table.</span></span>  

#### <a name="retrieving-heterogeneous-entity-types"></a><span data-ttu-id="bfbad-966">Heterogén entitástípusok beolvasása</span><span class="sxs-lookup"><span data-stu-id="bfbad-966">Retrieving heterogeneous entity types</span></span>
<span data-ttu-id="bfbad-967">A Storage ügyféloldali kódtára hello használ, az entitástípusok több három beállításai lesz.</span><span class="sxs-lookup"><span data-stu-id="bfbad-967">If you are using hello Storage Client Library, you have three options for working with multiple entity types.</span></span>  

<span data-ttu-id="bfbad-968">Ha tudja, hogy egy adott tárolt hello entitások hello típusú **RowKey** és **PartitionKey** értékeket, majd megadhat hello entitástípus, amikor hello entitás visszaállíthatja az előző két hello példákban típusú entitásokat beolvasása, amely **EmployeeEntity**: [hello Storage ügyféloldali kódtár segítségével pont lekérdezése](#executing-a-point-query-using-the-storage-client-library) és [LINQhasználatávaltöbbentitásbeolvasásakor](#retrieving-multiple-entities-using-linq).</span><span class="sxs-lookup"><span data-stu-id="bfbad-968">If you know hello type of hello entity stored with a specific **RowKey** and **PartitionKey** values, then you can specify hello entity type when you retrieve hello entity as shown in hello previous two examples that retrieve entities of type **EmployeeEntity**: [Executing a point query using hello Storage Client Library](#executing-a-point-query-using-the-storage-client-library) and [Retrieving multiple entities using LINQ](#retrieving-multiple-entities-using-linq).</span></span>  

<span data-ttu-id="bfbad-969">hello második lehetőség toouse hello **DynamicTableEntity** típusú (egy tulajdonságcsomagot) helyett egy konkrét POCO entitás típusa (ezt a lehetőséget is is teljesítményének javítása, mert nincs szükség tooserialize és hello entitás túl deszerializálni. NETTÓ esetében).</span><span class="sxs-lookup"><span data-stu-id="bfbad-969">hello second option is toouse hello **DynamicTableEntity** type (a property bag) instead of a concrete POCO entity type (this option may also improve performance because there is no need tooserialize and deserialize hello entity too.NET types).</span></span> <span data-ttu-id="bfbad-970">a következő C#-kódban potenciálisan hello különböző típusú entitásokat hello táblából, de mint minden entitásokat ad vissza **DynamicTableEntity** példányok.</span><span class="sxs-lookup"><span data-stu-id="bfbad-970">hello following C# code potentially retrieves multiple entities of different types from hello table, but returns all entities as **DynamicTableEntity** instances.</span></span> <span data-ttu-id="bfbad-971">Ezután hello **EntityType** toodetermine hello tulajdonságtípus minden entitás:</span><span class="sxs-lookup"><span data-stu-id="bfbad-971">It then uses hello **EntityType** property toodetermine hello type of each entity:</span></span>  

```csharp
string filter = TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("PartitionKey",
    QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("RowKey",
                    QueryComparisons.GreaterThanOrEqual, "B"),
        TableOperators.And,
        TableQuery.GenerateFilterCondition("RowKey",
        QueryComparisons.LessThan, "F")
    )
);
TableQuery<DynamicTableEntity> entityQuery =
    new TableQuery<DynamicTableEntity>().Where(filter);
var employees = employeeTable.ExecuteQuery(entityQuery);

IEnumerable<DynamicTableEntity> entities = employeeTable.ExecuteQuery(entityQuery);
foreach (var e in entities)
{
EntityProperty entityTypeProperty;
if (e.Properties.TryGetValue("EntityType", out entityTypeProperty))
{
    if (entityTypeProperty.StringValue == "Employee")
    {
        // Use entityTypeProperty, RowKey, PartitionKey, Etag, and Timestamp
        }
    }
}  
```

<span data-ttu-id="bfbad-972">Vegye figyelembe, hogy tooretrieve egyéb tulajdonságok hello kell használnia **TryGetValue** hello metódusa **tulajdonságok** hello tulajdonságának **DynamicTableEntity** osztály.</span><span class="sxs-lookup"><span data-stu-id="bfbad-972">Note that tooretrieve other properties you must use hello **TryGetValue** method on hello **Properties** property of hello **DynamicTableEntity** class.</span></span>  

<span data-ttu-id="bfbad-973">A harmadik lehetőség hello segítségével toocombine **DynamicTableEntity** típust és egy **EntityResolver** példány.</span><span class="sxs-lookup"><span data-stu-id="bfbad-973">A third option is toocombine using hello **DynamicTableEntity** type and an **EntityResolver** instance.</span></span> <span data-ttu-id="bfbad-974">Ez lehetővé teszi tooresolve toomultiple POCO típusainak hello ugyanabban a lekérdezésben.</span><span class="sxs-lookup"><span data-stu-id="bfbad-974">This enables you tooresolve toomultiple POCO types in hello same query.</span></span> <span data-ttu-id="bfbad-975">Ebben a példában hello **EntityResolver** delegált használ hello **EntityType** tulajdonság toodistinguish közötti hello két típusú entitás, amely hello lekérdezés értéket ad vissza.</span><span class="sxs-lookup"><span data-stu-id="bfbad-975">In this example, hello **EntityResolver** delegate is using hello **EntityType** property toodistinguish between hello two types of entity that hello query returns.</span></span> <span data-ttu-id="bfbad-976">Hello **megoldásához** metódusnak hello **feloldó** tooresolve delegálása **DynamicTableEntity** túl példányok**TableEntity** példányok.</span><span class="sxs-lookup"><span data-stu-id="bfbad-976">hello **Resolve** method uses hello **resolver** delegate tooresolve **DynamicTableEntity** instances too**TableEntity** instances.</span></span>  

```csharp
EntityResolver<TableEntity> resolver = (pk, rk, ts, props, etag) =>
{

        TableEntity resolvedEntity = null;
        if (props["EntityType"].StringValue == "Department")
        {
        resolvedEntity = new DepartmentEntity();
        }
        else if (props["EntityType"].StringValue == "Employee")
        {
        resolvedEntity = new EmployeeEntity();
        }
        else throw new ArgumentException("Unrecognized entity", "props");

        resolvedEntity.PartitionKey = pk;
        resolvedEntity.RowKey = rk;
        resolvedEntity.Timestamp = ts;
        resolvedEntity.ETag = etag;
        resolvedEntity.ReadEntity(props, null);
        return resolvedEntity;
};

string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<DynamicTableEntity> entityQuery =
        new TableQuery<DynamicTableEntity>().Where(filter);

var entities = employeeTable.ExecuteQuery(entityQuery, resolver);
foreach (var e in entities)
{
        if (e is DepartmentEntity)
        {
    ...
        }
        if (e is EmployeeEntity)
        {
    ...
        }
}  
```

#### <a name="modifying-heterogeneous-entity-types"></a><span data-ttu-id="bfbad-977">Heterogén entitástípusok módosítása</span><span class="sxs-lookup"><span data-stu-id="bfbad-977">Modifying heterogeneous entity types</span></span>
<span data-ttu-id="bfbad-978">Egy entitás toodelete tooknow hello típusú és hello típusú entitás mindig jelzi, ha azt nem kell.</span><span class="sxs-lookup"><span data-stu-id="bfbad-978">You do not need tooknow hello type of an entity toodelete it, and you always know hello type of an entity when you insert it.</span></span> <span data-ttu-id="bfbad-979">Használhat azonban **DynamicTableEntity** írja be a tooupdate entitást, anélkül, hogy tudnák típusára és egy POCO entitásosztályt használata nélkül.</span><span class="sxs-lookup"><span data-stu-id="bfbad-979">However, you can use **DynamicTableEntity** type tooupdate an entity without knowing its type and without using a POCO entity class.</span></span> <span data-ttu-id="bfbad-980">hello alábbi kódminta egyetlen entitás kéri le, és ellenőrzi hello **EmployeeCount** tulajdonság létezik-e frissítése előtt.</span><span class="sxs-lookup"><span data-stu-id="bfbad-980">hello following code sample retrieves a single entity, and checks hello **EmployeeCount** property exists before updating it.</span></span>  

```csharp
TableResult result =
        employeeTable.Execute(TableOperation.Retrieve(partitionKey, rowKey));
DynamicTableEntity department = (DynamicTableEntity)result.Result;

EntityProperty countProperty;

if (!department.Properties.TryGetValue("EmployeeCount", out countProperty))
{
        throw new
        InvalidOperationException("Invalid entity, EmployeeCount property not found.");
}
countProperty.Int32Value += 1;
employeeTable.Execute(TableOperation.Merge(department));  
```

### <a name="controlling-access-with-shared-access-signatures"></a><span data-ttu-id="bfbad-981">Megosztott hozzáférési aláírásokkal-hozzáférés szabályozásáról</span><span class="sxs-lookup"><span data-stu-id="bfbad-981">Controlling access with Shared Access Signatures</span></span>
<span data-ttu-id="bfbad-982">Használhat közös hozzáférésű Jogosultságkód (SAS) tokenek tooenable ügyfél alkalmazások toomodify (és lekérdezése) táblaentitásokat közvetlenül hello kell tooauthenticate közvetlenül az hello table szolgáltatás nélkül.</span><span class="sxs-lookup"><span data-stu-id="bfbad-982">You can use Shared Access Signature (SAS) tokens tooenable client applications toomodify (and query) table entities directly without hello need tooauthenticate directly with hello table service.</span></span> <span data-ttu-id="bfbad-983">Nincsenek általában három fő előnnyel jár toousing SAS az alkalmazásban:</span><span class="sxs-lookup"><span data-stu-id="bfbad-983">Typically, there are three main benefits toousing SAS in your application:</span></span>  

* <span data-ttu-id="bfbad-984">Nem kell toodistribute tárhelyét rendelés tooallow kulcs tooan nem biztonságos platform (például egy mobileszköz) fiók adott eszköz tooaccess, és módosítsa a Table szolgáltatás hello szerepelnek.</span><span class="sxs-lookup"><span data-stu-id="bfbad-984">You do not need toodistribute your storage account key tooan insecure platform (such as a mobile device) in order tooallow that device tooaccess and modify entities in hello Table service.</span></span>  
* <span data-ttu-id="bfbad-985">A web is kiszervezése egy része hello és feldolgozói szerepkörök hajtsa végre az entitások tooclient eszközök, például a végfelhasználói számítógépek és mobileszközök kezeléséhez.</span><span class="sxs-lookup"><span data-stu-id="bfbad-985">You can offload some of hello work that web and worker roles perform in managing your entities tooclient devices such as end-user computers and mobile devices.</span></span>  
* <span data-ttu-id="bfbad-986">Hozzárendelhet egy korlátozott, és időt korlátozott engedélyek tooa ügyfél (például így csak olvasási hozzáféréssel toospecific erőforrások) készletét.</span><span class="sxs-lookup"><span data-stu-id="bfbad-986">You can assign a constrained and time limited set of permissions tooa client (such as allowing read-only access toospecific resources).</span></span>  

<span data-ttu-id="bfbad-987">SAS-tokenje hello Table szolgáltatás használatával kapcsolatban további információkért lásd: [használatával megosztott hozzáférési aláírásokkal (SAS)](storage-dotnet-shared-access-signature-part-1.md).</span><span class="sxs-lookup"><span data-stu-id="bfbad-987">For more information about using SAS tokens with hello Table service, see [Using Shared Access Signatures (SAS)](storage-dotnet-shared-access-signature-part-1.md).</span></span>  

<span data-ttu-id="bfbad-988">Azonban továbbra is kell létrehoznia, amely adja meg egy ügyfél toohello alkalmazásentitásokat a table szolgáltatás hello hello SAS-tokenje: akkor tegye ezt, amely rendelkezik biztonságos hozzáférés tooyour tárfiókkulcsok környezetben.</span><span class="sxs-lookup"><span data-stu-id="bfbad-988">However, you must still generate hello SAS tokens that grant a client application toohello entities in hello table service: you should do this in an environment that has secure access tooyour storage account keys.</span></span> <span data-ttu-id="bfbad-989">Általában egy webes vagy feldolgozói szerepkör toogenerate hello SAS jogkivonatokat, és letöltheti toohello ügyfélalkalmazások elérő tooyour entitások kell használni.</span><span class="sxs-lookup"><span data-stu-id="bfbad-989">Typically, you use a web or worker role toogenerate hello SAS tokens and deliver them toohello client applications that need access tooyour entities.</span></span> <span data-ttu-id="bfbad-990">Mivel nincs még egy terhelés létrehozása és SAS-jogkivonatok tooclients kézbesítéséhez részt, vegye figyelembe a legjobb módja tooreduce Ez a terhelés, különösen a nagy mennyiségű forgatókönyvek.</span><span class="sxs-lookup"><span data-stu-id="bfbad-990">Because there is still an overhead involved in generating and delivering SAS tokens tooclients, you should consider how best tooreduce this overhead, especially in high-volume scenarios.</span></span>  

<span data-ttu-id="bfbad-991">Már lehetséges toogenerate egy SAS-jogkivonatot, hogy a hozzáférési tooa részhalmazát hello entitások egy táblázatban.</span><span class="sxs-lookup"><span data-stu-id="bfbad-991">It is possible toogenerate a SAS token that grants access tooa subset of hello entities in a table.</span></span> <span data-ttu-id="bfbad-992">Alapértelmezés szerint a teljes táblázat egy SAS-jogkivonat létrehozása, de azt is lehetséges toospecify adott hello SAS token grant hozzáférés tooeither a számos **PartitionKey** értékeket, vagy számos **PartitionKey** és  **RowKey** értékeket.</span><span class="sxs-lookup"><span data-stu-id="bfbad-992">By default, you create a SAS token for an entire table, but it is also possible toospecify that hello SAS token grant access tooeither a range of **PartitionKey** values, or a range of **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="bfbad-993">Akkor érdemes választania toogenerate SAS-tokenje egyedi számára a rendszer úgy, hogy minden felhasználó SAS-jogkivonat csak engedélyezi tootheir saját entitások hello a table szolgáltatás.</span><span class="sxs-lookup"><span data-stu-id="bfbad-993">You might choose toogenerate SAS tokens for individual users of your system such that each user's SAS token only allows them access tootheir own entities in hello table service.</span></span>  

### <a name="asynchronous-and-parallel-operations"></a><span data-ttu-id="bfbad-994">Aszinkron és párhuzamos műveletek</span><span class="sxs-lookup"><span data-stu-id="bfbad-994">Asynchronous and parallel operations</span></span>
<span data-ttu-id="bfbad-995">A kérelmek több partíciót között vannak oszlik, feltéve aszinkron vagy párhuzamos lekérdezések használatával is javítható az átviteli sebesség és az ügyfél válaszképességét.</span><span class="sxs-lookup"><span data-stu-id="bfbad-995">Provided you are spreading your requests across multiple partitions, you can improve throughput and client responsiveness by using asynchronous or parallel queries.</span></span>
<span data-ttu-id="bfbad-996">Például lehetséges, hogy két vagy több szerepkör feldolgozópéldányok párhuzamosan a táblák elérése.</span><span class="sxs-lookup"><span data-stu-id="bfbad-996">For example, you might have two or more worker role instances accessing your tables in parallel.</span></span> <span data-ttu-id="bfbad-997">Sikerült partíciók adott készleteinek felelős az egyes feldolgozói szerepköröket használ, vagy egyszerűen a feldolgozói szerepkör több példánya, minden egyes képes tooaccess rendelkezik az összes hello partíciókat egy táblázat.</span><span class="sxs-lookup"><span data-stu-id="bfbad-997">You could have individual worker roles responsible for particular sets of partitions, or simply have multiple worker role instances, each able tooaccess all hello partitions in a table.</span></span>  

<span data-ttu-id="bfbad-998">Belül egy ügyfél példány aszinkron módon tárolási műveletek végrehajtásával javíthatja a teljesítményt.</span><span class="sxs-lookup"><span data-stu-id="bfbad-998">Within a client instance, you can improve throughput by executing storage operations asynchronously.</span></span> <span data-ttu-id="bfbad-999">a Storage ügyféloldali kódtára hello segítségével könnyen toowrite aszinkron lekérdezések és módosításokat.</span><span class="sxs-lookup"><span data-stu-id="bfbad-999">hello Storage Client Library makes it easy toowrite asynchronous queries and modifications.</span></span> <span data-ttu-id="bfbad-1000">Például előfordulhat, hogy a kiindulási pont hello szinkron módszer, amely lekéri a egy partíció összes hello entitások, ahogy az alábbi C#-kódban hello:</span><span class="sxs-lookup"><span data-stu-id="bfbad-1000">For example, you might start with hello synchronous method that retrieves all hello entities in a partition as shown in hello following C# code:</span></span>  

```csharp
private static void ManyEntitiesQuery(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

        TableContinuationToken continuationToken = null;

        do
        {
        var employees = employeeTable.ExecuteQuerySegmented(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
    {
        ...
    }
        continuationToken = employees.ContinuationToken;
        } while (continuationToken != null);
}  
```

<span data-ttu-id="bfbad-1001">Ez a kód hello lekérdezés aszinkron módon fut, könnyen módosíthatja:</span><span class="sxs-lookup"><span data-stu-id="bfbad-1001">You can easily modify this code so that hello query runs asynchronously as follows:</span></span>  

```csharp
private static async Task ManyEntitiesQueryAsync(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);
        TableContinuationToken continuationToken = null;

        do
        {
        var employees = await employeeTable.ExecuteQuerySegmentedAsync(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
        {
            ...
        }
        continuationToken = employees.ContinuationToken;
            } while (continuationToken != null);
}  
```

<span data-ttu-id="bfbad-1002">A aszinkron példában látható hello következő hello szinkron verziójáról módosításai:</span><span class="sxs-lookup"><span data-stu-id="bfbad-1002">In this asynchronous example, you can see hello following changes from hello synchronous version:</span></span>  

* <span data-ttu-id="bfbad-1003">hello metódus-aláírás mostantól tartalmazza a hello **aszinkron** módosító és értéket ad vissza egy **feladat** példány.</span><span class="sxs-lookup"><span data-stu-id="bfbad-1003">hello method signature now includes hello **async** modifier and returns a **Task** instance.</span></span>  
* <span data-ttu-id="bfbad-1004">Helyett hívó hello **ExecuteSegmented** metódus tooretrieve eredményeket, hello metódus most hívások hello **ExecuteSegmentedAsync** metódus és felhasználási hello **await** módosító tooretrieve aszinkron eredmény.</span><span class="sxs-lookup"><span data-stu-id="bfbad-1004">Instead of calling hello **ExecuteSegmented** method tooretrieve results, hello method now calls hello **ExecuteSegmentedAsync** method and uses hello **await** modifier tooretrieve results asynchronously.</span></span>  

<span data-ttu-id="bfbad-1005">hello ügyfélalkalmazás a metódus hívása többször (hello különböző értékekkel **részleg** paraméter), és minden egyes lekérdezés külön szálban futtatandó.</span><span class="sxs-lookup"><span data-stu-id="bfbad-1005">hello client application can call this method multiple times (with different values for hello **department** parameter), and each query will run on a separate thread.</span></span>  

<span data-ttu-id="bfbad-1006">Vegye figyelembe, hogy van-e nem hello aszinkron verziója **Execute** metódus a hello **TableQuery** osztálynál, mert hello **IEnumerable** illesztőfelület nem támogatja a aszinkron enumerálása.</span><span class="sxs-lookup"><span data-stu-id="bfbad-1006">Note that there is no asynchronous version of hello **Execute** method in hello **TableQuery** class because hello **IEnumerable** interface does not support asynchronous enumeration.</span></span>  

<span data-ttu-id="bfbad-1007">Helyezze, frissítése, és aszinkron módon entitások törlésére.</span><span class="sxs-lookup"><span data-stu-id="bfbad-1007">You can also insert, update, and delete entities asynchronously.</span></span> <span data-ttu-id="bfbad-1008">a következő példa C# hello egy egyszerű, a szinkron módszer tooinsert jeleníti meg, vagy alkalmazott entitás cseréje:</span><span class="sxs-lookup"><span data-stu-id="bfbad-1008">hello following C# example shows a simple, synchronous method tooinsert or replace an employee entity:</span></span>  

```csharp
private static void SimpleEmployeeUpsert(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = employeeTable
        .Execute(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

<span data-ttu-id="bfbad-1009">Ez a kód könnyen módosíthatja, így hello frissítés aszinkron módon fut:</span><span class="sxs-lookup"><span data-stu-id="bfbad-1009">You can easily modify this code so that hello update runs asynchronously as follows:</span></span>  

```csharp
private static async Task SimpleEmployeeUpsertAsync(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = await employeeTable
        .ExecuteAsync(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

<span data-ttu-id="bfbad-1010">A aszinkron példában látható hello következő hello szinkron verziójáról módosításai:</span><span class="sxs-lookup"><span data-stu-id="bfbad-1010">In this asynchronous example, you can see hello following changes from hello synchronous version:</span></span>  

* <span data-ttu-id="bfbad-1011">hello metódus-aláírás mostantól tartalmazza a hello **aszinkron** módosító és értéket ad vissza egy **feladat** példány.</span><span class="sxs-lookup"><span data-stu-id="bfbad-1011">hello method signature now includes hello **async** modifier and returns a **Task** instance.</span></span>  
* <span data-ttu-id="bfbad-1012">Helyett hívó hello **Execute** metódus tooupdate hello entitás, hello metódus most hívások hello **ExecuteAsync** metódus és felhasználási hello **await** módosító tooretrieve aszinkron módon annak az eredménye.</span><span class="sxs-lookup"><span data-stu-id="bfbad-1012">Instead of calling hello **Execute** method tooupdate hello entity, hello method now calls hello **ExecuteAsync** method and uses hello **await** modifier tooretrieve results asynchronously.</span></span>  

<span data-ttu-id="bfbad-1013">hello ügyfélalkalmazás ehhez hasonló több aszinkron metódus meghívása, és minden metódushívás külön szálban futtatandó.</span><span class="sxs-lookup"><span data-stu-id="bfbad-1013">hello client application can call multiple asynchronous methods like this one, and each method invocation will run on a separate thread.</span></span>  

### <a name="credits"></a><span data-ttu-id="bfbad-1014">Kreditek</span><span class="sxs-lookup"><span data-stu-id="bfbad-1014">Credits</span></span>
<span data-ttu-id="bfbad-1015">A következő hello hozzájárulásuk Azure-csapat tagjai toothank hello tapasztalatairól: Dominic Betts, Jason Hogg, Jean Ghanem, Jai Haridas, Jeff Irwin, Vamshidhar Kommineni, Vinay Shah Serdar Ozler, valamint a Microsoft DX Tom Hollander.</span><span class="sxs-lookup"><span data-stu-id="bfbad-1015">We would like toothank hello following members of hello Azure team for their contributions: Dominic Betts, Jason Hogg, Jean Ghanem, Jai Haridas, Jeff Irwin, Vamshidhar Kommineni, Vinay Shah and Serdar Ozler as well as  Tom Hollander from Microsoft DX.</span></span> 

<span data-ttu-id="bfbad-1016">Azt is szeretné, Microsoft MVP tekintse meg az értékes visszajelzést való felülvizsgálati ciklus során toothank hello: Igor Papirov és Edward Bakker.</span><span class="sxs-lookup"><span data-stu-id="bfbad-1016">We would also like toothank hello following Microsoft MVP's for their valuable feedback during review cycles: Igor Papirov and Edward Bakker.</span></span>

[1]: ./media/storage-table-design-guide/storage-table-design-IMAGE01.png
[2]: ./media/storage-table-design-guide/storage-table-design-IMAGE02.png
[3]: ./media/storage-table-design-guide/storage-table-design-IMAGE03.png
[4]: ./media/storage-table-design-guide/storage-table-design-IMAGE04.png
[5]: ./media/storage-table-design-guide/storage-table-design-IMAGE05.png
[6]: ./media/storage-table-design-guide/storage-table-design-IMAGE06.png
[7]: ./media/storage-table-design-guide/storage-table-design-IMAGE07.png
[8]: ./media/storage-table-design-guide/storage-table-design-IMAGE08.png
[9]: ./media/storage-table-design-guide/storage-table-design-IMAGE09.png
[10]: ./media/storage-table-design-guide/storage-table-design-IMAGE10.png
[11]: ./media/storage-table-design-guide/storage-table-design-IMAGE11.png
[12]: ./media/storage-table-design-guide/storage-table-design-IMAGE12.png
[13]: ./media/storage-table-design-guide/storage-table-design-IMAGE13.png
[14]: ./media/storage-table-design-guide/storage-table-design-IMAGE14.png
[15]: ./media/storage-table-design-guide/storage-table-design-IMAGE15.png
[16]: ./media/storage-table-design-guide/storage-table-design-IMAGE16.png
[17]: ./media/storage-table-design-guide/storage-table-design-IMAGE17.png
[18]: ./media/storage-table-design-guide/storage-table-design-IMAGE18.png
[19]: ./media/storage-table-design-guide/storage-table-design-IMAGE19.png
[20]: ./media/storage-table-design-guide/storage-table-design-IMAGE20.png
[21]: ./media/storage-table-design-guide/storage-table-design-IMAGE21.png
[22]: ./media/storage-table-design-guide/storage-table-design-IMAGE22.png
[23]: ./media/storage-table-design-guide/storage-table-design-IMAGE23.png
[24]: ./media/storage-table-design-guide/storage-table-design-IMAGE24.png
[25]: ./media/storage-table-design-guide/storage-table-design-IMAGE25.png
[26]: ./media/storage-table-design-guide/storage-table-design-IMAGE26.png
[27]: ./media/storage-table-design-guide/storage-table-design-IMAGE27.png
[28]: ./media/storage-table-design-guide/storage-table-design-IMAGE28.png
[29]: ./media/storage-table-design-guide/storage-table-design-IMAGE29.png

