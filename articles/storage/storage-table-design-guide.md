---
title: "Az Azure Storage táblázat kialakítási útmutató |} Microsoft Docs"
description: "A Tervező méretezhető és Performant táblák Azure Table Storage-ban"
services: storage
documentationcenter: na
author: jasonnewyork
manager: tadb
editor: tysonn
ms.assetid: 8e228b0c-2998-4462-8101-9f16517393ca
ms.service: storage
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: storage
ms.date: 02/28/2017
ms.author: jahogg
ms.openlocfilehash: 5ddb234cc97b3113ec865f97195c871b9f2f40d3
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 07/11/2017
---
# <a name="azure-storage-table-design-guide-designing-scalable-and-performant-tables"></a><span data-ttu-id="9e2df-103">Az Azure Storage táblázat kialakítási Útmutató: Méretezhető tervezésével és Performant táblák</span><span class="sxs-lookup"><span data-stu-id="9e2df-103">Azure Storage Table Design Guide: Designing Scalable and Performant Tables</span></span>
[!INCLUDE [storage-table-cosmos-db-tip-include](../../includes/storage-table-cosmos-db-tip-include.md)]

<span data-ttu-id="9e2df-104">A Tervező méretezhető és performant táblák, például a teljesítmény, méretezhetőség és költség tényező figyelembe kell vennie.</span><span class="sxs-lookup"><span data-stu-id="9e2df-104">To design scalable and performant tables you must consider a number of factors such as performance, scalability, and cost.</span></span> <span data-ttu-id="9e2df-105">Ha korábban létrehozott sémák a relációs adatbázisok, ezeket a szempontokat ismerős lehet, de amíg vannak bizonyos az az Azure Table storage modell és a relációs modellek közötti Hasonlóságok, is számos fontos különbségek vannak.</span><span class="sxs-lookup"><span data-stu-id="9e2df-105">If you have previously designed schemas for relational databases, these considerations will be familiar to you, but while there are some similarities between the Azure Table service storage model and relational models, there are also many important differences.</span></span> <span data-ttu-id="9e2df-106">Ezek a különbségek általában nagyon különböző kialakításokról, előfordulhat, hogy keresse meg a counter-intuitive vagy valaki ismeri a relációs adatbázisok nem megfelelő, de amelyek tegye célszerű jó például az Azure Table szolgáltatás egy NoSQL kulcs-érték tároló tervezésekor vezethet.</span><span class="sxs-lookup"><span data-stu-id="9e2df-106">These differences typically lead to very different designs that may look counter-intuitive or wrong to someone familiar with relational databases, but which do make good sense if you are designing for a NoSQL key/value store such as the Azure Table service.</span></span> <span data-ttu-id="9e2df-107">A Tervező különbségek számos módon változik meg a tényt, hogy a Table szolgáltatás célja, hogy az entitások (relációs adatbázis-terminológia sorainak) vagy olyan adatkészletekhez, amelyek rendkívül nagy tranzakció kötetek támogatnia kell az adatok több milliárd tartalmazó felhőméretű alkalmazások támogatását: ezért figyelembe kell vennie eltérően, hogyan tárolja az adatait, és a Table szolgáltatás működésének megismerése.</span><span class="sxs-lookup"><span data-stu-id="9e2df-107">Many of your design differences will reflect the fact that the Table service is designed to support cloud-scale applications that can contain billions of entities (rows in relational database terminology) of data or for datasets that must support very high transaction volumes: therefore, you need to think differently about how you store your data and understand how the Table service works.</span></span> <span data-ttu-id="9e2df-108">Egy jól kidolgozott NoSQL-adattár engedélyezheti a megoldás méretezése sokkal tovább (és alacsonyabb költségekkel) mint olyan megoldás, amely egy relációs adatbázist használ.</span><span class="sxs-lookup"><span data-stu-id="9e2df-108">A well designed NoSQL data store can enable your solution to scale much further (and at a lower cost) than a solution that uses a relational database.</span></span> <span data-ttu-id="9e2df-109">Az útmutató az alábbi témakörök segítségével.</span><span class="sxs-lookup"><span data-stu-id="9e2df-109">This guide helps you with these topics.</span></span>  

## <a name="about-the-azure-table-service"></a><span data-ttu-id="9e2df-110">Az Azure Table szolgáltatással kapcsolatos</span><span class="sxs-lookup"><span data-stu-id="9e2df-110">About the Azure Table service</span></span>
<span data-ttu-id="9e2df-111">Ez a szakasz azt mutatja be néhány fő funkciója a Table szolgáltatás szempontjából különösen teljesítményének és méretezhetőségének tervezése.</span><span class="sxs-lookup"><span data-stu-id="9e2df-111">This section highlights some of the key features of the Table service that are especially relevant to designing for performance and scalability.</span></span> <span data-ttu-id="9e2df-112">Ha most ismerkedik az Azure Storage és a Table szolgáltatás, elolvashatja [Microsoft Azure Storage bemutatása](storage-introduction.md) és [Ismerkedés az Azure Table Storage használatának .NET](storage-dotnet-how-to-use-tables.md) további része a cikk elolvasása előtt.</span><span class="sxs-lookup"><span data-stu-id="9e2df-112">If you are new to Azure Storage and the Table service, first read [Introduction to Microsoft Azure Storage](storage-introduction.md) and [Get started with Azure Table Storage using .NET](storage-dotnet-how-to-use-tables.md) before reading the remainder of this article.</span></span> <span data-ttu-id="9e2df-113">Bár ez az útmutató célja azoknak a Table szolgáltatásban, ez magában foglalja a néhány semmiről nem kell az Azure üzenetsor és a Blob szolgáltatás, és hogyan használhatja őket a megoldás a Table szolgáltatás együtt.</span><span class="sxs-lookup"><span data-stu-id="9e2df-113">Although the focus of this guide is on the Table service, it will include some discussion of the Azure Queue and Blob services, and how you might use them along with the Table service in a solution.</span></span>  

<span data-ttu-id="9e2df-114">Mi az a Table szolgáltatás?</span><span class="sxs-lookup"><span data-stu-id="9e2df-114">What is the Table service?</span></span> <span data-ttu-id="9e2df-115">Előfordulhat, hogy a neve alapján várt, a Table szolgáltatás táblázatos formátumú adatok használ.</span><span class="sxs-lookup"><span data-stu-id="9e2df-115">As you might expect from the name, the Table service uses a tabular format to store data.</span></span> <span data-ttu-id="9e2df-116">A ismertetésében a tábla minden egyes sorára jelöli egy entitás, és az oszlopok tárolja, hogy az entitás tulajdonságait.</span><span class="sxs-lookup"><span data-stu-id="9e2df-116">In the standard terminology, each row of the table represents an entity, and the columns store the various properties of that entity.</span></span> <span data-ttu-id="9e2df-117">Minden entitás egy kulcspárra van szüksége, egyedi azonosításához, és a Timestamp típusú oszlop, amely a Table szolgáltatás segítségével nyomon követheti az entitás legutóbbi frissítése (Ez automatikusan megtörténik, és adjon meg egy tetszőleges értéket nem lehet felülírni a Timestamp típusú manuálisan).</span><span class="sxs-lookup"><span data-stu-id="9e2df-117">Every entity has a pair of keys to uniquely identify it, and a timestamp column that the Table service uses to track when the entity was last updated (this happens automatically and you cannot manually overwrite the timestamp with an arbitrary value).</span></span> <span data-ttu-id="9e2df-118">A Table szolgáltatás az utolsó módosításának időbélyegző (LMT) egyidejű hozzáférések optimista kezelésére használ.</span><span class="sxs-lookup"><span data-stu-id="9e2df-118">The Table service uses this last-modified timestamp (LMT) to manage optimistic concurrency.</span></span>  

> [!NOTE]
> <span data-ttu-id="9e2df-119">A Table szolgáltatás REST API-műveleteket is vissza egy **ETag** érték, amely azt a last-modified időbélyeg (LMT) származik.</span><span class="sxs-lookup"><span data-stu-id="9e2df-119">The Table service REST API operations also return an **ETag** value that it derives from the last-modified timestamp (LMT).</span></span> <span data-ttu-id="9e2df-120">Ebben a dokumentumban lesz a kifejezéseket használjuk ETag és LMT azonos értelemben mert ugyanazokat az alapul szolgáló adatokat hivatkoznak.</span><span class="sxs-lookup"><span data-stu-id="9e2df-120">In this document we will use the terms ETag and LMT interchangeably because they refer to the same underlying data.</span></span>  
> 
> 

<span data-ttu-id="9e2df-121">Az alábbi példában egy egyszerű Táblatervezés alkalmazott és részleg entitások tárolásához.</span><span class="sxs-lookup"><span data-stu-id="9e2df-121">The following example shows a simple table design to store employee and department entities.</span></span> <span data-ttu-id="9e2df-122">Ez a kialakítás egyszerű számos az útmutató későbbi részében látható példája alapul.</span><span class="sxs-lookup"><span data-stu-id="9e2df-122">Many of the examples shown later in this guide are based on this simple design.</span></span>  

<table>
<tr>
<th><span data-ttu-id="9e2df-123">PartitionKey</span><span class="sxs-lookup"><span data-stu-id="9e2df-123">PartitionKey</span></span></th>
<th><span data-ttu-id="9e2df-124">RowKey</span><span class="sxs-lookup"><span data-stu-id="9e2df-124">RowKey</span></span></th>
<th><span data-ttu-id="9e2df-125">időbélyeg</span><span class="sxs-lookup"><span data-stu-id="9e2df-125">Timestamp</span></span></th>
<th></th>
</tr>
<tr>
<td><span data-ttu-id="9e2df-126">Marketing</span><span class="sxs-lookup"><span data-stu-id="9e2df-126">Marketing</span></span></td>
<td><span data-ttu-id="9e2df-127">00001</span><span class="sxs-lookup"><span data-stu-id="9e2df-127">00001</span></span></td>
<td><span data-ttu-id="9e2df-128">2014-08-22T00:50:32Z</span><span class="sxs-lookup"><span data-stu-id="9e2df-128">2014-08-22T00:50:32Z</span></span></td>
<td>
<table>
<tr>
<th><span data-ttu-id="9e2df-129">Utónév</span><span class="sxs-lookup"><span data-stu-id="9e2df-129">FirstName</span></span></th>
<th><span data-ttu-id="9e2df-130">Vezetéknév</span><span class="sxs-lookup"><span data-stu-id="9e2df-130">LastName</span></span></th>
<th><span data-ttu-id="9e2df-131">Kor</span><span class="sxs-lookup"><span data-stu-id="9e2df-131">Age</span></span></th>
<th><span data-ttu-id="9e2df-132">E-mail cím</span><span class="sxs-lookup"><span data-stu-id="9e2df-132">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="9e2df-133">Nincs</span><span class="sxs-lookup"><span data-stu-id="9e2df-133">Don</span></span></td>
<td><span data-ttu-id="9e2df-134">Hall</span><span class="sxs-lookup"><span data-stu-id="9e2df-134">Hall</span></span></td>
<td><span data-ttu-id="9e2df-135">34</span><span class="sxs-lookup"><span data-stu-id="9e2df-135">34</span></span></td>
<td>donh@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td><span data-ttu-id="9e2df-136">Marketing</span><span class="sxs-lookup"><span data-stu-id="9e2df-136">Marketing</span></span></td>
<td><span data-ttu-id="9e2df-137">00002</span><span class="sxs-lookup"><span data-stu-id="9e2df-137">00002</span></span></td>
<td><span data-ttu-id="9e2df-138">2014-08-22T00:50:34Z</span><span class="sxs-lookup"><span data-stu-id="9e2df-138">2014-08-22T00:50:34Z</span></span></td>
<td>
<table>
<tr>
<th><span data-ttu-id="9e2df-139">Utónév</span><span class="sxs-lookup"><span data-stu-id="9e2df-139">FirstName</span></span></th>
<th><span data-ttu-id="9e2df-140">Vezetéknév</span><span class="sxs-lookup"><span data-stu-id="9e2df-140">LastName</span></span></th>
<th><span data-ttu-id="9e2df-141">Kor</span><span class="sxs-lookup"><span data-stu-id="9e2df-141">Age</span></span></th>
<th><span data-ttu-id="9e2df-142">E-mail cím</span><span class="sxs-lookup"><span data-stu-id="9e2df-142">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="9e2df-143">Jún</span><span class="sxs-lookup"><span data-stu-id="9e2df-143">Jun</span></span></td>
<td><span data-ttu-id="9e2df-144">CaO</span><span class="sxs-lookup"><span data-stu-id="9e2df-144">Cao</span></span></td>
<td><span data-ttu-id="9e2df-145">47</span><span class="sxs-lookup"><span data-stu-id="9e2df-145">47</span></span></td>
<td>junc@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td><span data-ttu-id="9e2df-146">Marketing</span><span class="sxs-lookup"><span data-stu-id="9e2df-146">Marketing</span></span></td>
<td><span data-ttu-id="9e2df-147">Szervezeti egység</span><span class="sxs-lookup"><span data-stu-id="9e2df-147">Department</span></span></td>
<td><span data-ttu-id="9e2df-148">2014-08-22T00:50:30Z</span><span class="sxs-lookup"><span data-stu-id="9e2df-148">2014-08-22T00:50:30Z</span></span></td>
<td>
<table>
<tr>
<th><span data-ttu-id="9e2df-149">departmentname nevű</span><span class="sxs-lookup"><span data-stu-id="9e2df-149">DepartmentName</span></span></th>
<th><span data-ttu-id="9e2df-150">EmployeeCount</span><span class="sxs-lookup"><span data-stu-id="9e2df-150">EmployeeCount</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="9e2df-151">Marketing</span><span class="sxs-lookup"><span data-stu-id="9e2df-151">Marketing</span></span></td>
<td><span data-ttu-id="9e2df-152">153</span><span class="sxs-lookup"><span data-stu-id="9e2df-152">153</span></span></td>
</tr>
</table>
</td>
</tr>
<tr>
<td><span data-ttu-id="9e2df-153">Értékesítés</span><span class="sxs-lookup"><span data-stu-id="9e2df-153">Sales</span></span></td>
<td><span data-ttu-id="9e2df-154">00010</span><span class="sxs-lookup"><span data-stu-id="9e2df-154">00010</span></span></td>
<td><span data-ttu-id="9e2df-155">2014-08-22T00:50:44Z</span><span class="sxs-lookup"><span data-stu-id="9e2df-155">2014-08-22T00:50:44Z</span></span></td>
<td>
<table>
<tr>
<th><span data-ttu-id="9e2df-156">Utónév</span><span class="sxs-lookup"><span data-stu-id="9e2df-156">FirstName</span></span></th>
<th><span data-ttu-id="9e2df-157">Vezetéknév</span><span class="sxs-lookup"><span data-stu-id="9e2df-157">LastName</span></span></th>
<th><span data-ttu-id="9e2df-158">Kor</span><span class="sxs-lookup"><span data-stu-id="9e2df-158">Age</span></span></th>
<th><span data-ttu-id="9e2df-159">E-mail cím</span><span class="sxs-lookup"><span data-stu-id="9e2df-159">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="9e2df-160">Ken</span><span class="sxs-lookup"><span data-stu-id="9e2df-160">Ken</span></span></td>
<td><span data-ttu-id="9e2df-161">Kwok</span><span class="sxs-lookup"><span data-stu-id="9e2df-161">Kwok</span></span></td>
<td><span data-ttu-id="9e2df-162">23</span><span class="sxs-lookup"><span data-stu-id="9e2df-162">23</span></span></td>
<td>kenk@contoso.com</td>
</tr>
</table>
</td>
</tr>
</table>


<span data-ttu-id="9e2df-163">Az eddigi Ez hasonlít nagyon a egy relációs adatbázisban a legfőbb különbségek a kötelező oszlopok, és ugyanabban a táblában több entitástípusok tárolásának képessége.</span><span class="sxs-lookup"><span data-stu-id="9e2df-163">So far, this looks very similar to a table in a relational database with the key differences being the mandatory columns, and the ability to store multiple entity types in the same table.</span></span> <span data-ttu-id="9e2df-164">Emellett egyes többek között a felhasználó által definiált tulajdonságok **Keresztnév** vagy **kora** adattípusú, például az egész szám vagy karakterlánc, csak, például egy relációs adatbázisban oszlop.</span><span class="sxs-lookup"><span data-stu-id="9e2df-164">In addition, each of the user-defined properties such as **FirstName** or **Age** has a data type, such as integer or string, just like a column in a relational database.</span></span> <span data-ttu-id="9e2df-165">Bár eltérően egy relációs adatbázisban, a Table szolgáltatás séma nélküli jellege azt jelenti, hogy a tulajdonság nem szükséges minden entitáshoz ugyanolyan adattípusúak.</span><span class="sxs-lookup"><span data-stu-id="9e2df-165">Although unlike in a relational database, the schema-less nature of the Table service means that a property need not have the same data type on each entity.</span></span> <span data-ttu-id="9e2df-166">Összetett adattípusú egy adott tulajdonságra vannak tárolva, például a JSON- vagy XML-szerializált formátum kell használnia.</span><span class="sxs-lookup"><span data-stu-id="9e2df-166">To store complex data types in a single property, you must use a serialized format such as JSON or XML.</span></span> <span data-ttu-id="9e2df-167">A table szolgáltatás például a támogatott adattípusok, támogatott dátumtartományok, elnevezési szabályok és mérete megkötések kapcsolatos további információkért lásd: [ismertetése a Table szolgáltatás adatmodell](http://msdn.microsoft.com/library/azure/dd179338.aspx).</span><span class="sxs-lookup"><span data-stu-id="9e2df-167">For more information about the table service such as supported data types, supported date ranges, naming rules, and size constraints, see [Understanding the Table Service Data Model](http://msdn.microsoft.com/library/azure/dd179338.aspx).</span></span>

<span data-ttu-id="9e2df-168">Mivel látni fogja, a választott **PartitionKey** és **RowKey** jó Táblatervezés alapvető.</span><span class="sxs-lookup"><span data-stu-id="9e2df-168">As you will see, your choice of **PartitionKey** and **RowKey** is fundamental to good table design.</span></span> <span data-ttu-id="9e2df-169">Minden entitás egy táblázatban tárolja rendelkeznie kell egy egyedi kombinációja **PartitionKey** és **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="9e2df-169">Every entity stored in a table must have a unique combination of **PartitionKey** and **RowKey**.</span></span> <span data-ttu-id="9e2df-170">Csakúgy, mint a kulcsokat egy relációs adatbázis tábláinak a **PartitionKey** és **RowKey** értékek egy fürtözött index, amely lehetővé teszi, hogy a gyors look-ups indexelt; azonban a Table szolgáltatás nem hoz létre az bármely másodlagos indexek, és így ezek a csak két az indexelt tulajdonságok (néhány későbbi mintázatokat megjelenítése hogyan oldható meg a nyilvánvaló korlátozás).</span><span class="sxs-lookup"><span data-stu-id="9e2df-170">As with keys in a relational database table, the **PartitionKey** and **RowKey** values are indexed to create a clustered index that enables fast look-ups; however, the Table service does not create any secondary indexes so these are the only two indexed properties (some of the patterns described later show how you can work around this apparent limitation).</span></span>  

<span data-ttu-id="9e2df-171">Egy tábla egy vagy több partíció épül fel, és látni fogja, a tervezési döntéseit számos lesz körül kiválasztása megfelelő **PartitionKey** és **RowKey** a megoldás optimalizálása érdekében.</span><span class="sxs-lookup"><span data-stu-id="9e2df-171">A table is made up of one or more partitions, and as you will see, many of the design decisions you make will be around choosing a suitable **PartitionKey** and **RowKey** to optimize your solution.</span></span> <span data-ttu-id="9e2df-172">A megoldás csak egyetlen tábla összes, a partíciók szervezve entitásokat tartalmazó sikerült alkotják, de általában egy megoldás több táblák esetében.</span><span class="sxs-lookup"><span data-stu-id="9e2df-172">A solution could consist of just a single table that contains all your entities organized into partitions, but typically a solution will have multiple tables.</span></span> <span data-ttu-id="9e2df-173">Táblázatok segítséget logikailag rendezheti az entitások, a hozzáférés-vezérlési listák segítségével adataihoz való hozzáférés kezeléséhez nyújt segítséget, és egyetlen tárolási művelettel teljes táblázat elvetné.</span><span class="sxs-lookup"><span data-stu-id="9e2df-173">Tables help you to logically organize your entities, help you manage access to the data using access control lists, and you can drop an entire table using a single storage operation.</span></span>  

### <a name="table-partitions"></a><span data-ttu-id="9e2df-174">Táblapartíciók</span><span class="sxs-lookup"><span data-stu-id="9e2df-174">Table partitions</span></span>
<span data-ttu-id="9e2df-175">A fiók neve, a tábla nevét és **PartitionKey** együtt azonosíthatja a partíción belül a társzolgáltatás, ahol a table szolgáltatás tárolja az entitás.</span><span class="sxs-lookup"><span data-stu-id="9e2df-175">The account name, table name and **PartitionKey** together identify the partition within the storage service where the table service stores the entity.</span></span> <span data-ttu-id="9e2df-176">Amellett, hogy az entitások címzési séma része, a partíciók az egyes tranzakciókra vonatkozóan hatókör meghatározása (lásd: [entitás csoport tranzakciók](#entity-group-transactions) alább), és hogyan méretezze át a table szolgáltatás alapját.</span><span class="sxs-lookup"><span data-stu-id="9e2df-176">As well as being part of the addressing scheme for entities, partitions define a scope for transactions (see [Entity Group Transactions](#entity-group-transactions) below), and form the basis of how the table service scales.</span></span> <span data-ttu-id="9e2df-177">További információk a partíciókon: [Azure Storage méretezhetőségi és teljesítménycéloknak](storage-scalability-targets.md).</span><span class="sxs-lookup"><span data-stu-id="9e2df-177">For more information on partitions see [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span></span>  

<span data-ttu-id="9e2df-178">A Table szolgáltatásban, az egyes csomópontok szolgáltatások egy vagy több befejezéseként partíciókat és a szolgáltatás méretezik dinamikus terheléselosztás partíciók csomópontjai között.</span><span class="sxs-lookup"><span data-stu-id="9e2df-178">In the Table service, an individual node services one or more complete partitions and the service scales by dynamically load-balancing partitions across nodes.</span></span> <span data-ttu-id="9e2df-179">Egy csomópont terhelésnek van kitéve, ha a table szolgáltatás is *vágási* a partíciók száma a tartományon, más csomópontok csomópont által kiszolgált; enyhül forgalmat, ha a szolgáltatás képes *egyesítési* csendes csomópontjáról partíció tartományok biztonsági alakzatot egyetlen csomópont.</span><span class="sxs-lookup"><span data-stu-id="9e2df-179">If a node is under load, the table service can *split* the range of partitions serviced by that node onto different nodes; when traffic subsides, the service can *merge* the partition ranges from quiet nodes back onto a single node.</span></span>  

<span data-ttu-id="9e2df-180">További információ a belső részleteit a Table szolgáltatás, és ebben az esetben a szolgáltatás kezeli a partíciók, hogyan talál a [Microsoft Azure Storage: A magas rendelkezésre álló felhőalapú tárolási szolgáltatásba az erős konzisztencia](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx).</span><span class="sxs-lookup"><span data-stu-id="9e2df-180">For more information about the internal details of the Table service, and in particular how the service manages partitions, see the paper [Microsoft Azure Storage: A Highly Available Cloud Storage Service with Strong Consistency](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx).</span></span>  

### <a name="entity-group-transactions"></a><span data-ttu-id="9e2df-181">Entitás csoport tranzakciók</span><span class="sxs-lookup"><span data-stu-id="9e2df-181">Entity Group Transactions</span></span>
<span data-ttu-id="9e2df-182">A Table szolgáltatásban entitás csoport tranzakciók (EGTs) atomi frissítések végrehajtásához a több egység közötti csak beépített mechanizmus.</span><span class="sxs-lookup"><span data-stu-id="9e2df-182">In the Table service, Entity Group Transactions (EGTs) are the only built-in mechanism for performing atomic updates across multiple entities.</span></span> <span data-ttu-id="9e2df-183">EGTs is nevezzük *kötegelt tranzakciókat* bizonyos dokumentációkban.</span><span class="sxs-lookup"><span data-stu-id="9e2df-183">EGTs are also referred to as *batch transactions* in some documentation.</span></span> <span data-ttu-id="9e2df-184">EGTs csak működhessenek entitások tárolt partícióra (ugyanazzal a partíciókulccsal egy adott táblában megosztás), így bármikor atomi tranzakciós viselkedését kell gondoskodnia kell arról, hogy ezeket az entitásokat tartalmazó partícióra vannak több egység közötti.</span><span class="sxs-lookup"><span data-stu-id="9e2df-184">EGTs can only operate on entities stored in the same partition (share the same partition key in a given table), so anytime you need atomic transactional behavior across multiple entities you need to ensure that those entities are in the same partition.</span></span> <span data-ttu-id="9e2df-185">Ez gyakran az több entitástípusok megőrzi a ugyanahhoz a táblához (és a partíció) található, és több tábla nem használ másik entitástípusok okát.</span><span class="sxs-lookup"><span data-stu-id="9e2df-185">This is often a reason for keeping multiple entity types in the same table (and partition) and not using multiple tables for different entity types.</span></span> <span data-ttu-id="9e2df-186">Egyetlen EGT legfeljebb 100 entitást is működik.</span><span class="sxs-lookup"><span data-stu-id="9e2df-186">A single EGT can operate on at most 100 entities.</span></span>  <span data-ttu-id="9e2df-187">Ha több egyidejű EGTs is fontos, hogy ezek EGTs működés nem lehetséges, amelyek közösek a EGTs között, mivel ellenkező esetben feldolgozása késleltethető entitások feldolgozásra.</span><span class="sxs-lookup"><span data-stu-id="9e2df-187">If you submit multiple concurrent EGTs for processing it is important to ensure  those EGTs do not operate on entities that are common across EGTs as otherwise processing can be delayed.</span></span>

<span data-ttu-id="9e2df-188">EGTs is vezethet, hogy kipróbálhassa a Tervező egy potenciális kompromisszum: több partíciót használata növeli a méretezhetőség, az alkalmazás Azure-csomópontokon keresztüli kérelmek terheléselosztási további lehetőségekkel rendelkezik, de ez korlátozhatja a lehetőségét, mert az alkalmazás atomi tranzakciók elvégzéséhez, és erős konzisztenciát biztosít az adatok karbantartása.</span><span class="sxs-lookup"><span data-stu-id="9e2df-188">EGTs also introduce a potential trade-off for you to evaluate in your design: using more partitions will increase the scalability of your application because Azure has more opportunities for load balancing requests across nodes, but this might limit the ability of your application to perform atomic transactions and maintain strong consistency for your data.</span></span> <span data-ttu-id="9e2df-189">Emellett nincsenek egyedi méretezhetőségi célok javasoljuk, hogy előfordulhat, hogy korlátozza az egyetlen csomópont számíthat tranzakciók átviteli szinten: az Azure storage-fiókok és a table szolgáltatás vonatkozó méretezhetőségi célok kapcsolatos további információkért lásd: [Az azure Storage méretezhetőségi és teljesítménycéloknak](storage-scalability-targets.md).</span><span class="sxs-lookup"><span data-stu-id="9e2df-189">Furthermore, there are specific scalability targets at the level of a partition that might limit the throughput of transactions you can expect for a single node: for more information about the scalability targets for Azure storage accounts and the table service, see [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span></span> <span data-ttu-id="9e2df-190">A jelen útmutató későbbi szakaszok tárgyalják különböző kialakítási stratégiák, amelyek segítenek kompromisszumot alakítson ki például a kezelése, és hogyan érdemes ismertetik a partíciós kulcs, az ügyfélalkalmazás a meghatározott követelmények alapján kiválaszthatja.</span><span class="sxs-lookup"><span data-stu-id="9e2df-190">Later sections of this guide discuss various design strategies that help you manage trade-offs such as this one, and discuss how best to choose your partition key based on the specific requirements of your client application.</span></span>  

### <a name="capacity-considerations"></a><span data-ttu-id="9e2df-191">A kapacitás kapcsolatos szempontok</span><span class="sxs-lookup"><span data-stu-id="9e2df-191">Capacity considerations</span></span>
<span data-ttu-id="9e2df-192">Az alábbi táblázat tartalmaz néhány érdemes figyelembe vennie, amikor tervezésekor a Table szolgáltatás megoldás értékek:</span><span class="sxs-lookup"><span data-stu-id="9e2df-192">The following table includes some of the key values to be aware of when you are designing a Table service solution:</span></span>  

| <span data-ttu-id="9e2df-193">Az Azure storage-fiók teljes kapacitás</span><span class="sxs-lookup"><span data-stu-id="9e2df-193">Total capacity of an Azure storage account</span></span> | <span data-ttu-id="9e2df-194">500 TB</span><span class="sxs-lookup"><span data-stu-id="9e2df-194">500 TB</span></span> |
| --- | --- |
| <span data-ttu-id="9e2df-195">Egy Azure storage-fiókot a táblák száma</span><span class="sxs-lookup"><span data-stu-id="9e2df-195">Number of tables in an Azure storage account</span></span> |<span data-ttu-id="9e2df-196">Csak a tárfiók kapacitásának korlátozva</span><span class="sxs-lookup"><span data-stu-id="9e2df-196">Limited only by the capacity of the storage account</span></span> |
| <span data-ttu-id="9e2df-197">Egy tábla partíciók száma</span><span class="sxs-lookup"><span data-stu-id="9e2df-197">Number of partitions in a table</span></span> |<span data-ttu-id="9e2df-198">Csak a tárfiók kapacitásának korlátozva</span><span class="sxs-lookup"><span data-stu-id="9e2df-198">Limited only by the capacity of the storage account</span></span> |
| <span data-ttu-id="9e2df-199">Partíció entitástartományának száma</span><span class="sxs-lookup"><span data-stu-id="9e2df-199">Number of entities in a partition</span></span> |<span data-ttu-id="9e2df-200">Csak a tárfiók kapacitásának korlátozva</span><span class="sxs-lookup"><span data-stu-id="9e2df-200">Limited only by the capacity of the storage account</span></span> |
| <span data-ttu-id="9e2df-201">Az egyes entitás mérete</span><span class="sxs-lookup"><span data-stu-id="9e2df-201">Size of an individual entity</span></span> |<span data-ttu-id="9e2df-202">Legfeljebb 255 tulajdonságok legfeljebb 1 MB (beleértve a **PartitionKey**, **RowKey**, és **időbélyeg**)</span><span class="sxs-lookup"><span data-stu-id="9e2df-202">Up to 1 MB with a maximum of 255 properties (including the **PartitionKey**, **RowKey**, and **Timestamp**)</span></span> |
| <span data-ttu-id="9e2df-203">A méret a **PartitionKey**</span><span class="sxs-lookup"><span data-stu-id="9e2df-203">Size of the **PartitionKey**</span></span> |<span data-ttu-id="9e2df-204">A karakterlánc legfeljebb 1 KB méretű</span><span class="sxs-lookup"><span data-stu-id="9e2df-204">A string up to 1 KB in size</span></span> |
| <span data-ttu-id="9e2df-205">A méret a **RowKey**</span><span class="sxs-lookup"><span data-stu-id="9e2df-205">Size of the **RowKey**</span></span> |<span data-ttu-id="9e2df-206">A karakterlánc legfeljebb 1 KB méretű</span><span class="sxs-lookup"><span data-stu-id="9e2df-206">A string up to 1 KB in size</span></span> |
| <span data-ttu-id="9e2df-207">Egy entitás csoport tranzakció mérete</span><span class="sxs-lookup"><span data-stu-id="9e2df-207">Size of an Entity Group Transaction</span></span> |<span data-ttu-id="9e2df-208">Egy tranzakció legfeljebb 100 entitást tartalmazhat, és a tartalom 4 MB-nál kevesebb kell lennie.</span><span class="sxs-lookup"><span data-stu-id="9e2df-208">A transaction can include at most 100 entities and the payload must be less than 4 MB in size.</span></span> <span data-ttu-id="9e2df-209">Egy EGT csak frissíthető entitás egyszer.</span><span class="sxs-lookup"><span data-stu-id="9e2df-209">An EGT can only update an entity once.</span></span> |

<span data-ttu-id="9e2df-210">További információkért lásd: [ismertetése a Table szolgáltatás adatmodell](http://msdn.microsoft.com/library/azure/dd179338.aspx).</span><span class="sxs-lookup"><span data-stu-id="9e2df-210">For more information, see [Understanding the Table Service Data Model](http://msdn.microsoft.com/library/azure/dd179338.aspx).</span></span>  

### <a name="cost-considerations"></a><span data-ttu-id="9e2df-211">Költség kapcsolatos szempontok</span><span class="sxs-lookup"><span data-stu-id="9e2df-211">Cost considerations</span></span>
<span data-ttu-id="9e2df-212">A TABLE storage költségei viszonylag alacsonyak, de a Table szolgáltatás használó megoldások próbaidőszakában részeként tartalmaznia kell a kapacitás és a tranzakciók mennyisége költség becslése.</span><span class="sxs-lookup"><span data-stu-id="9e2df-212">Table storage is relatively inexpensive, but you should include cost estimates for both capacity usage and the quantity of transactions as part of your evaluation of any solution that uses the Table service.</span></span> <span data-ttu-id="9e2df-213">Azonban számos forgatókönyvben denormalizált vagy ismétlődő adatok tárolására javítása érdekében a teljesítmény vagy a méretezhetőség miatt a megoldás nem egy érvényes megközelítés érvénybe.</span><span class="sxs-lookup"><span data-stu-id="9e2df-213">However, in many scenarios storing denormalized or duplicate data in order to improve the performance or scalability of your solution is a valid approach to take.</span></span> <span data-ttu-id="9e2df-214">Az árazással kapcsolatos további információkért lásd: [Azure Storage szolgáltatás díjszabása](https://azure.microsoft.com/pricing/details/storage/).</span><span class="sxs-lookup"><span data-stu-id="9e2df-214">For more information about pricing, see [Azure Storage Pricing](https://azure.microsoft.com/pricing/details/storage/).</span></span>  

## <a name="guidelines-for-table-design"></a><span data-ttu-id="9e2df-215">Táblatervezés vonatkozó irányelvek</span><span class="sxs-lookup"><span data-stu-id="9e2df-215">Guidelines for table design</span></span>
<span data-ttu-id="9e2df-216">A listák összesítésének néhány a kulcs irányelveket kell figyelembe venni a táblák tervezése során, és ez az útmutató foglalkozni fog velük az összes későbbi részében részletesebben.</span><span class="sxs-lookup"><span data-stu-id="9e2df-216">These lists summarize some of the key guidelines you should keep in mind when you are designing your tables, and this guide will address them all in more detail later in.</span></span> <span data-ttu-id="9e2df-217">Ezeket az irányelveket nagyon eltérnek a általában végrehajtania a relációs adatbázis tervezési irányelveket.</span><span class="sxs-lookup"><span data-stu-id="9e2df-217">These guidelines are very different from the guidelines you would typically follow for relational database design.</span></span>  

<span data-ttu-id="9e2df-218">A Table szolgáltatás megoldás kell tervezése *olvasási* hatékony:</span><span class="sxs-lookup"><span data-stu-id="9e2df-218">Designing your Table service solution to be *read* efficient:</span></span>

* <span data-ttu-id="9e2df-219">***Tervezze meg az olvasási műveleteket alkalmazásokban lekérdezése.***</span><span class="sxs-lookup"><span data-stu-id="9e2df-219">***Design for querying in read-heavy applications.***</span></span> <span data-ttu-id="9e2df-220">A táblák tervezésekor gondolja át a lekérdezések (különösen a várakozási bizalmas is), amely, végrehajtja a véleménye hogyan frissíti az entitások előtt.</span><span class="sxs-lookup"><span data-stu-id="9e2df-220">When you are designing your tables, think about the queries (especially the latency sensitive ones) that you will execute before you think about how you will update your entities.</span></span> <span data-ttu-id="9e2df-221">Ez általában annak az eredménye a hatékony és performant megoldás.</span><span class="sxs-lookup"><span data-stu-id="9e2df-221">This typically results in an efficient and performant solution.</span></span>  
* <span data-ttu-id="9e2df-222">***Adja meg a lekérdezések PartitionKey és RowKey is.***</span><span class="sxs-lookup"><span data-stu-id="9e2df-222">***Specify both PartitionKey and RowKey in your queries.***</span></span> <span data-ttu-id="9e2df-223">*Mutasson a lekérdezések* például ezek azok a leghatékonyabb tábla szolgáltatás lekérdezéseket.</span><span class="sxs-lookup"><span data-stu-id="9e2df-223">*Point queries* such as these are the most efficient table service queries.</span></span>  
* <span data-ttu-id="9e2df-224">***Érdemes tárolni a duplikált entitásokat.***</span><span class="sxs-lookup"><span data-stu-id="9e2df-224">***Consider storing duplicate copies of entities.***</span></span> <span data-ttu-id="9e2df-225">A TABLE storage olcsó, érdemes a ugyanaz az entitás tárolni többször (különböző kulccsal rendelkező) a hatékonyabb lekérdezések engedélyezéséhez.</span><span class="sxs-lookup"><span data-stu-id="9e2df-225">Table storage is cheap so consider storing the same entity multiple times (with different keys) to enable more efficient queries.</span></span>  
* <span data-ttu-id="9e2df-226">***Vegye figyelembe az adatok denormalizing.***</span><span class="sxs-lookup"><span data-stu-id="9e2df-226">***Consider denormalizing your data.***</span></span> <span data-ttu-id="9e2df-227">A TABLE storage olcsó ezért fontolja meg az adatok denormalizing.</span><span class="sxs-lookup"><span data-stu-id="9e2df-227">Table storage is cheap so consider denormalizing your data.</span></span> <span data-ttu-id="9e2df-228">Összegző entitások például tárolja, hogy az összesített adatok lekérdezések csak egyetlen entitáshoz eléréséhez szükséges.</span><span class="sxs-lookup"><span data-stu-id="9e2df-228">For example, store summary entities so that queries for aggregate data only need to access a single entity.</span></span>  
* <span data-ttu-id="9e2df-229">***Használja az összetett kulcs értékeket.***</span><span class="sxs-lookup"><span data-stu-id="9e2df-229">***Use compound key values.***</span></span> <span data-ttu-id="9e2df-230">A csak akkor kulcsokban **PartitionKey** és **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="9e2df-230">The only keys you have are **PartitionKey** and **RowKey**.</span></span> <span data-ttu-id="9e2df-231">Például összetett kulcsértékei használatával engedélyezze a másodlagos kulccsal elérési utakat a részére.</span><span class="sxs-lookup"><span data-stu-id="9e2df-231">For example, use compound key values to enable alternate keyed access paths to entities.</span></span>  
* <span data-ttu-id="9e2df-232">***Lekérdezés vetítéshez használni.***</span><span class="sxs-lookup"><span data-stu-id="9e2df-232">***Use query projection.***</span></span> <span data-ttu-id="9e2df-233">Válassza ki a szükséges mezők lekérdezésekkel a hálózati átvitel adatmennyiség csökkentése érdekében.</span><span class="sxs-lookup"><span data-stu-id="9e2df-233">You can reduce the amount of data that you transfer over the network by using queries that select just the fields you need.</span></span>  

<span data-ttu-id="9e2df-234">A Table szolgáltatás megoldás kell tervezése *írási* hatékony:</span><span class="sxs-lookup"><span data-stu-id="9e2df-234">Designing your Table service solution to be *write* efficient:</span></span>  

* <span data-ttu-id="9e2df-235">***Ne hozzon létre a gyakran használt adatok partíciókat.***</span><span class="sxs-lookup"><span data-stu-id="9e2df-235">***Do not create hot partitions.***</span></span> <span data-ttu-id="9e2df-236">Válassza ki a kulcsokat, amelyek lehetővé teszik, hogy a kérelmek elosztva idő minden helyen több partíciót.</span><span class="sxs-lookup"><span data-stu-id="9e2df-236">Choose keys that enable you to spread your requests across multiple partitions at any point of time.</span></span>  
* <span data-ttu-id="9e2df-237">***Kerülje a forgalmat a teljesítményt.***</span><span class="sxs-lookup"><span data-stu-id="9e2df-237">***Avoid spikes in traffic.***</span></span> <span data-ttu-id="9e2df-238">Elfogadható időn keresztül a forgalom sima, és elkerülheti a forgalmat a teljesítményt.</span><span class="sxs-lookup"><span data-stu-id="9e2df-238">Smooth the traffic over a reasonable period of time and avoid spikes in traffic.</span></span>
* <span data-ttu-id="9e2df-239">***Feltétlenül ne hozzon létre egy külön táblázat az egyes entitás.***</span><span class="sxs-lookup"><span data-stu-id="9e2df-239">***Don't necessarily create a separate table for each type of entity.***</span></span> <span data-ttu-id="9e2df-240">Ha atomi tranzakciók entitástípusok között, több entitás típusaival tárolhat partícióra ugyanabban a táblában.</span><span class="sxs-lookup"><span data-stu-id="9e2df-240">When you require atomic transactions across entity types, you can store these multiple entity types in the same partition in the same table.</span></span>
* <span data-ttu-id="9e2df-241">***Fontolja meg a maximális átviteli sebesség kell elérni.***</span><span class="sxs-lookup"><span data-stu-id="9e2df-241">***Consider the maximum throughput you must achieve.***</span></span> <span data-ttu-id="9e2df-242">Kell figyelembe vennie a méretezhetőségi célok a Table szolgáltatás, és győződjön meg arról, hogy a tervező nem okoz Önnek, hogy azokat.</span><span class="sxs-lookup"><span data-stu-id="9e2df-242">You must be aware of the scalability targets for the Table service and ensure that your design will not cause you to exceed them.</span></span>  

<span data-ttu-id="9e2df-243">Ez az útmutató olvasás példák, amelyek a gyakorlatban az összes alapelvek jelenik meg.</span><span class="sxs-lookup"><span data-stu-id="9e2df-243">As you read this guide, you will see examples that put all of these principles into practice.</span></span>  

## <a name="design-for-querying"></a><span data-ttu-id="9e2df-244">Tervezési lekérdezése</span><span class="sxs-lookup"><span data-stu-id="9e2df-244">Design for querying</span></span>
<span data-ttu-id="9e2df-245">TABLE szolgáltatási megoldások intenzív, írási intenzív vagy a két vegyesen olvashatók.</span><span class="sxs-lookup"><span data-stu-id="9e2df-245">Table service solutions may be read intensive, write intensive, or a mix of the two.</span></span> <span data-ttu-id="9e2df-246">Ez a szakasz a Table szolgáltatás az olvasási műveletek hatékonyan támogatásához tervezése során figyelembe kell vennie a következőket összpontosít.</span><span class="sxs-lookup"><span data-stu-id="9e2df-246">This section focuses on the things to bear in mind when you are designing your Table service to support read operations efficiently.</span></span> <span data-ttu-id="9e2df-247">A Tervező, támogatja a hatékony olvassa el az operations általában is hatékony az írási műveletek.</span><span class="sxs-lookup"><span data-stu-id="9e2df-247">Typically, a design that supports read operations efficiently is also efficient for write operations.</span></span> <span data-ttu-id="9e2df-248">Van azonban az írási műveletek, a következő szakaszban tárgyalt tervezésekor figyelembe kell vennie további szempontok [adatmódosítás kialakítása](#design-for-data-modification).</span><span class="sxs-lookup"><span data-stu-id="9e2df-248">However, there are additional considerations to bear in mind when designing to support write operations, discussed in the next section, [Design for data modification](#design-for-data-modification).</span></span>

<span data-ttu-id="9e2df-249">Ahhoz, hogy hatékonyan-adatok olvasása a Table szolgáltatás megoldás tervezése az jó kiindulási pont, kérje meg a "milyen lekérdezések alkalmazás kell végrehajtani a szükséges adatokat lekérdezni a Table szolgáltatás?"</span><span class="sxs-lookup"><span data-stu-id="9e2df-249">A good starting point for designing your Table service solution to enable you to read data efficiently is to ask "What queries will my application need to execute to retrieve the data it needs from the Table service?"</span></span>  

> [!NOTE]
> <span data-ttu-id="9e2df-250">A Table szolgáltatás fontos beolvasni a Tervező megfelelő előre mert bonyolult és költséges később módosítható.</span><span class="sxs-lookup"><span data-stu-id="9e2df-250">With the Table service, it's important to get the design correct up front because it's difficult and expensive to change it later.</span></span> <span data-ttu-id="9e2df-251">Például egy relációs adatbázisban is gyakran lehet cím teljesítményproblémák egyszerűen, amelyet indexek hozzáadása egy meglévő adatbázist: Ez a lehetőség nem érhető a Table szolgáltatással.</span><span class="sxs-lookup"><span data-stu-id="9e2df-251">For example, in a relational database it's often possible to address performance issues simply by adding indexes to an existing database: this is not an option with the Table service.</span></span>  
> 
> 

<span data-ttu-id="9e2df-252">Ez a szakasz meg kell oldania a táblák lekérdezése tervezésekor kulcs témákra összpontosít.</span><span class="sxs-lookup"><span data-stu-id="9e2df-252">This section focuses on the key issues you must address when you design your tables for querying.</span></span> <span data-ttu-id="9e2df-253">Ebben a szakaszban szereplő témakörök az alábbiak:</span><span class="sxs-lookup"><span data-stu-id="9e2df-253">The topics covered in this section include:</span></span>

* [<span data-ttu-id="9e2df-254">Hogy a választott PartitionKey és RowKey milyen hatással van a teljesítmény-küszöbérték</span><span class="sxs-lookup"><span data-stu-id="9e2df-254">How your choice of PartitionKey and RowKey impacts query performance</span></span>](#how-your-choice-of-partitionkey-and-rowkey-impacts-query-performance)
* [<span data-ttu-id="9e2df-255">Egy megfelelő PartitionKey kiválasztása</span><span class="sxs-lookup"><span data-stu-id="9e2df-255">Choosing an appropriate PartitionKey</span></span>](#choosing-an-appropriate-partitionkey)
* [<span data-ttu-id="9e2df-256">A Table szolgáltatás lekérdezések optimalizálása</span><span class="sxs-lookup"><span data-stu-id="9e2df-256">Optimizing queries for the Table service</span></span>](#optimizing-queries-for-the-table-service)
* [<span data-ttu-id="9e2df-257">A Table szolgáltatás az adatok rendezése</span><span class="sxs-lookup"><span data-stu-id="9e2df-257">Sorting data in the Table service</span></span>](#sorting-data-in-the-table-service)

### <a name="how-your-choice-of-partitionkey-and-rowkey-impacts-query-performance"></a><span data-ttu-id="9e2df-258">Hogy a választott PartitionKey és RowKey milyen hatással van a teljesítmény-küszöbérték</span><span class="sxs-lookup"><span data-stu-id="9e2df-258">How your choice of PartitionKey and RowKey impacts query performance</span></span>
<span data-ttu-id="9e2df-259">Az alábbi példák azt feltételezik, hogy a table szolgáltatás a következő struktúrával alkalmazott entitások tárolja (a példák a legtöbb hagyja ki ezt a **időbélyeg** jobb érthetőség kedvéért bizonyos tulajdonság):</span><span class="sxs-lookup"><span data-stu-id="9e2df-259">The following examples assume the table service is storing employee entities with the following structure (most of the examples omit the **Timestamp** property for clarity):</span></span>  

| <span data-ttu-id="9e2df-260">*Oszlop neve*</span><span class="sxs-lookup"><span data-stu-id="9e2df-260">*Column name*</span></span> | <span data-ttu-id="9e2df-261">*Adattípus*</span><span class="sxs-lookup"><span data-stu-id="9e2df-261">*Data type*</span></span> |
| --- | --- |
| <span data-ttu-id="9e2df-262">**PartitionKey** (részleg neve)</span><span class="sxs-lookup"><span data-stu-id="9e2df-262">**PartitionKey** (Department Name)</span></span> |<span data-ttu-id="9e2df-263">Karakterlánc</span><span class="sxs-lookup"><span data-stu-id="9e2df-263">String</span></span> |
| <span data-ttu-id="9e2df-264">**RowKey** (alkalmazott azonosítója)</span><span class="sxs-lookup"><span data-stu-id="9e2df-264">**RowKey** (Employee Id)</span></span> |<span data-ttu-id="9e2df-265">Karakterlánc</span><span class="sxs-lookup"><span data-stu-id="9e2df-265">String</span></span> |
| <span data-ttu-id="9e2df-266">**Utónév**</span><span class="sxs-lookup"><span data-stu-id="9e2df-266">**FirstName**</span></span> |<span data-ttu-id="9e2df-267">Karakterlánc</span><span class="sxs-lookup"><span data-stu-id="9e2df-267">String</span></span> |
| <span data-ttu-id="9e2df-268">**Vezetéknév**</span><span class="sxs-lookup"><span data-stu-id="9e2df-268">**LastName**</span></span> |<span data-ttu-id="9e2df-269">Karakterlánc</span><span class="sxs-lookup"><span data-stu-id="9e2df-269">String</span></span> |
| <span data-ttu-id="9e2df-270">**Kora**</span><span class="sxs-lookup"><span data-stu-id="9e2df-270">**Age**</span></span> |<span data-ttu-id="9e2df-271">Egész szám</span><span class="sxs-lookup"><span data-stu-id="9e2df-271">Integer</span></span> |
| <span data-ttu-id="9e2df-272">**E-mail cím**</span><span class="sxs-lookup"><span data-stu-id="9e2df-272">**EmailAddress**</span></span> |<span data-ttu-id="9e2df-273">Karakterlánc</span><span class="sxs-lookup"><span data-stu-id="9e2df-273">String</span></span> |

<span data-ttu-id="9e2df-274">A korábbi szakaszban [Azure Table szolgáltatás áttekintése](#overview) néhány szolgáltatását az Azure Table szolgáltatás, amely közvetlenül befolyásolják a lekérdezéshez tervezéséről foglalja össze.</span><span class="sxs-lookup"><span data-stu-id="9e2df-274">The earlier section [Azure Table service overview](#overview) describes some of the key features of the Azure Table service that have a direct influence on designing for query.</span></span> <span data-ttu-id="9e2df-275">Ezek a Table szolgáltatás Lekérdezéstervezés vonatkozó általános irányelveket eredményez.</span><span class="sxs-lookup"><span data-stu-id="9e2df-275">These result in the following general guidelines for designing Table service queries.</span></span> <span data-ttu-id="9e2df-276">Vegye figyelembe, hogy a Table szolgáltatásból REST API-t a további tudnivalókat lásd az alábbi példákban szereplő szűrőszintaxisának [lekérdezés entitások](http://msdn.microsoft.com/library/azure/dd179421.aspx).</span><span class="sxs-lookup"><span data-stu-id="9e2df-276">Note that the filter syntax used in the examples below is from the Table service REST API, for more information see [Query Entities](http://msdn.microsoft.com/library/azure/dd179421.aspx).</span></span>  

* <span data-ttu-id="9e2df-277">A ***pont lekérdezés*** a leghatékonyabb keresési használatára, és nagy mennyiségű keresések vagy a legkisebb mértékű késleltetést igénylő keresések használandó ajánlott.</span><span class="sxs-lookup"><span data-stu-id="9e2df-277">A ***Point Query*** is the most efficient lookup to use and is recommended to be used for high-volume lookups or lookups requiring lowest latency.</span></span> <span data-ttu-id="9e2df-278">Ilyen lekérdezést az indexek segítségével egyedi entitás nagyon hatékonyan mindkét megadásával keresse meg a **PartitionKey** és **RowKey** értékeket.</span><span class="sxs-lookup"><span data-stu-id="9e2df-278">Such a query can use the indexes to locate an individual entity very efficiently by specifying both the **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="9e2df-279">Például: $filter = (PartitionKey eq 'Értékesítés') és (RowKey eq '2')</span><span class="sxs-lookup"><span data-stu-id="9e2df-279">For example: $filter=(PartitionKey eq 'Sales') and (RowKey eq '2')</span></span>  
* <span data-ttu-id="9e2df-280">Második legjobb van egy ***értéktartomány lekérdezésének*** , amely használja a **PartitionKey** és a szűrők számos **RowKey** egynél több entitáskészlet visszaadandó értékek száma.</span><span class="sxs-lookup"><span data-stu-id="9e2df-280">Second best is a ***Range Query*** that uses the **PartitionKey** and filters on a range of **RowKey** values to return more than one entity.</span></span> <span data-ttu-id="9e2df-281">A **PartitionKey** érték azonosít egy adott partícióra, és a **RowKey** értékek azonosítsa az adott partíció entitástartományának részhalmazát.</span><span class="sxs-lookup"><span data-stu-id="9e2df-281">The **PartitionKey** value identifies a specific partition, and the **RowKey** values identify a subset of the entities in that partition.</span></span> <span data-ttu-id="9e2df-282">Például: $filter = "Értékesítési és RowKey ge" PartitionKey eq és RowKey lt jelzést "</span><span class="sxs-lookup"><span data-stu-id="9e2df-282">For example: $filter=PartitionKey eq 'Sales' and RowKey ge 'S' and RowKey lt 'T'</span></span>  
* <span data-ttu-id="9e2df-283">Harmadik legjobb van egy ***partíció vizsgálata*** , amely használja a **PartitionKey** és olyan nem kulcs tulajdonsága, és hogy a szűrők térhetnek vissza egy entitást.</span><span class="sxs-lookup"><span data-stu-id="9e2df-283">Third best is a ***Partition Scan*** that uses the **PartitionKey** and filters on another non-key property and that may return more than one entity.</span></span> <span data-ttu-id="9e2df-284">A **PartitionKey** érték egy adott partícióra azonosítja, és a tulajdonság értékek válassza ki az adott partíció entitást egy részéhez.</span><span class="sxs-lookup"><span data-stu-id="9e2df-284">The **PartitionKey** value identifies a specific partition, and the property values select for a subset of the entities in that partition.</span></span> <span data-ttu-id="9e2df-285">Például: $filter PartitionKey eq "Értékesítési" és a Vezetéknév eq 'Smith' =</span><span class="sxs-lookup"><span data-stu-id="9e2df-285">For example: $filter=PartitionKey eq 'Sales' and LastName eq 'Smith'</span></span>  
* <span data-ttu-id="9e2df-286">A ***tábla vizsgálata*** nem tartalmazza a **PartitionKey** és nem nagyon hatékony, mivel az összes pedig a hozzá tartozó entitások az a táblázat partíciókat keresi.</span><span class="sxs-lookup"><span data-stu-id="9e2df-286">A ***Table Scan*** does not include the **PartitionKey** and is very inefficient because it searches all of the partitions that make up your table in turn for any matching entities.</span></span> <span data-ttu-id="9e2df-287">A táblázatbeolvasás, függetlenül a szűrő használja-e hajtja végre a **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="9e2df-287">It will perform a table scan regardless of whether or not your filter uses the **RowKey**.</span></span> <span data-ttu-id="9e2df-288">Például: $filter Vezetéknév eq "János" =</span><span class="sxs-lookup"><span data-stu-id="9e2df-288">For example: $filter=LastName eq 'Jones'</span></span>  
* <span data-ttu-id="9e2df-289">Több entitás visszaadó lekérdezések Alapértelmezések rendezve **PartitionKey** és **RowKey** sorrendje.</span><span class="sxs-lookup"><span data-stu-id="9e2df-289">Queries that return multiple entities return them sorted in **PartitionKey** and **RowKey** order.</span></span> <span data-ttu-id="9e2df-290">Az ügyfél entitást keresésére átrendezésével elkerüléséhez válassza ki a **RowKey** , amely meghatározza, hogy a leggyakrabban használt rendezési sorrend.</span><span class="sxs-lookup"><span data-stu-id="9e2df-290">To avoid resorting the entities in the client, choose a **RowKey** that defines the most common sort order.</span></span>  

<span data-ttu-id="9e2df-291">Vegye figyelembe, hogy használja az "**vagy**" alapján egy szűrő meghatározására **RowKey** értéket egy partíció vizsgálati eredményeket, majd egy értéktartomány lekérdezésének nem számít.</span><span class="sxs-lookup"><span data-stu-id="9e2df-291">Note that using an "**or**" to specify a filter based on **RowKey** values results in a partition scan and is not treated as a range query.</span></span> <span data-ttu-id="9e2df-292">Ezért kerülje el a lekérdezéseket, szűrők, mint amelyekkel: $filter = PartitionKey eq 'Értékesítés' és (RowKey eq "121" vagy "322" RowKey eq)</span><span class="sxs-lookup"><span data-stu-id="9e2df-292">Therefore, you should avoid queries that use filters such as: $filter=PartitionKey eq 'Sales' and (RowKey eq '121' or RowKey eq '322')</span></span>  

<span data-ttu-id="9e2df-293">Az ügyféloldali kódot, amely hatékony-lekérdezéseket hajt végre a Storage ügyféloldali kódtár használatával című részben talál példákat:</span><span class="sxs-lookup"><span data-stu-id="9e2df-293">For examples of client-side code that use the Storage Client Library to execute efficient queries, see:</span></span>  

* [<span data-ttu-id="9e2df-294">A Storage ügyféloldali kódtár segítségével pont lekérdezése</span><span class="sxs-lookup"><span data-stu-id="9e2df-294">Executing a point query using the Storage Client Library</span></span>](#executing-a-point-query-using-the-storage-client-library)
* [<span data-ttu-id="9e2df-295">LINQ használatával több entitás beolvasásakor</span><span class="sxs-lookup"><span data-stu-id="9e2df-295">Retrieving multiple entities using LINQ</span></span>](#retrieving-multiple-entities-using-linq)
* [<span data-ttu-id="9e2df-296">Kiszolgálóoldali leképezése</span><span class="sxs-lookup"><span data-stu-id="9e2df-296">Server-side projection</span></span>](#server-side-projection)  

<span data-ttu-id="9e2df-297">Ügyféloldali kódot, amelyet kezelni ugyanabban a táblában tárolt több entitás típusokat tud példákért lásd:</span><span class="sxs-lookup"><span data-stu-id="9e2df-297">For examples of client-side code that can handle multiple entity types stored in the same table, see:</span></span>  

* [<span data-ttu-id="9e2df-298">Heterogén entitástípusok használata</span><span class="sxs-lookup"><span data-stu-id="9e2df-298">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)  

### <a name="choosing-an-appropriate-partitionkey"></a><span data-ttu-id="9e2df-299">Egy megfelelő PartitionKey kiválasztása</span><span class="sxs-lookup"><span data-stu-id="9e2df-299">Choosing an appropriate PartitionKey</span></span>
<span data-ttu-id="9e2df-300">A választott **PartitionKey** kell terheléselosztást kell EGTs (konzisztencia biztosításához) használatát teszi lehetővé a követelménnyel szemben az entitások szét több partíciót (méretezhető megoldás biztosításához).</span><span class="sxs-lookup"><span data-stu-id="9e2df-300">Your choice of **PartitionKey** should balance the need to enables the use of EGTs (to ensure consistency) against the requirement to distribute your entities across multiple partitions (to ensure a scalable solution).</span></span>  

<span data-ttu-id="9e2df-301">Egy rendkívüli az entitások sikerült egyetlen partícióra vannak tárolva, de ez korlátozottá teheti méretezhetőségét a megoldás, és akadályozzák a table szolgáltatás terheléselosztásához kérelmek igényt.</span><span class="sxs-lookup"><span data-stu-id="9e2df-301">At one extreme, you could store all your entities in a single partition, but this may limit the scalability of your solution and would prevent the table service from being able to load-balance requests.</span></span> <span data-ttu-id="9e2df-302">A rendkívüli egy entitás partíció található, amely magas szinten méretezhető lenne és amely lehetővé teszi a table szolgáltatás terheléselosztási kérésekre, de amelyek volna újrafelhasználásának megtiltása entitás csoport tranzakciók száma tárolhatja.</span><span class="sxs-lookup"><span data-stu-id="9e2df-302">At the other extreme, you could store one entity per partition, which would be highly scalable and which enables the table service to load-balance requests, but which would prevent you from using entity group transactions.</span></span>  

<span data-ttu-id="9e2df-303">Az ideális **PartitionKey** , amely lehetővé teszi, hogy használni lehessen a hatékony lekérdezések és annak biztosítása érdekében, a megoldás méretezhető elegendő partíciókkal rendelkezik, amelyek egyike.</span><span class="sxs-lookup"><span data-stu-id="9e2df-303">An ideal **PartitionKey** is one that enables you to use efficient queries and that has sufficient partitions to ensure your solution is scalable.</span></span> <span data-ttu-id="9e2df-304">Általában találja, hogy az entitások lesz-e az entitások elosztja elegendő partíciók megfelelő tulajdonság.</span><span class="sxs-lookup"><span data-stu-id="9e2df-304">Typically, you will find that your entities will have a suitable property that distributes your entities across sufficient partitions.</span></span>

> [!NOTE]
> <span data-ttu-id="9e2df-305">A rendszer, hogy a felhasználók vagy az alkalmazottak kapcsolatos információkat tárolja, például UserID lehet egy jó PartitionKey.</span><span class="sxs-lookup"><span data-stu-id="9e2df-305">For example, in a system that stores information about users or employees, UserID may be a good PartitionKey.</span></span> <span data-ttu-id="9e2df-306">Előfordulhat, hogy több entitás, amely egy adott felhasználói azonosítóját használják a partíciós kulcs.</span><span class="sxs-lookup"><span data-stu-id="9e2df-306">You may have several entities that use a given UserID as the partition key.</span></span> <span data-ttu-id="9e2df-307">Minden entitás, amely a felhasználó adatait tárolja egyetlen partícióra vannak csoportosítva, és ezért ezeket az entitásokat elérhetők entitás csoport tranzakciók, miközben továbbra is magas szinten méretezhető.</span><span class="sxs-lookup"><span data-stu-id="9e2df-307">Each entity that stores data about a user is grouped into a single partition, and so these entities are accessible via entity group transactions, while still being highly scalable.</span></span>
> 
> 

<span data-ttu-id="9e2df-308">A választott további szempontot **PartitionKey** hogyan meg fog beszúrási, frissítési és törlési entitások kapcsolódó: című [adatmódosítás kialakítása](#design-for-data-modification) alatt.</span><span class="sxs-lookup"><span data-stu-id="9e2df-308">There are additional considerations in your choice of **PartitionKey** that relate to how you will insert, update, and delete entities: see the section [Design for data modification](#design-for-data-modification) below.</span></span>  

### <a name="optimizing-queries-for-the-table-service"></a><span data-ttu-id="9e2df-309">A Table szolgáltatás lekérdezések optimalizálása</span><span class="sxs-lookup"><span data-stu-id="9e2df-309">Optimizing queries for the Table service</span></span>
<span data-ttu-id="9e2df-310">A Table szolgáltatás automatikusan indexeli az entitások használata a **PartitionKey** és **RowKey** egy fürtözött index, ezért az oka, hogy a lekérdezések pont értékei a leghatékonyabb használatára.</span><span class="sxs-lookup"><span data-stu-id="9e2df-310">The Table service automatically indexes your entities using the **PartitionKey** and **RowKey** values in a single clustered index, hence the reason that point queries are the most efficient to use.</span></span> <span data-ttu-id="9e2df-311">Van azonban nem indexei eltérő a fürtözött index a a **PartitionKey** és **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="9e2df-311">However, there are no indexes other than that on the clustered index on the **PartitionKey** and **RowKey**.</span></span>

<span data-ttu-id="9e2df-312">Sok ahhoz, hogy az entitások több feltétel alapján keresési kell megfelelnie.</span><span class="sxs-lookup"><span data-stu-id="9e2df-312">Many designs must meet requirements to enable lookup of entities based on multiple criteria.</span></span> <span data-ttu-id="9e2df-313">Például az e-mailek alapján alkalmazott entitások keresése Alkalmazottazonosító vagy vezetéknevét.</span><span class="sxs-lookup"><span data-stu-id="9e2df-313">For example, locating employee entities based on email, employee id, or last name.</span></span> <span data-ttu-id="9e2df-314">A szakasz a következő minták [táblázat kialakítási minta](#table-design-patterns) követelmény az ilyen típusú cím, és azt a tényt, hogy a Table szolgáltatás nem nyújt másodlagos indexek körül módon ismertetik:</span><span class="sxs-lookup"><span data-stu-id="9e2df-314">The following patterns in the section [Table Design Patterns](#table-design-patterns) address these types of requirement and describe ways of working around the fact that the Table service does not provide secondary indexes:</span></span>  

* <span data-ttu-id="9e2df-315">[Intra-partíció másodlagos index mintát](#intra-partition-secondary-index-pattern) -tárolja a több másolatot minden entitás használatával különböző **RowKey** engedélyezése gyors és hatékony keresések és másodlagos rendezési sorrend különböző használatával (a partícióra) értékek **RowKey** értékeket.</span><span class="sxs-lookup"><span data-stu-id="9e2df-315">[Intra-partition secondary index pattern](#intra-partition-secondary-index-pattern) - Store multiple copies of each entity using different **RowKey** values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span>  
* <span data-ttu-id="9e2df-316">[Másodlagos helyek közötti partíció index mintát](#inter-partition-secondary-index-pattern) - értékekkel különböző RowKey külön partíciók vagy külön táblázatban gyors engedélyezése minden entitás több példányát tárolja, és a különböző rendelésekhatékonykereséstésamásodlagosrendezésisorrend**RowKey** értékeket.</span><span class="sxs-lookup"><span data-stu-id="9e2df-316">[Inter-partition secondary index pattern](#inter-partition-secondary-index-pattern) - Store multiple copies of each entity using different RowKey values in separate partitions or in separate tables to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span>  
* <span data-ttu-id="9e2df-317">[Index entitások mintát](#index-entities-pattern) -index entitások entitások listájának visszaadó hatékony keresések engedélyezése karbantartása.</span><span class="sxs-lookup"><span data-stu-id="9e2df-317">[Index Entities Pattern](#index-entities-pattern) - Maintain index entities to enable efficient searches that return lists of entities.</span></span>  

### <a name="sorting-data-in-the-table-service"></a><span data-ttu-id="9e2df-318">A Table szolgáltatás az adatok rendezése</span><span class="sxs-lookup"><span data-stu-id="9e2df-318">Sorting data in the Table service</span></span>
<span data-ttu-id="9e2df-319">A Table szolgáltatás adja vissza növekvő sorrendben rendezve entitások **PartitionKey** és a majd **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="9e2df-319">The Table service returns entities sorted in ascending order based on **PartitionKey** and then by **RowKey**.</span></span> <span data-ttu-id="9e2df-320">Ezek a kulcsok karakterlánc-értékek és numerikus értékek megfelelően rendezése érdekében kell alakíthatja át őket egy rögzített hosszúságú és nulla kitölti őket.</span><span class="sxs-lookup"><span data-stu-id="9e2df-320">These keys are string values and to ensure that numeric values sort correctly, you should convert them to a fixed length and pad them with zeroes.</span></span> <span data-ttu-id="9e2df-321">Például, ha az alkalmazott azonosítóérték használja a **RowKey** megadott egész szám, alkalmazottazonosító átalakíthatja **123** való **00000123**.</span><span class="sxs-lookup"><span data-stu-id="9e2df-321">For example, if the employee id value you use as the **RowKey** is an integer value, you should convert employee id **123** to **00000123**.</span></span>  

<span data-ttu-id="9e2df-322">Számos alkalmazás más-más sorrendben rendezett adatok használata követelményekkel rendelkezik: az alkalmazottak például rendezést a neve vagy való csatlakozás dátumát.</span><span class="sxs-lookup"><span data-stu-id="9e2df-322">Many applications have requirements to use data sorted in different orders: for example, sorting employees by name, or by joining date.</span></span> <span data-ttu-id="9e2df-323">A szakasz a következő minták [táblázat kialakítási minta](#table-design-patterns) számára, hogy a rendezési sorrend a entitások hogyan cím:</span><span class="sxs-lookup"><span data-stu-id="9e2df-323">The following patterns in the section [Table Design Patterns](#table-design-patterns) address how to alternate sort orders for your entities:</span></span>  

* <span data-ttu-id="9e2df-324">[Helyen belüli-partíció másodlagos index mintát](#intra-partition-secondary-index-pattern) - különböző RowKey értékei alapján (a partícióra) gyors engedélyezése minden entitás több példányát tárolja, és hatékony keresést és a másodlagos rendezési sorrend rendelések különböző RowKey értékek használatával.</span><span class="sxs-lookup"><span data-stu-id="9e2df-324">[Intra-partition secondary index pattern](#intra-partition-secondary-index-pattern) - Store multiple copies of each entity using different RowKey values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different RowKey values.</span></span>  
* <span data-ttu-id="9e2df-325">[Másodlagos helyek közötti partíció index mintát](#inter-partition-secondary-index-pattern) – minden külön táblázatban külön partíciók különböző RowKey értékek segítségével engedélyezi a gyors entitás több példányát tárolja, és hatékony keresést és a másodlagos rendezési sorrend rendelések különböző RowKey értékek használatával .</span><span class="sxs-lookup"><span data-stu-id="9e2df-325">[Inter-partition secondary index pattern](#inter-partition-secondary-index-pattern) - Store multiple copies of each entity using different RowKey values in separate partitions in separate tables to enable fast and efficient lookups and alternate sort orders by using different RowKey values.</span></span>
* <span data-ttu-id="9e2df-326">[Napló végéről mintát](#log-tail-pattern) -beolvasni a  *n*  partíció legutóbb hozzáadott entitások egy **RowKey** érték, amely fordított dátum és idő sorrendben rendezi.</span><span class="sxs-lookup"><span data-stu-id="9e2df-326">[Log tail pattern](#log-tail-pattern) - Retrieve the *n* entities most recently added to a partition by using a **RowKey** value that sorts in reverse date and time order.</span></span>  

## <a name="design-for-data-modification"></a><span data-ttu-id="9e2df-327">Adatmódosítás kialakítása</span><span class="sxs-lookup"><span data-stu-id="9e2df-327">Design for data modification</span></span>
<span data-ttu-id="9e2df-328">Ez a szakasz a beszúrások, a frissítések optimalizálása kialakítási szempontjai összpontosít, és törli.</span><span class="sxs-lookup"><span data-stu-id="9e2df-328">This section focuses on the design considerations for optimizing inserts, updates, and deletes.</span></span> <span data-ttu-id="9e2df-329">Néhány esetben szüksége lesz a kompromisszum terveket, terveket, hasonlóan a relációs adatbázisok terveket (bár a Tervező kompromisszumot kezelésére szolgáló módszerek optimalizálás adatok módosítása ellen lekérdezése optimalizálása közötti kiértékelése különböző egy relációs adatbázisban).</span><span class="sxs-lookup"><span data-stu-id="9e2df-329">In some cases, you will need to evaluate the trade-off between designs that optimize for querying against designs that optimize for data modification just as you do in designs for relational databases (although the techniques for managing the design trade-offs are different in a relational database).</span></span> <span data-ttu-id="9e2df-330">A szakasz [táblázat kialakítási minta](#table-design-patterns) néhány részletes kialakítási minta a Table szolgáltatás ismerteti, és kiemeli a néhányat ezek kompromisszumot.</span><span class="sxs-lookup"><span data-stu-id="9e2df-330">The section [Table Design Patterns](#table-design-patterns) describes some detailed design patterns for the Table service and highlights some these trade-offs.</span></span> <span data-ttu-id="9e2df-331">A gyakorlatban találja, hogy az entitás lekérdezése optimalizált sok tervek is alkalmas entitások módosítása.</span><span class="sxs-lookup"><span data-stu-id="9e2df-331">In practice, you will find that many designs optimized for querying entities also work well for modifying entities.</span></span>  

### <a name="optimizing-the-performance-of-insert-update-and-delete-operations"></a><span data-ttu-id="9e2df-332">A teljesítmény optimalizálása a beszúrási, frissítési és törlési műveletek</span><span class="sxs-lookup"><span data-stu-id="9e2df-332">Optimizing the performance of insert, update, and delete operations</span></span>
<span data-ttu-id="9e2df-333">Frissíteni vagy törölni egy entitást, meg kell tudni használatával azonosíthassák a **PartitionKey** és **RowKey** értékeket.</span><span class="sxs-lookup"><span data-stu-id="9e2df-333">To update or delete an entity, you must be able to identify it by using the **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="9e2df-334">Ebben a tekintetben a választott **PartitionKey** és **RowKey** az entitások módosítása nyújtanak hasonló feltételek pont lekérdezések támogatja, mert a szervezetek, mint a azonosítani szeretné az Ön választása lehető leghatékonyabb módon.</span><span class="sxs-lookup"><span data-stu-id="9e2df-334">In this respect, your choice of **PartitionKey** and **RowKey** for modifying entities should follow similar criteria to your choice to support point queries because you want to identify entities as efficiently as possible.</span></span> <span data-ttu-id="9e2df-335">Nem használni kívánt nem elég hatékony partíció vagy tábla vizsgálat entitás található felderítéséhez a **PartitionKey** és **RowKey** értékek frissíteni vagy törölni kell.</span><span class="sxs-lookup"><span data-stu-id="9e2df-335">You do not want to use an inefficient partition or table scan to locate an entity in order to discover the **PartitionKey** and **RowKey** values you need to update or delete it.</span></span>  

<span data-ttu-id="9e2df-336">A szakasz a következő minták [táblázat kialakítási minta](#table-design-patterns) cím optimalizálása a teljesítmény vagy a beszúrási, frissítési és törlési műveletek:</span><span class="sxs-lookup"><span data-stu-id="9e2df-336">The following patterns in the section [Table Design Patterns](#table-design-patterns) address optimizing the performance or your insert, update, and delete operations:</span></span>  

* <span data-ttu-id="9e2df-337">[Nagy mennyiségű törlése mintát](#high-volume-delete-pattern) -a nagyszámú entitások törlésének engedélyezése a entitásokhoz egyidejű törlésre tárolása saját különálló táblában; a tábla törlésével törli az entitásokat.</span><span class="sxs-lookup"><span data-stu-id="9e2df-337">[High volume delete pattern](#high-volume-delete-pattern) - Enable the deletion of a high volume of entities by storing all the entities for simultaneous deletion in their own separate table; you delete the entities by deleting the table.</span></span>  
* <span data-ttu-id="9e2df-338">[Adatsorozat adatmintát](#data-series-pattern) -tároló teljes adatsorok egyetlen entitás minimalizálása érdekében elvégezte kérelmek számát jelenti.</span><span class="sxs-lookup"><span data-stu-id="9e2df-338">[Data series pattern](#data-series-pattern) - Store complete data series in a single entity to minimize the number of requests you make.</span></span>  
* <span data-ttu-id="9e2df-339">[Széles entitások mintát](#wide-entities-pattern) -használjon több fizikai entitás legfeljebb 252 tulajdonságot rendelkező logikai entitás tárolására.</span><span class="sxs-lookup"><span data-stu-id="9e2df-339">[Wide entities pattern](#wide-entities-pattern) - Use multiple physical entities to store logical entities with more than 252 properties.</span></span>  
* <span data-ttu-id="9e2df-340">[Nagy entitások mintát](#large-entities-pattern) -blob-tároló használjon nagy tulajdonságértékek tárolásához.</span><span class="sxs-lookup"><span data-stu-id="9e2df-340">[Large entities pattern](#large-entities-pattern) - Use blob storage to store large property values.</span></span>  

### <a name="ensuring-consistency-in-your-stored-entities"></a><span data-ttu-id="9e2df-341">A tárolt entitásokat következetes biztosítása</span><span class="sxs-lookup"><span data-stu-id="9e2df-341">Ensuring consistency in your stored entities</span></span>
<span data-ttu-id="9e2df-342">A más kulcsfontosságú tényező, amely befolyásolja a választott módosítása optimalizálási kulcsok, hogyan biztosíthatja a atomi tranzakciók használatával.</span><span class="sxs-lookup"><span data-stu-id="9e2df-342">The other key factor that influences your choice of keys for optimizing data modifications is how to ensure consistency by using atomic transactions.</span></span> <span data-ttu-id="9e2df-343">Csak használhat egy EGT az entitásokat tartalmazó partícióra tárolt való működésre.</span><span class="sxs-lookup"><span data-stu-id="9e2df-343">You can only use an EGT to operate on entities stored in the same partition.</span></span>  

<span data-ttu-id="9e2df-344">A szakasz a következő minták [táblázat kialakítási minta](#table-design-patterns) cím konzisztencia kezelése:</span><span class="sxs-lookup"><span data-stu-id="9e2df-344">The following patterns in the section [Table Design Patterns](#table-design-patterns) address managing consistency:</span></span>  

* <span data-ttu-id="9e2df-345">[Intra-partíció másodlagos index mintát](#intra-partition-secondary-index-pattern) -tárolja a több másolatot minden entitás használatával különböző **RowKey** engedélyezése gyors és hatékony keresések és másodlagos rendezési sorrend különböző használatával (a partícióra) értékek **RowKey** értékeket.</span><span class="sxs-lookup"><span data-stu-id="9e2df-345">[Intra-partition secondary index pattern](#intra-partition-secondary-index-pattern) - Store multiple copies of each entity using different **RowKey** values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span>  
* <span data-ttu-id="9e2df-346">[Másodlagos helyek közötti partíció index mintát](#inter-partition-secondary-index-pattern) - értékekkel különböző RowKey külön partíciók vagy külön táblázatban gyors engedélyezése minden entitás több példányát tárolja, és a különböző rendelésekhatékonykereséstésamásodlagosrendezésisorrend**RowKey** értékeket.</span><span class="sxs-lookup"><span data-stu-id="9e2df-346">[Inter-partition secondary index pattern](#inter-partition-secondary-index-pattern) - Store multiple copies of each entity using different RowKey values in separate partitions or in separate tables to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span>  
* <span data-ttu-id="9e2df-347">[Idővel konzisztenssé tranzakciók mintát](#eventually-consistent-transactions-pattern) -engedélyezni a idővel konzisztenssé partícióhatárok vagy tárolási rendszer határok Azure üzenetsorok használatával.</span><span class="sxs-lookup"><span data-stu-id="9e2df-347">[Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) - Enable eventually consistent behavior across partition boundaries or storage system boundaries by using Azure queues.</span></span>
* <span data-ttu-id="9e2df-348">[Index entitások mintát](#index-entities-pattern) -index entitások entitások listájának visszaadó hatékony keresések engedélyezése karbantartása.</span><span class="sxs-lookup"><span data-stu-id="9e2df-348">[Index Entities Pattern](#index-entities-pattern) - Maintain index entities to enable efficient searches that return lists of entities.</span></span>  
* <span data-ttu-id="9e2df-349">[Denormalization mintát](#denormalization-pattern) -egyesítése kapcsolódó adatok együtt az egyetlen entitás ahhoz, hogy beolvasni az összes adatot a hibaérzékeny pontok lekérdezéssel van szüksége.</span><span class="sxs-lookup"><span data-stu-id="9e2df-349">[Denormalization pattern](#denormalization-pattern) - Combine related data together in a single entity to enable you to retrieve all the data you need with a single point query.</span></span>  
* <span data-ttu-id="9e2df-350">[Adatsorozat adatmintát](#data-series-pattern) -tároló teljes adatsorok egyetlen entitás minimalizálása érdekében elvégezte kérelmek számát jelenti.</span><span class="sxs-lookup"><span data-stu-id="9e2df-350">[Data series pattern](#data-series-pattern) - Store complete data series in a single entity to minimize the number of requests you make.</span></span>  

<span data-ttu-id="9e2df-351">Entitás csoport tranzakciókkal kapcsolatos információkért lásd: a szakasz [entitás csoport tranzakciók](#entity-group-transactions).</span><span class="sxs-lookup"><span data-stu-id="9e2df-351">For information about entity group transactions, see the section [Entity Group Transactions](#entity-group-transactions).</span></span>  

### <a name="ensuring-your-design-for-efficient-modifications-facilitates-efficient-queries"></a><span data-ttu-id="9e2df-352">A módosítások hatékony kialakítása biztosítása elősegíti a hatékony lekérdezések</span><span class="sxs-lookup"><span data-stu-id="9e2df-352">Ensuring your design for efficient modifications facilitates efficient queries</span></span>
<span data-ttu-id="9e2df-353">Sok esetben egy tervezési módosítások hatékony, de hatékony lekérdező eredményez kell mindig mérlegelje, hogy ez a helyzet az adott forgatókönyv szerint.</span><span class="sxs-lookup"><span data-stu-id="9e2df-353">In many cases, a design for efficient querying results in efficient modifications, but you should always evaluate whether this is the case for your specific scenario.</span></span> <span data-ttu-id="9e2df-354">A szakasz a minták némelyike [táblázat kialakítási minta](#table-design-patterns) explicit módon értékeli az kérdez le, és módosítja az entitások közötti kompromisszumot, és hogy mindig figyelembe kell vennie a művelet típusonkénti darabszámot.</span><span class="sxs-lookup"><span data-stu-id="9e2df-354">Some of the patterns in the section [Table Design Patterns](#table-design-patterns) explicitly evaluate trade-offs between querying and modifying entities, and you should always take into account the number of each type of operation.</span></span>  

<span data-ttu-id="9e2df-355">A szakasz a következő minták [táblázat kialakítási minta](#table-design-patterns) hatékony lekérdezések tervezése és kialakítása hatékony adatok módosítása a közötti kompromisszumot cím:</span><span class="sxs-lookup"><span data-stu-id="9e2df-355">The following patterns in the section [Table Design Patterns](#table-design-patterns) address trade-offs between designing for efficient queries and designing for efficient data modification:</span></span>  

* <span data-ttu-id="9e2df-356">[Összetett kulcs mintát](#compound-key-pattern) – használható összetett **RowKey** értékek kapcsolódó adatok egyetlen pont lekérdezéssel talált ügyfél engedélyezése.</span><span class="sxs-lookup"><span data-stu-id="9e2df-356">[Compound key pattern](#compound-key-pattern) - Use compound **RowKey** values to enable a client to lookup related data with a single point query.</span></span>  
* <span data-ttu-id="9e2df-357">[Napló végéről mintát](#log-tail-pattern) -beolvasni a  *n*  partíció legutóbb hozzáadott entitások egy **RowKey** érték, amely fordított dátum és idő sorrendben rendezi.</span><span class="sxs-lookup"><span data-stu-id="9e2df-357">[Log tail pattern](#log-tail-pattern) - Retrieve the *n* entities most recently added to a partition by using a **RowKey** value that sorts in reverse date and time order.</span></span>  

## <a name="encrypting-table-data"></a><span data-ttu-id="9e2df-358">Tábla adatok titkosítása</span><span class="sxs-lookup"><span data-stu-id="9e2df-358">Encrypting Table Data</span></span>
<span data-ttu-id="9e2df-359">A .NET Azure Storage ügyféloldali kódtár támogatja a titkosítást a karakterlánc az Entitástulajdonságok szúrhatók be, és cserélje le a műveletek.</span><span class="sxs-lookup"><span data-stu-id="9e2df-359">The .NET Azure Storage Client Library supports encryption of string entity properties for insert and replace operations.</span></span> <span data-ttu-id="9e2df-360">A titkosított karakterláncok tárolja a szolgáltatás bináris tulajdonságként, és telepítésekké lesznek átalakítva vissza karakterláncok a visszafejtés után.</span><span class="sxs-lookup"><span data-stu-id="9e2df-360">The encrypted strings are stored on the service as binary properties, and they are converted back to strings after decryption.</span></span>    

<span data-ttu-id="9e2df-361">Táblák, a titkosítási házirenden kívül a felhasználók fiók kell adnia a titkosítani kell.</span><span class="sxs-lookup"><span data-stu-id="9e2df-361">For tables, in addition to the encryption policy, users must specify the properties to be encrypted.</span></span> <span data-ttu-id="9e2df-362">Ezt megteheti megadásával vagy (az POCO entitások, amelyek a TableEntity) [EncryptProperty] attribútum vagy egy titkosítási feloldó lehetőségek.</span><span class="sxs-lookup"><span data-stu-id="9e2df-362">This can be done by either specifying an [EncryptProperty] attribute (for POCO entities that derive from TableEntity) or an encryption resolver in request options.</span></span> <span data-ttu-id="9e2df-363">Egy titkosítási feloldó egy delegált veszi a partíciós kulcs, sorkulcsot és tulajdonság nevét, és logikai érték beolvasása, amely jelzi, hogy a tulajdonság titkosítani kell-e.</span><span class="sxs-lookup"><span data-stu-id="9e2df-363">An encryption resolver is a delegate that takes a partition key, row key, and property name and returns a Boolean that indicates whether that property should be encrypted.</span></span> <span data-ttu-id="9e2df-364">Titkosítás során az ügyféloldali kódtár döntse el, hogy a tulajdonság titkosítani kell-e az átvitel közbeni írása során fogja használni ezt az információt.</span><span class="sxs-lookup"><span data-stu-id="9e2df-364">During encryption, the client library will use this information to decide whether a property should be encrypted while writing to the wire.</span></span> <span data-ttu-id="9e2df-365">A delegált is körül hogyan tulajdonságok vannak titkosítva logika lehetőségét biztosítja.</span><span class="sxs-lookup"><span data-stu-id="9e2df-365">The delegate also provides for the possibility of logic around how properties are encrypted.</span></span> <span data-ttu-id="9e2df-366">(Például, ha X, majd titkosítása A tulajdonság; ellenkező esetben a Tulajdonságok A és b titkosítása) Vegye figyelembe, hogy nincs szükség arra, hogy ezek az információk olvasása vagy entitás lekérdezése közben.</span><span class="sxs-lookup"><span data-stu-id="9e2df-366">(For example, if X, then encrypt property A; otherwise encrypt properties A and B.) Note that it is not necessary to provide this information while reading or querying entities.</span></span>

<span data-ttu-id="9e2df-367">Vegye figyelembe, hogy a merge jelenleg nem támogatott.</span><span class="sxs-lookup"><span data-stu-id="9e2df-367">Note that merge is not currently supported.</span></span> <span data-ttu-id="9e2df-368">Mivel a Tulajdonságok részhalmazát, előfordulhat, hogy korábban használatával titkosított egy másik kulcsot, egyszerűen csak az új tulajdonságok egyesítése és a metaadatok frissítése adatok elvesztését eredményezi.</span><span class="sxs-lookup"><span data-stu-id="9e2df-368">Since a subset of properties may have been encrypted previously using a different key, simply merging the new properties and updating the metadata will result in data loss.</span></span> <span data-ttu-id="9e2df-369">Az egyesítés vagy megköveteli a már meglévő entitás olvasni a szolgáltatás további szolgáltatás-hívások, vagy tulajdonságonként egy új kulcsot használ, amelyek mindegyikét nem alkalmasak a teljesítményre vonatkozó megfontolásból.</span><span class="sxs-lookup"><span data-stu-id="9e2df-369">Merging either requires making extra service calls to read the pre-existing entity from the service, or using a new key per property, both of which are not suitable for performance reasons.</span></span>     

<span data-ttu-id="9e2df-370">További információ a táblabeli adatok titkosítása: [ügyféloldali titkosítás és a Microsoft Azure tárolás az Azure Key Vault](storage-client-side-encryption.md).</span><span class="sxs-lookup"><span data-stu-id="9e2df-370">For information about encrypting table data, see [Client-Side Encryption and Azure Key Vault for Microsoft Azure Storage](storage-client-side-encryption.md).</span></span>  

## <a name="modelling-relationships"></a><span data-ttu-id="9e2df-371">Kapcsolatok modellezésére</span><span class="sxs-lookup"><span data-stu-id="9e2df-371">Modelling relationships</span></span>
<span data-ttu-id="9e2df-372">A Tervező összetett rendszerek kulcsfontosságú lépés létrehozási modelleket tartomány.</span><span class="sxs-lookup"><span data-stu-id="9e2df-372">Building domain models is a key step in the design of complex systems.</span></span> <span data-ttu-id="9e2df-373">Általában a modellezési folyamat segítségével azonosíthatja a entitásokat és a köztük lévő viszonyt is egyik módja az üzleti tartomány megértéséhez, valamint a tervezési, a rendszer tájékoztatja.</span><span class="sxs-lookup"><span data-stu-id="9e2df-373">Typically, you use the modelling process to identify entities and the relationships between them as a way to understand the business domain and inform the design of your system.</span></span> <span data-ttu-id="9e2df-374">Ez a szakasz összpontosít hogyan tudja lefordítani néhány a közös kapcsolattípusok tartomány modellek mintájára a Table szolgáltatás található.</span><span class="sxs-lookup"><span data-stu-id="9e2df-374">This section focuses on how you can translate some of the common relationship types found in domain models to designs for the Table service.</span></span> <span data-ttu-id="9e2df-375">Egy logikai adatmodell-leképezés egy fizikai alapú NoSQL-adatmodellhez folyamat nagyon eltér a relációs tervezése során használt.</span><span class="sxs-lookup"><span data-stu-id="9e2df-375">The process of mapping from a logical data-model to a physical NoSQL based data-model is very different from that used when designing a relational database.</span></span> <span data-ttu-id="9e2df-376">Relációs adatbázisok terv általában azt feltételezi, hogy a normalizálási adatfeldolgozás minimalizálja a redundancia – és a deklaratív lekérdező képessége, hogy hogyan végrehajtásának az adatbázis működésének kivonatolja optimalizálva.</span><span class="sxs-lookup"><span data-stu-id="9e2df-376">Relational databases design typically assumes a data normalization process optimized for minimizing redundancy – and a declarative querying capability that abstracts how the implementation of how the database works.</span></span>  

### <a name="one-to-many-relationships"></a><span data-ttu-id="9e2df-377">Egy-a-többhöz kapcsolatok</span><span class="sxs-lookup"><span data-stu-id="9e2df-377">One-to-many relationships</span></span>
<span data-ttu-id="9e2df-378">Egy-a-többhöz kapcsolatok üzleti tartomány objektumok közötti nagyon gyakran előfordulnak: például egy részleg rendelkezik sok alkalmazott.</span><span class="sxs-lookup"><span data-stu-id="9e2df-378">One-to-many relationships between business domain objects occur very frequently: for example, one department has many employees.</span></span> <span data-ttu-id="9e2df-379">Többféleképpen is egy-a-többhöz kapcsolatok szolgáltatásban a tábla minden egyes az előnyei és hátrányai, amely fontos lehet az adott forgatókönyv megvalósításához.</span><span class="sxs-lookup"><span data-stu-id="9e2df-379">There are several ways to implement one-to-many relationships in the Table service each with pros and cons that may be relevant to the particular scenario.</span></span>  

<span data-ttu-id="9e2df-380">Vegye figyelembe a példa egy nagy több nemzeti vállalat osztályai és ahol minden részlege rendelkezik sok alkalmazott, és minden alkalmazott, egy adott részleg társított alkalmazott entitások tízezreit tartalmazó.</span><span class="sxs-lookup"><span data-stu-id="9e2df-380">Consider the example of a large multi-national corporation with tens of thousands of departments and employee entities where every department has many employees and each employee as associated with one specific department.</span></span> <span data-ttu-id="9e2df-381">Egy megoldás, külön részleg és az alkalmazott entitások, például a tároló:</span><span class="sxs-lookup"><span data-stu-id="9e2df-381">One approach is to store separate department and employee entities such as these:</span></span>  

![][1]

<span data-ttu-id="9e2df-382">Ez a példa bemutatja egy implicit egy-a-többhöz kapcsolat alapján típusa közötti a **PartitionKey** érték.</span><span class="sxs-lookup"><span data-stu-id="9e2df-382">This example shows an implicit one-to-many relationship between the types based on the **PartitionKey** value.</span></span> <span data-ttu-id="9e2df-383">Minden részleghez rendelkezhet sok alkalmazott.</span><span class="sxs-lookup"><span data-stu-id="9e2df-383">Each department can have many employees.</span></span>  

<span data-ttu-id="9e2df-384">Ez a példa egy szervezeti egység és a kapcsolódó alkalmazott entitásokat is tartalmazó partícióra szerepel.</span><span class="sxs-lookup"><span data-stu-id="9e2df-384">This example also shows a department entity and its related employee entities in the same partition.</span></span> <span data-ttu-id="9e2df-385">Megadhatja, hogy a különböző entitástípusok különböző partíciók, táblák, vagy még akkor is, storage-fiókok használandó.</span><span class="sxs-lookup"><span data-stu-id="9e2df-385">You could choose to use different partitions, tables, or even storage accounts for the different entity types.</span></span>  

<span data-ttu-id="9e2df-386">Egy másik módszert is, hogy az adatok denormalize és csak alkalmazott entitások denormalizált részleg adatokkal a következő példában látható módon tárolja.</span><span class="sxs-lookup"><span data-stu-id="9e2df-386">An alternative approach is to denormalize your data and store only employee entities with denormalized department data as shown in the following example.</span></span> <span data-ttu-id="9e2df-387">Adott esetben ez a megközelítés denormalizált nem lehet a legjobb lehet módosítani a részleg vezetője részleteit, mert ehhez frissítenie kell az osztály minden alkalmazott számára, ha.</span><span class="sxs-lookup"><span data-stu-id="9e2df-387">In this particular scenario, this denormalized approach may not be the best if you have a requirement to be able to change the details of a department manager because to do this you need to update every employee in the department.</span></span>  

![][2]

<span data-ttu-id="9e2df-388">További információkért lásd: a [Denormalization mintát](#denormalization-pattern) című útmutatóban.</span><span class="sxs-lookup"><span data-stu-id="9e2df-388">For more information, see the [Denormalization pattern](#denormalization-pattern) later in this guide.</span></span>  

<span data-ttu-id="9e2df-389">Az alábbi táblázat foglalja össze, és az egyes az alkalmazottak és a részleg entitások, amelyek egy-a-többhöz tárolását a fent vázolt módszerekkel.</span><span class="sxs-lookup"><span data-stu-id="9e2df-389">The following table summarizes the pros and cons of each of the approaches outlined above for storing employee and department entities that have a one-to-many relationship.</span></span> <span data-ttu-id="9e2df-390">Emellett érdemes milyen gyakran várható a különböző műveletek végrehajtásához: elfogadható kell rendelkeznie, amely tartalmaz egy drága művelet, ha ez a művelet csak akkor fordul elő, a ritkán lehet.</span><span class="sxs-lookup"><span data-stu-id="9e2df-390">You should also consider how often you expect to perform various operations: it may be acceptable to have a design that includes an expensive operation if that operation only happens infrequently.</span></span>  

<table>
<tr>
<th><span data-ttu-id="9e2df-391">Módszer</span><span class="sxs-lookup"><span data-stu-id="9e2df-391">Approach</span></span></th>
<th><span data-ttu-id="9e2df-392">Informatikai szakemberek</span><span class="sxs-lookup"><span data-stu-id="9e2df-392">Pros</span></span></th>
<th><span data-ttu-id="9e2df-393">Hátrányok</span><span class="sxs-lookup"><span data-stu-id="9e2df-393">Cons</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="9e2df-394">Külön entitástípusok, egyazon partícióra kerüljenek, ugyanahhoz a táblához</span><span class="sxs-lookup"><span data-stu-id="9e2df-394">Separate entity types, same partition, same table</span></span></td>
<td>
<ul>
<li><span data-ttu-id="9e2df-395">A részleg entitás egyetlen művelettel frissítheti.</span><span class="sxs-lookup"><span data-stu-id="9e2df-395">You can update a department entity with a single operation.</span></span></li>
<li><span data-ttu-id="9e2df-396">Egy EGT használatával biztosítja az egységességet, ha egy szervezeti egység módosítása követelmény amikor Ön frissítés/Beszúrás/törlés alkalmazott entitás.</span><span class="sxs-lookup"><span data-stu-id="9e2df-396">You can use an EGT to maintain consistency if you have a requirement to modify a department entity whenever you update/insert/delete an employee entity.</span></span> <span data-ttu-id="9e2df-397">Például ha a részlegszintű alkalmazott száma minden részleg számára.</span><span class="sxs-lookup"><span data-stu-id="9e2df-397">For example if you maintain a departmental employee count for each department.</span></span></li>
</ul>
</td>
<td>
<ul>
<li><span data-ttu-id="9e2df-398">Az alkalmazottak és a bizonyos ügyfél tevékenységek egy részleg entitást szeretne.</span><span class="sxs-lookup"><span data-stu-id="9e2df-398">You may need to retrieve both an employee and a department entity for some client activities.</span></span></li>
<li><span data-ttu-id="9e2df-399">Tárolási műveletekre kerül sor a partícióra.</span><span class="sxs-lookup"><span data-stu-id="9e2df-399">Storage operations happen in the same partition.</span></span> <span data-ttu-id="9e2df-400">A magas tranzakció kötetek Ez azt eredményezheti, interaktív terület.</span><span class="sxs-lookup"><span data-stu-id="9e2df-400">At high transaction volumes, this may result in a hotspot.</span></span></li>
<li><span data-ttu-id="9e2df-401">Egy alkalmazott egy új osztály használatával egy EGT nem helyezhető át.</span><span class="sxs-lookup"><span data-stu-id="9e2df-401">You cannot move an employee to a new department using an EGT.</span></span></li>
</ul>
</td>
</tr>
<tr>
<td><span data-ttu-id="9e2df-402">Külön entitástípusok, a különböző partíciók vagy a táblák vagy a storage-fiókok</span><span class="sxs-lookup"><span data-stu-id="9e2df-402">Separate entity types, different partitions or tables or storage accounts</span></span></td>
<td>
<ul>
<li><span data-ttu-id="9e2df-403">A részleg entitás vagy az alkalmazott entitás egyetlen művelettel frissítheti.</span><span class="sxs-lookup"><span data-stu-id="9e2df-403">You can update a department entity or employee entity with a single operation.</span></span></li>
<li><span data-ttu-id="9e2df-404">A magas tranzakció kötetek ez elősegítheti a terhelés elosztva több partíciót.</span><span class="sxs-lookup"><span data-stu-id="9e2df-404">At high transaction volumes, this may help spread the load across more partitions.</span></span></li>
</ul>
</td>
<td>
<ul>
<li><span data-ttu-id="9e2df-405">Az alkalmazottak és a bizonyos ügyfél tevékenységek egy részleg entitást szeretne.</span><span class="sxs-lookup"><span data-stu-id="9e2df-405">You may need to retrieve both an employee and a department entity for some client activities.</span></span></li>
<li><span data-ttu-id="9e2df-406">Nem használhat EGTs biztosítja az egységességet amikor akkor frissítés/Beszúrás/Törlés az alkalmazottak és a frissítés részleget.</span><span class="sxs-lookup"><span data-stu-id="9e2df-406">You cannot use EGTs to maintain consistency when you update/insert/delete an employee and update a department.</span></span> <span data-ttu-id="9e2df-407">Például frissítése folyamatban van egy szervezeti egységben egy alkalmazott száma.</span><span class="sxs-lookup"><span data-stu-id="9e2df-407">For example, updating an employee count in a department entity.</span></span></li>
<li><span data-ttu-id="9e2df-408">Egy alkalmazott egy új osztály használatával egy EGT nem helyezhető át.</span><span class="sxs-lookup"><span data-stu-id="9e2df-408">You cannot move an employee to a new department using an EGT.</span></span></li>
</ul>
</td>
</tr>
<tr>
<td><span data-ttu-id="9e2df-409">Az egyetlen entitás típusa denormalize</span><span class="sxs-lookup"><span data-stu-id="9e2df-409">Denormalize into single entity type</span></span></td>
<td>
<ul>
<li><span data-ttu-id="9e2df-410">Az egy kérelemhez szükséges összes információ kérheti le.</span><span class="sxs-lookup"><span data-stu-id="9e2df-410">You can retrieve all the information you need with a single request.</span></span></li>
</ul>
</td>
<td>
<ul>
<li><span data-ttu-id="9e2df-411">Biztosítja az egységességet, ha a szervezeti adatok (Ez akkor miatt frissítenie kell egy osztály minden alkalmazott) kell drága lehet.</span><span class="sxs-lookup"><span data-stu-id="9e2df-411">It may be expensive to maintain consistency if you need to update department information (this would require you to update all the employees in a department).</span></span></li>
</ul>
</td>
</tr>
</table>

<span data-ttu-id="9e2df-412">Hogyan választja ezeket a beállításokat, és mely előnyének és hátrányának jelentős, függ az adott alkalmazás forgatókönyvek között.</span><span class="sxs-lookup"><span data-stu-id="9e2df-412">How you choose between these options, and which of the pros and cons are most significant, depends on your specific application scenarios.</span></span> <span data-ttu-id="9e2df-413">Például milyen gyakran tegye módosítása részleg entitások; szükség van a további részlegre vonatkozó információkat; az alkalmazott lekérdezés milyen közel legyenek, a partíciók vagy a tárfiók a méretezhetőségének korlátai?</span><span class="sxs-lookup"><span data-stu-id="9e2df-413">For example, how often do you modify department entities; do all your employee queries need the additional departmental information; how close are you to the scalability limits on your partitions or your storage account?</span></span>  

### <a name="one-to-one-relationships"></a><span data-ttu-id="9e2df-414">-Az-egyhez kapcsolat</span><span class="sxs-lookup"><span data-stu-id="9e2df-414">One-to-one relationships</span></span>
<span data-ttu-id="9e2df-415">Tartomány modellek egy az egyhez típusú entitások közötti kapcsolatok is tartalmazhat.</span><span class="sxs-lookup"><span data-stu-id="9e2df-415">Domain models may include one-to-one relationships between entities.</span></span> <span data-ttu-id="9e2df-416">Kell megvalósítani a Table szolgáltatás egy az egyhez kapcsolat, a két kapcsolódó entitás csatolása, ha vissza mindkét kell is ki kell választania.</span><span class="sxs-lookup"><span data-stu-id="9e2df-416">If you need to implement a one-to-one relationship in the Table service, you must also choose how to link the two related entities when you need to retrieve them both.</span></span> <span data-ttu-id="9e2df-417">Ez a hivatkozás lehet implicit, egy egyezmény értékek alapján, vagy explicit hivatkozás formájában elhelyezésével **PartitionKey** és **RowKey** értékek az entitásban, a kapcsolódó entitás.</span><span class="sxs-lookup"><span data-stu-id="9e2df-417">This link can be either implicit, based on a convention in the key values, or explicit by storing a link in the form of **PartitionKey** and **RowKey** values in each entity to its related entity.</span></span> <span data-ttu-id="9e2df-418">E tárolja a kapcsolódó entitásokból partícióra tárgyalását című [egy-a-többhöz kapcsolatok](#one-to-many-relationships).</span><span class="sxs-lookup"><span data-stu-id="9e2df-418">For a discussion of whether you should store the related entities in the same partition, see the section [One-to-many relationships](#one-to-many-relationships).</span></span>  

<span data-ttu-id="9e2df-419">Vegye figyelembe, hogy nincsenek-e is vezethet, hogy egy az egyhez kapcsolat megvalósíthatja a Table szolgáltatás megvalósítási szempontokat:</span><span class="sxs-lookup"><span data-stu-id="9e2df-419">Note that there are also implementation considerations that might lead you to implement one-to-one relationships in the Table service:</span></span>  

* <span data-ttu-id="9e2df-420">Nagy entitások kezelése (további információkért lásd: [nagy entitások mintát](#large-entities-pattern)).</span><span class="sxs-lookup"><span data-stu-id="9e2df-420">Handling large entities (for more information, see [Large Entities Pattern](#large-entities-pattern)).</span></span>  
* <span data-ttu-id="9e2df-421">A végrehajtási hozzáférés-vezérlést (további információkért lásd: [megosztott hozzáférési aláírásokkal-hozzáférés szabályozásáról](#controlling-access-with-shared-access-signatures)).</span><span class="sxs-lookup"><span data-stu-id="9e2df-421">Implementing access controls (for more information, see [Controlling access with Shared Access Signatures](#controlling-access-with-shared-access-signatures)).</span></span>  

### <a name="join-in-the-client"></a><span data-ttu-id="9e2df-422">Az ügyfél csatlakozott</span><span class="sxs-lookup"><span data-stu-id="9e2df-422">Join in the client</span></span>
<span data-ttu-id="9e2df-423">Bár vannak lehetőségek kapcsolatok modellezésére a Table szolgáltatásban, érdemes nem elfelejti, hogy a két elsődleges oka a Table szolgáltatás használatára vonatkozó-e a méretezhetőséget és teljesítményt nyújt.</span><span class="sxs-lookup"><span data-stu-id="9e2df-423">Although there are ways to model relationships in the Table service, you should not forget that the two prime reasons for using the Table service are scalability and performance.</span></span> <span data-ttu-id="9e2df-424">Ha meg vannak modellezés több kapcsolatot, amelyek veszélyeztetik a teljesítmény és méretezhetőség a megoldás, kérdezze meg saját kezűleg esetén az adatok minden olyan kapcsolat létrehozásához rendszerbe tábla szükséges.</span><span class="sxs-lookup"><span data-stu-id="9e2df-424">If you find you are modelling many relationships that compromise the performance and scalability of your solution, you should ask yourself if it is necessary to build all the data relationships into your table design.</span></span> <span data-ttu-id="9e2df-425">Előfordulhat, hogy a tervezési és javítását célzó méretezhetőségét és teljesítményét a megoldás, ha az ügyfélalkalmazást, hajtsa végre a szükséges illesztések.</span><span class="sxs-lookup"><span data-stu-id="9e2df-425">You may be able to simplify the design and improve the scalability and performance of your solution if you let your client application perform any necessary joins.</span></span>  

<span data-ttu-id="9e2df-426">Például ha adatokat tartalmaznak, amelyek nem változik gyakran nagyon kis táblákhoz, majd után lekérdezhetik ezeket az adatokat többször is gyorsítótárazása azt az ügyfélen.</span><span class="sxs-lookup"><span data-stu-id="9e2df-426">For example, if you have small tables that contain data that does not change very often, then you can retrieve this data once and cache it on the client.</span></span> <span data-ttu-id="9e2df-427">Ennek elkerülése érdekében ismételt használatával ugyanazokat az adatokat beolvasni.</span><span class="sxs-lookup"><span data-stu-id="9e2df-427">This can avoid repeated roundtrips to retrieve the same data.</span></span> <span data-ttu-id="9e2df-428">A példákban azt kell venni, a jelen útmutató kis szervezet szervezeti egységek készletét valószínű, hogy rövid, és módosítsa a ritkán így egy jó jelölt az ügyfélalkalmazás tölthetik le egyszer adatok és a gyorsítótár, keresse meg a adatok.</span><span class="sxs-lookup"><span data-stu-id="9e2df-428">In the examples we have looked at in this guide, the set of departments in a small organization is likely to be small and change infrequently making it a good candidate for data that client application can download once and cache as look up data.</span></span>  

### <a name="inheritance-relationships"></a><span data-ttu-id="9e2df-429">Öröklődés kapcsolatok</span><span class="sxs-lookup"><span data-stu-id="9e2df-429">Inheritance relationships</span></span>
<span data-ttu-id="9e2df-430">Ha az ügyfélalkalmazást használ, amely egy üzleti entitásokat képviselő öröklési kapcsolatban részét osztályok, egyszerűen a a Table szolgáltatásban entitásokból maradnak meg.</span><span class="sxs-lookup"><span data-stu-id="9e2df-430">If your client application uses a set of classes that form part of an inheritance relationship to represent business entities, you can easily persist those entities in the Table service.</span></span> <span data-ttu-id="9e2df-431">Például lehetséges, hogy az ügyfél alkalmazásban megadott üzenetosztályának beolvasása a következő funkciócsoport ahol **személy** absztrakt osztály.</span><span class="sxs-lookup"><span data-stu-id="9e2df-431">For example, you might have the following set of classes defined in your client application where **Person** is an abstract class.</span></span>

![][3]

<span data-ttu-id="9e2df-432">A Table szolgáltatásban entitások használata, hogy a hely egyetlen személy tábla használatával két konkrét osztályok példányai is továbbra is fennáll:</span><span class="sxs-lookup"><span data-stu-id="9e2df-432">You can persist instances of the two concrete classes in the Table service using a single Person table using entities in that look like this:</span></span>  

![][4]

<span data-ttu-id="9e2df-433">További információt az Ügyfélkód ugyanabban a táblában a több entitás, című [használata heterogén entitástípusok](#working-with-heterogeneous-entity-types) Ez az útmutató későbbi.</span><span class="sxs-lookup"><span data-stu-id="9e2df-433">For more information about working with multiple entity types in the same table in client code, see the section [Working with heterogeneous entity types](#working-with-heterogeneous-entity-types) later in this guide.</span></span> <span data-ttu-id="9e2df-434">Ez az Ügyfélkód entitástípus felismerése példákat tartalmaz.</span><span class="sxs-lookup"><span data-stu-id="9e2df-434">This provides examples of how to recognize the entity type in client code.</span></span>  

## <a name="table-design-patterns"></a><span data-ttu-id="9e2df-435">Táblázat kialakítási minták</span><span class="sxs-lookup"><span data-stu-id="9e2df-435">Table Design Patterns</span></span>
<span data-ttu-id="9e2df-436">A korábbi szakaszokban láthatta, néhány részletes beszélgetéseket optimalizálása a Táblatervezés mindkét lekérése során Entitásadatok lekérdezésekkel és beszúrását, frissítését és entitás adatok törlése.</span><span class="sxs-lookup"><span data-stu-id="9e2df-436">In previous sections, you have seen some detailed discussions about how to optimize your table design for both retrieving entity data using queries and for inserting, updating, and deleting entity data.</span></span> <span data-ttu-id="9e2df-437">Ez a szakasz ismerteti az egyes mintázatok megfelelő Table szolgáltatási megoldások való használatra.</span><span class="sxs-lookup"><span data-stu-id="9e2df-437">This section describes some patterns appropriate for use with Table service solutions.</span></span> <span data-ttu-id="9e2df-438">Ezenkívül láthatja, hogyan meg is gyakorlatilag cím egyes problémák és kompromisszumot alakítson ki az útmutatóban korábban következik be.</span><span class="sxs-lookup"><span data-stu-id="9e2df-438">In addition, you will see how you can practically address some of the issues and trade-offs raised previously in this guide.</span></span> <span data-ttu-id="9e2df-439">Az alábbi ábra a különböző minták kapcsolatai foglalja össze:</span><span class="sxs-lookup"><span data-stu-id="9e2df-439">The following diagram summarizes the relationships between the different patterns:</span></span>  

![][5]

<span data-ttu-id="9e2df-440">A minta térkép fent néhány minták (kék) és a jelen útmutatóban leírt elleni minták (narancs) közötti kapcsolatokat mutatja be.</span><span class="sxs-lookup"><span data-stu-id="9e2df-440">The pattern map above highlights some relationships between patterns (blue) and anti-patterns (orange) that are documented in this guide.</span></span> <span data-ttu-id="9e2df-441">Természetesen nincsenek sok más mintákat, amelyek érdemes figyelembe véve.</span><span class="sxs-lookup"><span data-stu-id="9e2df-441">There are of course many other patterns that are worth considering.</span></span> <span data-ttu-id="9e2df-442">Például a Table szolgáltatás azon kulcsfontosságú forgatókönyvek egyike használatára a [materializált nézet mintát](https://msdn.microsoft.com/library/azure/dn589782.aspx) a a [parancs lekérdezés felelősségi elkülönítése (CQRS)](https://msdn.microsoft.com/library/azure/jj554200.aspx) mintát.</span><span class="sxs-lookup"><span data-stu-id="9e2df-442">For example, one of the key scenarios for Table Service is to use the [Materialized View Pattern](https://msdn.microsoft.com/library/azure/dn589782.aspx) from the [Command Query Responsibility Segregation (CQRS)](https://msdn.microsoft.com/library/azure/jj554200.aspx) pattern.</span></span>  

### <a name="intra-partition-secondary-index-pattern"></a><span data-ttu-id="9e2df-443">Helyen belüli-partíció másodlagos index minta</span><span class="sxs-lookup"><span data-stu-id="9e2df-443">Intra-partition secondary index pattern</span></span>
<span data-ttu-id="9e2df-444">Több másolatot minden entitás használatával különböző tárolására **RowKey** értékeket (a partícióra) engedélyezése gyors és hatékony keresések és a másodlagos rendezési sorrend különböző **RowKey** értékeket.</span><span class="sxs-lookup"><span data-stu-id="9e2df-444">Store multiple copies of each entity using different **RowKey** values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span> <span data-ttu-id="9e2df-445">Példányok közötti frissítéseket is konzisztens EGT tartozó használatával.</span><span class="sxs-lookup"><span data-stu-id="9e2df-445">Updates between copies can be kept consistent using EGT's.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="9e2df-446">A környezetben, és probléma</span><span class="sxs-lookup"><span data-stu-id="9e2df-446">Context and problem</span></span>
<span data-ttu-id="9e2df-447">A Table szolgáltatás automatikusan elvégzi a segítségével a **PartitionKey** és **RowKey** értékeket.</span><span class="sxs-lookup"><span data-stu-id="9e2df-447">The Table service automatically indexes entities using the **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="9e2df-448">Ez lehetővé teszi, hogy hatékonyan végez ezeket az értékeket entitást lekérdezni egy ügyfélalkalmazást.</span><span class="sxs-lookup"><span data-stu-id="9e2df-448">This enables a client application to retrieve an entity efficiently using these values.</span></span> <span data-ttu-id="9e2df-449">Például a lent látható módon táblaszerkezet, ügyfélalkalmazás használatával pont lekérdezés egy adott alkalmazott bejegyzés lekérdezésére a részleg neve és az alkalmazott azonosítója (a **PartitionKey** és **RowKey** értékek).</span><span class="sxs-lookup"><span data-stu-id="9e2df-449">For example, using the table structure shown below, a client application can use a point query to retrieve an individual employee entity by using the department name and the employee id (the **PartitionKey** and **RowKey** values).</span></span> <span data-ttu-id="9e2df-450">Egy ügyfél is kérje le az entitásokat alkalmazottazonosító belül minden részleg szerint rendezve.</span><span class="sxs-lookup"><span data-stu-id="9e2df-450">A client can also retrieve entities sorted by employee id within each department.</span></span>

![][6]

<span data-ttu-id="9e2df-451">Ha is érdemes lehet egy másik tulajdonság, például az e-mail cím alapján alkalmazott entitás megkeresni a kevésbé hatékony partíció ellenőrzések keres kell használnia.</span><span class="sxs-lookup"><span data-stu-id="9e2df-451">If you also want to be able to find an employee entity based on the value of another property, such as email address, you must use a less efficient partition scan to find a match.</span></span> <span data-ttu-id="9e2df-452">Ennek oka az, a table szolgáltatás nem adja meg a másodlagos kulcsot.</span><span class="sxs-lookup"><span data-stu-id="9e2df-452">This is because the table service does not provide secondary indexes.</span></span> <span data-ttu-id="9e2df-453">Ezenkívül nincs lehetőség az alkalmazottakat, mint egy másik sorrendbe rendezve kéréséhez **RowKey** sorrendje.</span><span class="sxs-lookup"><span data-stu-id="9e2df-453">In addition, there is no option to request a list of employees sorted in a different order than **RowKey** order.</span></span>  

#### <a name="solution"></a><span data-ttu-id="9e2df-454">Megoldás</span><span class="sxs-lookup"><span data-stu-id="9e2df-454">Solution</span></span>
<span data-ttu-id="9e2df-455">Másodlagos indexek hiánya megoldása érdekében minden egyes másolataihoz, a különböző entitás több példányát is tárolhatja **RowKey** érték.</span><span class="sxs-lookup"><span data-stu-id="9e2df-455">To work around the lack of secondary indexes, you can store multiple copies of each entity with each copy using a different **RowKey** value.</span></span> <span data-ttu-id="9e2df-456">Ha egy entitás tárolja az alább látható struktúrákat, e-mail címét vagy az alkalmazott azonosítója alapján alkalmazott entitások hatékonyan kérheti le.</span><span class="sxs-lookup"><span data-stu-id="9e2df-456">If you store an entity with the structures shown below, you can efficiently retrieve employee entities based on email address or employee id.</span></span> <span data-ttu-id="9e2df-457">Az előtag értékei a **RowKey**, "empid_" és "email_" lehetővé teszi egyetlen alkalmazott vagy alkalmazottak számos lekérdezése a számos különböző e-mail címek vagy alkalmazott-azonosítók használatával.</span><span class="sxs-lookup"><span data-stu-id="9e2df-457">The prefix values for the **RowKey**, "empid_" and "email_" enable you to query for a single employee or a range of employees by using a range of email addresses or employee ids.</span></span>  

![][7]

<span data-ttu-id="9e2df-458">Az alábbi két feltételeket (egy keresésekor által alkalmazott- és egy keresése e-mail cím alapján) is adja meg a pont lekérdezéseket:</span><span class="sxs-lookup"><span data-stu-id="9e2df-458">The following two filter criteria (one looking up by employee id and one looking up by email address) both specify point queries:</span></span>  

* <span data-ttu-id="9e2df-459">$filter = (PartitionKey eq 'Értékesítés') és (RowKey eq "empid_000223")</span><span class="sxs-lookup"><span data-stu-id="9e2df-459">$filter=(PartitionKey eq 'Sales') and (RowKey eq 'empid_000223')</span></span>  
* <span data-ttu-id="9e2df-460">$filter = (PartitionKey eq 'Értékesítés') és (RowKey eq 'email_jonesj@contoso.com")</span><span class="sxs-lookup"><span data-stu-id="9e2df-460">$filter=(PartitionKey eq 'Sales') and (RowKey eq 'email_jonesj@contoso.com')</span></span>  

<span data-ttu-id="9e2df-461">Ha alkalmazott entitástartományának kérdezze le, megadhatja a alkalmazott azonosítója sorrendbe rendezve tartománya vagy egy tartományt, a megfelelő előtaggal rendelkező entitások lekérdezésével e-mail cím sorrendbe rendezve a **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="9e2df-461">If you query for a range of employee entities, you can specify a range sorted in employee id order, or a range sorted in email address order by querying for entities with the appropriate prefix in the **RowKey**.</span></span>  

* <span data-ttu-id="9e2df-462">Az alkalmazottak található a tartomány 000100 való 000199 használatban alkalmazott azonosítóval rendelkező az értékesítési osztályon: $filter = (PartitionKey eq 'Értékesítés') és (RowKey ge "empid_000100") és (RowKey le "empid_000199")</span><span class="sxs-lookup"><span data-stu-id="9e2df-462">To find all the employees in the Sales department with an employee id in the range 000100 to 000199 use: $filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000100') and (RowKey le 'empid_000199')</span></span>  
* <span data-ttu-id="9e2df-463">Az alkalmazottak található az értékesítési osztályon kezdve "a" használja e-mail címmel rendelkező: $filter = (PartitionKey eq 'Értékesítés') és (RowKey ge "email_a") és (RowKey lt "email_b")</span><span class="sxs-lookup"><span data-stu-id="9e2df-463">To find all the employees in the Sales department with an email address starting with the letter 'a' use: $filter=(PartitionKey eq 'Sales') and (RowKey ge 'email_a') and (RowKey lt 'email_b')</span></span>  
  
  <span data-ttu-id="9e2df-464">Vegye figyelembe, hogy a Table szolgáltatásból REST API-t a további tudnivalókat lásd a fenti példákban használt szűrőszintaxisának [lekérdezés entitások](http://msdn.microsoft.com/library/azure/dd179421.aspx).</span><span class="sxs-lookup"><span data-stu-id="9e2df-464">Note that the filter syntax used in the examples above is from the Table service REST API, for more information see [Query Entities](http://msdn.microsoft.com/library/azure/dd179421.aspx).</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="9e2df-465">Problémákat és szempontok</span><span class="sxs-lookup"><span data-stu-id="9e2df-465">Issues and considerations</span></span>
<span data-ttu-id="9e2df-466">Ebben a mintában megvalósításához meghatározásakor, vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="9e2df-466">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="9e2df-467">A TABLE storage viszonylag olcsó használatára, így költség növeli a duplikált adatok tárolására nem szabad jelentős probléma.</span><span class="sxs-lookup"><span data-stu-id="9e2df-467">Table storage is relatively cheap to use so the cost overhead of storing duplicate data should not be a major concern.</span></span> <span data-ttu-id="9e2df-468">Azonban kell kiértékelésének eredménye mindig a tervező a várható tárolási szükségletek költségeinek, és csak hozzá az ügyfélalkalmazást hajtja végre a lekérdezéseket kettős bejegyzés.</span><span class="sxs-lookup"><span data-stu-id="9e2df-468">However, you should always evaluate the cost of your design based on your anticipated storage requirements and only add duplicate entities to support the queries your client application will execute.</span></span>  
* <span data-ttu-id="9e2df-469">Mivel a másodlagos index entitások az eredeti entitásokat tartalmazó partícióra vannak tárolva, ellenőrizze, hogy nem haladhatja meg a a méretezhetőségi célok, az egyes partíciók.</span><span class="sxs-lookup"><span data-stu-id="9e2df-469">Because the secondary index entities are stored in the same partition as the original entities, you should ensure that you do not exceed the scalability targets for an individual partition.</span></span>  
* <span data-ttu-id="9e2df-470">Beállíthatja, hogy az ismétlődő entitások egymással konzisztenssé i frissíteni az entitást két példányával EGTs használatával.</span><span class="sxs-lookup"><span data-stu-id="9e2df-470">You can keep your duplicate entities consistent with each other by using EGTs to update the two copies of the entity atomically.</span></span> <span data-ttu-id="9e2df-471">Ez azt jelenti, hogy ugyanazon partíció egy entitás összes másolatát tárolja.</span><span class="sxs-lookup"><span data-stu-id="9e2df-471">This implies that you should store all copies of an entity in the same partition.</span></span> <span data-ttu-id="9e2df-472">További információkért tekintse meg a szakasz [entitás csoport tranzakciók használatával](#entity-group-transactions).</span><span class="sxs-lookup"><span data-stu-id="9e2df-472">For more information, see the section [Using Entity Group Transactions](#entity-group-transactions).</span></span>  
* <span data-ttu-id="9e2df-473">A használt érték a **RowKey** minden egyes entitásnál egyedinek kell lennie.</span><span class="sxs-lookup"><span data-stu-id="9e2df-473">The value used for the **RowKey** must be unique for each entity.</span></span> <span data-ttu-id="9e2df-474">Érdemes lehet összetett kulcs értékeket.</span><span class="sxs-lookup"><span data-stu-id="9e2df-474">Consider using compound key values.</span></span>  
* <span data-ttu-id="9e2df-475">Kitöltési szerepel benne numerikus érték a **RowKey** (például a alkalmazottazonosító 000223), lehetővé teszi, hogy javítsa ki, rendezési és szűrési alapján felső és alsó határait.</span><span class="sxs-lookup"><span data-stu-id="9e2df-475">Padding numeric values in the **RowKey** (for example, the employee id 000223), enables correct sorting and filtering based on upper and lower bounds.</span></span>  
* <span data-ttu-id="9e2df-476">Nem feltétlenül kell ismétlődő az entitás tulajdonságait.</span><span class="sxs-lookup"><span data-stu-id="9e2df-476">You do not necessarily need to duplicate all the properties of your entity.</span></span> <span data-ttu-id="9e2df-477">Például ha a lekérdezések, hogy a Keresés az entitásokat, az e-mail cím a **RowKey** soha nem kell az alkalmazott életkora, ezeket az entitásokat eredményezhet. az alábbi szerkezettel:</span><span class="sxs-lookup"><span data-stu-id="9e2df-477">For example, if the queries that lookup the entities using the email address in the **RowKey** never need the employee's age, these entities could have the following structure:</span></span>

![][8]

* <span data-ttu-id="9e2df-478">Általában jobb megoldás, az ismétlődő adatokat tárolhatnak, és győződjön meg arról, hogy egyetlen lekérdezést, a szükséges összes adatot kérheti le egy lekérdezés használata egy entitás, majd egy másikat talált a szükséges adatok kereséséhez.</span><span class="sxs-lookup"><span data-stu-id="9e2df-478">It is typically better to store duplicate data and ensure that you can retrieve all the data you need with a single query, than to use one query to locate an entity and another to lookup the required data.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="9e2df-479">Mikor érdemes használni ezt a mintát</span><span class="sxs-lookup"><span data-stu-id="9e2df-479">When to use this pattern</span></span>
<span data-ttu-id="9e2df-480">Ezt a mintát használja, ha az ügyfélalkalmazást kérje le az entitásokat, különböző kulccsal, számos használatát, ha az ügyfél eltérő rendezési sorrend entitásának lekérése, valamint olyan esetben minden entitás egyedi értékeket számos segítségével azonosíthatja.</span><span class="sxs-lookup"><span data-stu-id="9e2df-480">Use this pattern when your client application needs to retrieve entities using a variety of different keys, when your client needs to retrieve entities in different sort orders, and where you can identify each entity using a variety of unique values.</span></span> <span data-ttu-id="9e2df-481">Azonban ügyelnie kell, hogy Ön nem lépik túl a partíció méretezhetőségének korlátai a különböző entitás keresések végrehajtásakor **RowKey** értékeket.</span><span class="sxs-lookup"><span data-stu-id="9e2df-481">However, you should be sure that you do not exceed the partition scalability limits when you are performing entity lookups using the different **RowKey** values.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="9e2df-482">Útmutató és a kapcsolódó minták</span><span class="sxs-lookup"><span data-stu-id="9e2df-482">Related patterns and guidance</span></span>
<span data-ttu-id="9e2df-483">A következő mintákat és útmutatókat is megfelelő ebben a mintában végrehajtása során:</span><span class="sxs-lookup"><span data-stu-id="9e2df-483">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="9e2df-484">Másodlagos helyek közötti partíció index minta</span><span class="sxs-lookup"><span data-stu-id="9e2df-484">Inter-partition secondary index pattern</span></span>](#inter-partition-secondary-index-pattern)
* [<span data-ttu-id="9e2df-485">Összetett kulcs minta</span><span class="sxs-lookup"><span data-stu-id="9e2df-485">Compound key pattern</span></span>](#compound-key-pattern)
* [<span data-ttu-id="9e2df-486">Entitás csoport tranzakciók</span><span class="sxs-lookup"><span data-stu-id="9e2df-486">Entity Group Transactions</span></span>](#entity-group-transactions)
* [<span data-ttu-id="9e2df-487">Heterogén entitástípusok használata</span><span class="sxs-lookup"><span data-stu-id="9e2df-487">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)

### <a name="inter-partition-secondary-index-pattern"></a><span data-ttu-id="9e2df-488">Másodlagos helyek közötti partíció index minta</span><span class="sxs-lookup"><span data-stu-id="9e2df-488">Inter-partition secondary index pattern</span></span>
<span data-ttu-id="9e2df-489">Több másolatot minden entitás használatával különböző tárolására **RowKey** értékek a különböző partíciók, vagy a külön táblázatokat engedélyezése gyors és hatékony keresések és a másodlagos rendezési sorrend különböző **RowKey** értékeket.</span><span class="sxs-lookup"><span data-stu-id="9e2df-489">Store multiple copies of each entity using different **RowKey** values in separate partitions or in separate tables to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="9e2df-490">A környezetben, és probléma</span><span class="sxs-lookup"><span data-stu-id="9e2df-490">Context and problem</span></span>
<span data-ttu-id="9e2df-491">A Table szolgáltatás automatikusan elvégzi a segítségével a **PartitionKey** és **RowKey** értékeket.</span><span class="sxs-lookup"><span data-stu-id="9e2df-491">The Table service automatically indexes entities using the **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="9e2df-492">Ez lehetővé teszi, hogy hatékonyan végez ezeket az értékeket entitást lekérdezni egy ügyfélalkalmazást.</span><span class="sxs-lookup"><span data-stu-id="9e2df-492">This enables a client application to retrieve an entity efficiently using these values.</span></span> <span data-ttu-id="9e2df-493">Például a lent látható módon táblaszerkezet, ügyfélalkalmazás használatával pont lekérdezés egy adott alkalmazott bejegyzés lekérdezésére a részleg neve és az alkalmazott azonosítója (a **PartitionKey** és **RowKey** értékek).</span><span class="sxs-lookup"><span data-stu-id="9e2df-493">For example, using the table structure shown below, a client application can use a point query to retrieve an individual employee entity by using the department name and the employee id (the **PartitionKey** and **RowKey** values).</span></span> <span data-ttu-id="9e2df-494">Egy ügyfél is kérje le az entitásokat alkalmazottazonosító belül minden részleg szerint rendezve.</span><span class="sxs-lookup"><span data-stu-id="9e2df-494">A client can also retrieve entities sorted by employee id within each department.</span></span>  

![][9]

<span data-ttu-id="9e2df-495">Ha is érdemes lehet egy másik tulajdonság, például az e-mail cím alapján alkalmazott entitás megkeresni a kevésbé hatékony partíció ellenőrzések keres kell használnia.</span><span class="sxs-lookup"><span data-stu-id="9e2df-495">If you also want to be able to find an employee entity based on the value of another property, such as email address, you must use a less efficient partition scan to find a match.</span></span> <span data-ttu-id="9e2df-496">Ennek oka az, a table szolgáltatás nem adja meg a másodlagos kulcsot.</span><span class="sxs-lookup"><span data-stu-id="9e2df-496">This is because the table service does not provide secondary indexes.</span></span> <span data-ttu-id="9e2df-497">Ezenkívül nincs lehetőség az alkalmazottakat, mint egy másik sorrendbe rendezve kéréséhez **RowKey** sorrendje.</span><span class="sxs-lookup"><span data-stu-id="9e2df-497">In addition, there is no option to request a list of employees sorted in a different order than **RowKey** order.</span></span>  

<span data-ttu-id="9e2df-498">Ezeket az entitásokat tranzakciókról nagyon nagy mennyiségű rendszer előrejelző, és szeretné, hogy a Table szolgáltatás szabályozása az ügyfél kockázatának minimalizálása érdekében.</span><span class="sxs-lookup"><span data-stu-id="9e2df-498">You are anticipating a very high volume of transactions against these entities and want to minimize the risk of the Table service throttling your client.</span></span>  

#### <a name="solution"></a><span data-ttu-id="9e2df-499">Megoldás</span><span class="sxs-lookup"><span data-stu-id="9e2df-499">Solution</span></span>
<span data-ttu-id="9e2df-500">Másodlagos indexek hiánya megkerüléséhez tárolhat több másolatot minden példány használatával minden entitás különböző **PartitionKey** és **RowKey** értékeket.</span><span class="sxs-lookup"><span data-stu-id="9e2df-500">To work around the lack of secondary indexes, you can store multiple copies of each entity with each copy using different **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="9e2df-501">Ha egy entitás tárolja az alább látható struktúrákat, e-mail címét vagy az alkalmazott azonosítója alapján alkalmazott entitások hatékonyan kérheti le.</span><span class="sxs-lookup"><span data-stu-id="9e2df-501">If you store an entity with the structures shown below, you can efficiently retrieve employee entities based on email address or employee id.</span></span> <span data-ttu-id="9e2df-502">Az előtag értékei a **PartitionKey**, "empid_" és "email_" engedélyezi, hogy melyik index lekérdezéshez használni kívánt azonosításához.</span><span class="sxs-lookup"><span data-stu-id="9e2df-502">The prefix values for the **PartitionKey**, "empid_" and "email_" enable you to identify which index you want to use for a query.</span></span>  

![][10]

<span data-ttu-id="9e2df-503">Az alábbi két feltételeket (egy keresésekor által alkalmazott- és egy keresése e-mail cím alapján) is adja meg a pont lekérdezéseket:</span><span class="sxs-lookup"><span data-stu-id="9e2df-503">The following two filter criteria (one looking up by employee id and one looking up by email address) both specify point queries:</span></span>  

* <span data-ttu-id="9e2df-504">$filter = (PartitionKey eq ' empid_Sales") és (RowKey eq"000223")</span><span class="sxs-lookup"><span data-stu-id="9e2df-504">$filter=(PartitionKey eq 'empid_Sales') and (RowKey eq '000223')</span></span>
* <span data-ttu-id="9e2df-505">$filter = (PartitionKey eq ' email_Sales") és (RowKey eq 'jonesj@contoso.com")</span><span class="sxs-lookup"><span data-stu-id="9e2df-505">$filter=(PartitionKey eq 'email_Sales') and (RowKey eq 'jonesj@contoso.com')</span></span>  

<span data-ttu-id="9e2df-506">Ha alkalmazott entitástartományának kérdezze le, megadhatja a alkalmazott azonosítója sorrendbe rendezve tartománya vagy egy tartományt, a megfelelő előtaggal rendelkező entitások lekérdezésével e-mail cím sorrendbe rendezve a **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="9e2df-506">If you query for a range of employee entities, you can specify a range sorted in employee id order, or a range sorted in email address order by querying for entities with the appropriate prefix in the **RowKey**.</span></span>  

* <span data-ttu-id="9e2df-507">Az alkalmazottak az értékesítési osztályon az alkalmazott ID tartományban található **000100** való **000199** alkalmazott azonosítója sorrendben használja rendezve: $filter = (PartitionKey eq ' empid_Sales") és (RowKey ge"000100") és (RowKey le "000199")</span><span class="sxs-lookup"><span data-stu-id="9e2df-507">To find all the employees in the Sales department with an employee id in the range **000100** to **000199** sorted in employee id order use: $filter=(PartitionKey eq 'empid_Sales') and (RowKey ge '000100') and (RowKey le '000199')</span></span>  
* <span data-ttu-id="9e2df-508">Az alkalmazottak az értékesítési részleg kezdetű "a" e-mail cím sorrendben használja rendezett e-mail címmel rendelkező kereséséhez: $filter = (PartitionKey eq ' email_Sales") és (RowKey ge"a") és (RowKey lt"b")</span><span class="sxs-lookup"><span data-stu-id="9e2df-508">To find all the employees in the Sales department with an email address that starts with 'a' sorted in email address order use: $filter=(PartitionKey eq 'email_Sales') and (RowKey ge 'a') and (RowKey lt 'b')</span></span>  

<span data-ttu-id="9e2df-509">Vegye figyelembe, hogy a Table szolgáltatásból REST API-t a további tudnivalókat lásd a fenti példákban használt szűrőszintaxisának [lekérdezés entitások](http://msdn.microsoft.com/library/azure/dd179421.aspx).</span><span class="sxs-lookup"><span data-stu-id="9e2df-509">Note that the filter syntax used in the examples above is from the Table service REST API, for more information see [Query Entities](http://msdn.microsoft.com/library/azure/dd179421.aspx).</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="9e2df-510">Problémákat és szempontok</span><span class="sxs-lookup"><span data-stu-id="9e2df-510">Issues and considerations</span></span>
<span data-ttu-id="9e2df-511">Ebben a mintában megvalósításához meghatározásakor, vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="9e2df-511">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="9e2df-512">Hálózati adaptere esetében megtarthatja az ismétlődő entitások idővel konzisztenssé egymással használatával a [idővel konzisztenssé tranzakciók mintát](#eventually-consistent-transactions-pattern) az elsődleges és másodlagos index entitások fenntartásához.</span><span class="sxs-lookup"><span data-stu-id="9e2df-512">You can keep your duplicate entities eventually consistent with each other by using the [Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) to maintain the primary and secondary index entities.</span></span>  
* <span data-ttu-id="9e2df-513">A TABLE storage viszonylag olcsó használatára, így költség növeli a duplikált adatok tárolására nem szabad jelentős probléma.</span><span class="sxs-lookup"><span data-stu-id="9e2df-513">Table storage is relatively cheap to use so the cost overhead of storing duplicate data should not be a major concern.</span></span> <span data-ttu-id="9e2df-514">Azonban kell kiértékelésének eredménye mindig a tervező a várható tárolási szükségletek költségeinek, és csak hozzá az ügyfélalkalmazást hajtja végre a lekérdezéseket kettős bejegyzés.</span><span class="sxs-lookup"><span data-stu-id="9e2df-514">However, you should always evaluate the cost of your design based on your anticipated storage requirements and only add duplicate entities to support the queries your client application will execute.</span></span>  
* <span data-ttu-id="9e2df-515">A használt érték a **RowKey** minden egyes entitásnál egyedinek kell lennie.</span><span class="sxs-lookup"><span data-stu-id="9e2df-515">The value used for the **RowKey** must be unique for each entity.</span></span> <span data-ttu-id="9e2df-516">Érdemes lehet összetett kulcs értékeket.</span><span class="sxs-lookup"><span data-stu-id="9e2df-516">Consider using compound key values.</span></span>  
* <span data-ttu-id="9e2df-517">Kitöltési szerepel benne numerikus érték a **RowKey** (például a alkalmazottazonosító 000223), lehetővé teszi, hogy javítsa ki, rendezési és szűrési alapján felső és alsó határait.</span><span class="sxs-lookup"><span data-stu-id="9e2df-517">Padding numeric values in the **RowKey** (for example, the employee id 000223), enables correct sorting and filtering based on upper and lower bounds.</span></span>  
* <span data-ttu-id="9e2df-518">Nem feltétlenül kell ismétlődő az entitás tulajdonságait.</span><span class="sxs-lookup"><span data-stu-id="9e2df-518">You do not necessarily need to duplicate all the properties of your entity.</span></span> <span data-ttu-id="9e2df-519">Például ha a lekérdezések, hogy a Keresés az entitásokat, az e-mail cím a **RowKey** soha nem kell az alkalmazott életkora, ezeket az entitásokat eredményezhet. az alábbi szerkezettel:</span><span class="sxs-lookup"><span data-stu-id="9e2df-519">For example, if the queries that lookup the entities using the email address in the **RowKey** never need the employee's age, these entities could have the following structure:</span></span>
  
  ![][11]
* <span data-ttu-id="9e2df-520">Érdemes jellemzően ismétlődő adatokat tárolhatnak, és győződjön meg arról, hogy egyetlen lekérdezést egy lekérdezési használata a másodlagos index, míg a másik keresési a szükséges adatok használatát az elsődleges index entitás található a szükséges összes adatot kérheti le.</span><span class="sxs-lookup"><span data-stu-id="9e2df-520">It is typically better to store duplicate data and ensure that you can retrieve all the data you need with a single query than to use one query to locate an entity using the secondary index and another to lookup the required data in the primary index.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="9e2df-521">Mikor érdemes használni ezt a mintát</span><span class="sxs-lookup"><span data-stu-id="9e2df-521">When to use this pattern</span></span>
<span data-ttu-id="9e2df-522">Ezt a mintát használja, ha az ügyfélalkalmazást kérje le az entitásokat, különböző kulccsal, számos használatát, ha az ügyfél eltérő rendezési sorrend entitásának lekérése, valamint olyan esetben minden entitás egyedi értékeket számos segítségével azonosíthatja.</span><span class="sxs-lookup"><span data-stu-id="9e2df-522">Use this pattern when your client application needs to retrieve entities using a variety of different keys, when your client needs to retrieve entities in different sort orders, and where you can identify each entity using a variety of unique values.</span></span> <span data-ttu-id="9e2df-523">Ezt a mintát használja, ha el szeretné kerülni, a partíció méretezhetőségének korlátai meghaladja a különböző entitás keresések végrehajtásakor **RowKey** értékeket.</span><span class="sxs-lookup"><span data-stu-id="9e2df-523">Use this pattern when you want to avoid exceeding the partition scalability limits when you are performing entity lookups using the different **RowKey** values.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="9e2df-524">Útmutató és a kapcsolódó minták</span><span class="sxs-lookup"><span data-stu-id="9e2df-524">Related patterns and guidance</span></span>
<span data-ttu-id="9e2df-525">A következő mintákat és útmutatókat is megfelelő ebben a mintában végrehajtása során:</span><span class="sxs-lookup"><span data-stu-id="9e2df-525">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="9e2df-526">Idővel konzisztenssé tranzakciók minta</span><span class="sxs-lookup"><span data-stu-id="9e2df-526">Eventually consistent transactions pattern</span></span>](#eventually-consistent-transactions-pattern)  
* [<span data-ttu-id="9e2df-527">Helyen belüli-partíció másodlagos index minta</span><span class="sxs-lookup"><span data-stu-id="9e2df-527">Intra-partition secondary index pattern</span></span>](#intra-partition-secondary-index-pattern)  
* [<span data-ttu-id="9e2df-528">Összetett kulcs minta</span><span class="sxs-lookup"><span data-stu-id="9e2df-528">Compound key pattern</span></span>](#compound-key-pattern)  
* [<span data-ttu-id="9e2df-529">Entitás csoport tranzakciók</span><span class="sxs-lookup"><span data-stu-id="9e2df-529">Entity Group Transactions</span></span>](#entity-group-transactions)  
* [<span data-ttu-id="9e2df-530">Heterogén entitástípusok használata</span><span class="sxs-lookup"><span data-stu-id="9e2df-530">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)  

### <a name="eventually-consistent-transactions-pattern"></a><span data-ttu-id="9e2df-531">Idővel konzisztenssé tranzakciók minta</span><span class="sxs-lookup"><span data-stu-id="9e2df-531">Eventually consistent transactions pattern</span></span>
<span data-ttu-id="9e2df-532">Engedélyezze a idővel konzisztenssé viselkedés partícióhatárok vagy tárolási rendszer határok az Azure-üzenetsorok használatával.</span><span class="sxs-lookup"><span data-stu-id="9e2df-532">Enable eventually consistent behavior across partition boundaries or storage system boundaries by using Azure queues.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="9e2df-533">A környezetben, és probléma</span><span class="sxs-lookup"><span data-stu-id="9e2df-533">Context and problem</span></span>
<span data-ttu-id="9e2df-534">EGTs atomi tranzakciók engedélyezhető a kiszolgálók közötti ugyanazzal a partíciós kulccsal rendelkező entitásokat.</span><span class="sxs-lookup"><span data-stu-id="9e2df-534">EGTs enable atomic transactions across multiple entities that share the same partition key.</span></span> <span data-ttu-id="9e2df-535">A teljesítmény és méretezhetőség érdekében dönthet külön partíciók vagy egy különálló tárhelyet rendszer konzisztencia-követelményekkel rendelkező entitások tárolására: ilyen esetben nem használhat EGTs biztosítja az egységességet.</span><span class="sxs-lookup"><span data-stu-id="9e2df-535">For performance and scalability reasons, you might decide to store entities that have consistency requirements in separate partitions or in a separate storage system: in such a scenario, you cannot use EGTs to maintain consistency.</span></span> <span data-ttu-id="9e2df-536">Például lehetséges, hogy követelmény a végleges konzisztencia közötti karbantartása:</span><span class="sxs-lookup"><span data-stu-id="9e2df-536">For example, you might have a requirement to maintain eventual consistency between:</span></span>  

* <span data-ttu-id="9e2df-537">Az entitások tárolva két különböző partíciók ugyanabban a táblában, a különböző táblák, a másik tárfiókokban.</span><span class="sxs-lookup"><span data-stu-id="9e2df-537">Entities stored in two different partitions in the same table, in different tables, in in different storage accounts.</span></span>  
* <span data-ttu-id="9e2df-538">A Table szolgáltatásban tárolni entitás és a Blob szolgáltatásban tárolt blob.</span><span class="sxs-lookup"><span data-stu-id="9e2df-538">An entity stored in the Table service and a blob stored in the Blob service.</span></span>  
* <span data-ttu-id="9e2df-539">A Table szolgáltatás és a fájl a fájlrendszerben tárolt entitás.</span><span class="sxs-lookup"><span data-stu-id="9e2df-539">An entity stored in the Table service and a file in a file system.</span></span>  
* <span data-ttu-id="9e2df-540">A Table szolgáltatásban az entitást áruházra még indexelése az Azure Search szolgáltatás használatával.</span><span class="sxs-lookup"><span data-stu-id="9e2df-540">An entity store in the Table service yet indexed using the Azure Search service.</span></span>  

#### <a name="solution"></a><span data-ttu-id="9e2df-541">Megoldás</span><span class="sxs-lookup"><span data-stu-id="9e2df-541">Solution</span></span>
<span data-ttu-id="9e2df-542">Azure üzenetsorok használata esetén alkalmazhat olyan megoldás, amely továbbítja a végleges konzisztencia két vagy több partíciót, vagy tárolási rendszerek között.</span><span class="sxs-lookup"><span data-stu-id="9e2df-542">By using Azure queues, you can implement a solution that delivers eventual consistency across two or more partitions or storage systems.</span></span>
<span data-ttu-id="9e2df-543">Ezt a módszert mutatja be, során feltételezzük, hogy archiválja a régi alkalmazott entitások tennie követelmény.</span><span class="sxs-lookup"><span data-stu-id="9e2df-543">To illustrate this approach, assume you have a requirement to be able to archive old employee entities.</span></span> <span data-ttu-id="9e2df-544">Régi alkalmazott entitások ritkán a rendszer megkérdezi, és olyan tevékenységet, amely az aktuális alkalmazottak kezelésére ki kell zárni.</span><span class="sxs-lookup"><span data-stu-id="9e2df-544">Old employee entities are rarely queried and should be excluded from any activities that deal with current employees.</span></span> <span data-ttu-id="9e2df-545">Ez a követelmény végrehajtásához aktív alkalmazottak tárolja a **aktuális** tábla és a régi alkalmazottak a **archív** tábla.</span><span class="sxs-lookup"><span data-stu-id="9e2df-545">To implement this requirement you store active employees in the **Current** table and old employees in the **Archive** table.</span></span> <span data-ttu-id="9e2df-546">Egy alkalmazott archiválásához törlését a vállalat, a **aktuális** tábla, és adja hozzá az entitás a **archív** táblában, de nem használható egy EGT két művelet végrehajtásához.</span><span class="sxs-lookup"><span data-stu-id="9e2df-546">Archiving an employee requires you to delete the entity from the **Current** table and add the entity to the **Archive** table, but you cannot use an EGT to perform these two operations.</span></span> <span data-ttu-id="9e2df-547">Annak elkerülése érdekében okozó hiba jelenik meg egy entitás mindkét vagy egyiket se táblázatokban, az archiválási művelet idővel konzisztenssé kell lennie.</span><span class="sxs-lookup"><span data-stu-id="9e2df-547">To avoid the risk that a failure causes an entity to appear in both or neither tables, the archive operation must be eventually consistent.</span></span> <span data-ttu-id="9e2df-548">A következő Szekvenciadiagram ebben a műveletben lépéseit mutatja be.</span><span class="sxs-lookup"><span data-stu-id="9e2df-548">The following sequence diagram outlines the steps in this operation.</span></span> <span data-ttu-id="9e2df-549">Kivétel elérési utak, a következő szöveg a biztosított további információkhoz juthat.</span><span class="sxs-lookup"><span data-stu-id="9e2df-549">More detail is provided for exception paths in the text following.</span></span>  

![][12]

<span data-ttu-id="9e2df-550">Üzenet helyez el egy Azure-üzenetsorba, ebben a példában alkalmazott #456 archiválására az ügyfél kezdeményez az archiválási művelet.</span><span class="sxs-lookup"><span data-stu-id="9e2df-550">A client initiates the archive operation by placing a message on an Azure queue, in this example to archive employee #456.</span></span> <span data-ttu-id="9e2df-551">A feldolgozói szerepkör kérdezze le a várólista új üzenetek; Ha talál egyet, kiolvassa az üzenetet, és egy rejtett másolatot elhagyja a várólistán.</span><span class="sxs-lookup"><span data-stu-id="9e2df-551">A worker role polls the queue for new messages; when it finds one, it reads the message and leaves a hidden copy on the queue.</span></span> <span data-ttu-id="9e2df-552">A feldolgozói szerepkör ezután lekéri az entitást egy példányát a **aktuális** table, a másolja a **archív** tábla, és végül törli az eredeti a **aktuális** tábla.</span><span class="sxs-lookup"><span data-stu-id="9e2df-552">The worker role next fetches a copy of the entity from the **Current** table, inserts a copy in the **Archive** table, and then deletes the original from the **Current** table.</span></span> <span data-ttu-id="9e2df-553">Végül ha nincs hiba az előző lépésekben vannak, a feldolgozói szerepkör törli az rejtett üzenetet az üzenetsorból.</span><span class="sxs-lookup"><span data-stu-id="9e2df-553">Finally, if there were no errors from the previous steps, the worker role deletes the hidden message from the queue.</span></span>  

<span data-ttu-id="9e2df-554">Ebben a példában a 4. lépés szúr be az alkalmazott a **archív** tábla.</span><span class="sxs-lookup"><span data-stu-id="9e2df-554">In this example, step 4 inserts the employee into the **Archive** table.</span></span> <span data-ttu-id="9e2df-555">Az alkalmazott a Blob szolgáltatás blob vagy egy fájl a fájlrendszerben hozzáadhatja azt.</span><span class="sxs-lookup"><span data-stu-id="9e2df-555">It could add the employee to a blob in the Blob service or a file in a file system.</span></span>  

#### <a name="recovering-from-failures"></a><span data-ttu-id="9e2df-556">Végezze el a hibák</span><span class="sxs-lookup"><span data-stu-id="9e2df-556">Recovering from failures</span></span>
<span data-ttu-id="9e2df-557">Fontos, hogy lépéseket műveleteknek **4** és **5** kell *idempotent* abban az esetben a feldolgozói szerepkör újra kell indítani az archiválási művelet.</span><span class="sxs-lookup"><span data-stu-id="9e2df-557">It is important that the operations in steps **4** and **5** must be *idempotent* in case the worker role needs to restart the archive operation.</span></span> <span data-ttu-id="9e2df-558">Ha használ a Table szolgáltatás lépés **4** kell használnia az "insert vagy cserélje le a" művelet; lépés **5** kell használnia egy "törlése, ha létezik-e" az ügyféloldali kódtár használata a műveletet.</span><span class="sxs-lookup"><span data-stu-id="9e2df-558">If you are using the Table service, for step **4** you should use an "insert or replace" operation; for step **5** you should use a "delete if exists" operation in the client library you are using.</span></span> <span data-ttu-id="9e2df-559">Ha egy másik tárolási rendszert használ, egy megfelelő idempotent műveletet kell használnia.</span><span class="sxs-lookup"><span data-stu-id="9e2df-559">If you are using another storage system, you must use an appropriate idempotent operation.</span></span>  

<span data-ttu-id="9e2df-560">Ha a feldolgozói szerepkör soha nem fejeződik be a lépés **6**, majd után egy időtúllépési az üzenet ismét megjelenik a várólistán, készen áll arra, hogy újból feldolgozza, próbáljon a feldolgozói szerepkör esetében.</span><span class="sxs-lookup"><span data-stu-id="9e2df-560">If the worker role never completes step **6**, then after a timeout the message reappears on the queue ready for the worker role to try to reprocess it.</span></span> <span data-ttu-id="9e2df-561">A feldolgozói szerepkör ellenőrizheti, hogy hányszor egy üzenetet a várólistában lett, olvassa el, és ha szükséges, ez a jelző külön várólista küldésével egy "elhalt" üzenet, hogy meg lehessen vizsgálni.</span><span class="sxs-lookup"><span data-stu-id="9e2df-561">The worker role can check how many times a message on the queue has been read and, if necessary, flag it is a "poison" message for investigation by sending it to a separate queue.</span></span> <span data-ttu-id="9e2df-562">Várólista-üzenetek olvasásához és a dequeue számának ellenőrzése kapcsolatos további információkért lásd: [üzeneteket beolvasni](https://msdn.microsoft.com/library/azure/dd179474.aspx).</span><span class="sxs-lookup"><span data-stu-id="9e2df-562">For more information about reading queue messages and checking the dequeue count, see [Get Messages](https://msdn.microsoft.com/library/azure/dd179474.aspx).</span></span>  

<span data-ttu-id="9e2df-563">A tábla- és várólista szolgáltatásokból hibák átmeneti hibák, és az ügyfélalkalmazás tartalmaznia kell a megfelelő újrapróbálkozási logika kezelni azokat.</span><span class="sxs-lookup"><span data-stu-id="9e2df-563">Some errors from the Table and Queue services are transient errors, and your client application should include suitable retry logic to handle them.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="9e2df-564">Problémákat és szempontok</span><span class="sxs-lookup"><span data-stu-id="9e2df-564">Issues and considerations</span></span>
<span data-ttu-id="9e2df-565">Ebben a mintában megvalósításához meghatározásakor, vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="9e2df-565">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="9e2df-566">Ez a megoldás elkülönítési tranzakció nem ad meg.</span><span class="sxs-lookup"><span data-stu-id="9e2df-566">This solution does not provide for transaction isolation.</span></span> <span data-ttu-id="9e2df-567">Például egy ügyfél olvasható a **aktuális** és **archív** táblák, ha a feldolgozói szerepkör lépések között **4** és **5**, és tekintse meg egy az adatok inkonzisztens nézetét.</span><span class="sxs-lookup"><span data-stu-id="9e2df-567">For example, a client could read the **Current** and **Archive** tables when the worker role was between steps **4** and **5**, and see an inconsistent view of the data.</span></span> <span data-ttu-id="9e2df-568">Vegye figyelembe, hogy az adatok konzisztens idővel.</span><span class="sxs-lookup"><span data-stu-id="9e2df-568">Note that the data will be consistent eventually.</span></span>  
* <span data-ttu-id="9e2df-569">Lehet, hogy-e 4. és 5 idempotent végleges konzisztencia biztosításához.</span><span class="sxs-lookup"><span data-stu-id="9e2df-569">You must be sure that steps 4 and 5 are idempotent in order to ensure eventual consistency.</span></span>  
* <span data-ttu-id="9e2df-570">A megoldás több várólisták és feldolgozópéldányok szerepkör segítségével méretezhető.</span><span class="sxs-lookup"><span data-stu-id="9e2df-570">You can scale the solution by using multiple queues and worker role instances.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="9e2df-571">Mikor érdemes használni ezt a mintát</span><span class="sxs-lookup"><span data-stu-id="9e2df-571">When to use this pattern</span></span>
<span data-ttu-id="9e2df-572">Ebben a mintában használja, ha azt szeretné, amely szerepel a különböző partíciók, illetve olyan táblázatok entitások közötti végleges konzisztencia biztosításához.</span><span class="sxs-lookup"><span data-stu-id="9e2df-572">Use this pattern when you want to guarantee eventual consistency between entities that exist in different partitions or tables.</span></span> <span data-ttu-id="9e2df-573">Ebben a mintában biztosíthatja a végleges műveletekhez a tábla és a Blob szolgáltatás és más nem Azure Storage között adatforrások, például az adatbázis vagy a fájlrendszer terjeszthetők ki.</span><span class="sxs-lookup"><span data-stu-id="9e2df-573">You can extend this pattern to ensure eventual consistency for operations across the Table service and the Blob service and other non-Azure Storage data sources such as database or the file system.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="9e2df-574">Útmutató és a kapcsolódó minták</span><span class="sxs-lookup"><span data-stu-id="9e2df-574">Related patterns and guidance</span></span>
<span data-ttu-id="9e2df-575">A következő mintákat és útmutatókat is megfelelő ebben a mintában végrehajtása során:</span><span class="sxs-lookup"><span data-stu-id="9e2df-575">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="9e2df-576">Entitás csoport tranzakciók</span><span class="sxs-lookup"><span data-stu-id="9e2df-576">Entity Group Transactions</span></span>](#entity-group-transactions)  
* [<span data-ttu-id="9e2df-577">Egyesítés vagy cseréje</span><span class="sxs-lookup"><span data-stu-id="9e2df-577">Merge or replace</span></span>](#merge-or-replace)  

> [!NOTE]
> <span data-ttu-id="9e2df-578">Ha a tranzakció elkülönítési fontos, hogy a megoldás, vegye figyelembe a táblák lehetővé váljon EGTs újratervezése.</span><span class="sxs-lookup"><span data-stu-id="9e2df-578">If transaction isolation is important to your solution, you should consider redesigning your tables to enable you to use EGTs.</span></span>  
> 
> 

### <a name="index-entities-pattern"></a><span data-ttu-id="9e2df-579">Index entitások minta</span><span class="sxs-lookup"><span data-stu-id="9e2df-579">Index Entities Pattern</span></span>
<span data-ttu-id="9e2df-580">Ahhoz, hogy térjen vissza az entitások listák hatékony kereséseket index entitások karbantartása.</span><span class="sxs-lookup"><span data-stu-id="9e2df-580">Maintain index entities to enable efficient searches that return lists of entities.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="9e2df-581">A környezetben, és probléma</span><span class="sxs-lookup"><span data-stu-id="9e2df-581">Context and problem</span></span>
<span data-ttu-id="9e2df-582">A Table szolgáltatás automatikusan elvégzi a segítségével a **PartitionKey** és **RowKey** értékeket.</span><span class="sxs-lookup"><span data-stu-id="9e2df-582">The Table service automatically indexes entities using the **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="9e2df-583">Ez lehetővé teszi, hogy egy entitás hatékonyan pont lekérdezéssel lekérni ügyfélalkalmazást.</span><span class="sxs-lookup"><span data-stu-id="9e2df-583">This enables a client application to retrieve an entity efficiently using a point query.</span></span> <span data-ttu-id="9e2df-584">Például használja az alábbi táblázat szerkezetét, ügyfélalkalmazás hatékonyan alkalmazott entitás használatával lekérhető a részleg neve és az alkalmazott azonosítója (a **PartitionKey** és **RowKey**).</span><span class="sxs-lookup"><span data-stu-id="9e2df-584">For example, using the table structure shown below, a client application can efficiently retrieve an individual employee entity by using the department name and the employee id (the **PartitionKey** and **RowKey**).</span></span>  

![][13]

<span data-ttu-id="9e2df-585">Ha szeretné tenni a vezetéknevét, például egy másik nem egyedi tulajdonság alapján alkalmazott entitások listájának beolvasása a kevésbé hatékony partíció ellenőrzések található egyező helyett index kereshető azokat közvetlenül kell használnia.</span><span class="sxs-lookup"><span data-stu-id="9e2df-585">If you also want to be able to retrieve a list of employee entities based on the value of another non-unique property, such as their last name, you must use a less efficient partition scan to find matches rather than using an index to look them up directly.</span></span> <span data-ttu-id="9e2df-586">Ennek oka az, a table szolgáltatás nem adja meg a másodlagos kulcsot.</span><span class="sxs-lookup"><span data-stu-id="9e2df-586">This is because the table service does not provide secondary indexes.</span></span>  

#### <a name="solution"></a><span data-ttu-id="9e2df-587">Megoldás</span><span class="sxs-lookup"><span data-stu-id="9e2df-587">Solution</span></span>
<span data-ttu-id="9e2df-588">Vezetéknév keresési engedélyezze a fent látható entitás struktúrával, kezelnie kell az alkalmazott azonosítók listája.</span><span class="sxs-lookup"><span data-stu-id="9e2df-588">To enable lookup by last name with the entity structure shown above, you must maintain lists of employee ids.</span></span> <span data-ttu-id="9e2df-589">Szeretné beolvasni a alkalmazott entitások egy adott nevű utolsó, például a János, ha először keresse meg az alkalmazott azonosítók listáját János a Vezetéknév, az alkalmazottak számára, és az majd lekérheti az alkalmazott entitásokból.</span><span class="sxs-lookup"><span data-stu-id="9e2df-589">If you want to retrieve the employee entities with a particular last name, such as Jones, you must first locate the list of employee ids for employees with Jones as their last name, and then retrieve those employee entities.</span></span> <span data-ttu-id="9e2df-590">Az alkalmazott azonosítók listájának tárolására három fő lehetőség áll rendelkezésre:</span><span class="sxs-lookup"><span data-stu-id="9e2df-590">There are three main options for storing the lists of employee ids:</span></span>  

* <span data-ttu-id="9e2df-591">A blob storage használata.</span><span class="sxs-lookup"><span data-stu-id="9e2df-591">Use blob storage.</span></span>  
* <span data-ttu-id="9e2df-592">Hozzon létre indexet entitások az alkalmazott entitásokat tartalmazó partícióra.</span><span class="sxs-lookup"><span data-stu-id="9e2df-592">Create index entities in the same partition as the employee entities.</span></span>  
* <span data-ttu-id="9e2df-593">Hozzon létre indexet entitások külön partíció vagy tábla.</span><span class="sxs-lookup"><span data-stu-id="9e2df-593">Create index entities in a separate partition or table.</span></span>  

<span data-ttu-id="9e2df-594"><u>#1. lehetőség: Használja a blob storage</u></span><span class="sxs-lookup"><span data-stu-id="9e2df-594"><u>Option #1: Use blob storage</u></span></span>  

<span data-ttu-id="9e2df-595">Az első lehetőség létrehoz minden egyedi Vezetéknév, és minden egyes blob tárolóban blob listáját a **PartitionKey** (osztály) és **RowKey** adott Vezetéknév rendelkező alkalmazottak (alkalmazott azonosítója) értékeit.</span><span class="sxs-lookup"><span data-stu-id="9e2df-595">For the first option, you create a blob for every unique last name, and in each blob store a list of the **PartitionKey** (department) and **RowKey** (employee id) values for employees that have that last name.</span></span> <span data-ttu-id="9e2df-596">Adja hozzá, vagy egy alkalmazott törlésekor biztosítania kell, hogy idővel konzisztenssé váljanak a alkalmazott entitások a megfelelő blob tartalma.</span><span class="sxs-lookup"><span data-stu-id="9e2df-596">When you add or delete an employee you should ensure that the content of the relevant blob is eventually consistent with the employee entities.</span></span>  

<span data-ttu-id="9e2df-597"><u>#2. lehetőség:</u> ugyanazon partíció index entitások létrehozása</span><span class="sxs-lookup"><span data-stu-id="9e2df-597"><u>Option #2:</u> Create index entities in the same partition</span></span>  

<span data-ttu-id="9e2df-598">A második lehetőség használja a következő adatok tárolására szolgáló index entitás:</span><span class="sxs-lookup"><span data-stu-id="9e2df-598">For the second option, use index entities that store the following data:</span></span>  

![][14]

<span data-ttu-id="9e2df-599">A **EmployeeIDs** tárolt utolsó nevű tulajdonsága tartalmazza az alkalmazottak számára alkalmazott azonosítók listáját a **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="9e2df-599">The **EmployeeIDs** property contains a list of employee ids for employees with the last name stored in the **RowKey**.</span></span>  

<span data-ttu-id="9e2df-600">Az alábbi lépéseket kell követnie, amikor a hozzáadni kívánt új alkalmazott a második lehetőség használata vázoltuk.</span><span class="sxs-lookup"><span data-stu-id="9e2df-600">The following steps outline the process you should follow when you are adding a new employee if you are using the second option.</span></span> <span data-ttu-id="9e2df-601">Ebben a példában azt ad hozzá egy alkalmazott azonosítója 000152 és a Vezetéknév János az értékesítési részleg:</span><span class="sxs-lookup"><span data-stu-id="9e2df-601">In this example, we are adding an employee with Id 000152 and a last name Jones in the Sales department:</span></span>  

1. <span data-ttu-id="9e2df-602">Az index bejegyzés lekérdezésére egy **PartitionKey** "Értékesítési" értéket, és a **RowKey** érték "János."</span><span class="sxs-lookup"><span data-stu-id="9e2df-602">Retrieve the index entity with a **PartitionKey** value "Sales" and the **RowKey** value "Jones."</span></span> <span data-ttu-id="9e2df-603">Mentse ezt az entitást a 2. lépésben használandó ETag címkét.</span><span class="sxs-lookup"><span data-stu-id="9e2df-603">Save the ETag of this entity to use in step 2.</span></span>  
2. <span data-ttu-id="9e2df-604">Hozzon létre egy entitás-csoport tranzakció (Ez azt jelenti, hogy a kötegelt művelet), amely az új alkalmazottak entitás beszúrása (**PartitionKey** "Értékesítési" érték és **RowKey** "000152" értéket), és frissíti az index entitás (**PartitionKey** "Értékesítési" értéket, és **RowKey** "János" érték) az új alkalmazottazonosító ad hozzá a EmployeeIDs mező listáján.</span><span class="sxs-lookup"><span data-stu-id="9e2df-604">Create an entity group transaction (that is, a batch operation) that inserts the new employee entity (**PartitionKey** value "Sales" and **RowKey** value "000152"), and updates the index entity (**PartitionKey** value "Sales" and **RowKey** value "Jones") by adding the new employee id to the list in the EmployeeIDs field.</span></span> <span data-ttu-id="9e2df-605">Entitás csoport tranzakciókkal kapcsolatos további információkért lásd: [entitás csoport tranzakciók](#entity-group-transactions).</span><span class="sxs-lookup"><span data-stu-id="9e2df-605">For more information about entity group transactions, see [Entity Group Transactions](#entity-group-transactions).</span></span>  
3. <span data-ttu-id="9e2df-606">Ha az entitás csoport tranzakció (valaki más csak módosította az index entitás) egyidejű hozzáférések optimista hiba miatt nem sikerül, akkor szüksége az 1. lépés: újra újrakezdéshez.</span><span class="sxs-lookup"><span data-stu-id="9e2df-606">If the entity group transaction fails because of an optimistic concurrency error (someone else has just modified the index entity), then you need to start over at step 1 again.</span></span>  

<span data-ttu-id="9e2df-607">Egy alkalmazott törlése, a második lehetőség használata hasonló megközelítése is használhatja.</span><span class="sxs-lookup"><span data-stu-id="9e2df-607">You can use a similar approach to deleting an employee if you are using the second option.</span></span> <span data-ttu-id="9e2df-608">Egy alkalmazott Vezetéknév módosítása nem kicsit bonyolultabb, mert szüksége lesz egy entitás csoport tranzakció, amely három entitások frissíti hajtható végre: az alkalmazott, a régi vezetékneve index entitás, és a index entitás az új utolsó nevét.</span><span class="sxs-lookup"><span data-stu-id="9e2df-608">Changing an employee's last name is slightly more complex because you will need to execute an entity group transaction that updates three entities: the employee entity, the index entity for the old last name, and the index entity for the new last name.</span></span> <span data-ttu-id="9e2df-609">Minden entitás optimista konkurenciát alkalmazott frissítések végrehajtásához használhatja ETag értékek beolvasása érdekében módosítások végrehajtása előtt be kell olvasni.</span><span class="sxs-lookup"><span data-stu-id="9e2df-609">You must retrieve each entity before making any changes in order to retrieve the ETag values that you can then use to perform the updates using optimistic concurrency.</span></span>  

<span data-ttu-id="9e2df-610">Az alábbi lépéseket kell követnie, amikor meg kell keresnie egy osztály adott utolsó nevű az alkalmazottak, a második lehetőség használata vázoltuk.</span><span class="sxs-lookup"><span data-stu-id="9e2df-610">The following steps outline the process you should follow when you need to look up all the employees with a given last name in a department if you are using the second option.</span></span> <span data-ttu-id="9e2df-611">Ebben a példában azt keressük az értékesítési részleg utolsó nevű János az alkalmazottak:</span><span class="sxs-lookup"><span data-stu-id="9e2df-611">In this example, we are looking up all the employees with last name Jones in the Sales department:</span></span>  

1. <span data-ttu-id="9e2df-612">Az index bejegyzés lekérdezésére egy **PartitionKey** "Értékesítési" értéket, és a **RowKey** érték "János."</span><span class="sxs-lookup"><span data-stu-id="9e2df-612">Retrieve the index entity with a **PartitionKey** value "Sales" and the **RowKey** value "Jones."</span></span>  
2. <span data-ttu-id="9e2df-613">Elemezni alkalmazott a EmployeeIDs mezőben azonosítók listáját.</span><span class="sxs-lookup"><span data-stu-id="9e2df-613">Parse the list of employee Ids in the EmployeeIDs field.</span></span>  
3. <span data-ttu-id="9e2df-614">Ha további információ az egyes ezeknek a dolgozóknak (például az e-mail címmel) van szüksége, lekéri az egyes használatával alkalmazott entitások **PartitionKey** "Értékesítési" értéket, és **RowKey** közötti értéket a 2. lépésben beolvasott alkalmazottak listája.</span><span class="sxs-lookup"><span data-stu-id="9e2df-614">If you need additional information about each of these employees (such as their email addresses), retrieve each of the employee entities using **PartitionKey** value "Sales" and **RowKey** values from the list of employees you obtained in step 2.</span></span>  

<span data-ttu-id="9e2df-615"><u>#3. lehetőség:</u> index entitások külön partíció vagy tábla létrehozása</span><span class="sxs-lookup"><span data-stu-id="9e2df-615"><u>Option #3:</u> Create index entities in a separate partition or table</span></span>  

<span data-ttu-id="9e2df-616">A harmadik lehetőség használja a következő adatok tárolására szolgáló index entitás:</span><span class="sxs-lookup"><span data-stu-id="9e2df-616">For the third option, use index entities that store the following data:</span></span>  

![][15]

<span data-ttu-id="9e2df-617">A **EmployeeIDs** tárolt utolsó nevű tulajdonsága tartalmazza az alkalmazottak számára alkalmazott azonosítók listáját a **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="9e2df-617">The **EmployeeIDs** property contains a list of employee ids for employees with the last name stored in the **RowKey**.</span></span>  

<span data-ttu-id="9e2df-618">A harmadik beállítással biztosítja az egységességet, mert az index entitások az alkalmazott entitások külön partícióra EGTs nem használható.</span><span class="sxs-lookup"><span data-stu-id="9e2df-618">With the third option, you cannot use EGTs to maintain consistency because the index entities are in a separate partition from the employee entities.</span></span> <span data-ttu-id="9e2df-619">Ellenőrizze, hogy idővel konzisztenssé váljanak a alkalmazott entitások-e az index entitásokat.</span><span class="sxs-lookup"><span data-stu-id="9e2df-619">You should ensure that the index entities are eventually consistent with the employee entities.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="9e2df-620">Problémákat és szempontok</span><span class="sxs-lookup"><span data-stu-id="9e2df-620">Issues and considerations</span></span>
<span data-ttu-id="9e2df-621">Ebben a mintában megvalósításához meghatározásakor, vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="9e2df-621">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="9e2df-622">Ehhez a megoldáshoz szükségesek egyező entitást lekérdezni legalább két lekérdezést: egyet az index entitásokat a listájának lekérdezése **RowKey** értékek, majd beolvasni a listában szereplő lekérdezések.</span><span class="sxs-lookup"><span data-stu-id="9e2df-622">This solution requires at least two queries to retrieve matching entities: one to query the index entities to obtain the list of **RowKey** values, and then queries to retrieve each entity in the list.</span></span>  
* <span data-ttu-id="9e2df-623">Fényében, hogy az egyes entitásnak van a maximális méret 1 MB, #2 és a megoldás #3 lehetőség feltételezik, hogy bármely adott Vezetéknév alkalmazott azonosítóinak listáját soha nem 1 MB-nál nagyobb.</span><span class="sxs-lookup"><span data-stu-id="9e2df-623">Given that an individual entity has a maximum size of 1 MB, option #2 and option #3 in the solution assume that the list of employee ids for any given last name is never greater than 1 MB.</span></span> <span data-ttu-id="9e2df-624">Ha alkalmazott azonosítók listáját mérete 1 MB-nál nagyobbnak kell lennie, #1. lehetőség és az index adatokat a blob Storage tárolóban tárolja.</span><span class="sxs-lookup"><span data-stu-id="9e2df-624">If the list of employee ids is likely to be greater than 1 MB in size, use option #1 and store the index data in blob storage.</span></span>  
* <span data-ttu-id="9e2df-625">#2. beállítás (EGTs használ hozzáadása és az alkalmazottak törlése és módosítása az alkalmazott Vezetéknév kezeléséhez) ki kell értékelnie, ha a tranzakciók mennyisége fog megközelíti a méretezhetőségének korlátai egy adott partíció.</span><span class="sxs-lookup"><span data-stu-id="9e2df-625">If you use option #2 (using EGTs to handle adding and deleting employees, and changing an employee's last name) you must evaluate if the volume of transactions will approach the scalability limits in a given partition.</span></span> <span data-ttu-id="9e2df-626">Ha ez a helyzet, fontolja meg egy idővel konzisztenssé megoldás (#1. lehetőség vagy #3. lehetőség), amely várólisták használja a frissítés-kérelmeket kezelnek, és lehetővé teszi, hogy az index entitások az alkalmazott entitások külön partícióra.</span><span class="sxs-lookup"><span data-stu-id="9e2df-626">If this is the case, you should consider an eventually consistent solution (option #1 or option #3) that uses queues to handle the update requests and enables you to store your index entities in a separate partition from the employee entities.</span></span>  
* <span data-ttu-id="9e2df-627">Ebben a megoldásban #2. lehetőség azt feltételezi, hogy szeretné-e kereshet meg egy részleg vezetéknév: például szeretné beolvasni az alkalmazottakat az értékesítési részleg János utolsó néven.</span><span class="sxs-lookup"><span data-stu-id="9e2df-627">Option #2 in this solution assumes that you want to look up by last name within a department: for example, you want to retrieve a list of employees with a last name Jones in the Sales department.</span></span> <span data-ttu-id="9e2df-628">Ha szeretné tudni nevű utolsó János a teljes szervezeten belül minden alkalmazott kereshet, #1. lehetőség vagy a #3. lehetőség használatával.</span><span class="sxs-lookup"><span data-stu-id="9e2df-628">If you want to be able to look up all the employees with a last name Jones across the whole organization, use either option #1 or option #3.</span></span>
* <span data-ttu-id="9e2df-629">Megvalósíthat egy várólista-alapú megoldás, amely a végleges konzisztencia biztosítja (lásd a [idővel konzisztenssé tranzakciók mintát](#eventually-consistent-transactions-pattern) további részletekért).</span><span class="sxs-lookup"><span data-stu-id="9e2df-629">You can implement a queue-based solution that delivers eventual consistency (see the [Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) for more details).</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="9e2df-630">Mikor érdemes használni ezt a mintát</span><span class="sxs-lookup"><span data-stu-id="9e2df-630">When to use this pattern</span></span>
<span data-ttu-id="9e2df-631">Ezt a mintát használja, ha meg szeretné megkeresni az, hogy minden közös közös tulajdonság értéke, például minden alkalmazott Vezetéknév János a entitások készletének.</span><span class="sxs-lookup"><span data-stu-id="9e2df-631">Use this pattern when you want to lookup a set of entities that all share a common property value, such as all employees with the last name Jones.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="9e2df-632">Útmutató és a kapcsolódó minták</span><span class="sxs-lookup"><span data-stu-id="9e2df-632">Related patterns and guidance</span></span>
<span data-ttu-id="9e2df-633">A következő mintákat és útmutatókat is megfelelő ebben a mintában végrehajtása során:</span><span class="sxs-lookup"><span data-stu-id="9e2df-633">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="9e2df-634">Összetett kulcs minta</span><span class="sxs-lookup"><span data-stu-id="9e2df-634">Compound key pattern</span></span>](#compound-key-pattern)  
* [<span data-ttu-id="9e2df-635">Idővel konzisztenssé tranzakciók minta</span><span class="sxs-lookup"><span data-stu-id="9e2df-635">Eventually consistent transactions pattern</span></span>](#eventually-consistent-transactions-pattern)  
* [<span data-ttu-id="9e2df-636">Entitás csoport tranzakciók</span><span class="sxs-lookup"><span data-stu-id="9e2df-636">Entity Group Transactions</span></span>](#entity-group-transactions)  
* [<span data-ttu-id="9e2df-637">Heterogén entitástípusok használata</span><span class="sxs-lookup"><span data-stu-id="9e2df-637">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)  

### <a name="denormalization-pattern"></a><span data-ttu-id="9e2df-638">Denormalization minta</span><span class="sxs-lookup"><span data-stu-id="9e2df-638">Denormalization pattern</span></span>
<span data-ttu-id="9e2df-639">Együtt kapcsolódó adatok egyesítése egyetlen entitás ahhoz, hogy beolvasni az összes adatot a hibaérzékeny pontok lekérdezéssel van szüksége.</span><span class="sxs-lookup"><span data-stu-id="9e2df-639">Combine related data together in a single entity to enable you to retrieve all the data you need with a single point query.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="9e2df-640">A környezetben, és probléma</span><span class="sxs-lookup"><span data-stu-id="9e2df-640">Context and problem</span></span>
<span data-ttu-id="9e2df-641">Egy relációs adatbázisban akkor általában normalizálása az adatok eltávolítása a lekérdezéseiben, amelyeket adatainak lekérése több táblából származó ismétlődést.</span><span class="sxs-lookup"><span data-stu-id="9e2df-641">In a relational database, you typically normalize data to remove duplication resulting in queries that retrieve data from multiple tables.</span></span> <span data-ttu-id="9e2df-642">Ha normalizálása az adatok Azure-táblákban, meg kell győződnie több kiszolgálókkal való adatváltások számát az ügyfélről a kiszolgálónak a kapcsolódó adatok beolvasása.</span><span class="sxs-lookup"><span data-stu-id="9e2df-642">If you normalize your data in Azure tables, you must make multiple round trips from the client to the server to retrieve your related data.</span></span> <span data-ttu-id="9e2df-643">Például a táblázat szerkezetét alábbi értékekre, akkor a két adatváltások beolvasni egy részleg részleteit kell: egyet a részleg entitás, amely tartalmazza a kezelő azonosítója és a kezelő részletek alkalmazott entitás lehívása majd egy másik kérelem beolvasása.</span><span class="sxs-lookup"><span data-stu-id="9e2df-643">For example, with the table structure shown below you need two round trips to retrieve the details for a department: one to fetch the department entity that includes the manager's id, and then another request to fetch the manager's details in an employee entity.</span></span>  

![][16]

#### <a name="solution"></a><span data-ttu-id="9e2df-644">Megoldás</span><span class="sxs-lookup"><span data-stu-id="9e2df-644">Solution</span></span>
<span data-ttu-id="9e2df-645">Helyett két külön entitás tárolni az adatokat, az adatok denormalize, és a részleg entitás megőrzi a manager részletei.</span><span class="sxs-lookup"><span data-stu-id="9e2df-645">Instead of storing the data in two separate entities, denormalize the data and keep a copy of the manager's details in the department entity.</span></span> <span data-ttu-id="9e2df-646">Példa:</span><span class="sxs-lookup"><span data-stu-id="9e2df-646">For example:</span></span>  

![][17]

<span data-ttu-id="9e2df-647">Ezekkel a tulajdonságokkal tárolt részleg entitásokkal kapcsolatos pont lekérdezéssel részleget szükséges összes információt most le.</span><span class="sxs-lookup"><span data-stu-id="9e2df-647">With department entities stored with these properties, you can now retrieve all the details you need about a department using a point query.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="9e2df-648">Problémákat és szempontok</span><span class="sxs-lookup"><span data-stu-id="9e2df-648">Issues and considerations</span></span>
<span data-ttu-id="9e2df-649">Ebben a mintában megvalósításához meghatározásakor, vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="9e2df-649">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="9e2df-650">Van néhány költsége terhet kétszer néhány adatainak tárolásához.</span><span class="sxs-lookup"><span data-stu-id="9e2df-650">There is some cost overhead associated with storing some data twice.</span></span> <span data-ttu-id="9e2df-651">A teljesítmény előny (kevesebb kéréseket a tárolási szolgáltatásba) általában ez fontosabb, mint a tárolási költségeket marginális növekedése (és az ehhez kapcsolódó költséget részben eltolva csökkentése szüksége van egy részleg részleteinek beolvasása tranzakciók száma ).</span><span class="sxs-lookup"><span data-stu-id="9e2df-651">The performance benefit (resulting from fewer requests to the storage service) typically outweighs the marginal increase in storage costs (and this cost is partially offset by a reduction in the number of transactions you require to fetch the details of a department).</span></span>  
* <span data-ttu-id="9e2df-652">A kezelők vonatkozó információt tároló két entitások konzisztencia kell fenntartani.</span><span class="sxs-lookup"><span data-stu-id="9e2df-652">You must maintain the consistency of the two entities that store information about managers.</span></span> <span data-ttu-id="9e2df-653">Egy atomi tranzakción belül több entitás frissítése EGTs használatával kezelni tud a konzisztencia problémát: Ebben az esetben a részleg, és a alkalmazott entitás részleg kezelőjének partícióra tárolják.</span><span class="sxs-lookup"><span data-stu-id="9e2df-653">You can handle the consistency issue by using EGTs to update multiple entities in a single atomic transaction: in this case, the department entity, and the employee entity for the department manager are stored in the same partition.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="9e2df-654">Mikor érdemes használni ezt a mintát</span><span class="sxs-lookup"><span data-stu-id="9e2df-654">When to use this pattern</span></span>
<span data-ttu-id="9e2df-655">Ebben a mintában használja, ha gyakran kell a kapcsolódó tudnivalókat.</span><span class="sxs-lookup"><span data-stu-id="9e2df-655">Use this pattern when you frequently need to look up related information.</span></span> <span data-ttu-id="9e2df-656">Ebben a mintában csökkenti az ügyfél biztosítsa a szükséges adatok beolvasásához lekérdezések száma.</span><span class="sxs-lookup"><span data-stu-id="9e2df-656">This pattern reduces the number of queries your client must make to retrieve the data it requires.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="9e2df-657">Útmutató és a kapcsolódó minták</span><span class="sxs-lookup"><span data-stu-id="9e2df-657">Related patterns and guidance</span></span>
<span data-ttu-id="9e2df-658">A következő mintákat és útmutatókat is megfelelő ebben a mintában végrehajtása során:</span><span class="sxs-lookup"><span data-stu-id="9e2df-658">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="9e2df-659">Összetett kulcs minta</span><span class="sxs-lookup"><span data-stu-id="9e2df-659">Compound key pattern</span></span>](#compound-key-pattern)  
* [<span data-ttu-id="9e2df-660">Entitás csoport tranzakciók</span><span class="sxs-lookup"><span data-stu-id="9e2df-660">Entity Group Transactions</span></span>](#entity-group-transactions)  
* [<span data-ttu-id="9e2df-661">Heterogén entitástípusok használata</span><span class="sxs-lookup"><span data-stu-id="9e2df-661">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)

### <a name="compound-key-pattern"></a><span data-ttu-id="9e2df-662">Összetett kulcs minta</span><span class="sxs-lookup"><span data-stu-id="9e2df-662">Compound key pattern</span></span>
<span data-ttu-id="9e2df-663">Használjon összetett **RowKey** értékek kapcsolódó adatok egyetlen pont lekérdezéssel talált ügyfél engedélyezése.</span><span class="sxs-lookup"><span data-stu-id="9e2df-663">Use compound **RowKey** values to enable a client to lookup related data with a single point query.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="9e2df-664">A környezetben, és probléma</span><span class="sxs-lookup"><span data-stu-id="9e2df-664">Context and problem</span></span>
<span data-ttu-id="9e2df-665">Egy relációs adatbázisban hogy a rendszer teljesen illesztések lekérdezésekben használatához kapcsolódó adatok kódrészletek vissza az ügyfélnek egyetlen lekérdezést természetes.</span><span class="sxs-lookup"><span data-stu-id="9e2df-665">In a relational database, it is quite natural to use joins in queries to return related pieces of data to the client in a single query.</span></span> <span data-ttu-id="9e2df-666">Például használhatja a alkalmazottazonosító megkeresheti a kapcsolódó entitásokból, melyek teljesítményét, és tekintse át az adatokat azt listáját.</span><span class="sxs-lookup"><span data-stu-id="9e2df-666">For example, you might use the employee id to look up a list of related entities that contain performance and review data for that employee.</span></span>  

<span data-ttu-id="9e2df-667">Tegyük fel, a Table szolgáltatás használatával az alábbi szerkezettel alkalmazott entitások tárolja:</span><span class="sxs-lookup"><span data-stu-id="9e2df-667">Assume you are storing employee entities in the Table service using the following structure:</span></span>  

![][18]

<span data-ttu-id="9e2df-668">Szükség értékelést, és a teljesítmény évente az alkalmazott működött a szervezet számára vonatkozó előzményadatok tárolja, és érhetik el ezeket az információkat évente kell.</span><span class="sxs-lookup"><span data-stu-id="9e2df-668">You also need to store historical data relating to reviews and performance for each year the employee has worked for your organization and you need to be able to access this information by year.</span></span> <span data-ttu-id="9e2df-669">Egy elem egy másik tábla tárolja az alábbi szerkezettel rendelkező entitások létrehozásához:</span><span class="sxs-lookup"><span data-stu-id="9e2df-669">One option is to create another table that stores entities with the following structure:</span></span>  

![][19]

<span data-ttu-id="9e2df-670">Figyelje meg, hogy ezt a módszert is dönthet, hogy néhány adat (például a Keresztnév és Vezetéknév) ismétlődő ahhoz, hogy az egy kérelemhez adatok beolvasása az új entitásban.</span><span class="sxs-lookup"><span data-stu-id="9e2df-670">Notice that with this approach you may decide to duplicate some information (such as first name and last name) in the new entity to enable you to retrieve your data with a single request.</span></span> <span data-ttu-id="9e2df-671">Azonban az erős konzisztencia nem fenntartása, mivel a két entitások frissítésére i egy EGT nem használható.</span><span class="sxs-lookup"><span data-stu-id="9e2df-671">However, you cannot maintain strong consistency because you cannot use an EGT to update the two entities atomically.</span></span>  

#### <a name="solution"></a><span data-ttu-id="9e2df-672">Megoldás</span><span class="sxs-lookup"><span data-stu-id="9e2df-672">Solution</span></span>
<span data-ttu-id="9e2df-673">Egy új entitástípus tárolása az eredeti tábla entitások használata az alábbi szerkezettel:</span><span class="sxs-lookup"><span data-stu-id="9e2df-673">Store a new entity type in your original table using entities with the following structure:</span></span>  

![][20]

<span data-ttu-id="9e2df-674">Értesítés az **RowKey** mostantól az alkalmazott azonosítója és az év, amely lehetővé teszi az alkalmazott beolvasásához, és ellenőrizze az adatokat egyetlen entitás egyetlen kérelmet tartalmazó felülvizsgálati adatok összetett kulcs.</span><span class="sxs-lookup"><span data-stu-id="9e2df-674">Notice how the **RowKey** is now a compound key made up of the employee id and the year of the review data that enables you to retrieve the employee's performance and review data with a single request for a single entity.</span></span>  

<span data-ttu-id="9e2df-675">A következő példa bemutatja, hogyan kérheti le a felülvizsgálati adatok (például alkalmazott 000123 az értékesítési részleg) egy alkalmazott:</span><span class="sxs-lookup"><span data-stu-id="9e2df-675">The following example outlines how you can retrieve all the review data for a particular employee (such as employee 000123 in the Sales department):</span></span>  

<span data-ttu-id="9e2df-676">$filter = (PartitionKey eq 'Értékesítés') és (RowKey ge "empid_000123") és (RowKey lt "empid_000124") & $select = RowKey, Manager értékelése, társ értékelése, megjegyzések</span><span class="sxs-lookup"><span data-stu-id="9e2df-676">$filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000123') and (RowKey lt 'empid_000124')&$select=RowKey,Manager Rating,Peer Rating,Comments</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="9e2df-677">Problémákat és szempontok</span><span class="sxs-lookup"><span data-stu-id="9e2df-677">Issues and considerations</span></span>
<span data-ttu-id="9e2df-678">Ebben a mintában megvalósításához meghatározásakor, vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="9e2df-678">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="9e2df-679">Könnyen értelmezhető megfelelő elválasztó karaktert kell használnia a **RowKey** érték: például **000123_2012**.</span><span class="sxs-lookup"><span data-stu-id="9e2df-679">You should use a suitable separator character that makes it easy to parse the **RowKey** value: for example, **000123_2012**.</span></span>  
* <span data-ttu-id="9e2df-680">Ehhez az entitáshoz kapcsolódó adatokat tartalmaznak az azonos alkalmazott, ami azt jelenti, EGTs segítségével karbantartása erős konzisztenciát végző más entitásokkal partícióra is tárolja.</span><span class="sxs-lookup"><span data-stu-id="9e2df-680">You are also storing this entity in the same partition as other entities that contain related data for the same employee, which means you can use EGTs to maintain strong consistency.</span></span>
* <span data-ttu-id="9e2df-681">Akkor érdemes megfontolni, hogy milyen gyakran fogja kérdezni az adatokat a megállapításához, hogy ez a minta megfelelő.</span><span class="sxs-lookup"><span data-stu-id="9e2df-681">You should consider how frequently you will query the data to determine whether this pattern is appropriate.</span></span>  <span data-ttu-id="9e2df-682">Például ha az felülvizsgálati ritkán, és a főbb alkalmazotti adatok gyakran férnek hozzá legyen őket, különálló entitások.</span><span class="sxs-lookup"><span data-stu-id="9e2df-682">For example, if you will access the review data infrequently and the main employee data often you should keep them as separate entities.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="9e2df-683">Mikor érdemes használni ezt a mintát</span><span class="sxs-lookup"><span data-stu-id="9e2df-683">When to use this pattern</span></span>
<span data-ttu-id="9e2df-684">Ebben a mintában használatára kell tárolni egy vagy több kapcsolódó entitások lekérdezett gyakran.</span><span class="sxs-lookup"><span data-stu-id="9e2df-684">Use this pattern when you need to store one or more related entities that you query frequently.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="9e2df-685">Útmutató és a kapcsolódó minták</span><span class="sxs-lookup"><span data-stu-id="9e2df-685">Related patterns and guidance</span></span>
<span data-ttu-id="9e2df-686">A következő mintákat és útmutatókat is megfelelő ebben a mintában végrehajtása során:</span><span class="sxs-lookup"><span data-stu-id="9e2df-686">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="9e2df-687">Entitás csoport tranzakciók</span><span class="sxs-lookup"><span data-stu-id="9e2df-687">Entity Group Transactions</span></span>](#entity-group-transactions)  
* [<span data-ttu-id="9e2df-688">Heterogén entitástípusok használata</span><span class="sxs-lookup"><span data-stu-id="9e2df-688">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)  
* [<span data-ttu-id="9e2df-689">Idővel konzisztenssé tranzakciók minta</span><span class="sxs-lookup"><span data-stu-id="9e2df-689">Eventually consistent transactions pattern</span></span>](#eventually-consistent-transactions-pattern)  

### <a name="log-tail-pattern"></a><span data-ttu-id="9e2df-690">Napló végéről minta</span><span class="sxs-lookup"><span data-stu-id="9e2df-690">Log tail pattern</span></span>
<span data-ttu-id="9e2df-691">Beolvasni a  *n*  partíció legutóbb hozzáadott entitások egy **RowKey** érték, amely fordított dátum és idő sorrendben rendezi.</span><span class="sxs-lookup"><span data-stu-id="9e2df-691">Retrieve the *n* entities most recently added to a partition by using a **RowKey** value that sorts in reverse date and time order.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="9e2df-692">A környezetben, és probléma</span><span class="sxs-lookup"><span data-stu-id="9e2df-692">Context and problem</span></span>
<span data-ttu-id="9e2df-693">A közös vonatkozó követelmény akkor állítható vissza a legutóbb létrehozott entitások, például a tíz legújabb kiadás az alkalmazottak által küldött jogcímek.</span><span class="sxs-lookup"><span data-stu-id="9e2df-693">A common requirement is be able to retrieve the most recently created entities, for example the ten most recent expense claims submitted by an employee.</span></span> <span data-ttu-id="9e2df-694">Táblázat a támogatási lekérdezi egy **$top** lekérdezési művelet vissza az első  *n*  egy entitás: az utolsó n entitások vissza egy készlet nincs egyenértékű lekérdezési művelet.</span><span class="sxs-lookup"><span data-stu-id="9e2df-694">Table queries support a **$top** query operation to return the first *n* entities from a set: there is no equivalent query operation to return the last n entities in a set.</span></span>  

#### <a name="solution"></a><span data-ttu-id="9e2df-695">Megoldás</span><span class="sxs-lookup"><span data-stu-id="9e2df-695">Solution</span></span>
<span data-ttu-id="9e2df-696">Az entitások használatával tárolja a **RowKey** , hogy természetes rendezi fordított dátum/idő ahhoz, így a legutóbbi bejegyzés használatával, mindig az első egy a táblázatban.</span><span class="sxs-lookup"><span data-stu-id="9e2df-696">Store the entities using a **RowKey** that naturally sorts in reverse date/time order by using so the most recent entry is always the first one in the table.</span></span>  

<span data-ttu-id="9e2df-697">Például nem fogja tudni kérik le az alkalmazottak által küldött tíz legújabb kiadás jogcímeket, használhatja a fordított osztásjelek származó az aktuális dátum/idő értékkel.</span><span class="sxs-lookup"><span data-stu-id="9e2df-697">For example, to be able to retrieve the ten most recent expense claims submitted by an employee, you can use a reverse tick value derived from the current date/time.</span></span> <span data-ttu-id="9e2df-698">A következő C# kódminta jeleníti meg a megfelelő "fordított ticks" értéket a létrehozásának egyik módja egy **RowKey** , amely a legújabb rendezi a legrégebbi:</span><span class="sxs-lookup"><span data-stu-id="9e2df-698">The following C# code sample shows one way to create a suitable "inverted ticks" value for a **RowKey** that sorts from the most recent to the oldest:</span></span>  

`string invertedTicks = string.Format("{0:D19}", DateTime.MaxValue.Ticks - DateTime.UtcNow.Ticks);`  

<span data-ttu-id="9e2df-699">Is vissza a dátum idő értéknek megfelelően a következő kódot:</span><span class="sxs-lookup"><span data-stu-id="9e2df-699">You can get back to the date time value using the following code:</span></span>  

`DateTime dt = new DateTime(DateTime.MaxValue.Ticks - Int64.Parse(invertedTicks));`  

<span data-ttu-id="9e2df-700">A lekérdezés így néz ki:</span><span class="sxs-lookup"><span data-stu-id="9e2df-700">The table query looks like this:</span></span>  

`https://myaccount.table.core.windows.net/EmployeeExpense(PartitionKey='empid')?$top=10`  

#### <a name="issues-and-considerations"></a><span data-ttu-id="9e2df-701">Problémákat és szempontok</span><span class="sxs-lookup"><span data-stu-id="9e2df-701">Issues and considerations</span></span>
<span data-ttu-id="9e2df-702">Ebben a mintában megvalósításához meghatározásakor, vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="9e2df-702">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="9e2df-703">Annak érdekében, hogy a karakterlánc rendezi a várt módon nullából kezdő fordított osztásjelek értékének kell írni.</span><span class="sxs-lookup"><span data-stu-id="9e2df-703">You must pad the reverse tick value with leading zeroes to ensure the string value sorts as expected.</span></span>  
* <span data-ttu-id="9e2df-704">A partíció szinten vonatkozó méretezhetőségi célok tisztában kell lennie.</span><span class="sxs-lookup"><span data-stu-id="9e2df-704">You must be aware of the scalability targets at the level of a partition.</span></span> <span data-ttu-id="9e2df-705">Legyen óvatos nem interaktív terület partíciókat.</span><span class="sxs-lookup"><span data-stu-id="9e2df-705">Be careful not create hot spot partitions.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="9e2df-706">Mikor érdemes használni ezt a mintát</span><span class="sxs-lookup"><span data-stu-id="9e2df-706">When to use this pattern</span></span>
<span data-ttu-id="9e2df-707">Ebben a mintában felhasználhatja hozzá kell férnie a fordított dátum/idő sorrend, illetve ha a közelmúltban felvett entitások eléréséhez szükséges szerepelnek.</span><span class="sxs-lookup"><span data-stu-id="9e2df-707">Use this pattern when you need to access entities in reverse date/time order or when you need to access the most recently added entities.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="9e2df-708">Útmutató és a kapcsolódó minták</span><span class="sxs-lookup"><span data-stu-id="9e2df-708">Related patterns and guidance</span></span>
<span data-ttu-id="9e2df-709">A következő mintákat és útmutatókat is megfelelő ebben a mintában végrehajtása során:</span><span class="sxs-lookup"><span data-stu-id="9e2df-709">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="9e2df-710">Illesztenie elleni mintát hozzáfűzése</span><span class="sxs-lookup"><span data-stu-id="9e2df-710">Prepend / append anti-pattern</span></span>](#prepend-append-anti-pattern)  
* [<span data-ttu-id="9e2df-711">Entitások beolvasása</span><span class="sxs-lookup"><span data-stu-id="9e2df-711">Retrieving entities</span></span>](#retrieving-entities)  

### <a name="high-volume-delete-pattern"></a><span data-ttu-id="9e2df-712">Nagy mennyiségű delete minta</span><span class="sxs-lookup"><span data-stu-id="9e2df-712">High volume delete pattern</span></span>
<span data-ttu-id="9e2df-713">Az entitások nagy mennyiségű törlésének engedélyezése a entitásokhoz egyidejű törlésre tárolása saját külön táblázatban; a tábla törlésével törli az entitásokat.</span><span class="sxs-lookup"><span data-stu-id="9e2df-713">Enable the deletion of a high volume of entities by storing all the entities for simultaneous deletion in their own separate table; you delete the entities by deleting the table.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="9e2df-714">A környezetben, és probléma</span><span class="sxs-lookup"><span data-stu-id="9e2df-714">Context and problem</span></span>
<span data-ttu-id="9e2df-715">Számos alkalmazás törlése a régi adatokat, amely már nem elérhető egy ügyfélalkalmazást, vagy az alkalmazás rendelkezik archivált más adattárolóra.</span><span class="sxs-lookup"><span data-stu-id="9e2df-715">Many applications delete old data which no longer needs to be available to a client application, or that the application has archived to another storage medium.</span></span> <span data-ttu-id="9e2df-716">Általában azonosíthatja az ilyen adatokat a dátum: például, hogy egy követelmény, törlendő rekordok, amelyek több mint 60 napos bejelentkezési kérelmek.</span><span class="sxs-lookup"><span data-stu-id="9e2df-716">You typically identify such data by a date: for example, you have a requirement to delete records of all login requests that are more than 60 days old.</span></span>  

<span data-ttu-id="9e2df-717">Egy lehetséges tervezési, hogy a dátum és idő, a bejelentkezési kérelem a használja a **RowKey**:</span><span class="sxs-lookup"><span data-stu-id="9e2df-717">One possible design is to use the date and time of the login request in the **RowKey**:</span></span>  

![][21]

<span data-ttu-id="9e2df-718">Ez a megközelítés partíció elérési pontokhoz való elkerülhető, mert az alkalmazás beszúrása, és minden felhasználóhoz külön partícióra bejelentkezési entitások törlésére.</span><span class="sxs-lookup"><span data-stu-id="9e2df-718">This approach avoids partition hotspots because the application can insert and delete login entities for each user in a separate partition.</span></span> <span data-ttu-id="9e2df-719">Azonban ez a megközelítés lehet költséges és időigényes Ha sok entitást mivel először végre kell hajtania a táblázatbeolvasás ahhoz, hogy törli a entitások azonosítása, és törölnie kell minden egyes régi entitás.</span><span class="sxs-lookup"><span data-stu-id="9e2df-719">However, this approach may be costly and time consuming if you have a large number of entities because first you need to perform a table scan in order to identify all the entities to delete, and then you must delete each old entity.</span></span> <span data-ttu-id="9e2df-720">Vegye figyelembe, hogy adatváltások számát csökkentheti a kiszolgálóra, törölje a régi entitások több törlési kérelmek kötegelés történő EGTs szükséges.</span><span class="sxs-lookup"><span data-stu-id="9e2df-720">Note that you can reduce the number of round trips to the server required to delete the old entities by batching multiple delete requests into EGTs.</span></span>  

#### <a name="solution"></a><span data-ttu-id="9e2df-721">Megoldás</span><span class="sxs-lookup"><span data-stu-id="9e2df-721">Solution</span></span>
<span data-ttu-id="9e2df-722">Egy külön táblázattal minden nap a bejelentkezési kísérletek.</span><span class="sxs-lookup"><span data-stu-id="9e2df-722">Use a separate table for each day of login attempts.</span></span> <span data-ttu-id="9e2df-723">A fenti entitás tervező segítségével elkerülése csatlakozási pontokhoz entities beszúrt, és most már egyszerűen törlése egy tábla minden nap adott esetben régi entitások törlése (egyetlen tárhelyművelettel) keresése és több száz és egyéni több ezer törlése helyett bejelentkezési entitások minden nap.</span><span class="sxs-lookup"><span data-stu-id="9e2df-723">You can use the entity design above to avoid hotspots when you are inserting entities, and deleting old entities is now simply a question of deleting one table every day (a single storage operation) instead of finding and deleting hundreds and thousands of individual login entities every day.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="9e2df-724">Problémákat és szempontok</span><span class="sxs-lookup"><span data-stu-id="9e2df-724">Issues and considerations</span></span>
<span data-ttu-id="9e2df-725">Ebben a mintában megvalósításához meghatározásakor, vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="9e2df-725">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="9e2df-726">Támogatja a Tervező más módon, az alkalmazás fogja használni az adatok, például adott entitások kapcsolódik-e más adatok, vagy előállítása összesített adatát keresésekor?</span><span class="sxs-lookup"><span data-stu-id="9e2df-726">Does your design support other ways your application will use the data such as looking up specific entities, linking with other data, or generating aggregate information?</span></span>  
* <span data-ttu-id="9e2df-727">Nem a Tervező elkerülése interaktív területek új entitások beszúráskor?</span><span class="sxs-lookup"><span data-stu-id="9e2df-727">Does your design avoid hot spots when you are inserting new entities?</span></span>  
* <span data-ttu-id="9e2df-728">A késleltetés várható, ha azt szeretné, hogy a tábla néven törlése után újból.</span><span class="sxs-lookup"><span data-stu-id="9e2df-728">Expect a delay if you want to reuse the same table name after deleting it.</span></span> <span data-ttu-id="9e2df-729">Érdemes mindig használjon egyedi tábla neve.</span><span class="sxs-lookup"><span data-stu-id="9e2df-729">It's better to always use unique table names.</span></span>  
* <span data-ttu-id="9e2df-730">Várt néhány szabályozás első használata alkalmával érdemes egy új tábla a Table szolgáltatás Tanulja meg a hozzáférési minták, és a partíciók elosztja a csomópontok között.</span><span class="sxs-lookup"><span data-stu-id="9e2df-730">Expect some throttling when you first use a new table while the Table service learns the access patterns and distributes the partitions across nodes.</span></span> <span data-ttu-id="9e2df-731">Milyen gyakran kell létrehoznia az új táblákat vegye figyelembe.</span><span class="sxs-lookup"><span data-stu-id="9e2df-731">You should consider how frequently you need to create new tables.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="9e2df-732">Mikor érdemes használni ezt a mintát</span><span class="sxs-lookup"><span data-stu-id="9e2df-732">When to use this pattern</span></span>
<span data-ttu-id="9e2df-733">Ezt a mintát használja, ha az entitásokat, törölnie kell az egyszerre nagy mennyiségű van.</span><span class="sxs-lookup"><span data-stu-id="9e2df-733">Use this pattern when you have a high volume of entities that you must delete at the same time.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="9e2df-734">Útmutató és a kapcsolódó minták</span><span class="sxs-lookup"><span data-stu-id="9e2df-734">Related patterns and guidance</span></span>
<span data-ttu-id="9e2df-735">A következő mintákat és útmutatókat is megfelelő ebben a mintában végrehajtása során:</span><span class="sxs-lookup"><span data-stu-id="9e2df-735">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="9e2df-736">Entitás csoport tranzakciók</span><span class="sxs-lookup"><span data-stu-id="9e2df-736">Entity Group Transactions</span></span>](#entity-group-transactions)
* [<span data-ttu-id="9e2df-737">Entitások módosítása</span><span class="sxs-lookup"><span data-stu-id="9e2df-737">Modifying entities</span></span>](#modifying-entities)  

### <a name="data-series-pattern"></a><span data-ttu-id="9e2df-738">Adatsorozat adatmintát</span><span class="sxs-lookup"><span data-stu-id="9e2df-738">Data series pattern</span></span>
<span data-ttu-id="9e2df-739">Tároló teljes adatsorok egyetlen entitás minimalizálása érdekében elvégezte kérelmek számát jelenti.</span><span class="sxs-lookup"><span data-stu-id="9e2df-739">Store complete data series in a single entity to minimize the number of requests you make.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="9e2df-740">A környezetben, és probléma</span><span class="sxs-lookup"><span data-stu-id="9e2df-740">Context and problem</span></span>
<span data-ttu-id="9e2df-741">Egy általános forgatókönyv van az alkalmazás számára az adatok általában szükséges egyszerre beolvasandó sorozatát tárolja.</span><span class="sxs-lookup"><span data-stu-id="9e2df-741">A common scenario is for an application to store a series of data that it typically needs to retrieve all at once.</span></span> <span data-ttu-id="9e2df-742">Például az alkalmazás előfordulhat, hogy minden alkalmazott óránként küld hány Csevegési üzeneteket rögzíti, és majd használja az információt megrajzolásához hány üzenetek minden felhasználóhoz az előző 24 óra során küldött.</span><span class="sxs-lookup"><span data-stu-id="9e2df-742">For example, your application might record how many IM messages each employee sends every hour, and then use this information to plot how many messages each user sent over the preceding 24 hours.</span></span> <span data-ttu-id="9e2df-743">Lehet, hogy egy tervezési tárolni 24 entitások minden alkalmazott számára:</span><span class="sxs-lookup"><span data-stu-id="9e2df-743">One design might be to store 24 entities for each employee:</span></span>  

![][22]

<span data-ttu-id="9e2df-744">Ezzel a kialakítással egyszerűen keresse meg és frissítése minden alkalmazott számára, amikor az alkalmazás az üzenet számérték frissíteni kell az entitás módosítására.</span><span class="sxs-lookup"><span data-stu-id="9e2df-744">With this design, you can easily locate and update the entity to update for each employee whenever the application needs to update the message count value.</span></span> <span data-ttu-id="9e2df-745">Azonban a tevékenység diagram megrajzolásához az előző 24 órával kapcsolatos információk lekéréséhez be 24 entitások kell olvasni.</span><span class="sxs-lookup"><span data-stu-id="9e2df-745">However, to retrieve the information to plot a chart of the activity for the preceding 24 hours, you must retrieve 24 entities.</span></span>  

#### <a name="solution"></a><span data-ttu-id="9e2df-746">Megoldás</span><span class="sxs-lookup"><span data-stu-id="9e2df-746">Solution</span></span>
<span data-ttu-id="9e2df-747">Külön tulajdonsággal a következő tervezési használatával tárolja az üzenetek száma óránként:</span><span class="sxs-lookup"><span data-stu-id="9e2df-747">Use the following design with a separate property to store the message count for each hour:</span></span>  

![][23]

<span data-ttu-id="9e2df-748">Ezzel a kialakítással használhatja a partícióegyesítési művelet az üzenetek száma az alkalmazott frissíteni az adott időpont.</span><span class="sxs-lookup"><span data-stu-id="9e2df-748">With this design, you can use a merge operation to update the message count for an employee for a specific hour.</span></span> <span data-ttu-id="9e2df-749">Most kérheti le az összes kérelem használatával egyetlen entitás diagram megrajzolásához szükséges információkat.</span><span class="sxs-lookup"><span data-stu-id="9e2df-749">Now, you can retrieve all the information you need to plot the chart using a request for a single entity.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="9e2df-750">Problémákat és szempontok</span><span class="sxs-lookup"><span data-stu-id="9e2df-750">Issues and considerations</span></span>
<span data-ttu-id="9e2df-751">Ebben a mintában megvalósításához meghatározásakor, vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="9e2df-751">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="9e2df-752">Ha a teljes adatsor nem fér el egyetlen entitás (egy entitás legfeljebb 252 tulajdonságot is rendelkeznek), például blob alternatív adattár használata.</span><span class="sxs-lookup"><span data-stu-id="9e2df-752">If your complete data series does not fit into a single entity (an entity can have up to 252 properties), use an alternative data store such as a blob.</span></span>  
* <span data-ttu-id="9e2df-753">Ha egy entitás frissítése egyszerre több ügyfélnek, akkor használja a **ETag** egyidejű hozzáférések optimista végrehajtásához.</span><span class="sxs-lookup"><span data-stu-id="9e2df-753">If you have multiple clients updating an entity simultaneously, you will need to use the **ETag** to implement optimistic concurrency.</span></span> <span data-ttu-id="9e2df-754">Ha sok ügyfél, magas versengés tapasztalhatja.</span><span class="sxs-lookup"><span data-stu-id="9e2df-754">If you have many clients, you may experience high contention.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="9e2df-755">Mikor érdemes használni ezt a mintát</span><span class="sxs-lookup"><span data-stu-id="9e2df-755">When to use this pattern</span></span>
<span data-ttu-id="9e2df-756">Akkor használja ezt a mintát, ha kell frissíteni, és az egyes entitáshoz kapcsolódó adatsor beolvasása.</span><span class="sxs-lookup"><span data-stu-id="9e2df-756">Use this pattern when you need to update and retrieve a data series associated with an individual entity.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="9e2df-757">Útmutató és a kapcsolódó minták</span><span class="sxs-lookup"><span data-stu-id="9e2df-757">Related patterns and guidance</span></span>
<span data-ttu-id="9e2df-758">A következő mintákat és útmutatókat is megfelelő ebben a mintában végrehajtása során:</span><span class="sxs-lookup"><span data-stu-id="9e2df-758">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="9e2df-759">Nagy entitások minta</span><span class="sxs-lookup"><span data-stu-id="9e2df-759">Large entities pattern</span></span>](#large-entities-pattern)  
* [<span data-ttu-id="9e2df-760">Egyesítés vagy cseréje</span><span class="sxs-lookup"><span data-stu-id="9e2df-760">Merge or replace</span></span>](#merge-or-replace)  
* <span data-ttu-id="9e2df-761">[Idővel konzisztenssé tranzakciók mintát](#eventually-consistent-transactions-pattern) (ha tárolja az adatsorozat blob)</span><span class="sxs-lookup"><span data-stu-id="9e2df-761">[Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) (if you are storing the data series in a blob)</span></span>  

### <a name="wide-entities-pattern"></a><span data-ttu-id="9e2df-762">Széles entitások minta</span><span class="sxs-lookup"><span data-stu-id="9e2df-762">Wide entities pattern</span></span>
<span data-ttu-id="9e2df-763">Használni több fizikai entitás legfeljebb 252 tulajdonságot rendelkező logikai entitás tárolni.</span><span class="sxs-lookup"><span data-stu-id="9e2df-763">Use multiple physical entities to store logical entities with more than 252 properties.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="9e2df-764">A környezetben, és probléma</span><span class="sxs-lookup"><span data-stu-id="9e2df-764">Context and problem</span></span>
<span data-ttu-id="9e2df-765">Egyes entitás legfeljebb 252 tulajdonságot (kivéve a kötelező tulajdonságai) állhat, és nem tárolható 1 MB-nál több adatok összesen.</span><span class="sxs-lookup"><span data-stu-id="9e2df-765">An individual entity can have no more than 252 properties (excluding the mandatory system properties) and cannot store more than 1 MB of data in total.</span></span> <span data-ttu-id="9e2df-766">Egy relációs adatbázisban általában számíthat round semmilyen határnak sor mérete hozzáadása egy új tábla és a közöttük 1-1 kapcsolatot.</span><span class="sxs-lookup"><span data-stu-id="9e2df-766">In a relational database, you would typically get round any limits on the size of a row by adding a new table and enforcing a 1-to-1 relationship between them.</span></span>  

#### <a name="solution"></a><span data-ttu-id="9e2df-767">Megoldás</span><span class="sxs-lookup"><span data-stu-id="9e2df-767">Solution</span></span>
<span data-ttu-id="9e2df-768">A Table szolgáltatás több entitás legfeljebb 252 tulajdonságot az egyetlen nagy üzleti objektumot képviselő tárolhatja.</span><span class="sxs-lookup"><span data-stu-id="9e2df-768">Using the Table service, you can store multiple entities to represent a single large business object with more than 252 properties.</span></span> <span data-ttu-id="9e2df-769">Például ha szeretné tárolni az elmúlt 365 napban minden alkalmazott által küldött IM üzenetek száma számát, a következő kialakítás ezért más sémák használ, két olyan entitásra használhatja:</span><span class="sxs-lookup"><span data-stu-id="9e2df-769">For example, if you want to store a count of the number of IM messages sent by each employee for the last 365 days, you could use the following design that uses two entities with different schemas:</span></span>  

![][24]

<span data-ttu-id="9e2df-770">Ha olyan módosítást igénylő frissítése mindkét entitások, hogy továbbra is szinkronizálja egymással kell egy EGT is használhatja.</span><span class="sxs-lookup"><span data-stu-id="9e2df-770">If you need to make a change that requires updating both entities to keep them synchronized with each other you can use an EGT.</span></span> <span data-ttu-id="9e2df-771">Ellenkező esetben egy egyetlen egyesítési művelet használatával frissítse az üzenetek száma egy adott napjára.</span><span class="sxs-lookup"><span data-stu-id="9e2df-771">Otherwise, you can use a single merge operation to update the message count for a specific day.</span></span> <span data-ttu-id="9e2df-772">Az adatok beolvasása egyetlen alkalmazott be kell olvasni mindkét entitások, amely két hatékony kérelmekre is elvégezhető a **PartitionKey** és egy **RowKey** érték.</span><span class="sxs-lookup"><span data-stu-id="9e2df-772">To retrieve all the data for an individual employee you must retrieve both entities, which you can do with two efficient requests that use both a **PartitionKey** and a **RowKey** value.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="9e2df-773">Problémákat és szempontok</span><span class="sxs-lookup"><span data-stu-id="9e2df-773">Issues and considerations</span></span>
<span data-ttu-id="9e2df-774">Ebben a mintában megvalósításához meghatározásakor, vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="9e2df-774">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="9e2df-775">A teljes logikai entitás beolvasásakor magában foglalja a legalább két storage-tranzakció: egy minden fizikai bejegyzés lekérdezésére.</span><span class="sxs-lookup"><span data-stu-id="9e2df-775">Retrieving a complete logical entity involves at least two storage transactions: one to retrieve each physical entity.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="9e2df-776">Mikor érdemes használni ezt a mintát</span><span class="sxs-lookup"><span data-stu-id="9e2df-776">When to use this pattern</span></span>
<span data-ttu-id="9e2df-777">Használja ezt a mintát mikor kell entitások, amelynek méretét vagy a tulajdonságok száma meghaladja az egyes entitásnál a Table szolgáltatásban tárolni.</span><span class="sxs-lookup"><span data-stu-id="9e2df-777">Use this pattern when  need to store entities whose size or number of properties exceeds the limits for an individual entity in the Table service.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="9e2df-778">Útmutató és a kapcsolódó minták</span><span class="sxs-lookup"><span data-stu-id="9e2df-778">Related patterns and guidance</span></span>
<span data-ttu-id="9e2df-779">A következő mintákat és útmutatókat is megfelelő ebben a mintában végrehajtása során:</span><span class="sxs-lookup"><span data-stu-id="9e2df-779">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="9e2df-780">Entitás csoport tranzakciók</span><span class="sxs-lookup"><span data-stu-id="9e2df-780">Entity Group Transactions</span></span>](#entity-group-transactions)
* [<span data-ttu-id="9e2df-781">Egyesítés vagy cseréje</span><span class="sxs-lookup"><span data-stu-id="9e2df-781">Merge or replace</span></span>](#merge-or-replace)

### <a name="large-entities-pattern"></a><span data-ttu-id="9e2df-782">Nagy entitások minta</span><span class="sxs-lookup"><span data-stu-id="9e2df-782">Large entities pattern</span></span>
<span data-ttu-id="9e2df-783">A blob storage használatával nagy tulajdonságértékek tárolja.</span><span class="sxs-lookup"><span data-stu-id="9e2df-783">Use blob storage to store large property values.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="9e2df-784">A környezetben, és probléma</span><span class="sxs-lookup"><span data-stu-id="9e2df-784">Context and problem</span></span>
<span data-ttu-id="9e2df-785">Egyes entitás nem 1 MB-nál több adat tárolása összesen.</span><span class="sxs-lookup"><span data-stu-id="9e2df-785">An individual entity cannot store more than 1 MB of data in total.</span></span> <span data-ttu-id="9e2df-786">Ha egy vagy több, a tulajdonság tárolja az értékeket, amelyek a teljes mérete meghaladja ezt az értéket az entitás, a teljes entitás nem tárolja a Table szolgáltatás.</span><span class="sxs-lookup"><span data-stu-id="9e2df-786">If one or several of your properties store values that cause the total size of your entity to exceed this value, you cannot store the entire entity in the Table service.</span></span>  

#### <a name="solution"></a><span data-ttu-id="9e2df-787">Megoldás</span><span class="sxs-lookup"><span data-stu-id="9e2df-787">Solution</span></span>
<span data-ttu-id="9e2df-788">Ha az entitás meghaladja mérete 1 MB, mert egy vagy több tulajdonságának nagy mennyiségű adatot tartalmaz, adatok tárolása a Blob szolgáltatás, és majd tárolja a blob címét az entitásban található egy tulajdonság.</span><span class="sxs-lookup"><span data-stu-id="9e2df-788">If your entity exceeds 1 MB in size because one or more properties contain a large amount of data, you can store data in the Blob service and then store the address of the blob in a property in the entity.</span></span> <span data-ttu-id="9e2df-789">Például egy alkalmazott fénykép a blob Storage tárolóban tárolja és tárolására is használható a fénykép mutató hivatkozást a **fénykép** tulajdonság az alkalmazott entitás:</span><span class="sxs-lookup"><span data-stu-id="9e2df-789">For example, you can store the photo of an employee in blob storage and store a link to the photo in the **Photo** property of your employee entity:</span></span>  

![][25]

#### <a name="issues-and-considerations"></a><span data-ttu-id="9e2df-790">Problémákat és szempontok</span><span class="sxs-lookup"><span data-stu-id="9e2df-790">Issues and considerations</span></span>
<span data-ttu-id="9e2df-791">Ebben a mintában megvalósításához meghatározásakor, vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="9e2df-791">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="9e2df-792">Az entitás a Table szolgáltatás és az adatokat a Blob szolgáltatás közötti végleges konzisztencia fenntartása érdekében használja a [idővel konzisztenssé tranzakciók mintát](#eventually-consistent-transactions-pattern) az entitások fenntartásához.</span><span class="sxs-lookup"><span data-stu-id="9e2df-792">To maintain eventual consistency between the entity in the Table service and the data in the Blob service, use the [Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) to maintain your entities.</span></span>
* <span data-ttu-id="9e2df-793">Legalább két storage-tranzakció teljes entitásnak beolvasása foglalja magában: egyet az entitás és egyet a blob adatainak beolvasása.</span><span class="sxs-lookup"><span data-stu-id="9e2df-793">Retrieving a complete entity involves at least two storage transactions: one to retrieve the entity and one to retrieve the blob data.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="9e2df-794">Mikor érdemes használni ezt a mintát</span><span class="sxs-lookup"><span data-stu-id="9e2df-794">When to use this pattern</span></span>
<span data-ttu-id="9e2df-795">Használja ezt a mintát, ha a kell entitások, amelyek mérete meghaladja az egyes entitásnál a Table szolgáltatásban tárolni.</span><span class="sxs-lookup"><span data-stu-id="9e2df-795">Use this pattern when you need to store entities whose size exceeds the limits for an individual entity in the Table service.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="9e2df-796">Útmutató és a kapcsolódó minták</span><span class="sxs-lookup"><span data-stu-id="9e2df-796">Related patterns and guidance</span></span>
<span data-ttu-id="9e2df-797">A következő mintákat és útmutatókat is megfelelő ebben a mintában végrehajtása során:</span><span class="sxs-lookup"><span data-stu-id="9e2df-797">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="9e2df-798">Idővel konzisztenssé tranzakciók minta</span><span class="sxs-lookup"><span data-stu-id="9e2df-798">Eventually consistent transactions pattern</span></span>](#eventually-consistent-transactions-pattern)  
* [<span data-ttu-id="9e2df-799">Széles entitások minta</span><span class="sxs-lookup"><span data-stu-id="9e2df-799">Wide entities pattern</span></span>](#wide-entities-pattern)

<a name="prepend-append-anti-pattern"></a>

### <a name="prependappend-anti-pattern"></a><span data-ttu-id="9e2df-800">Víruskereső mintát illesztenie hozzáfűzése</span><span class="sxs-lookup"><span data-stu-id="9e2df-800">Prepend/append anti-pattern</span></span>
<span data-ttu-id="9e2df-801">Méretezhetőség fokozása, ha nagyszámú Beszúrások által a Beszúrás több partíciót keresztül terjednek.</span><span class="sxs-lookup"><span data-stu-id="9e2df-801">Increase scalability when you have a high volume of inserts by spreading the inserts across multiple partitions.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="9e2df-802">A környezetben, és probléma</span><span class="sxs-lookup"><span data-stu-id="9e2df-802">Context and problem</span></span>
<span data-ttu-id="9e2df-803">Fertőző vagy entitások hozzáfűzi a tárolt entitásokat általában az alkalmazás új entitásokat ad hozzá az első vagy utolsó partíció partíciók több eredményez.</span><span class="sxs-lookup"><span data-stu-id="9e2df-803">Prepending or appending entities to your stored entities typically results in the application adding new entities to the first or last partition of a sequence of partitions.</span></span> <span data-ttu-id="9e2df-804">Ebben az esetben egy adott időpontban Beszúrások mindegyikét történnek az egyazon partícióra kerüljenek, létrehozása, amely megakadályozza a table szolgáltatás betöltési eseménybeszúrások terheléselosztás több csomópont között, és ami miatt az alkalmazás elérte a méretezhetőségi célok az interaktív terület a partíció.</span><span class="sxs-lookup"><span data-stu-id="9e2df-804">In this case, all of the inserts at any given time are taking place in the same partition, creating a hotspot that prevents the table service from load balancing inserts across multiple nodes, and possibly causing your application to hit the scalability targets for partition.</span></span> <span data-ttu-id="9e2df-805">Például, ha az alkalmazottak által elérhető naplók hálózati és az erőforrás alkalmazás, majd egy entitás struktúra alább látható módon eredményezhet a forgalmas adattömbök váljon, ha a tranzakciók mennyisége eléri a méretezhetőség célja a jelenlegi órán partíció egy egyes partíció:</span><span class="sxs-lookup"><span data-stu-id="9e2df-805">For example, if you have an application that logs network and resource access by employees, then an entity structure as shown below could result in the current hour's partition becoming a hotspot if the volume of transactions reaches the scalability target for an individual partition:</span></span>  

![][26]

#### <a name="solution"></a><span data-ttu-id="9e2df-806">Megoldás</span><span class="sxs-lookup"><span data-stu-id="9e2df-806">Solution</span></span>
<span data-ttu-id="9e2df-807">A következő alternatív entitás struktúra bármely adott partíció interaktív terület elkerülhető az alkalmazás naplók eseményként is:</span><span class="sxs-lookup"><span data-stu-id="9e2df-807">The following alternative entity structure avoids a hotspot on any particular partition as the application logs events:</span></span>  

![][27]

<span data-ttu-id="9e2df-808">Figyelje meg, az ebben a példában hogyan mindkét a **PartitionKey** és **RowKey** összetett kulcs.</span><span class="sxs-lookup"><span data-stu-id="9e2df-808">Notice with this example how both the **PartitionKey** and **RowKey** are compound keys.</span></span> <span data-ttu-id="9e2df-809">A **PartitionKey** a részleg és az alkalmazott azonosítóját használja a naplózás szét több partíciót.</span><span class="sxs-lookup"><span data-stu-id="9e2df-809">The **PartitionKey** uses both the department and employee id to distribute the logging across multiple partitions.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="9e2df-810">Problémákat és szempontok</span><span class="sxs-lookup"><span data-stu-id="9e2df-810">Issues and considerations</span></span>
<span data-ttu-id="9e2df-811">Ebben a mintában megvalósításához meghatározásakor, vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="9e2df-811">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="9e2df-812">Támogatja az alternatív struktúra, amely hatékonyan létrehozása a gyakran használt adatok partíciók a Beszúrás az ügyfélalkalmazás lekérdezések?</span><span class="sxs-lookup"><span data-stu-id="9e2df-812">Does the alternative key structure that avoids creating hot partitions on inserts efficiently support the queries your client application makes?</span></span>  
* <span data-ttu-id="9e2df-813">A tranzakciók várható mennyisége azt jelenti, hogy valószínűleg, az egyes partíciók a méretezhetőségi célok eléréséhez, és a tároló szolgáltatás által szabályozott kell?</span><span class="sxs-lookup"><span data-stu-id="9e2df-813">Does your anticipated volume of transactions mean that you are likely to reach the scalability targets for an individual partition and be throttled by the storage service?</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="9e2df-814">Mikor érdemes használni ezt a mintát</span><span class="sxs-lookup"><span data-stu-id="9e2df-814">When to use this pattern</span></span>
<span data-ttu-id="9e2df-815">A víruskereső prepend hozzáfűzése minta elkerülése a tranzakciók mennyisége valószínű, hogy a társzolgáltatás általi szabályozás, amikor hozzáfér a gyakran használt adatok partíció eredményez.</span><span class="sxs-lookup"><span data-stu-id="9e2df-815">Avoid the prepend/append anti-pattern when your volume of transactions is likely to result in throttling by the storage service when you access a hot partition.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="9e2df-816">Útmutató és a kapcsolódó minták</span><span class="sxs-lookup"><span data-stu-id="9e2df-816">Related patterns and guidance</span></span>
<span data-ttu-id="9e2df-817">A következő mintákat és útmutatókat is megfelelő ebben a mintában végrehajtása során:</span><span class="sxs-lookup"><span data-stu-id="9e2df-817">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="9e2df-818">Összetett kulcs minta</span><span class="sxs-lookup"><span data-stu-id="9e2df-818">Compound key pattern</span></span>](#compound-key-pattern)  
* [<span data-ttu-id="9e2df-819">Napló végéről minta</span><span class="sxs-lookup"><span data-stu-id="9e2df-819">Log tail pattern</span></span>](#log-tail-pattern)  
* [<span data-ttu-id="9e2df-820">Entitások módosítása</span><span class="sxs-lookup"><span data-stu-id="9e2df-820">Modifying entities</span></span>](#modifying-entities)  

### <a name="log-data-anti-pattern"></a><span data-ttu-id="9e2df-821">Napló elleni adatmintát</span><span class="sxs-lookup"><span data-stu-id="9e2df-821">Log data anti-pattern</span></span>
<span data-ttu-id="9e2df-822">Általában kell használnia a Blob szolgáltatás helyett a Table szolgáltatás naplózási adatok tárolására.</span><span class="sxs-lookup"><span data-stu-id="9e2df-822">Typically, you should use the Blob service instead of the Table service to store log data.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="9e2df-823">A környezetben, és probléma</span><span class="sxs-lookup"><span data-stu-id="9e2df-823">Context and problem</span></span>
<span data-ttu-id="9e2df-824">Egy gyakori használati eset, a naplózási adatokat beolvasni a kijelölt naplóbejegyzések adott dátum/idő köre: például keresendő összes hiba és kritikus üzeneteihez, az alkalmazás a rendszer 15:04 és 15:06 egy adott dátumon között.</span><span class="sxs-lookup"><span data-stu-id="9e2df-824">A common use case for log data is to retrieve a selection of log entries for a specific date/time range: for example, you want to find all the error and critical messages that your application logged between 15:04 and 15:06 on a specific date.</span></span> <span data-ttu-id="9e2df-825">Nem szeretné, hogy a dátum és idő a naplóüzenet segítségével határozza meg a napló entitásokat mentése partíció:, amely az okozza, a működés közbeni partíció egy adott időpontban a napló entitások aliashoz ugyanaz **PartitionKey** érték (lásd: a a szakasz [elleni mintát Prepend hozzáfűzése](#prepend-append-anti-pattern)).</span><span class="sxs-lookup"><span data-stu-id="9e2df-825">You do not want to use the date and time of the log message to determine the partition you save log entities to: that results in a hot partition because at any given time, all the log entities will share the same **PartitionKey** value (see the section [Prepend/append anti-pattern](#prepend-append-anti-pattern)).</span></span> <span data-ttu-id="9e2df-826">Például egy naplófájlüzenetre a következő entitás sémát eredményezi egy gyakran használt adatok partíció, mert az alkalmazás összes naplóüzenetek ír a partíció az aktuális dátum és az óra:</span><span class="sxs-lookup"><span data-stu-id="9e2df-826">For example, the following entity schema for a log message results in a hot partition because the application writes all log messages to the partition for the current date and hour:</span></span>  

![][28]

<span data-ttu-id="9e2df-827">Ebben a példában a **RowKey** tartalmazza a dátum és idő a naplóüzenet annak érdekében, hogy naplóüzenetek kell tárolni, dátum/idő sorrendbe rendezve, és egy üzenetazonosítója abban az esetben, ha több naplóüzenetek megosztása azonos dátumát és idejét.</span><span class="sxs-lookup"><span data-stu-id="9e2df-827">In this example, the **RowKey** includes the date and time of the log message to ensure that log messages are stored sorted in date/time order, and includes a message id in case multiple log messages share the same date and time.</span></span>  

<span data-ttu-id="9e2df-828">Egy másik megoldás, használatához egy **PartitionKey** , amely biztosítja, hogy az alkalmazás írja az üzenetek között számos különböző partíciókat.</span><span class="sxs-lookup"><span data-stu-id="9e2df-828">Another approach is to use a **PartitionKey** that ensures that the application writes messages across a range of partitions.</span></span> <span data-ttu-id="9e2df-829">Például ha a napló-üzenet forrása üzenetek szét sok partíciót lehetőséget biztosít, a következő entitás séma használhatja:</span><span class="sxs-lookup"><span data-stu-id="9e2df-829">For example, if the source of the log message provides a way to distribute messages across many partitions, you could use the following entity schema:</span></span>  

![][29]

<span data-ttu-id="9e2df-830">A probléma a séma azonban, hogy egy adott időtartam összes a naplózott üzeneteket beolvasni akkor kell megkeresni minden partíció a táblában.</span><span class="sxs-lookup"><span data-stu-id="9e2df-830">However, the problem with this schema is that to retrieve all the log messages for a specific time span you must search every partition in the table.</span></span>

#### <a name="solution"></a><span data-ttu-id="9e2df-831">Megoldás</span><span class="sxs-lookup"><span data-stu-id="9e2df-831">Solution</span></span>
<span data-ttu-id="9e2df-832">Az előző szakaszban kiemeli a problémát, a Table szolgáltatás használatakor a naplóbejegyzések és a javasolt a két, nem megfelelő, a terveinek tárolásához.</span><span class="sxs-lookup"><span data-stu-id="9e2df-832">The previous section highlighted the problem of trying to use the Table service to store log entries and suggested two, unsatisfactory, designs.</span></span> <span data-ttu-id="9e2df-833">Naplóüzenetek; írása gyenge teljesítményt veszélye kiemelt partíció vezetett egy megoldást a más megoldás eredményezett gyenge lekérdezési teljesítmény megvizsgálja az adott ideig üzeneteket beolvasni a táblázatban minden partíció követelmény miatt.</span><span class="sxs-lookup"><span data-stu-id="9e2df-833">One solution led to a hot partition with the risk of poor performance writing log messages; the other solution resulted in poor query performance because of the requirement to scan every partition in the table to retrieve log messages for a specific time span.</span></span> <span data-ttu-id="9e2df-834">A BLOB storage ilyen esetben jobb megoldást kínál, és ez az az Azure Storage Analytics tárolja a naplózási adatokat gyűjt.</span><span class="sxs-lookup"><span data-stu-id="9e2df-834">Blob storage offers a better solution for this type of scenario and this is how Azure Storage Analytics stores the log data it collects.</span></span>  

<span data-ttu-id="9e2df-835">Ez a szakasz ismerteti, hogyan tárolási analitika napló adatot tárol a blob storage szemléltetésére ezt a módszert, amely általában szerint kíván lekérdezni tartomány adatainak tárolásához.</span><span class="sxs-lookup"><span data-stu-id="9e2df-835">This section outlines how Storage Analytics stores log data in blob storage as an illustration of this approach to storing data that you typically query by range.</span></span>  

<span data-ttu-id="9e2df-836">Tárolási analitika naplóüzenetek több blobok tagolt formátumban tárolja.</span><span class="sxs-lookup"><span data-stu-id="9e2df-836">Storage Analytics stores log messages in a delimited format in multiple blobs.</span></span> <span data-ttu-id="9e2df-837">A tagolt formátumú megkönnyíti, hogy a napló üzenetben az adatok egy ügyfél alkalmazáshoz.</span><span class="sxs-lookup"><span data-stu-id="9e2df-837">The delimited format makes it easy for a client application to parse the data in the log message.</span></span>  

<span data-ttu-id="9e2df-838">Tárolási analitika elnevezési szabályait, amely lehetővé teszi a blob található blobok (vagy blobok), amelyek tartalmazzák a naplófájlüzeneteket keresést, amelynek használja.</span><span class="sxs-lookup"><span data-stu-id="9e2df-838">Storage Analytics uses a naming convention for blobs that enables you to locate the blob (or blobs) that contain the log messages for which you are searching.</span></span> <span data-ttu-id="9e2df-839">Például a "queue/2014/07/31/1800/000001.log" nevű blob a queue szolgáltatás a kezdő pozíció: 31 2014. július 18:00 óra kapcsolódó naplóüzenetek tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="9e2df-839">For example, a blob named "queue/2014/07/31/1800/000001.log" contains log messages that relate to the queue service for the hour starting at 18:00 on 31 July 2014.</span></span> <span data-ttu-id="9e2df-840">A "000001" azt jelzi, hogy ez az első naplófájlja erre az időszakra.</span><span class="sxs-lookup"><span data-stu-id="9e2df-840">The "000001" indicates that this is the first log file for this period.</span></span> <span data-ttu-id="9e2df-841">Tárolási analitika az első és utolsó naplóüzenetek a blob metaadatai részeként fájlban tárolja az időbélyegeket is rögzíti.</span><span class="sxs-lookup"><span data-stu-id="9e2df-841">Storage Analytics also records the timestamps of the first and last log messages stored in the file as part of the blob's metadata.</span></span> <span data-ttu-id="9e2df-842">Az API a blob storage lehetővé teszi, hogy blobok keresse meg a tartománynév előtagján alapuló tároló: keresse meg a kezdődő 18:00 órára várólistára naplózási adatokat tartalmazó összes BLOB, használja az előtag "várólista/2014/07/31/1800."</span><span class="sxs-lookup"><span data-stu-id="9e2df-842">The API for blob storage enables you locate blobs in a container based on a name prefix: to locate all the blobs that contain queue log data for the hour starting at 18:00, you can use the prefix "queue/2014/07/31/1800."</span></span>  

<span data-ttu-id="9e2df-843">Storage Analytics pufferek üzenetek naplózása belső majd rendszeres időközönként frissíti a megfelelő blob vagy hoz létre egy újat a legújabb naplóbejegyzéseket tranzakcióköteghez.</span><span class="sxs-lookup"><span data-stu-id="9e2df-843">Storage Analytics buffers log messages internally and then periodically updates the appropriate blob or creates a new one with the latest batch of log entries.</span></span> <span data-ttu-id="9e2df-844">Ez csökkenti azt végezze el a blob szolgáltatás írási műveletek számát.</span><span class="sxs-lookup"><span data-stu-id="9e2df-844">This reduces the number of writes it must perform to the blob service.</span></span>  

<span data-ttu-id="9e2df-845">Egy hasonló megoldás webkiszolgálókból a saját alkalmazásban, meg kell fontolnia és megbízhatóság (írása minden naplóbejegyzés a blob storage módon történik, akkor) és méretezhetőség (pufferelés az alkalmazás és az írás a frissítések közötti kompromisszum kezelése azokat a blob-tároló kötegekben).</span><span class="sxs-lookup"><span data-stu-id="9e2df-845">If you are implementing a similar solution in your own application, you must consider how to manage the trade-off between reliability (writing every log entry to blob storage as it happens) and cost and scalability (buffering updates in your application and writing them to blob storage in batches).</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="9e2df-846">Problémákat és szempontok</span><span class="sxs-lookup"><span data-stu-id="9e2df-846">Issues and considerations</span></span>
<span data-ttu-id="9e2df-847">Módjának napló adatok tárolására, vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="9e2df-847">Consider the following points when deciding how to store log data:</span></span>  

* <span data-ttu-id="9e2df-848">Ha létrehoz egy Táblatervezés, amellyel elkerülhető a potenciális kiemelt partíciók, előfordulhat, hogy nem férhet hozzá a naplóadatok hatékonyan.</span><span class="sxs-lookup"><span data-stu-id="9e2df-848">If you create a table design that avoids potential hot partitions, you may find that you cannot access your log data efficiently.</span></span>  
* <span data-ttu-id="9e2df-849">Egy ügyfél naplóadatokat feldolgozni, gyakran kell sok rekord betöltése.</span><span class="sxs-lookup"><span data-stu-id="9e2df-849">To process log data, a client often needs to load many records.</span></span>  
* <span data-ttu-id="9e2df-850">Bár gyakran felépítése naplóadatokat, a blob storage egy jobb megoldás lehet.</span><span class="sxs-lookup"><span data-stu-id="9e2df-850">Although log data is often structured, blob storage may be a better solution.</span></span>  

### <a name="implementation-considerations"></a><span data-ttu-id="9e2df-851">Megvalósítási kapcsolatos szempontok</span><span class="sxs-lookup"><span data-stu-id="9e2df-851">Implementation considerations</span></span>
<span data-ttu-id="9e2df-852">Ez a szakasz ismerteti a szempontokat tartalmaz, amelyek a korábbi szakaszokban ismertetett mintázatokat bevezetésekor figyelembe kell vennie néhány.</span><span class="sxs-lookup"><span data-stu-id="9e2df-852">This section discusses some of the considerations to bear in mind when you implement the patterns described in the previous sections.</span></span> <span data-ttu-id="9e2df-853">Ez a szakasz a legtöbb a Storage ügyféloldali kódtára (verziója 4.3.0 időpontjában írása) használó C# nyelven írt példák használja.</span><span class="sxs-lookup"><span data-stu-id="9e2df-853">Most of this section uses examples written in C# that use the Storage Client Library (version 4.3.0 at the time of writing).</span></span>  

### <a name="retrieving-entities"></a><span data-ttu-id="9e2df-854">Entitások beolvasása</span><span class="sxs-lookup"><span data-stu-id="9e2df-854">Retrieving entities</span></span>
<span data-ttu-id="9e2df-855">A szakaszban bemutatott [lekérdezése tervezési](#design-for-querying), a legtöbb hatékony Ez egy pont lekérdezés.</span><span class="sxs-lookup"><span data-stu-id="9e2df-855">As discussed in the section [Design for querying](#design-for-querying), the most efficient query is a point query.</span></span> <span data-ttu-id="9e2df-856">Azonban bizonyos esetekben szükség lehet lekérdezni a több entitás.</span><span class="sxs-lookup"><span data-stu-id="9e2df-856">However, in some scenarios you may need to retrieve multiple entities.</span></span> <span data-ttu-id="9e2df-857">Ez a szakasz ismerteti az egyes közös megközelítés beolvasása a Storage ügyféloldali kódtár segítségével.</span><span class="sxs-lookup"><span data-stu-id="9e2df-857">This section describes some common approaches to retrieving entities using the Storage Client Library.</span></span>  

#### <a name="executing-a-point-query-using-the-storage-client-library"></a><span data-ttu-id="9e2df-858">A Storage ügyféloldali kódtár segítségével pont lekérdezése</span><span class="sxs-lookup"><span data-stu-id="9e2df-858">Executing a point query using the Storage Client Library</span></span>
<span data-ttu-id="9e2df-859">Pont lekérdezés végrehajtása legegyszerűbb módja a használja a **beolvasása** művelet tábla, ahogy az az alábbi C# kódrészletet, amely lekéri az entitás egy **PartitionKey** érték "Értékesítési" és a  **RowKey** "212" érték:</span><span class="sxs-lookup"><span data-stu-id="9e2df-859">The easiest way to execute a point query is to use the **Retrieve** table operation as shown in the following C# code snippet that retrieves an entity with a **PartitionKey** of value "Sales" and a **RowKey** of value "212":</span></span>  

```csharp
TableOperation retrieveOperation = TableOperation.Retrieve<EmployeeEntity>("Sales", "212");
var retrieveResult = employeeTable.Execute(retrieveOperation);
if (retrieveResult.Result != null)
{
    EmployeeEntity employee = (EmployeeEntity)retrieveResult.Result;
    ...
}  
```

<span data-ttu-id="9e2df-860">Figyelje meg, hogyan ebben a példában vár az entitás típusa lekérdezi **EmployeeEntity**.</span><span class="sxs-lookup"><span data-stu-id="9e2df-860">Notice how this example expects the entity it retrieves to be of type **EmployeeEntity**.</span></span>  

#### <a name="retrieving-multiple-entities-using-linq"></a><span data-ttu-id="9e2df-861">LINQ használatával több entitás beolvasásakor</span><span class="sxs-lookup"><span data-stu-id="9e2df-861">Retrieving multiple entities using LINQ</span></span>
<span data-ttu-id="9e2df-862">A Storage ügyféloldali kódtára a LINQ használatával, és a lekérdezés megadásával több entitás le egy **ahol** záradékban.</span><span class="sxs-lookup"><span data-stu-id="9e2df-862">You can retrieve multiple entities by using LINQ with Storage Client Library and specifying a query with a **where** clause.</span></span> <span data-ttu-id="9e2df-863">Egy táblázatbeolvasás elkerülése érdekében meg kell adnia a **PartitionKey** érték WHERE záradék, és ha lehetséges a **RowKey** érték tábla és a partíció vizsgálatok elkerülése érdekében.</span><span class="sxs-lookup"><span data-stu-id="9e2df-863">To avoid a table scan, you should always include the **PartitionKey** value in the where clause, and if possible the **RowKey** value to avoid table and partition scans.</span></span> <span data-ttu-id="9e2df-864">A table szolgáltatás támogatja a korlátozott számú összehasonlító operátorok (nagyobb, mint, nagyobb vagy egyenlő, kevesebb mint, kisebb vagy egyenlő, egyenlő, és nem egyenlő) használható a where záradékban.</span><span class="sxs-lookup"><span data-stu-id="9e2df-864">The table service supports a limited set of comparison operators (greater than, greater than or equal, less than, less than or equal, equal, and not equal) to use in the where clause.</span></span> <span data-ttu-id="9e2df-865">A következő C# kódrészletet megállapítja az alkalmazottak, amelynek utolsó neve kezdődik, "B" (feltéve, hogy a **RowKey** vezetékneve tárolja) az értékesítési részleg (feltéve, hogy a **PartitionKey** tárolja a osztály neve):</span><span class="sxs-lookup"><span data-stu-id="9e2df-865">The following C# code snippet finds all the employees whose last name starts with "B" (assuming that the **RowKey** stores the last name) in the sales department (assuming the **PartitionKey** stores the department name):</span></span>  

```csharp
TableQuery<EmployeeEntity> employeeQuery = employeeTable.CreateQuery<EmployeeEntity>();
var query = (from employee in employeeQuery
            where employee.PartitionKey == "Sales" &&
            employee.RowKey.CompareTo("B") >= 0 &&
            employee.RowKey.CompareTo("C") < 0
            select employee).AsTableQuery();
var employees = query.Execute();  
```

<span data-ttu-id="9e2df-866">Figyelje meg, hogyan a lekérdezés határoz meg, mindkét egy **RowKey** és egy **PartitionKey** jobb teljesítmény érdekében.</span><span class="sxs-lookup"><span data-stu-id="9e2df-866">Notice how the query specifies both a **RowKey** and a **PartitionKey** to ensure better performance.</span></span>  

<span data-ttu-id="9e2df-867">Az alábbi példakód mutatja Folyékonyan beszél API használatával egyenértékű funkciókat (További információ a Folyékonyan beszél API-k általában: [Folyékonyan beszél API tervezéséhez gyakorlati tanácsok](http://visualstudiomagazine.com/articles/2013/12/01/best-practices-for-designing-a-fluent-api.aspx)):</span><span class="sxs-lookup"><span data-stu-id="9e2df-867">The following code sample shows equivalent functionality using the fluent API (for more information about fluent APIs in general, see [Best Practices for Designing a Fluent API](http://visualstudiomagazine.com/articles/2013/12/01/best-practices-for-designing-a-fluent-api.aspx)):</span></span>  

```csharp
TableQuery<EmployeeEntity> employeeQuery = new TableQuery<EmployeeEntity>().Where(
    TableQuery.CombineFilters(
    TableQuery.CombineFilters(
        TableQuery.GenerateFilterCondition(
    "PartitionKey", QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.GenerateFilterCondition(
    "RowKey", QueryComparisons.GreaterThanOrEqual, "B")
),
TableOperators.And,
TableQuery.GenerateFilterCondition("RowKey", QueryComparisons.LessThan, "C")
    )
);
var employees = employeeTable.ExecuteQuery(employeeQuery);  
```

> [!NOTE]
> <span data-ttu-id="9e2df-868">A minta ágyazza több **CombineFilters** , melyek a szűrési feltételek.</span><span class="sxs-lookup"><span data-stu-id="9e2df-868">The sample nests multiple **CombineFilters** methods to include the three filter conditions.</span></span>  
> 
> 

#### <a name="retrieving-large-numbers-of-entities-from-a-query"></a><span data-ttu-id="9e2df-869">Egy lekérdezés által nagyszámú entitások beolvasása</span><span class="sxs-lookup"><span data-stu-id="9e2df-869">Retrieving large numbers of entities from a query</span></span>
<span data-ttu-id="9e2df-870">Az optimális lekérdezési alapuló egyéni entitást adja vissza egy **PartitionKey** érték és egy **RowKey** érték.</span><span class="sxs-lookup"><span data-stu-id="9e2df-870">An optimal query returns an individual entity based on a **PartitionKey** value and a **RowKey** value.</span></span> <span data-ttu-id="9e2df-871">Azonban bizonyos esetekben előfordulhat, hogy ad vissza a sok entitásokat tartalmazó partícióra vagy akár több partíciók számára.</span><span class="sxs-lookup"><span data-stu-id="9e2df-871">However, in some scenarios you may have a requirement to return many entities from the same partition or even from many partitions.</span></span>  

<span data-ttu-id="9e2df-872">Ilyen esetekben mindig teljes tesztelje az alkalmazás teljesítményét.</span><span class="sxs-lookup"><span data-stu-id="9e2df-872">You should always fully test the performance of your application in such scenarios.</span></span>  

<span data-ttu-id="9e2df-873">Egy lekérdezést hajtanak a table szolgáltatás térhetnek vissza egy adott időpontban legfeljebb 1000 entitásokat, és előfordulhat, hogy öt másodpercenként legfeljebb hajtható végre.</span><span class="sxs-lookup"><span data-stu-id="9e2df-873">A query against the table service may return a maximum of 1,000 entities at one time and may execute for a maximum of five seconds.</span></span> <span data-ttu-id="9e2df-874">Ha az eredménykészlet 1000-nél több entitásokat tartalmaz, ha a lekérdezés nem fejeződött be 5 másodpercen belül, vagy ha a lekérdezés áthalad a partíció határán, a Table szolgáltatás a folytatási kód ahhoz, hogy az ügyfélalkalmazás igényelni az entitások következő készletét adja vissza.</span><span class="sxs-lookup"><span data-stu-id="9e2df-874">If the result set contains more than 1,000 entities, if the query did not complete within five seconds, or if the query crosses the partition boundary, the Table service returns a continuation token to enable the client application to request the next set of entities.</span></span> <span data-ttu-id="9e2df-875">Hogyan folytatási jogkivonatok munkahelyi kapcsolatos további információkért lásd: [lekérdezés időkorlátja és tördelési](http://msdn.microsoft.com/library/azure/dd135718.aspx).</span><span class="sxs-lookup"><span data-stu-id="9e2df-875">For more information about how continuation tokens work, see [Query Timeout and Pagination](http://msdn.microsoft.com/library/azure/dd135718.aspx).</span></span>  

<span data-ttu-id="9e2df-876">A Storage ügyféloldali kódtár használ, ha azt automatikusan kezelik a folytatási jogkivonatok meg, az entitásokat ad vissza a Table szolgáltatásból.</span><span class="sxs-lookup"><span data-stu-id="9e2df-876">If you are using the Storage Client Library, it can automatically handle continuation tokens for you as it returns entities from the Table service.</span></span> <span data-ttu-id="9e2df-877">A következő C# kódminta a Storage ügyféloldali kódtár segítségével automatikusan kezeli a folytatási jogkivonatokat, ha a table szolgáltatás visszaadja azokat a válasz:</span><span class="sxs-lookup"><span data-stu-id="9e2df-877">The following C# code sample using the Storage Client Library automatically handles continuation tokens if the table service returns them in a response:</span></span>  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

var employees = employeeTable.ExecuteQuery(employeeQuery);
foreach (var emp in employees)
{
        ...
}  
```

<span data-ttu-id="9e2df-878">A következő C#-kódban explicit módon kezeli a folytatási jogkivonatokat:</span><span class="sxs-lookup"><span data-stu-id="9e2df-878">The following C# code handles continuation tokens explicitly:</span></span>  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

TableContinuationToken continuationToken = null;

do
{
        var employees = employeeTable.ExecuteQuerySegmented(
        employeeQuery, continuationToken);
    foreach (var emp in employees)
    {
    ...
    }
    continuationToken = employees.ContinuationToken;
} while (continuationToken != null);  
```

<span data-ttu-id="9e2df-879">Jogkivonatok segítségével képes folytatási explicit módon, megadhatja, ha az alkalmazás kéri le a következő szegmensnél az adatok.</span><span class="sxs-lookup"><span data-stu-id="9e2df-879">By using continuation tokens explicitly, you can control when your application retrieves the next segment of data.</span></span> <span data-ttu-id="9e2df-880">Például ha az ügyfélalkalmazást lehetővé teszi, hogy a felhasználók a táblában tárolt entitásokat között, a felhasználó dönthet nem között, az alkalmazás csak használna a folytatási kód beolvasása a Tovább gombra a lekérdezés által lekért összes entitás szegmenseket, mikor a felhasználó a jelenlegi szegmens összes entitást lapozást kellett befejeződött.</span><span class="sxs-lookup"><span data-stu-id="9e2df-880">For example, if your client application enables users to page through the entities stored in a table, a user may decide not to page through all the entities retrieved by the query so your application would only use a continuation token to retrieve the next segment when the user had finished paging through all the entities in the current segment.</span></span> <span data-ttu-id="9e2df-881">Ez a megközelítés azzal számos előnnyel jár:</span><span class="sxs-lookup"><span data-stu-id="9e2df-881">This approach has several benefits:</span></span>  

* <span data-ttu-id="9e2df-882">Ez lehetővé teszi, hogy korlátozza az adatok beolvasása a Table szolgáltatásból, és a hálózaton keresztül áthelyeznie.</span><span class="sxs-lookup"><span data-stu-id="9e2df-882">It enables you to limit the amount of data to retrieve from the Table service and that you move over the network.</span></span>  
* <span data-ttu-id="9e2df-883">Lehetővé teszi a .NET aszinkron IO végrehajtásához.</span><span class="sxs-lookup"><span data-stu-id="9e2df-883">It enables you to perform asynchronous IO in .NET.</span></span>  
* <span data-ttu-id="9e2df-884">Ez lehetővé teszi, hogy szerializálni a folytatási kód állandó tárhelyre, így egy alkalmazás összeomlása esetén is.</span><span class="sxs-lookup"><span data-stu-id="9e2df-884">It enables you to serialize the continuation token to persistent storage so you can continue in the event of an application crash.</span></span>  

> [!NOTE]
> <span data-ttu-id="9e2df-885">A folytatási kód általában 1000 entitásokat tartalmazó szegmens adja vissza, bár kevesebb lehet.</span><span class="sxs-lookup"><span data-stu-id="9e2df-885">A continuation token typically returns a segment containing 1,000 entities, although it may be fewer.</span></span> <span data-ttu-id="9e2df-886">Ez is így, ha a lekérdezés visszaadja a bejegyzések számának korlátozása **érvénybe** vissza az első n entitásokat, a keresési feltételeknek megfelelő: a table szolgáltatás térhetnek vissza egy szegmenst mentén rendelkező n entitások nem lépi-e a a folytatási ahhoz, hogy a többi entitások beolvasása.</span><span class="sxs-lookup"><span data-stu-id="9e2df-886">This is also the case if you limit the number of entries a query returns by using **Take** to return the first n entities that match your lookup criteria: the table service may return a segment containing fewer than n entities along with a continuation token to enable you to retrieve the remaining entities.</span></span>  
> 
> 

<span data-ttu-id="9e2df-887">A következő C# kód bemutatja, hogyan lehet módosítani egy szegmens belül visszaadott entitások száma:</span><span class="sxs-lookup"><span data-stu-id="9e2df-887">The following C# code shows how to modify the number of entities returned inside a segment:</span></span>  

```csharp
employeeQuery.TakeCount = 50;  
```

#### <a name="server-side-projection"></a><span data-ttu-id="9e2df-888">Kiszolgálóoldali leképezése</span><span class="sxs-lookup"><span data-stu-id="9e2df-888">Server-side projection</span></span>
<span data-ttu-id="9e2df-889">Egy entitás legfeljebb 255 jellemzőkkel rendelkezik, és legfeljebb 1 MB méretű lehet.</span><span class="sxs-lookup"><span data-stu-id="9e2df-889">A single entity can have up to 255 properties and be up to 1 MB in size.</span></span> <span data-ttu-id="9e2df-890">Ha a tábla lekérdezése, és kérje le az entitásokat, nem feltétlenül kell a tulajdonságok, és elkerülheti a adatátvitel feleslegesen (a késés és a költségek csökkentése érdekében).</span><span class="sxs-lookup"><span data-stu-id="9e2df-890">When you query the table and retrieve entities, you may not need all the properties and can avoid transferring data unnecessarily (to help reduce latency and cost).</span></span> <span data-ttu-id="9e2df-891">Kiszolgálóoldali leképezése vihet át kell tulajdonságait.</span><span class="sxs-lookup"><span data-stu-id="9e2df-891">You can use server-side projection to transfer just the properties you need.</span></span> <span data-ttu-id="9e2df-892">A következő példa egy lekéri csak a **E-mail** tulajdonság (valamint **PartitionKey**, **RowKey**, **időbélyeg**, és **ETag**) az a lekérdezés által kiválasztott entitások.</span><span class="sxs-lookup"><span data-stu-id="9e2df-892">The following example is retrieves just the **Email** property (along with **PartitionKey**, **RowKey**, **Timestamp**, and **ETag**) from the entities selected by the query.</span></span>  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
List<string> columns = new List<string>() { "Email" };
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter).Select(columns);

var entities = employeeTable.ExecuteQuery(employeeQuery);
foreach (var e in entities)
{
        Console.WriteLine("RowKey: {0}, EmployeeEmail: {1}", e.RowKey, e.Email);
}  
```

<span data-ttu-id="9e2df-893">Értesítés az **RowKey** érték érhető el annak ellenére, hogy azt meg beolvasandó tulajdonságként listája nem tartalmazott.</span><span class="sxs-lookup"><span data-stu-id="9e2df-893">Notice how the **RowKey** value is available even though it was not included in the list of properties to retrieve.</span></span>  

### <a name="modifying-entities"></a><span data-ttu-id="9e2df-894">Entitások módosítása</span><span class="sxs-lookup"><span data-stu-id="9e2df-894">Modifying entities</span></span>
<span data-ttu-id="9e2df-895">A Storage ügyféloldali kódtár lehetővé teszi a Beszúrás, törlésével és entitások frissítése a table szolgáltatásban tárolt entitásokat módosítását.</span><span class="sxs-lookup"><span data-stu-id="9e2df-895">The Storage Client Library enables you to modify your entities stored in the table service by inserting, deleting, and updating entities.</span></span> <span data-ttu-id="9e2df-896">EGTs segítségével több insert, update és delete műveletek segítségével csökkentheti a szükséges adatváltások számát kötegelt és a megoldás a teljesítmény javításához.</span><span class="sxs-lookup"><span data-stu-id="9e2df-896">You can use EGTs to batch multiple insert, update, and delete operations together to reduce the number of round trips required and improve the performance of your solution.</span></span>  

<span data-ttu-id="9e2df-897">Fontos megjegyezni, hogy a kivételek, amikor a Storage ügyféloldali kódtár végrehajt egy EGT általában az index az entitás, ami miatt sikertelen a kötegelt tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="9e2df-897">Note that exceptions thrown when the Storage Client Library executes an EGT typically include the index of the entity that caused the batch to fail.</span></span> <span data-ttu-id="9e2df-898">Ez akkor hasznos, ha EGTs kód hibakeresés alatt.</span><span class="sxs-lookup"><span data-stu-id="9e2df-898">This is helpful when you are debugging code that uses EGTs.</span></span>  

<span data-ttu-id="9e2df-899">Azt is figyelembe kell venni, hogyan a kialakítás befolyásolja, miként kezeli az ügyfélalkalmazást a feldolgozási mód és a frissítési művelet.</span><span class="sxs-lookup"><span data-stu-id="9e2df-899">You should also consider how your design affects how your client application handles concurrency and update operations.</span></span>  

#### <a name="managing-concurrency"></a><span data-ttu-id="9e2df-900">Párhuzamossági kezelése</span><span class="sxs-lookup"><span data-stu-id="9e2df-900">Managing concurrency</span></span>
<span data-ttu-id="9e2df-901">Alapértelmezés szerint a table szolgáltatás megvalósítja az optimista feldolgozási ellenőrzi az egyes entitásokat szintjén **beszúrása**, **egyesítése**, és **törlése** műveletek, bár ez az ügyfél számára a table szolgáltatás ellenőrzés elkerülésére lehetőség.</span><span class="sxs-lookup"><span data-stu-id="9e2df-901">By default, the table service implements optimistic concurrency checks at the level of individual entities for **Insert**, **Merge**, and **Delete** operations, although it is possible for a client to force the table service to bypass these checks.</span></span> <span data-ttu-id="9e2df-902">Hogyan kezeli a table szolgáltatás a feldolgozási kapcsolatos további információkért lásd: [egyidejűségi kezelése a Microsoft Azure Storage](storage-concurrency.md).</span><span class="sxs-lookup"><span data-stu-id="9e2df-902">For more information about how the table service manages concurrency, see  [Managing Concurrency in Microsoft Azure Storage](storage-concurrency.md).</span></span>  

#### <a name="merge-or-replace"></a><span data-ttu-id="9e2df-903">Egyesítés vagy cseréje</span><span class="sxs-lookup"><span data-stu-id="9e2df-903">Merge or replace</span></span>
<span data-ttu-id="9e2df-904">A **cserélje le** metódusában a **TableOperation** mindig a felváltja a Table szolgáltatásban teljes entitásnak osztály.</span><span class="sxs-lookup"><span data-stu-id="9e2df-904">The **Replace** method of the **TableOperation** class always replaces the complete entity in the Table service.</span></span> <span data-ttu-id="9e2df-905">Ha nem adja meg a tulajdonság a kérelemben szereplő tulajdonság a tárolt entitás létezik, a kérelem tulajdonság eltávolítja a tárolt entitás.</span><span class="sxs-lookup"><span data-stu-id="9e2df-905">If you do not include a property in the request when that property exists in the stored entity, the request removes that property from the stored entity.</span></span> <span data-ttu-id="9e2df-906">Hacsak nem szeretné tulajdonság explicit módon eltávolítása egy tárolt entitás, meg kell adnia minden tulajdonsághoz a kérelemben.</span><span class="sxs-lookup"><span data-stu-id="9e2df-906">Unless you want to remove a property explicitly from a stored entity, you must include every property in the request.</span></span>  

<span data-ttu-id="9e2df-907">Használhatja a **egyesítése** metódusában a **TableOperation** osztály, amely a Table szolgáltatás helyzet frissíthető entitás küldött adatmennyiség csökkentése érdekében.</span><span class="sxs-lookup"><span data-stu-id="9e2df-907">You can use the **Merge** method of the **TableOperation** class to reduce the amount of data that you send to the Table service when you want to update an entity.</span></span> <span data-ttu-id="9e2df-908">A **egyesítése** módszer semmilyen tulajdonságot a tárolt entitás lecseréli a kérelemben szereplő entitásból tulajdonságértékek, de érintetlenül hagyja a tárolt entitás bármelyik tulajdonságot, amelyek nem szerepelnek a kérelmet.</span><span class="sxs-lookup"><span data-stu-id="9e2df-908">The **Merge** method replaces any properties in the stored entity with property values from the entity included in the request, but leaves intact any properties in the stored entity that are not included in the request.</span></span> <span data-ttu-id="9e2df-909">Ez akkor hasznos, ha nagy entitások és csak a kérelem tulajdonságok kis számú frissíteni kell.</span><span class="sxs-lookup"><span data-stu-id="9e2df-909">This is useful if you have large entities and only need to update a small number of properties in a request.</span></span>  

> [!NOTE]
> <span data-ttu-id="9e2df-910">A **cserélje le** és **egyesítése** módszer sem jár sikerrel, ha az entitás nem létezik.</span><span class="sxs-lookup"><span data-stu-id="9e2df-910">The **Replace** and **Merge** methods fail if the entity does not exist.</span></span> <span data-ttu-id="9e2df-911">Alternatív megoldásként használhatja a **InsertOrReplace** és **InsertOrMerge** módszereket, amelyek új entitás létrehozása, ha még nem létezik.</span><span class="sxs-lookup"><span data-stu-id="9e2df-911">As an alternative, you can use the **InsertOrReplace** and **InsertOrMerge** methods that create a new entity if it doesn't exist.</span></span>  
> 
> 

### <a name="working-with-heterogeneous-entity-types"></a><span data-ttu-id="9e2df-912">Heterogén entitástípusok használata</span><span class="sxs-lookup"><span data-stu-id="9e2df-912">Working with heterogeneous entity types</span></span>
<span data-ttu-id="9e2df-913">A Table szolgáltatás egy *séma nélküli* tábla tároló, amely azt jelenti, hogy egyetlen tábla tud tárolni a Tervező nagyfokú rugalmasságot biztosít több típusú entitásokat.</span><span class="sxs-lookup"><span data-stu-id="9e2df-913">The Table service is a *schema-less* table store that means that a single table can store entities of multiple types providing great flexibility in your design.</span></span> <span data-ttu-id="9e2df-914">Az alábbi példában látható egy tábla dolgozó és a részleg entitások tárolására:</span><span class="sxs-lookup"><span data-stu-id="9e2df-914">The following example illustrates a table storing both employee and department entities:</span></span>  

<table>
<tr>
<th><span data-ttu-id="9e2df-915">PartitionKey</span><span class="sxs-lookup"><span data-stu-id="9e2df-915">PartitionKey</span></span></th>
<th><span data-ttu-id="9e2df-916">RowKey</span><span class="sxs-lookup"><span data-stu-id="9e2df-916">RowKey</span></span></th>
<th><span data-ttu-id="9e2df-917">időbélyeg</span><span class="sxs-lookup"><span data-stu-id="9e2df-917">Timestamp</span></span></th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="9e2df-918">Utónév</span><span class="sxs-lookup"><span data-stu-id="9e2df-918">FirstName</span></span></th>
<th><span data-ttu-id="9e2df-919">Vezetéknév</span><span class="sxs-lookup"><span data-stu-id="9e2df-919">LastName</span></span></th>
<th><span data-ttu-id="9e2df-920">Kor</span><span class="sxs-lookup"><span data-stu-id="9e2df-920">Age</span></span></th>
<th><span data-ttu-id="9e2df-921">E-mail cím</span><span class="sxs-lookup"><span data-stu-id="9e2df-921">Email</span></span></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="9e2df-922">Utónév</span><span class="sxs-lookup"><span data-stu-id="9e2df-922">FirstName</span></span></th>
<th><span data-ttu-id="9e2df-923">Vezetéknév</span><span class="sxs-lookup"><span data-stu-id="9e2df-923">LastName</span></span></th>
<th><span data-ttu-id="9e2df-924">Kor</span><span class="sxs-lookup"><span data-stu-id="9e2df-924">Age</span></span></th>
<th><span data-ttu-id="9e2df-925">E-mail cím</span><span class="sxs-lookup"><span data-stu-id="9e2df-925">Email</span></span></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="9e2df-926">departmentname nevű</span><span class="sxs-lookup"><span data-stu-id="9e2df-926">DepartmentName</span></span></th>
<th><span data-ttu-id="9e2df-927">EmployeeCount</span><span class="sxs-lookup"><span data-stu-id="9e2df-927">EmployeeCount</span></span></th>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="9e2df-928">Utónév</span><span class="sxs-lookup"><span data-stu-id="9e2df-928">FirstName</span></span></th>
<th><span data-ttu-id="9e2df-929">Vezetéknév</span><span class="sxs-lookup"><span data-stu-id="9e2df-929">LastName</span></span></th>
<th><span data-ttu-id="9e2df-930">Kor</span><span class="sxs-lookup"><span data-stu-id="9e2df-930">Age</span></span></th>
<th><span data-ttu-id="9e2df-931">E-mail cím</span><span class="sxs-lookup"><span data-stu-id="9e2df-931">Email</span></span></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

<span data-ttu-id="9e2df-932">Vegye figyelembe, hogy minden egyes szervezet továbbra is rendelkeznie kell **PartitionKey**, **RowKey**, és **időbélyeg** értékeket, de rendelkezhetnek bármely tulajdonságkészletbe.</span><span class="sxs-lookup"><span data-stu-id="9e2df-932">Note that each entity must still have **PartitionKey**, **RowKey**, and **Timestamp** values, but may have any set of properties.</span></span> <span data-ttu-id="9e2df-933">Ezenkívül nincs mit entitás típusát jelzi, kivéve, ha úgy dönt, hogy valahol az információk tárolására.</span><span class="sxs-lookup"><span data-stu-id="9e2df-933">Furthermore, there is nothing to indicate the type of an entity unless you choose to store that information somewhere.</span></span> <span data-ttu-id="9e2df-934">Az entitástípus azonosítására szolgáló két lehetőség áll rendelkezésre:</span><span class="sxs-lookup"><span data-stu-id="9e2df-934">There are two options for identifying the entity type:</span></span>  

* <span data-ttu-id="9e2df-935">Az entitástípus illesztenie a **RowKey** (vagy esetleg a **PartitionKey**).</span><span class="sxs-lookup"><span data-stu-id="9e2df-935">Prepend the entity type to the **RowKey** (or possibly the **PartitionKey**).</span></span> <span data-ttu-id="9e2df-936">Például **EMPLOYEE_000123** vagy **DEPARTMENT_SALES** , **RowKey** értékeket.</span><span class="sxs-lookup"><span data-stu-id="9e2df-936">For example, **EMPLOYEE_000123** or **DEPARTMENT_SALES** as **RowKey** values.</span></span>  
* <span data-ttu-id="9e2df-937">Egy külön tulajdonsággal entitástípus jegyezze fel az alábbi táblázatban látható módon.</span><span class="sxs-lookup"><span data-stu-id="9e2df-937">Use a separate property to record the entity type as shown in the table below.</span></span>  

<table>
<tr>
<th><span data-ttu-id="9e2df-938">PartitionKey</span><span class="sxs-lookup"><span data-stu-id="9e2df-938">PartitionKey</span></span></th>
<th><span data-ttu-id="9e2df-939">RowKey</span><span class="sxs-lookup"><span data-stu-id="9e2df-939">RowKey</span></span></th>
<th><span data-ttu-id="9e2df-940">időbélyeg</span><span class="sxs-lookup"><span data-stu-id="9e2df-940">Timestamp</span></span></th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="9e2df-941">EntityType</span><span class="sxs-lookup"><span data-stu-id="9e2df-941">EntityType</span></span></th>
<th><span data-ttu-id="9e2df-942">Utónév</span><span class="sxs-lookup"><span data-stu-id="9e2df-942">FirstName</span></span></th>
<th><span data-ttu-id="9e2df-943">Vezetéknév</span><span class="sxs-lookup"><span data-stu-id="9e2df-943">LastName</span></span></th>
<th><span data-ttu-id="9e2df-944">Kor</span><span class="sxs-lookup"><span data-stu-id="9e2df-944">Age</span></span></th>
<th><span data-ttu-id="9e2df-945">E-mail cím</span><span class="sxs-lookup"><span data-stu-id="9e2df-945">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="9e2df-946">Alkalmazott</span><span class="sxs-lookup"><span data-stu-id="9e2df-946">Employee</span></span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="9e2df-947">EntityType</span><span class="sxs-lookup"><span data-stu-id="9e2df-947">EntityType</span></span></th>
<th><span data-ttu-id="9e2df-948">Utónév</span><span class="sxs-lookup"><span data-stu-id="9e2df-948">FirstName</span></span></th>
<th><span data-ttu-id="9e2df-949">Vezetéknév</span><span class="sxs-lookup"><span data-stu-id="9e2df-949">LastName</span></span></th>
<th><span data-ttu-id="9e2df-950">Kor</span><span class="sxs-lookup"><span data-stu-id="9e2df-950">Age</span></span></th>
<th><span data-ttu-id="9e2df-951">E-mail cím</span><span class="sxs-lookup"><span data-stu-id="9e2df-951">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="9e2df-952">Alkalmazott</span><span class="sxs-lookup"><span data-stu-id="9e2df-952">Employee</span></span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="9e2df-953">EntityType</span><span class="sxs-lookup"><span data-stu-id="9e2df-953">EntityType</span></span></th>
<th><span data-ttu-id="9e2df-954">departmentname nevű</span><span class="sxs-lookup"><span data-stu-id="9e2df-954">DepartmentName</span></span></th>
<th><span data-ttu-id="9e2df-955">EmployeeCount</span><span class="sxs-lookup"><span data-stu-id="9e2df-955">EmployeeCount</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="9e2df-956">Szervezeti egység</span><span class="sxs-lookup"><span data-stu-id="9e2df-956">Department</span></span></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="9e2df-957">EntityType</span><span class="sxs-lookup"><span data-stu-id="9e2df-957">EntityType</span></span></th>
<th><span data-ttu-id="9e2df-958">Utónév</span><span class="sxs-lookup"><span data-stu-id="9e2df-958">FirstName</span></span></th>
<th><span data-ttu-id="9e2df-959">Vezetéknév</span><span class="sxs-lookup"><span data-stu-id="9e2df-959">LastName</span></span></th>
<th><span data-ttu-id="9e2df-960">Kor</span><span class="sxs-lookup"><span data-stu-id="9e2df-960">Age</span></span></th>
<th><span data-ttu-id="9e2df-961">E-mail cím</span><span class="sxs-lookup"><span data-stu-id="9e2df-961">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="9e2df-962">Alkalmazott</span><span class="sxs-lookup"><span data-stu-id="9e2df-962">Employee</span></span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

<span data-ttu-id="9e2df-963">Az első a beállítást, az entitás prepending a **RowKey**, akkor hasznos, ha lehetséges, hogy két különböző típusú előfordulhat, hogy entitásnak azonos kulcs értéke.</span><span class="sxs-lookup"><span data-stu-id="9e2df-963">The first option, prepending the entity type to the **RowKey**, is useful if there is a possibility that two entities of different types might have the same key value.</span></span> <span data-ttu-id="9e2df-964">Azt is csoportokat együtt a partíció az azonos típusú entitásokat.</span><span class="sxs-lookup"><span data-stu-id="9e2df-964">It also groups entities of the same type together in the partition.</span></span>  

<span data-ttu-id="9e2df-965">Az ebben a szakaszban bemutatott eljárások gyakran a vitafórum [öröklési kapcsolatok](#inheritance-relationships) korábbi szakaszában az útmutatóban [kapcsolatok modellezésére](#modelling-relationships).</span><span class="sxs-lookup"><span data-stu-id="9e2df-965">The techniques discussed in this section are especially relevant to the discussion [Inheritance relationships](#inheritance-relationships) earlier in this guide in the section [Modelling relationships](#modelling-relationships).</span></span>  

> [!NOTE]
> <span data-ttu-id="9e2df-966">Érdemes lehet például egy verziószámot ügyfél alkalmazások POCO objektumok fejlődnek, és különböző verziói együttműködve entitás típus értéke.</span><span class="sxs-lookup"><span data-stu-id="9e2df-966">You should consider including a version number in the entity type value to enable client applications to evolve POCO objects and work with different versions.</span></span>  
> 
> 

<span data-ttu-id="9e2df-967">Ez a szakasz többi néhány a Storage ügyféloldali kódtára a funkciója, amely ugyanabban a táblában a több entitás munka megkönnyítése ismerteti.</span><span class="sxs-lookup"><span data-stu-id="9e2df-967">The remainder of this section describes some of the features in the Storage Client Library that facilitate working with multiple entity types in the same table.</span></span>  

#### <a name="retrieving-heterogeneous-entity-types"></a><span data-ttu-id="9e2df-968">Heterogén entitástípusok beolvasása</span><span class="sxs-lookup"><span data-stu-id="9e2df-968">Retrieving heterogeneous entity types</span></span>
<span data-ttu-id="9e2df-969">A Storage ügyféloldali kódtár használ, az entitástípusok több három beállításai lesz.</span><span class="sxs-lookup"><span data-stu-id="9e2df-969">If you are using the Storage Client Library, you have three options for working with multiple entity types.</span></span>  

<span data-ttu-id="9e2df-970">Ha tudja, hogy az entitás egy adott tárolt típusú **RowKey** és **PartitionKey** érték található, akkor megadhatja az entitás típusa, ha a bejegyzés lekérdezésére, ahogy az előző két példán típusú entitásokat beolvasása az **EmployeeEntity**: [a Storage ügyféloldali kódtár segítségével pont lekérdezése](#executing-a-point-query-using-the-storage-client-library) és [beolvasása a LINQ használatával több entitás](#retrieving-multiple-entities-using-linq).</span><span class="sxs-lookup"><span data-stu-id="9e2df-970">If you know the type of the entity stored with a specific **RowKey** and **PartitionKey** values, then you can specify the entity type when you retrieve the entity as shown in the previous two examples that retrieve entities of type **EmployeeEntity**: [Executing a point query using the Storage Client Library](#executing-a-point-query-using-the-storage-client-library) and [Retrieving multiple entities using LINQ](#retrieving-multiple-entities-using-linq).</span></span>  

<span data-ttu-id="9e2df-971">A második lehetőség a **DynamicTableEntity** típusú (egy tulajdonságcsomagot) helyett egy konkrét POCO entitástípus (ezt a lehetőséget is javíthatja a teljesítményt, mert nincs szükség szerializálása és deszerializálása .NET típusú entitás).</span><span class="sxs-lookup"><span data-stu-id="9e2df-971">The second option is to use the **DynamicTableEntity** type (a property bag) instead of a concrete POCO entity type (this option may also improve performance because there is no need to serialize and deserialize the entity to .NET types).</span></span> <span data-ttu-id="9e2df-972">A következő C#-kódban potenciálisan eltérő típusú entitásokat táblából, de mint minden entitásokat ad vissza **DynamicTableEntity** példányok.</span><span class="sxs-lookup"><span data-stu-id="9e2df-972">The following C# code potentially retrieves multiple entities of different types from the table, but returns all entities as **DynamicTableEntity** instances.</span></span> <span data-ttu-id="9e2df-973">Ezután a **EntityType** tulajdonság minden entitás típusának meghatározására:</span><span class="sxs-lookup"><span data-stu-id="9e2df-973">It then uses the **EntityType** property to determine the type of each entity:</span></span>  

```csharp
string filter = TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("PartitionKey",
    QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("RowKey",
                    QueryComparisons.GreaterThanOrEqual, "B"),
        TableOperators.And,
        TableQuery.GenerateFilterCondition("RowKey",
        QueryComparisons.LessThan, "F")
    )
);
TableQuery<DynamicTableEntity> entityQuery =
    new TableQuery<DynamicTableEntity>().Where(filter);
var employees = employeeTable.ExecuteQuery(entityQuery);

IEnumerable<DynamicTableEntity> entities = employeeTable.ExecuteQuery(entityQuery);
foreach (var e in entities)
{
EntityProperty entityTypeProperty;
if (e.Properties.TryGetValue("EntityType", out entityTypeProperty))
{
    if (entityTypeProperty.StringValue == "Employee")
    {
        // Use entityTypeProperty, RowKey, PartitionKey, Etag, and Timestamp
        }
    }
}  
```

<span data-ttu-id="9e2df-974">Vegye figyelembe, hogy beolvasni más tulajdonságokat kell használnia a **TryGetValue** metódust a **tulajdonságok** tulajdonsága a **DynamicTableEntity** osztály.</span><span class="sxs-lookup"><span data-stu-id="9e2df-974">Note that to retrieve other properties you must use the **TryGetValue** method on the **Properties** property of the **DynamicTableEntity** class.</span></span>  

<span data-ttu-id="9e2df-975">Egy harmadik lehetőség egy kombinálhatja a használatával a **DynamicTableEntity** típust és egy **EntityResolver** példány.</span><span class="sxs-lookup"><span data-stu-id="9e2df-975">A third option is to combine using the **DynamicTableEntity** type and an **EntityResolver** instance.</span></span> <span data-ttu-id="9e2df-976">Ez lehetővé teszi, hogy oldja fel ugyanabban a lekérdezésben többféle POCO.</span><span class="sxs-lookup"><span data-stu-id="9e2df-976">This enables you to resolve to multiple POCO types in the same query.</span></span> <span data-ttu-id="9e2df-977">Ebben a példában a **EntityResolver** delegált használ a **EntityType** tulajdonság használatával tudja megkülönböztetni a két típusú entitás, amely a lekérdezés visszaadja.</span><span class="sxs-lookup"><span data-stu-id="9e2df-977">In this example, the **EntityResolver** delegate is using the **EntityType** property to distinguish between the two types of entity that the query returns.</span></span> <span data-ttu-id="9e2df-978">A **megoldásához** módszert használ a **feloldó** megoldásához delegált **DynamicTableEntity** a példányok **TableEntity** példányok.</span><span class="sxs-lookup"><span data-stu-id="9e2df-978">The **Resolve** method uses the **resolver** delegate to resolve **DynamicTableEntity** instances to **TableEntity** instances.</span></span>  

```csharp
EntityResolver<TableEntity> resolver = (pk, rk, ts, props, etag) =>
{

        TableEntity resolvedEntity = null;
        if (props["EntityType"].StringValue == "Department")
        {
        resolvedEntity = new DepartmentEntity();
        }
        else if (props["EntityType"].StringValue == "Employee")
        {
        resolvedEntity = new EmployeeEntity();
        }
        else throw new ArgumentException("Unrecognized entity", "props");

        resolvedEntity.PartitionKey = pk;
        resolvedEntity.RowKey = rk;
        resolvedEntity.Timestamp = ts;
        resolvedEntity.ETag = etag;
        resolvedEntity.ReadEntity(props, null);
        return resolvedEntity;
};

string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<DynamicTableEntity> entityQuery =
        new TableQuery<DynamicTableEntity>().Where(filter);

var entities = employeeTable.ExecuteQuery(entityQuery, resolver);
foreach (var e in entities)
{
        if (e is DepartmentEntity)
        {
    ...
        }
        if (e is EmployeeEntity)
        {
    ...
        }
}  
```

#### <a name="modifying-heterogeneous-entity-types"></a><span data-ttu-id="9e2df-979">Heterogén entitástípusok módosítása</span><span class="sxs-lookup"><span data-stu-id="9e2df-979">Modifying heterogeneous entity types</span></span>
<span data-ttu-id="9e2df-980">Nem kell tudni, hogy milyen típusú entitás törli-e, és mindig ismeri a jogi, amikor a meghajtóba.</span><span class="sxs-lookup"><span data-stu-id="9e2df-980">You do not need to know the type of an entity to delete it, and you always know the type of an entity when you insert it.</span></span> <span data-ttu-id="9e2df-981">Használhat azonban **DynamicTableEntity** típus frissíthető entitás, anélkül, hogy tudnák típusára és egy POCO entitásosztályt használata nélkül.</span><span class="sxs-lookup"><span data-stu-id="9e2df-981">However, you can use **DynamicTableEntity** type to update an entity without knowing its type and without using a POCO entity class.</span></span> <span data-ttu-id="9e2df-982">A következő példakód egyetlen entitás kéri le, és ellenőrzi a **EmployeeCount** tulajdonság létezik-e frissítése előtt.</span><span class="sxs-lookup"><span data-stu-id="9e2df-982">The following code sample retrieves a single entity, and checks the **EmployeeCount** property exists before updating it.</span></span>  

```csharp
TableResult result =
        employeeTable.Execute(TableOperation.Retrieve(partitionKey, rowKey));
DynamicTableEntity department = (DynamicTableEntity)result.Result;

EntityProperty countProperty;

if (!department.Properties.TryGetValue("EmployeeCount", out countProperty))
{
        throw new
        InvalidOperationException("Invalid entity, EmployeeCount property not found.");
}
countProperty.Int32Value += 1;
employeeTable.Execute(TableOperation.Merge(department));  
```

### <a name="controlling-access-with-shared-access-signatures"></a><span data-ttu-id="9e2df-983">Megosztott hozzáférési aláírásokkal-hozzáférés szabályozásáról</span><span class="sxs-lookup"><span data-stu-id="9e2df-983">Controlling access with Shared Access Signatures</span></span>
<span data-ttu-id="9e2df-984">Közös hozzáférésű Jogosultságkód (SAS) jogkivonatok segítségével engedélyezheti az ügyfélalkalmazások (és módosításához lekérdezése) táblaentitásokat közvetlenül nem közvetlenül a table szolgáltatás hitelesítéshez szükséges.</span><span class="sxs-lookup"><span data-stu-id="9e2df-984">You can use Shared Access Signature (SAS) tokens to enable client applications to modify (and query) table entities directly without the need to authenticate directly with the table service.</span></span> <span data-ttu-id="9e2df-985">Nincsenek általában három fő előnyei a SAS használatával az alkalmazásban:</span><span class="sxs-lookup"><span data-stu-id="9e2df-985">Typically, there are three main benefits to using SAS in your application:</span></span>  

* <span data-ttu-id="9e2df-986">Nem kell terjeszteni a tárfiók kulcsára egy nem biztonságos platformon (például egy mobileszköz) annak érdekében, hogy adott eszköz eléréséhez, és módosítsa a Table szolgáltatás szerepelnek.</span><span class="sxs-lookup"><span data-stu-id="9e2df-986">You do not need to distribute your storage account key to an insecure platform (such as a mobile device) in order to allow that device to access and modify entities in the Table service.</span></span>  
* <span data-ttu-id="9e2df-987">Kiürítési egy része az, hogy a webes és feldolgozói szerepkörök hajtsa végre az entitások ügyfél eszközök, például a végfelhasználói számítógépek és mobileszközök kezeléséhez.</span><span class="sxs-lookup"><span data-stu-id="9e2df-987">You can offload some of the work that web and worker roles perform in managing your entities to client devices such as end-user computers and mobile devices.</span></span>  
* <span data-ttu-id="9e2df-988">Hozzárendelhet egy korlátozott, és idő korlátozott engedélyekkel (például a csak olvasási hozzáféréssel egy adott erőforráshoz való engedélyezése) ügyfél számára.</span><span class="sxs-lookup"><span data-stu-id="9e2df-988">You can assign a constrained and time limited set of permissions to a client (such as allowing read-only access to specific resources).</span></span>  

<span data-ttu-id="9e2df-989">A Table szolgáltatás SAS-tokenje használatával kapcsolatban további információkért lásd: [használatával megosztott hozzáférési aláírásokkal (SAS)](storage-dotnet-shared-access-signature-part-1.md).</span><span class="sxs-lookup"><span data-stu-id="9e2df-989">For more information about using SAS tokens with the Table service, see [Using Shared Access Signatures (SAS)](storage-dotnet-shared-access-signature-part-1.md).</span></span>  

<span data-ttu-id="9e2df-990">Azonban továbbra is kell létrehoznia, amely adja meg a table szolgáltatás entitást ügyfélalkalmazás SAS-tokenje: akkor tegye ezt egy olyan környezetben, a tárfiókok kulcsait biztonságos hozzáféréssel rendelkezik.</span><span class="sxs-lookup"><span data-stu-id="9e2df-990">However, you must still generate the SAS tokens that grant a client application to the entities in the table service: you should do this in an environment that has secure access to your storage account keys.</span></span> <span data-ttu-id="9e2df-991">Egy webes vagy feldolgozói szerepkör általában a rendszer az SAS-jogkivonatokat hoz létre, és letöltheti az ügyfélalkalmazások számára az entitások hozzáférést igénylő használják.</span><span class="sxs-lookup"><span data-stu-id="9e2df-991">Typically, you use a web or worker role to generate the SAS tokens and deliver them to the client applications that need access to your entities.</span></span> <span data-ttu-id="9e2df-992">Mivel nincs még egy terhelés létrehozásakor, és kézbesíti SAS-tokenje az ügyfelek számára, hogyan lehet a legjobban érdemes lehet csökkenteni a terhelést, különösen a nagy mennyiségű forgatókönyvek részt.</span><span class="sxs-lookup"><span data-stu-id="9e2df-992">Because there is still an overhead involved in generating and delivering SAS tokens to clients, you should consider how best to reduce this overhead, especially in high-volume scenarios.</span></span>  

<span data-ttu-id="9e2df-993">Úgy is, amely hozzáférést biztosít egy tábla az entitások egy részét a SAS-token létrehozásához.</span><span class="sxs-lookup"><span data-stu-id="9e2df-993">It is possible to generate a SAS token that grants access to a subset of the entities in a table.</span></span> <span data-ttu-id="9e2df-994">Alapértelmezés szerint egy SAS-jogkivonat teljes táblát hoz létre, de akkor is meg, hogy a SAS-jogkivonat való hozzáférés engedélyezése vagy számos **PartitionKey** értékeket, vagy számos **PartitionKey** és **RowKey** értékeket.</span><span class="sxs-lookup"><span data-stu-id="9e2df-994">By default, you create a SAS token for an entire table, but it is also possible to specify that the SAS token grant access to either a range of **PartitionKey** values, or a range of **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="9e2df-995">Akkor célszerű használni, úgy, hogy minden felhasználó SAS-jogkivonat csak lehetővé teszi őket elérését a saját részére a table szolgáltatás egyes felhasználókat a rendszer az SAS-tokenje létrehozásához.</span><span class="sxs-lookup"><span data-stu-id="9e2df-995">You might choose to generate SAS tokens for individual users of your system such that each user's SAS token only allows them access to their own entities in the table service.</span></span>  

### <a name="asynchronous-and-parallel-operations"></a><span data-ttu-id="9e2df-996">Aszinkron és párhuzamos műveletek</span><span class="sxs-lookup"><span data-stu-id="9e2df-996">Asynchronous and parallel operations</span></span>
<span data-ttu-id="9e2df-997">A kérelmek több partíciót között vannak oszlik, feltéve aszinkron vagy párhuzamos lekérdezések használatával is javítható az átviteli sebesség és az ügyfél válaszképességét.</span><span class="sxs-lookup"><span data-stu-id="9e2df-997">Provided you are spreading your requests across multiple partitions, you can improve throughput and client responsiveness by using asynchronous or parallel queries.</span></span>
<span data-ttu-id="9e2df-998">Például lehetséges, hogy két vagy több szerepkör feldolgozópéldányok párhuzamosan a táblák elérése.</span><span class="sxs-lookup"><span data-stu-id="9e2df-998">For example, you might have two or more worker role instances accessing your tables in parallel.</span></span> <span data-ttu-id="9e2df-999">Adott partíciók-készletek felelős az egyes feldolgozói szerepkörök rendelkezik, vagy egyszerűen több feldolgozói szerepkör példánya lehet, minden egyes érhessék el az egy tábla minden egyes partícióra.</span><span class="sxs-lookup"><span data-stu-id="9e2df-999">You could have individual worker roles responsible for particular sets of partitions, or simply have multiple worker role instances, each able to access all the partitions in a table.</span></span>  

<span data-ttu-id="9e2df-1000">Belül egy ügyfél példány aszinkron módon tárolási műveletek végrehajtásával javíthatja a teljesítményt.</span><span class="sxs-lookup"><span data-stu-id="9e2df-1000">Within a client instance, you can improve throughput by executing storage operations asynchronously.</span></span> <span data-ttu-id="9e2df-1001">A Storage ügyféloldali kódtár egyszerűen aszinkron lekérdezések és módosításokat írni.</span><span class="sxs-lookup"><span data-stu-id="9e2df-1001">The Storage Client Library makes it easy to write asynchronous queries and modifications.</span></span> <span data-ttu-id="9e2df-1002">Például előfordulhat, hogy a kiindulási pont a szinkron módszer, amely lekéri az alábbi C#-kódban látható módon egy partíció összes entitásának:</span><span class="sxs-lookup"><span data-stu-id="9e2df-1002">For example, you might start with the synchronous method that retrieves all the entities in a partition as shown in the following C# code:</span></span>  

```csharp
private static void ManyEntitiesQuery(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

        TableContinuationToken continuationToken = null;

        do
        {
        var employees = employeeTable.ExecuteQuerySegmented(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
    {
        ...
    }
        continuationToken = employees.ContinuationToken;
        } while (continuationToken != null);
}  
```

<span data-ttu-id="9e2df-1003">Könnyen módosíthatja ezt a kódot, hogy a lekérdezés aszinkron módon az alábbiak szerint:</span><span class="sxs-lookup"><span data-stu-id="9e2df-1003">You can easily modify this code so that the query runs asynchronously as follows:</span></span>  

```csharp
private static async Task ManyEntitiesQueryAsync(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);
        TableContinuationToken continuationToken = null;

        do
        {
        var employees = await employeeTable.ExecuteQuerySegmentedAsync(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
        {
            ...
        }
        continuationToken = employees.ContinuationToken;
            } while (continuationToken != null);
}  
```

<span data-ttu-id="9e2df-1004">A aszinkron példában láthatja a szinkron verziójáról az alábbi módosításokat:</span><span class="sxs-lookup"><span data-stu-id="9e2df-1004">In this asynchronous example, you can see the following changes from the synchronous version:</span></span>  

* <span data-ttu-id="9e2df-1005">A metódus-aláírás mostantól tartalmazza a **aszinkron** módosító és értéket ad vissza egy **feladat** példány.</span><span class="sxs-lookup"><span data-stu-id="9e2df-1005">The method signature now includes the **async** modifier and returns a **Task** instance.</span></span>  
* <span data-ttu-id="9e2df-1006">Hívása helyett a **ExecuteSegmented** metódusának segítéségével lekérheti az eredményeket, most metódus meghívja a **ExecuteSegmentedAsync** metódus, és használja a **await** módosító eredmények aszinkron beolvasásához.</span><span class="sxs-lookup"><span data-stu-id="9e2df-1006">Instead of calling the **ExecuteSegmented** method to retrieve results, the method now calls the **ExecuteSegmentedAsync** method and uses the **await** modifier to retrieve results asynchronously.</span></span>  

<span data-ttu-id="9e2df-1007">Az ügyfélalkalmazás a metódus hívása többször (a különböző értékekkel a **részleg** paraméter), és minden egyes lekérdezés külön szálban futtatandó.</span><span class="sxs-lookup"><span data-stu-id="9e2df-1007">The client application can call this method multiple times (with different values for the **department** parameter), and each query will run on a separate thread.</span></span>  

<span data-ttu-id="9e2df-1008">Vegye figyelembe, hogy van-e nem aszinkron verziója a **Execute** metódust a **TableQuery** osztálynál, mert a **IEnumerable** illesztőfelület nem támogatja a aszinkron enumerálása.</span><span class="sxs-lookup"><span data-stu-id="9e2df-1008">Note that there is no asynchronous version of the **Execute** method in the **TableQuery** class because the **IEnumerable** interface does not support asynchronous enumeration.</span></span>  

<span data-ttu-id="9e2df-1009">Helyezze, frissítése, és aszinkron módon entitások törlésére.</span><span class="sxs-lookup"><span data-stu-id="9e2df-1009">You can also insert, update, and delete entities asynchronously.</span></span> <span data-ttu-id="9e2df-1010">Az alábbi C# példában egy egyszerű, a szinkron módszer szúrható be, illetve alkalmazott entitás cseréje:</span><span class="sxs-lookup"><span data-stu-id="9e2df-1010">The following C# example shows a simple, synchronous method to insert or replace an employee entity:</span></span>  

```csharp
private static void SimpleEmployeeUpsert(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = employeeTable
        .Execute(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

<span data-ttu-id="9e2df-1011">Könnyen módosíthatja ezt a kódot, hogy a frissítés aszinkron módon az alábbiak szerint:</span><span class="sxs-lookup"><span data-stu-id="9e2df-1011">You can easily modify this code so that the update runs asynchronously as follows:</span></span>  

```csharp
private static async Task SimpleEmployeeUpsertAsync(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = await employeeTable
        .ExecuteAsync(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

<span data-ttu-id="9e2df-1012">A aszinkron példában láthatja a szinkron verziójáról az alábbi módosításokat:</span><span class="sxs-lookup"><span data-stu-id="9e2df-1012">In this asynchronous example, you can see the following changes from the synchronous version:</span></span>  

* <span data-ttu-id="9e2df-1013">A metódus-aláírás mostantól tartalmazza a **aszinkron** módosító és értéket ad vissza egy **feladat** példány.</span><span class="sxs-lookup"><span data-stu-id="9e2df-1013">The method signature now includes the **async** modifier and returns a **Task** instance.</span></span>  
* <span data-ttu-id="9e2df-1014">Hívása helyett a **Execute** metódushívások az entitás-, a metódus most frissíteni a **ExecuteAsync** metódus, és használja a **await** módosító eredmények beolvasásához aszinkron módon.</span><span class="sxs-lookup"><span data-stu-id="9e2df-1014">Instead of calling the **Execute** method to update the entity, the method now calls the **ExecuteAsync** method and uses the **await** modifier to retrieve results asynchronously.</span></span>  

<span data-ttu-id="9e2df-1015">Az ügyfélalkalmazás ehhez hasonló több aszinkron metódus meghívása, és minden metódushívás külön szálban futtatandó.</span><span class="sxs-lookup"><span data-stu-id="9e2df-1015">The client application can call multiple asynchronous methods like this one, and each method invocation will run on a separate thread.</span></span>  

### <a name="credits"></a><span data-ttu-id="9e2df-1016">Kreditek</span><span class="sxs-lookup"><span data-stu-id="9e2df-1016">Credits</span></span>
<span data-ttu-id="9e2df-1017">Örömmel vesszük az Azure-csapat a hozzájárulásuk következő tagjai szeretnénk: Dominic Betts, Jason Hogg, Jean Ghanem, Jai Haridas, Jeff Irwin, Vamshidhar Kommineni, Vinay Shah Serdar Ozler, valamint a Microsoft DX Tom Hollander.</span><span class="sxs-lookup"><span data-stu-id="9e2df-1017">We would like to thank the following members of the Azure team for their contributions: Dominic Betts, Jason Hogg, Jean Ghanem, Jai Haridas, Jeff Irwin, Vamshidhar Kommineni, Vinay Shah and Serdar Ozler as well as  Tom Hollander from Microsoft DX.</span></span> 

<span data-ttu-id="9e2df-1018">Azt is szeretne felülvizsgálati ciklus során a következő Microsoft MVP meg az értékes visszajelzés Köszönjük: Igor Papirov és Edward Bakker.</span><span class="sxs-lookup"><span data-stu-id="9e2df-1018">We would also like to thank the following Microsoft MVP's for their valuable feedback during review cycles: Igor Papirov and Edward Bakker.</span></span>

[1]: ./media/storage-table-design-guide/storage-table-design-IMAGE01.png
[2]: ./media/storage-table-design-guide/storage-table-design-IMAGE02.png
[3]: ./media/storage-table-design-guide/storage-table-design-IMAGE03.png
[4]: ./media/storage-table-design-guide/storage-table-design-IMAGE04.png
[5]: ./media/storage-table-design-guide/storage-table-design-IMAGE05.png
[6]: ./media/storage-table-design-guide/storage-table-design-IMAGE06.png
[7]: ./media/storage-table-design-guide/storage-table-design-IMAGE07.png
[8]: ./media/storage-table-design-guide/storage-table-design-IMAGE08.png
[9]: ./media/storage-table-design-guide/storage-table-design-IMAGE09.png
[10]: ./media/storage-table-design-guide/storage-table-design-IMAGE10.png
[11]: ./media/storage-table-design-guide/storage-table-design-IMAGE11.png
[12]: ./media/storage-table-design-guide/storage-table-design-IMAGE12.png
[13]: ./media/storage-table-design-guide/storage-table-design-IMAGE13.png
[14]: ./media/storage-table-design-guide/storage-table-design-IMAGE14.png
[15]: ./media/storage-table-design-guide/storage-table-design-IMAGE15.png
[16]: ./media/storage-table-design-guide/storage-table-design-IMAGE16.png
[17]: ./media/storage-table-design-guide/storage-table-design-IMAGE17.png
[18]: ./media/storage-table-design-guide/storage-table-design-IMAGE18.png
[19]: ./media/storage-table-design-guide/storage-table-design-IMAGE19.png
[20]: ./media/storage-table-design-guide/storage-table-design-IMAGE20.png
[21]: ./media/storage-table-design-guide/storage-table-design-IMAGE21.png
[22]: ./media/storage-table-design-guide/storage-table-design-IMAGE22.png
[23]: ./media/storage-table-design-guide/storage-table-design-IMAGE23.png
[24]: ./media/storage-table-design-guide/storage-table-design-IMAGE24.png
[25]: ./media/storage-table-design-guide/storage-table-design-IMAGE25.png
[26]: ./media/storage-table-design-guide/storage-table-design-IMAGE26.png
[27]: ./media/storage-table-design-guide/storage-table-design-IMAGE27.png
[28]: ./media/storage-table-design-guide/storage-table-design-IMAGE28.png
[29]: ./media/storage-table-design-guide/storage-table-design-IMAGE29.png

