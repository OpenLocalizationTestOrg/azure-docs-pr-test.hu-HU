---
title: "A párhuzamosság kezelése a Microsoft Azure Storage szolgáltatásban"
description: "A Blob, a várólista, a tábla és a fájl szolgáltatások egyidejűségi kezelése"
services: storage
documentationcenter: 
author: jasontang501
manager: tadb
editor: tysonn
ms.assetid: cc6429c4-23ee-46e3-b22d-50dd68bd4680
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: dotnet
ms.topic: article
ms.date: 05/11/2017
ms.author: jasontang501
ms.openlocfilehash: 8b894af2f15cd22f04701c545d8250e20b99a094
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 07/11/2017
---
# <a name="managing-concurrency-in-microsoft-azure-storage"></a><span data-ttu-id="14aa8-103">A párhuzamosság kezelése a Microsoft Azure Storage szolgáltatásban</span><span class="sxs-lookup"><span data-stu-id="14aa8-103">Managing Concurrency in Microsoft Azure Storage</span></span>
## <a name="overview"></a><span data-ttu-id="14aa8-104">Áttekintés</span><span class="sxs-lookup"><span data-stu-id="14aa8-104">Overview</span></span>
<span data-ttu-id="14aa8-105">Internet alapú modern alkalmazások megtekintéséhez és adatok frissítése egyszerre több felhasználó általában rendelkeznek.</span><span class="sxs-lookup"><span data-stu-id="14aa8-105">Modern Internet based applications usually have multiple users viewing and updating data simultaneously.</span></span> <span data-ttu-id="14aa8-106">Ehhez az alkalmazásfejlesztők számára alaposan gondolja át hogyan előre jelezhető környezetet biztosítson a végfelhasználóknak, különösen a forgatókönyvekben, ahol több felhasználó frissítheti ugyanazokat az adatokat.</span><span class="sxs-lookup"><span data-stu-id="14aa8-106">This requires application developers to think carefully about how to provide a predictable experience to their end users, particularly for scenarios where multiple users can update the same data.</span></span> <span data-ttu-id="14aa8-107">Számos három fő adatok feldolgozási stratégiák fejlesztők általában figyelembe veszi.</span><span class="sxs-lookup"><span data-stu-id="14aa8-107">There are three main data concurrency strategies developers will typically consider:</span></span>  

1. <span data-ttu-id="14aa8-108">Egyidejű hozzáférések optimista – utolsó egy kérelem végrehajtása egy frissítést a frissítés részeként ellenőrzi, hogy ha az adatok alkalmazása óta megváltozott olvasható adatok.</span><span class="sxs-lookup"><span data-stu-id="14aa8-108">Optimistic concurrency – An application performing an update will as part of its update verify if the data has changed since the application last read that data.</span></span> <span data-ttu-id="14aa8-109">Például ha két wiki lap megtekintésével tehetjük a frissítés ugyanazon az oldalon majd a wiki platform ellenőriznie kell, hogy a második frissítés nem ír felül az első frissítés –, és hogy mindkét tisztában legyenek azzal, hogy a frissítés sikeres volt-e vagy sem.</span><span class="sxs-lookup"><span data-stu-id="14aa8-109">For example, if two users viewing a wiki page make an update to the same page then the wiki platform must ensure that the second update does not overwrite the first update – and that both users understand whether their update was successful or not.</span></span> <span data-ttu-id="14aa8-110">Ezt a stratégiát leggyakrabban a webes alkalmazásokhoz.</span><span class="sxs-lookup"><span data-stu-id="14aa8-110">This strategy is most often used in web applications.</span></span>
2. <span data-ttu-id="14aa8-111">Pesszimista feldolgozási – az alkalmazás keresése frissítésének lépnek a zárolási más felhasználók megakadályozza az adatok frissítése, amíg a zárolás objektum.</span><span class="sxs-lookup"><span data-stu-id="14aa8-111">Pessimistic concurrency – An application looking to perform an update will take a lock on an object preventing other users from updating the data until the lock is released.</span></span> <span data-ttu-id="14aa8-112">Például, ahol csak a fő frissítések végrehajtása fő/alárendelt adatok replikáció esetén a fő általában tárolására kizárólagos zárolást ideje, annak érdekében, hogy senki más nem frissítheti az adatokat hosszú időn keresztül.</span><span class="sxs-lookup"><span data-stu-id="14aa8-112">For example, in a master/slave data replication scenario where only the master will perform updates the master will typically hold an exclusive lock for an extended period of time on the data to ensure no one else can update it.</span></span>
3. <span data-ttu-id="14aa8-113">Utolsó író wins –, amely lehetővé teszi a frissítési műveleteket ellenőrzése, ha egyetlen más alkalmazáshoz sem az adatok óta frissített az alkalmazás első nélkül folytatja megközelítés beolvasni az adatokat.</span><span class="sxs-lookup"><span data-stu-id="14aa8-113">Last writer wins – An approach that allows any update operations to proceed without verifying if any other application has updated the data since the application first read the data.</span></span> <span data-ttu-id="14aa8-114">A stratégia (vagy egy hivatalos stratégia hiánya) általában használt ahol adatok particionálása úgy, hogy van-e nem valószínű, hogy több felhasználó érik el a ugyanazokat az adatokat.</span><span class="sxs-lookup"><span data-stu-id="14aa8-114">This strategy (or lack of a formal strategy) is usually used where data is partitioned in such a way that there is no likelihood that multiple users will access the same data.</span></span> <span data-ttu-id="14aa8-115">Lehet hasznos, ahol rövid élettartamú adatfolyamokat feldolgozott.</span><span class="sxs-lookup"><span data-stu-id="14aa8-115">It can also be useful where short-lived data streams are being processed.</span></span>  

<span data-ttu-id="14aa8-116">Ez a cikk áttekintést hogyan az Azure Storage platform egyszerűbbé teszi a fejlesztés első osztályú támogatást biztosít a ezek párhuzamossági stratégiák három.</span><span class="sxs-lookup"><span data-stu-id="14aa8-116">This article provides an overview of how the Azure Storage platform simplifies development by providing first class support for all three of these concurrency strategies.</span></span>  

## <a name="azure-storage--simplifies-cloud-development"></a><span data-ttu-id="14aa8-117">Az Azure Storage – egyszerűbbé teszi a felhőalapú fejlesztési</span><span class="sxs-lookup"><span data-stu-id="14aa8-117">Azure Storage – Simplifies Cloud Development</span></span>
<span data-ttu-id="14aa8-118">Az az Azure storage szolgáltatás összes három stratégiák, támogatja a teljes körű támogatást nyújt az optimista és pesszimista feldolgozási, mert azt úgy lett kialakítva, amely biztosítja, hogy ha az erős konzisztencia-modellt támogató képessége megkülönböztető azonban a Adatok insert társzolgáltatás megmutatják a véglegesítések számát, vagy frissítési művelet az összes további fér hozzá az, hogy adatokat megjelenik-e a legújabb frissítést.</span><span class="sxs-lookup"><span data-stu-id="14aa8-118">The Azure storage service supports all three strategies, although it is distinctive in its ability to provide full support for optimistic and pessimistic concurrency because it was designed to embrace a strong consistency model which guarantees that when the Storage service commits a data insert or update operation all further accesses to that data will see the latest update.</span></span> <span data-ttu-id="14aa8-119">A végleges konzisztencia modellt használó tárolási platformok közötti késés lehet, ha egy írási történik, egy felhasználó, és így megfelel a az inkonzisztenciák elkerülése ügyfélalkalmazások fejlesztéséhez más felhasználók által látható a frissített adatokat befolyásolja a végfelhasználók számára.</span><span class="sxs-lookup"><span data-stu-id="14aa8-119">Storage platforms that use an eventual consistency model have a lag between when a write is performed by one user and when the updated data can be seen by other users thus complicating development of client applications in order to prevent inconsistencies from affecting end users.</span></span>  

<span data-ttu-id="14aa8-120">Egy megfelelő feldolgozási stratégia mellett fejlesztők is kell ügyelnie, hogyan egy tárolási platform elkülöníti módosításai – különösen az objektumon keresztül tranzakciók.</span><span class="sxs-lookup"><span data-stu-id="14aa8-120">In addition to selecting an appropriate concurrency strategy developers should also be aware of how a storage platform isolates changes – particularly changes to the same object across transactions.</span></span> <span data-ttu-id="14aa8-121">Az Azure storage szolgáltatás pillanatkép-elkülönítés használatával megtörténjen-e írási műveletek belül egyetlen partícióra egyidejűleg az olvasási műveletek engedélyezése.</span><span class="sxs-lookup"><span data-stu-id="14aa8-121">The Azure storage service uses snapshot isolation to allow read operations to happen concurrently with write operations within a single partition.</span></span> <span data-ttu-id="14aa8-122">Más elkülönítési szinten eltérően pillanatkép-elkülönítés biztosítja, hogy az, hogy minden olvasási tekintse meg az adatok alkalmazáskonzisztens pillanatfelvételi frissítések is megjelenhetnek – tulajdonképpen által egy frissítés során az utolsó véglegesített értékeket ad vissza tranzakció feldolgozása közben is.</span><span class="sxs-lookup"><span data-stu-id="14aa8-122">Unlike other isolation levels, snapshot isolation guarantees that all reads see a consistent snapshot of the data even while updates are occurring – essentially by returning the last committed values while an update transaction is being processed.</span></span>  

## <a name="managing-concurrency-in-blob-storage"></a><span data-ttu-id="14aa8-123">A Blob Storage tárolóban párhuzamossági kezelése</span><span class="sxs-lookup"><span data-stu-id="14aa8-123">Managing Concurrency in Blob storage</span></span>
<span data-ttu-id="14aa8-124">Dönthet úgy is, blobok és a tárolók a blob szolgáltatás hozzáférésének kezelése vagy optimista vagy pesszimista feldolgozási modellek segítségével.</span><span class="sxs-lookup"><span data-stu-id="14aa8-124">You can opt to use either optimistic or pessimistic concurrency models to manage access to blobs and containers in the blob service.</span></span> <span data-ttu-id="14aa8-125">Ha explicit módon stratégia utolsó írás wins meg az alapértelmezett beállítás.</span><span class="sxs-lookup"><span data-stu-id="14aa8-125">If you do not explicitly specify a strategy last writes wins is the default.</span></span>  

### <a name="optimistic-concurrency-for-blobs-and-containers"></a><span data-ttu-id="14aa8-126">A bináris objektumok és tárolók egyidejű hozzáférések optimista</span><span class="sxs-lookup"><span data-stu-id="14aa8-126">Optimistic concurrency for blobs and containers</span></span>
<span data-ttu-id="14aa8-127">A társzolgáltatás azonosítót rendel hozzá minden tárolt objektum.</span><span class="sxs-lookup"><span data-stu-id="14aa8-127">The Storage service assigns an identifier to every object stored.</span></span> <span data-ttu-id="14aa8-128">Ez az azonosító minden alkalommal, amikor a frissítési művelet történik egy objektum frissül.</span><span class="sxs-lookup"><span data-stu-id="14aa8-128">This identifier is updated every time an update operation is performed on an object.</span></span> <span data-ttu-id="14aa8-129">Az azonosító az ETag (entitáscímke) fejlécet, amely a HTTP protokoll van meghatározva egy HTTP GET választ részeként az ügyfél küld vissza.</span><span class="sxs-lookup"><span data-stu-id="14aa8-129">The identifier is returned to the client as part of an HTTP GET response using the ETag (entity tag) header that is defined within the HTTP protocol.</span></span> <span data-ttu-id="14aa8-130">A felhasználó egy olyan objektumon frissítésében elküldheti az eredeti ETag feltételes fejlécet együtt annak érdekében, hogy egy frissítés akkor történik, ha egy bizonyos feltétel teljesül – ebben az esetben az feltétele egy "If-Match" fejlécet, amely a tárolási szolgáltatásának kell  Győződjön meg arról, a frissítés kérelemben megadott ETag értéke ugyanaz, mint amellyel a Társzolgáltatás tárolja.</span><span class="sxs-lookup"><span data-stu-id="14aa8-130">A user performing an update on such an object can send in the original ETag along with a conditional header to ensure that an update will only occur if a certain condition has been met – in this case the condition is an "If-Match" header which requires the Storage Service to ensure the value of the ETag specified in the update request is the same as that stored in the Storage Service.</span></span>  

<span data-ttu-id="14aa8-131">A folyamat során vázlatot a következőképpen történik:</span><span class="sxs-lookup"><span data-stu-id="14aa8-131">The outline of this process is as follows:</span></span>  

1. <span data-ttu-id="14aa8-132">A blob lekérése a társzolgáltatás, a válasz egy HTTP ETag Fejlécérték, amely azonosítja a társzolgáltatás objektum aktuális verziója tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="14aa8-132">Retrieve a blob from the storage service, the response includes an HTTP ETag Header value that identifies the current version of the object in the storage service.</span></span>
2. <span data-ttu-id="14aa8-133">A blob frissíti, az 1. lépésben kapott ETag érték adja meg a **If-Match** küldött a szolgáltatás a kérelem feltételes fejlécet.</span><span class="sxs-lookup"><span data-stu-id="14aa8-133">When you update the blob, include the ETag value you received in step 1 in the **If-Match** conditional header of the request you send to the service.</span></span>
3. <span data-ttu-id="14aa8-134">A szolgáltatás összehasonlítja a blob jelenlegi ETag-értékével a kérés a ETag értéket.</span><span class="sxs-lookup"><span data-stu-id="14aa8-134">The service compares the ETag value in the request with the current ETag value of the blob.</span></span>
4. <span data-ttu-id="14aa8-135">Ha az aktuális ETag érték a BLOB egy eltérő verziójú, mint az ETag a **If-Match** feltételes fejlécet a kérelem, a szolgáltatás egy 412 hibát ad vissza az ügyfélnek.</span><span class="sxs-lookup"><span data-stu-id="14aa8-135">If the current ETag value of the blob is a different version than the ETag in the **If-Match** conditional header in the request, the service returns a 412 error to the client.</span></span> <span data-ttu-id="14aa8-136">Ez azt jelzi, az ügyfél számára, hogy egy másik folyamat frissítette a blob, mivel az ügyfél azt lekérése.</span><span class="sxs-lookup"><span data-stu-id="14aa8-136">This indicates to the client that another process has updated the blob since the client retrieved it.</span></span>
5. <span data-ttu-id="14aa8-137">Ha az aktuális ETag érték a BLOB szereplő ETag címkével verziójával megegyező verzióra a **If-Match** feltételes fejlécet a kérelem, a szolgáltatás végzi a kért műveletet, és frissíti a blob megjelenítése, hogy hozott létre a jelenlegi ETag érték egy új verziója.</span><span class="sxs-lookup"><span data-stu-id="14aa8-137">If the current ETag value of the blob is the same version as the ETag in the **If-Match** conditional header in the request, the service performs the requested operation and updates the current ETag value of the blob to show that it has created a new version.</span></span>  

<span data-ttu-id="14aa8-138">Az alábbi C# kódrészletet (Storage Ügyfélkódtár 4.2.0 használatával) mutatja egy egyszerű példa bemutatja, hogyan hozható létre egy **If-Match AccessCondition** az ETag érték, amelyhez a korábban vagy blob tulajdonságai alapján le, vagy szúrja be.</span><span class="sxs-lookup"><span data-stu-id="14aa8-138">The following C# snippet (using the Client Storage Library 4.2.0) shows a simple example of how to construct an **If-Match AccessCondition** based on the ETag value that is accessed from the properties of a blob that was previously either retrieved or inserted.</span></span> <span data-ttu-id="14aa8-139">Ezután a **AccessCondition** objektum amikor azt a blob frissítése: a **AccessCondition** objektumot ad hozzá a **If-Match** fejléc kérésre.</span><span class="sxs-lookup"><span data-stu-id="14aa8-139">It then uses the **AccessCondition** object when it updating the blob: the **AccessCondition** object adds the **If-Match** header to the request.</span></span> <span data-ttu-id="14aa8-140">Ha egy másik folyamat frissítette a blob, a blob szolgáltatás egy HTTP 412 (előfeltétel nem teljesült) állapotüzenetet adja vissza.</span><span class="sxs-lookup"><span data-stu-id="14aa8-140">If another process has updated the blob, the blob service returns an HTTP 412 (Precondition Failed) status message.</span></span> <span data-ttu-id="14aa8-141">Letöltheti a teljes mintát itt: [kezelése egyidejű használata az Azure Storage](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span><span class="sxs-lookup"><span data-stu-id="14aa8-141">You can download the full sample here: [Managing Concurrency using Azure Storage](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span></span>  

```csharp
// Retrieve the ETag from the newly created blob
// Etag is already populated as UploadText should cause a PUT Blob call
// to storage blob service which returns the etag in response.
string orignalETag = blockBlob.Properties.ETag;

// This code simulates an update by a third party.
string helloText = "Blob updated by a third party.";

// No etag, provided so orignal blob is overwritten (thus generating a new etag)
blockBlob.UploadText(helloText);
Console.WriteLine("Blob updated. Updated ETag = {0}",
blockBlob.Properties.ETag);

// Now try to update the blob using the orignal ETag provided when the blob was created
try
{
    Console.WriteLine("Trying to update blob using orignal etag to generate if-match access condition");
    blockBlob.UploadText(helloText,accessCondition:
    AccessCondition.GenerateIfMatchCondition(orignalETag));
}
catch (StorageException ex)
{
    if (ex.RequestInformation.HttpStatusCode == (int)HttpStatusCode.PreconditionFailed)
    {
        Console.WriteLine("Precondition failure as expected. Blob's orignal etag no longer matches");
        // TODO: client can decide on how it wants to handle the 3rd party updated content.
    }
    else
        throw;
}  
```

<span data-ttu-id="14aa8-142">A tároló szolgáltatást is támogatja a további feltételes fejlécek például **If-Modified-Since**, **If-Unmodified-Since** és **If-None-Match** , valamint ezek kombinációi.</span><span class="sxs-lookup"><span data-stu-id="14aa8-142">The Storage Service also includes support for additional conditional headers such as **If-Modified-Since**, **If-Unmodified-Since** and **If-None-Match** as well as combinations thereof.</span></span> <span data-ttu-id="14aa8-143">További információ: [megadó feltételes fejlécek Blob szolgáltatási műveletek](http://msdn.microsoft.com/library/azure/dd179371.aspx) az MSDN Webhelyén.</span><span class="sxs-lookup"><span data-stu-id="14aa8-143">For more information see [Specifying Conditional Headers for Blob Service Operations](http://msdn.microsoft.com/library/azure/dd179371.aspx) on MSDN.</span></span>  

<span data-ttu-id="14aa8-144">A következő táblázat összefoglalja a tároló műveletek, például a feltételes fejlécek elfogadó **If-Match** , valamint a kérelmet a válaszban szereplő ETag értéket adnak vissza.</span><span class="sxs-lookup"><span data-stu-id="14aa8-144">The following table summarizes the container operations that accept conditional headers such as **If-Match** in the request and that return an ETag value in the response.</span></span>  

| <span data-ttu-id="14aa8-145">Művelet</span><span class="sxs-lookup"><span data-stu-id="14aa8-145">Operation</span></span> | <span data-ttu-id="14aa8-146">Tároló ETag értékét adja vissza</span><span class="sxs-lookup"><span data-stu-id="14aa8-146">Returns Container ETag value</span></span> | <span data-ttu-id="14aa8-147">Feltételes fejlécek fogad el</span><span class="sxs-lookup"><span data-stu-id="14aa8-147">Accepts conditional headers</span></span> |
|:--- |:--- |:--- |
| <span data-ttu-id="14aa8-148">Tároló létrehozása</span><span class="sxs-lookup"><span data-stu-id="14aa8-148">Create Container</span></span> |<span data-ttu-id="14aa8-149">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-149">Yes</span></span> |<span data-ttu-id="14aa8-150">Nem</span><span class="sxs-lookup"><span data-stu-id="14aa8-150">No</span></span> |
| <span data-ttu-id="14aa8-151">A tároló tulajdonságainak beolvasása</span><span class="sxs-lookup"><span data-stu-id="14aa8-151">Get Container Properties</span></span> |<span data-ttu-id="14aa8-152">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-152">Yes</span></span> |<span data-ttu-id="14aa8-153">Nem</span><span class="sxs-lookup"><span data-stu-id="14aa8-153">No</span></span> |
| <span data-ttu-id="14aa8-154">Tároló metaadatot beszerezni</span><span class="sxs-lookup"><span data-stu-id="14aa8-154">Get Container Metadata</span></span> |<span data-ttu-id="14aa8-155">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-155">Yes</span></span> |<span data-ttu-id="14aa8-156">Nem</span><span class="sxs-lookup"><span data-stu-id="14aa8-156">No</span></span> |
| <span data-ttu-id="14aa8-157">Állítsa be a Csomagtároló metaadatai</span><span class="sxs-lookup"><span data-stu-id="14aa8-157">Set Container Metadata</span></span> |<span data-ttu-id="14aa8-158">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-158">Yes</span></span> |<span data-ttu-id="14aa8-159">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-159">Yes</span></span> |
| <span data-ttu-id="14aa8-160">Tároló hozzáférés-vezérlési lista beolvasása</span><span class="sxs-lookup"><span data-stu-id="14aa8-160">Get Container ACL</span></span> |<span data-ttu-id="14aa8-161">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-161">Yes</span></span> |<span data-ttu-id="14aa8-162">Nem</span><span class="sxs-lookup"><span data-stu-id="14aa8-162">No</span></span> |
| <span data-ttu-id="14aa8-163">Tároló hozzáférés-vezérlési lista beállítása</span><span class="sxs-lookup"><span data-stu-id="14aa8-163">Set Container ACL</span></span> |<span data-ttu-id="14aa8-164">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-164">Yes</span></span> |<span data-ttu-id="14aa8-165">Igen (*)</span><span class="sxs-lookup"><span data-stu-id="14aa8-165">Yes (*)</span></span> |
| <span data-ttu-id="14aa8-166">Törli a tárolót</span><span class="sxs-lookup"><span data-stu-id="14aa8-166">Delete Container</span></span> |<span data-ttu-id="14aa8-167">Nem</span><span class="sxs-lookup"><span data-stu-id="14aa8-167">No</span></span> |<span data-ttu-id="14aa8-168">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-168">Yes</span></span> |
| <span data-ttu-id="14aa8-169">Címbérlet tároló</span><span class="sxs-lookup"><span data-stu-id="14aa8-169">Lease Container</span></span> |<span data-ttu-id="14aa8-170">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-170">Yes</span></span> |<span data-ttu-id="14aa8-171">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-171">Yes</span></span> |
| <span data-ttu-id="14aa8-172">Lista Blobok</span><span class="sxs-lookup"><span data-stu-id="14aa8-172">List Blobs</span></span> |<span data-ttu-id="14aa8-173">Nem</span><span class="sxs-lookup"><span data-stu-id="14aa8-173">No</span></span> |<span data-ttu-id="14aa8-174">Nem</span><span class="sxs-lookup"><span data-stu-id="14aa8-174">No</span></span> |

<span data-ttu-id="14aa8-175">(*) A SetContainerACL által meghatározott engedélyekkel gyorsítótárba kerüljenek-e, és ezeket az engedélyeket a frissítések érvénybe propagálására, 30 másodperces, mely időszakban frissítések nem garantált, hogy konzisztens.</span><span class="sxs-lookup"><span data-stu-id="14aa8-175">(*) The permissions defined by SetContainerACL are cached and updates to these permissions take 30 seconds to propagate during which period updates are not guaranteed to be consistent.</span></span>  

<span data-ttu-id="14aa8-176">A következő táblázat összefoglalja a blob műveletek, például a feltételes fejlécek elfogadó **If-Match** , valamint a kérelmet a válaszban szereplő ETag értéket adnak vissza.</span><span class="sxs-lookup"><span data-stu-id="14aa8-176">The following table summarizes the blob operations that accept conditional headers such as **If-Match** in the request and that return an ETag value in the response.</span></span>

| <span data-ttu-id="14aa8-177">Művelet</span><span class="sxs-lookup"><span data-stu-id="14aa8-177">Operation</span></span> | <span data-ttu-id="14aa8-178">ETag értéket ad vissza</span><span class="sxs-lookup"><span data-stu-id="14aa8-178">Returns ETag value</span></span> | <span data-ttu-id="14aa8-179">Feltételes fejlécek fogad el</span><span class="sxs-lookup"><span data-stu-id="14aa8-179">Accepts conditional headers</span></span> |
|:--- |:--- |:--- |
| <span data-ttu-id="14aa8-180">Helyezze a Blob</span><span class="sxs-lookup"><span data-stu-id="14aa8-180">Put Blob</span></span> |<span data-ttu-id="14aa8-181">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-181">Yes</span></span> |<span data-ttu-id="14aa8-182">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-182">Yes</span></span> |
| <span data-ttu-id="14aa8-183">A Blob beolvasása</span><span class="sxs-lookup"><span data-stu-id="14aa8-183">Get Blob</span></span> |<span data-ttu-id="14aa8-184">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-184">Yes</span></span> |<span data-ttu-id="14aa8-185">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-185">Yes</span></span> |
| <span data-ttu-id="14aa8-186">A Blob tulajdonságainak beolvasása</span><span class="sxs-lookup"><span data-stu-id="14aa8-186">Get Blob Properties</span></span> |<span data-ttu-id="14aa8-187">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-187">Yes</span></span> |<span data-ttu-id="14aa8-188">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-188">Yes</span></span> |
| <span data-ttu-id="14aa8-189">A Blob tulajdonságainak beállítása</span><span class="sxs-lookup"><span data-stu-id="14aa8-189">Set Blob Properties</span></span> |<span data-ttu-id="14aa8-190">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-190">Yes</span></span> |<span data-ttu-id="14aa8-191">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-191">Yes</span></span> |
| <span data-ttu-id="14aa8-192">A Blob metaadatot beszerezni</span><span class="sxs-lookup"><span data-stu-id="14aa8-192">Get Blob Metadata</span></span> |<span data-ttu-id="14aa8-193">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-193">Yes</span></span> |<span data-ttu-id="14aa8-194">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-194">Yes</span></span> |
| <span data-ttu-id="14aa8-195">Állítsa be a Blob metaadatai</span><span class="sxs-lookup"><span data-stu-id="14aa8-195">Set Blob Metadata</span></span> |<span data-ttu-id="14aa8-196">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-196">Yes</span></span> |<span data-ttu-id="14aa8-197">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-197">Yes</span></span> |
| <span data-ttu-id="14aa8-198">Címbérlet Blob (*)</span><span class="sxs-lookup"><span data-stu-id="14aa8-198">Lease Blob (*)</span></span> |<span data-ttu-id="14aa8-199">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-199">Yes</span></span> |<span data-ttu-id="14aa8-200">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-200">Yes</span></span> |
| <span data-ttu-id="14aa8-201">Pillanatkép Blob</span><span class="sxs-lookup"><span data-stu-id="14aa8-201">Snapshot Blob</span></span> |<span data-ttu-id="14aa8-202">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-202">Yes</span></span> |<span data-ttu-id="14aa8-203">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-203">Yes</span></span> |
| <span data-ttu-id="14aa8-204">A Blob másolása</span><span class="sxs-lookup"><span data-stu-id="14aa8-204">Copy Blob</span></span> |<span data-ttu-id="14aa8-205">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-205">Yes</span></span> |<span data-ttu-id="14aa8-206">Igen (a forrás és cél blob)</span><span class="sxs-lookup"><span data-stu-id="14aa8-206">Yes (for source and destination blob)</span></span> |
| <span data-ttu-id="14aa8-207">A Blob másolási megszakítása</span><span class="sxs-lookup"><span data-stu-id="14aa8-207">Abort Copy Blob</span></span> |<span data-ttu-id="14aa8-208">Nem</span><span class="sxs-lookup"><span data-stu-id="14aa8-208">No</span></span> |<span data-ttu-id="14aa8-209">Nem</span><span class="sxs-lookup"><span data-stu-id="14aa8-209">No</span></span> |
| <span data-ttu-id="14aa8-210">A Blob törlése</span><span class="sxs-lookup"><span data-stu-id="14aa8-210">Delete Blob</span></span> |<span data-ttu-id="14aa8-211">Nem</span><span class="sxs-lookup"><span data-stu-id="14aa8-211">No</span></span> |<span data-ttu-id="14aa8-212">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-212">Yes</span></span> |
| <span data-ttu-id="14aa8-213">PUT letiltása</span><span class="sxs-lookup"><span data-stu-id="14aa8-213">Put Block</span></span> |<span data-ttu-id="14aa8-214">Nem</span><span class="sxs-lookup"><span data-stu-id="14aa8-214">No</span></span> |<span data-ttu-id="14aa8-215">Nem</span><span class="sxs-lookup"><span data-stu-id="14aa8-215">No</span></span> |
| <span data-ttu-id="14aa8-216">PUT tiltólista</span><span class="sxs-lookup"><span data-stu-id="14aa8-216">Put Block List</span></span> |<span data-ttu-id="14aa8-217">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-217">Yes</span></span> |<span data-ttu-id="14aa8-218">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-218">Yes</span></span> |
| <span data-ttu-id="14aa8-219">Tiltólista beolvasása</span><span class="sxs-lookup"><span data-stu-id="14aa8-219">Get Block List</span></span> |<span data-ttu-id="14aa8-220">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-220">Yes</span></span> |<span data-ttu-id="14aa8-221">Nem</span><span class="sxs-lookup"><span data-stu-id="14aa8-221">No</span></span> |
| <span data-ttu-id="14aa8-222">Helyezze a lap</span><span class="sxs-lookup"><span data-stu-id="14aa8-222">Put Page</span></span> |<span data-ttu-id="14aa8-223">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-223">Yes</span></span> |<span data-ttu-id="14aa8-224">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-224">Yes</span></span> |
| <span data-ttu-id="14aa8-225">Get tartományokat</span><span class="sxs-lookup"><span data-stu-id="14aa8-225">Get Page Ranges</span></span> |<span data-ttu-id="14aa8-226">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-226">Yes</span></span> |<span data-ttu-id="14aa8-227">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-227">Yes</span></span> |

<span data-ttu-id="14aa8-228">(*) Címbérlet Blob nem módosítja a blob ETag.</span><span class="sxs-lookup"><span data-stu-id="14aa8-228">(*) Lease Blob does not change the ETag on a blob.</span></span>  

### <a name="pessimistic-concurrency-for-blobs"></a><span data-ttu-id="14aa8-229">A blobok pesszimista feldolgozási</span><span class="sxs-lookup"><span data-stu-id="14aa8-229">Pessimistic concurrency for blobs</span></span>
<span data-ttu-id="14aa8-230">Kizárólagos használatra blob zárolásához, szerezzen be egy [bérleti](http://msdn.microsoft.com/library/azure/ee691972.aspx) rajta.</span><span class="sxs-lookup"><span data-stu-id="14aa8-230">To lock a blob for exclusive use, you can acquire a [lease](http://msdn.microsoft.com/library/azure/ee691972.aspx) on it.</span></span> <span data-ttu-id="14aa8-231">Amikor bérletet szerezni, megadhatja, hogy mennyi ideig kell a címbérlet: Ez lehet a 15-60 másodperc között vagy végtelen amely kizárólagos zárolást összege.</span><span class="sxs-lookup"><span data-stu-id="14aa8-231">When you acquire a lease, you specify for how long you need the lease: this can be for between 15 to 60 seconds or infinite which amounts to an exclusive lock.</span></span> <span data-ttu-id="14aa8-232">A kiterjesztéshez véges címbérlet megújítása is, és semmilyen címbérlet is megjelenhetnek, amikor elkészült, azt.</span><span class="sxs-lookup"><span data-stu-id="14aa8-232">You can renew a finite lease to extend it, and you can release any lease when you are finished with it.</span></span> <span data-ttu-id="14aa8-233">A blob szolgáltatás véges címbérleteket automatikusan feloldja a lejárat után.</span><span class="sxs-lookup"><span data-stu-id="14aa8-233">The blob service automatically releases finite leases when they expire.</span></span>  

<span data-ttu-id="14aa8-234">Címbérleteket engedélyezése különböző szinkronizálási stratégiák támogatja, beleértve a kizárólagos írási / olvasási, kizárólagos írási megosztott / kizárólagos olvasási és írási megosztott / kizárólagos olvasása.</span><span class="sxs-lookup"><span data-stu-id="14aa8-234">Leases enable different synchronization strategies to be supported, including exclusive write / shared read, exclusive write / exclusive read and shared write / exclusive read.</span></span> <span data-ttu-id="14aa8-235">Ahol a címbérlet létezik a tároló szolgáltatás érvényesíti kizárólagos írási (put, állítsa be és törlési műveletek) azonban biztosítása kizárólagosság az olvasási műveletek igényel a fejlesztő, hogy minden ügyfélalkalmazások használja a címbérlet-Azonosítót, és egyszerre csak egy ügyfél van egy érvényes bérleti azonosítóját.</span><span class="sxs-lookup"><span data-stu-id="14aa8-235">Where a lease exists the storage service enforces exclusive writes (put, set and delete operations) however ensuring exclusivity for read operations requires the developer to ensure that all client applications use a lease ID and that only one client at a time has a valid lease ID.</span></span> <span data-ttu-id="14aa8-236">Olvassa el, amelyek nem tartalmazzák a címbérlet azonosító eredményt megosztott olvasási műveletek.</span><span class="sxs-lookup"><span data-stu-id="14aa8-236">Read operations that do not include a lease ID result in shared reads.</span></span>  

<span data-ttu-id="14aa8-237">Az alábbi C# kódrészletet az beszerzése egy kizárólagos bérleti 30 másodpercig a blob, a blob tartalmát frissítése, és majd felszabadítása a címbérlet példáját mutatja be.</span><span class="sxs-lookup"><span data-stu-id="14aa8-237">The following C# snippet shows an example of acquiring an exclusive lease for 30 seconds on a blob, updating the content of the blob, and then releasing the lease.</span></span> <span data-ttu-id="14aa8-238">Ha már létezik egy érvényes bérleti blobot meg egy új bérleti jogot szerezni, a blob szolgáltatás eredményt adja vissza, az "HTTP (409) ütközés" állapot.</span><span class="sxs-lookup"><span data-stu-id="14aa8-238">If there is already a valid lease on the blob when you try to acquire a new lease, the blob service returns an "HTTP (409) Conflict" status result.</span></span> <span data-ttu-id="14aa8-239">A által használt alábbi részlet egy **AccessCondition** foglalják magukban a címbérleti információkat, amikor egy kérést a blob storage szolgáltatási frissíteni az objektumot.</span><span class="sxs-lookup"><span data-stu-id="14aa8-239">The snippet below uses an **AccessCondition** object to encapsulate the lease information when it makes a request to update the blob in the storage service.</span></span>  <span data-ttu-id="14aa8-240">Letöltheti a teljes mintát itt: [kezelése egyidejű használata az Azure Storage](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span><span class="sxs-lookup"><span data-stu-id="14aa8-240">You can download the full sample here: [Managing Concurrency using Azure Storage](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span></span>

```csharp
// Acquire lease for 15 seconds
string lease = blockBlob.AcquireLease(TimeSpan.FromSeconds(15), null);
Console.WriteLine("Blob lease acquired. Lease = {0}", lease);

// Update blob using lease. This operation will succeed
const string helloText = "Blob updated";
var accessCondition = AccessCondition.GenerateLeaseCondition(lease);
blockBlob.UploadText(helloText, accessCondition: accessCondition);
Console.WriteLine("Blob updated using an exclusive lease");

//Simulate third party update to blob without lease
try
{
    // Below operation will fail as no valid lease provided
    Console.WriteLine("Trying to update blob without valid lease");
    blockBlob.UploadText("Update without lease, will fail");
}
catch (StorageException ex)
{
    if (ex.RequestInformation.HttpStatusCode == (int)HttpStatusCode.PreconditionFailed)
        Console.WriteLine("Precondition failure as expected. Blob's lease does not match");
    else
        throw;
}  
```

<span data-ttu-id="14aa8-241">Bérelt blob egy írási művelet a címbérlet azonosító továbbításához nélkül kísérli meg, ha a kérelem egy 412 hibaüzenettel meghiúsul.</span><span class="sxs-lookup"><span data-stu-id="14aa8-241">If you attempt a write operation on a leased blob without passing the lease ID, the request fails with a 412 error.</span></span> <span data-ttu-id="14aa8-242">Ha a bérlete lejár hívása előtt vegye figyelembe, hogy a **UploadText** metódust, de továbbra is át a címbérlet-azonosító, a kérelem is sikertelen, és egy **412** hiba.</span><span class="sxs-lookup"><span data-stu-id="14aa8-242">Note that if the lease expires before calling the **UploadText** method but you still pass the lease ID, the request also fails with a **412** error.</span></span> <span data-ttu-id="14aa8-243">Címbérlet lejárati idejét és a címbérlet azonosítók kezelésével kapcsolatos további információkért lásd: a [bérleti Blob](http://msdn.microsoft.com/library/azure/ee691972.aspx) REST dokumentációját.</span><span class="sxs-lookup"><span data-stu-id="14aa8-243">For more information about managing lease expiry times and lease ids, see the [Lease Blob](http://msdn.microsoft.com/library/azure/ee691972.aspx) REST documentation.</span></span>  

<span data-ttu-id="14aa8-244">A következő blob műveletek címbérleteket segítségével pesszimista feldolgozási kezelheti:</span><span class="sxs-lookup"><span data-stu-id="14aa8-244">The following blob operations can use leases to manage pessimistic concurrency:</span></span>  

* <span data-ttu-id="14aa8-245">Helyezze a Blob</span><span class="sxs-lookup"><span data-stu-id="14aa8-245">Put Blob</span></span>
* <span data-ttu-id="14aa8-246">A Blob beolvasása</span><span class="sxs-lookup"><span data-stu-id="14aa8-246">Get Blob</span></span>
* <span data-ttu-id="14aa8-247">A Blob tulajdonságainak beolvasása</span><span class="sxs-lookup"><span data-stu-id="14aa8-247">Get Blob Properties</span></span>
* <span data-ttu-id="14aa8-248">A Blob tulajdonságainak beállítása</span><span class="sxs-lookup"><span data-stu-id="14aa8-248">Set Blob Properties</span></span>
* <span data-ttu-id="14aa8-249">A Blob metaadatot beszerezni</span><span class="sxs-lookup"><span data-stu-id="14aa8-249">Get Blob Metadata</span></span>
* <span data-ttu-id="14aa8-250">Állítsa be a Blob metaadatai</span><span class="sxs-lookup"><span data-stu-id="14aa8-250">Set Blob Metadata</span></span>
* <span data-ttu-id="14aa8-251">A Blob törlése</span><span class="sxs-lookup"><span data-stu-id="14aa8-251">Delete Blob</span></span>
* <span data-ttu-id="14aa8-252">PUT letiltása</span><span class="sxs-lookup"><span data-stu-id="14aa8-252">Put Block</span></span>
* <span data-ttu-id="14aa8-253">PUT tiltólista</span><span class="sxs-lookup"><span data-stu-id="14aa8-253">Put Block List</span></span>
* <span data-ttu-id="14aa8-254">Tiltólista beolvasása</span><span class="sxs-lookup"><span data-stu-id="14aa8-254">Get Block List</span></span>
* <span data-ttu-id="14aa8-255">Helyezze a lap</span><span class="sxs-lookup"><span data-stu-id="14aa8-255">Put Page</span></span>
* <span data-ttu-id="14aa8-256">Get tartományokat</span><span class="sxs-lookup"><span data-stu-id="14aa8-256">Get Page Ranges</span></span>
* <span data-ttu-id="14aa8-257">Pillanatkép a Blob - címbérlet azonosítója nem kötelező, ha a címbérlet létezik</span><span class="sxs-lookup"><span data-stu-id="14aa8-257">Snapshot Blob - lease ID optional if a lease exists</span></span>
* <span data-ttu-id="14aa8-258">A Blob - azonosító szükséges, ha a címbérlet megtalálható-e a cél blob bérleti másolása</span><span class="sxs-lookup"><span data-stu-id="14aa8-258">Copy Blob - lease ID required if a lease exists on the destination blob</span></span>
* <span data-ttu-id="14aa8-259">Megszakítási másolási Blob - bérleti azonosító szükséges, ha egy végtelen címbérleti megtalálható-e a cél blob</span><span class="sxs-lookup"><span data-stu-id="14aa8-259">Abort Copy Blob - lease ID required if an infinite lease exists on the destination blob</span></span>
* <span data-ttu-id="14aa8-260">Címbérlet Blob</span><span class="sxs-lookup"><span data-stu-id="14aa8-260">Lease Blob</span></span>  

### <a name="pessimistic-concurrency-for-containers"></a><span data-ttu-id="14aa8-261">A tárolók pesszimista feldolgozási</span><span class="sxs-lookup"><span data-stu-id="14aa8-261">Pessimistic concurrency for containers</span></span>
<span data-ttu-id="14aa8-262">A tárolók címbérleteket engedélyezése blobok a támogatott szinkronizálási ugyanezen stratégiák (kizárólagos írási és olvasási, kizárólagos írási megosztott / kizárólagos olvasási és írási megosztott kizárólagos olvasási /) azonban blobok eltérően a társzolgáltatás csak kikényszeríti kizárólagosság a a törlési műveletek.</span><span class="sxs-lookup"><span data-stu-id="14aa8-262">Leases on containers enable the same synchronization strategies to be supported as on blobs (exclusive write / shared read, exclusive write / exclusive read and shared write / exclusive read) however unlike blobs the storage service only enforces exclusivity on delete operations.</span></span> <span data-ttu-id="14aa8-263">Törli a tárolóhoz egy aktív bérleti jog vonatkozik, egy ügyfél a törlési kérelem aktív bérleti Azonosítójú tartalmaznia kell.</span><span class="sxs-lookup"><span data-stu-id="14aa8-263">To delete a container with an active lease, a client must include the active lease ID with the delete request.</span></span> <span data-ttu-id="14aa8-264">Minden más tároló művelet sikerült bérelt tárolóba többek között a címbérleti azonosító nélkül megosztott ebben az esetben azok a műveletek.</span><span class="sxs-lookup"><span data-stu-id="14aa8-264">All other container operations succeed on a leased container without including the lease ID in which case they are shared operations.</span></span> <span data-ttu-id="14aa8-265">Ha szükség a frissítés (put vagy beállítása) vagy az olvasási műveletek kizárólagosság majd fejlesztők győződjön meg arról az összes ügyfél használni a címbérlet-Azonosítót, és hogy csak egy ügyfél egyszerre rendelkezik-e egy érvényes bérleti.</span><span class="sxs-lookup"><span data-stu-id="14aa8-265">If exclusivity of update (put or set) or read operations is required then developers should ensure all clients use a lease ID and that only one client at a time has a valid lease ID.</span></span>  

<span data-ttu-id="14aa8-266">A következő tároló műveletek címbérleteket segítségével pesszimista feldolgozási kezelheti:</span><span class="sxs-lookup"><span data-stu-id="14aa8-266">The following container operations can use leases to manage pessimistic concurrency:</span></span>  

* <span data-ttu-id="14aa8-267">Törli a tárolót</span><span class="sxs-lookup"><span data-stu-id="14aa8-267">Delete Container</span></span>
* <span data-ttu-id="14aa8-268">A tároló tulajdonságainak beolvasása</span><span class="sxs-lookup"><span data-stu-id="14aa8-268">Get Container Properties</span></span>
* <span data-ttu-id="14aa8-269">Tároló metaadatot beszerezni</span><span class="sxs-lookup"><span data-stu-id="14aa8-269">Get Container Metadata</span></span>
* <span data-ttu-id="14aa8-270">Állítsa be a Csomagtároló metaadatai</span><span class="sxs-lookup"><span data-stu-id="14aa8-270">Set Container Metadata</span></span>
* <span data-ttu-id="14aa8-271">Tároló hozzáférés-vezérlési lista beolvasása</span><span class="sxs-lookup"><span data-stu-id="14aa8-271">Get Container ACL</span></span>
* <span data-ttu-id="14aa8-272">Tároló hozzáférés-vezérlési lista beállítása</span><span class="sxs-lookup"><span data-stu-id="14aa8-272">Set Container ACL</span></span>
* <span data-ttu-id="14aa8-273">Címbérlet tároló</span><span class="sxs-lookup"><span data-stu-id="14aa8-273">Lease Container</span></span>  

<span data-ttu-id="14aa8-274">További információk:</span><span class="sxs-lookup"><span data-stu-id="14aa8-274">For more information see:</span></span>  

* [<span data-ttu-id="14aa8-275">A Blob szolgáltatás műveletek feltételes fejlécek megadása</span><span class="sxs-lookup"><span data-stu-id="14aa8-275">Specifying Conditional Headers for Blob Service Operations</span></span>](http://msdn.microsoft.com/library/azure/dd179371.aspx)
* [<span data-ttu-id="14aa8-276">Címbérlet tároló</span><span class="sxs-lookup"><span data-stu-id="14aa8-276">Lease Container</span></span>](http://msdn.microsoft.com/library/azure/jj159103.aspx)
* [<span data-ttu-id="14aa8-277">Címbérlet Blob</span><span class="sxs-lookup"><span data-stu-id="14aa8-277">Lease Blob </span></span>](http://msdn.microsoft.com/library/azure/ee691972.aspx)

## <a name="managing-concurrency-in-the-table-service"></a><span data-ttu-id="14aa8-278">A Table szolgáltatásban párhuzamossági kezelése</span><span class="sxs-lookup"><span data-stu-id="14aa8-278">Managing Concurrency in the Table Service</span></span>
<span data-ttu-id="14aa8-279">A table szolgáltatás optimista párhuzamossági alapértelmezett viselkedésként ellenőrzi, amikor dolgozunk entitások, ellentétben a blob szolgáltatás, ha explicit módon választania kell az egyidejű hozzáférések optimista ellenőrzéséhez használ.</span><span class="sxs-lookup"><span data-stu-id="14aa8-279">The table service uses optimistic concurrency checks as the default behavior when you are working with entities, unlike the blob service where you must explicitly choose to perform optimistic concurrency checks.</span></span> <span data-ttu-id="14aa8-280">A más a tábla és a blob szolgáltatás közötti különbség, hogy csak kezelheti az entitások viselkedésének párhuzamossági mivel a blob szolgáltatás segítségével kezelheti a tárolók és blobok CONCURRENCY paraméterének értékét.</span><span class="sxs-lookup"><span data-stu-id="14aa8-280">The other difference between the table and blob services is that you can only manage the concurrency behavior of entities whereas with the blob service you can manage the concurrency of both containers and blobs.</span></span>  

<span data-ttu-id="14aa8-281">Egyidejű hozzáférések optimista használja, és ellenőrizze, hogy egy másik folyamat entitás módosítása, mivel a table storage szolgáltatásból való lekérése, amikor az entitást adja vissza, a table szolgáltatás ETag érték is használhatja.</span><span class="sxs-lookup"><span data-stu-id="14aa8-281">To use optimistic concurrency and to check if another process modified an entity since you retrieved it from the table storage service, you can use the ETag value you receive when the table service returns an entity.</span></span> <span data-ttu-id="14aa8-282">A folyamat során vázlatot a következőképpen történik:</span><span class="sxs-lookup"><span data-stu-id="14aa8-282">The outline of this process is as follows:</span></span>  

1. <span data-ttu-id="14aa8-283">Egy entitás lekérdezni a table storage szolgáltatásból, a válasz az egy ETag érték, amely azonosítja az alkalmazás a társzolgáltatás társított aktuális azonosítót tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="14aa8-283">Retrieve an entity from the table storage service, the response includes an ETag value that identifies the current identifier associated with that entity in the storage service.</span></span>
2. <span data-ttu-id="14aa8-284">Ha az entitás módosítására, vegye fel a kötelező az 1. lépésben kapott ETag érték **If-Match** küldött a szolgáltatás a kérelem fejlécében.</span><span class="sxs-lookup"><span data-stu-id="14aa8-284">When you update the entity, include the ETag value you received in step 1 in the mandatory **If-Match** header of the request you send to the service.</span></span>
3. <span data-ttu-id="14aa8-285">A szolgáltatás összehasonlítja az entitás jelenlegi ETag-értékével a kérés a ETag értéket.</span><span class="sxs-lookup"><span data-stu-id="14aa8-285">The service compares the ETag value in the request with the current ETag value of the entity.</span></span>
4. <span data-ttu-id="14aa8-286">Ha a jelenlegi ETag entitás értéke eltér a kötelező az ETag **If-Match** fejléc a következő a kérelem, a szolgáltatás egy 412 hibát ad vissza az ügyfélnek.</span><span class="sxs-lookup"><span data-stu-id="14aa8-286">If the current ETag value of the entity is different than the ETag in the mandatory **If-Match** header in the request, the service returns a 412 error to the client.</span></span> <span data-ttu-id="14aa8-287">Ez azt jelzi, az ügyfél számára, hogy egy másik folyamat frissítette az entitás, mivel az ügyfél azt lekérése.</span><span class="sxs-lookup"><span data-stu-id="14aa8-287">This indicates to the client that another process has updated the entity since the client retrieved it.</span></span>
5. <span data-ttu-id="14aa8-288">Ha a jelenlegi ETag az entitás értéke ugyanaz, mint a kötelező az ETag **If-Match** a kérelem fejlécében vagy a **If-Match** fejlécet tartalmaz (*) helyettesítő karakter, a szolgáltatás hajtja végre a a kért műveletet, és frissíti az aktuális ETag érték megjelenítéséhez, hogy frissült az entitás.</span><span class="sxs-lookup"><span data-stu-id="14aa8-288">If the current ETag value of the entity is the same as the ETag in the mandatory **If-Match** header in the request or the **If-Match** header contains the wildcard character (*), the service performs the requested operation and updates the current ETag value of the entity to show that it has been updated.</span></span>  

<span data-ttu-id="14aa8-289">Vegye figyelembe, hogy a blob szolgáltatás eltérően a table szolgáltatás tartalmazza az ügyfél igényel egy **If-Match** fejléc a következő frissítési kérelmek.</span><span class="sxs-lookup"><span data-stu-id="14aa8-289">Note that unlike the blob service, the table service requires the client to include an **If-Match** header in update requests.</span></span> <span data-ttu-id="14aa8-290">Azonban is lehet kényszeríteni egy feltétel nélküli (utolsó író wins stratégia) frissítése és feldolgozási ellenőrzések megkerülését, ha az ügyfél beállítja a **If-Match** fejlécének helyettesítő karakter (*) a kérelemben.</span><span class="sxs-lookup"><span data-stu-id="14aa8-290">However, it is possible to force an unconditional update (last writer wins strategy) and bypass concurrency checks if the client sets the **If-Match** header to the wildcard character (*) in the request.</span></span>  

<span data-ttu-id="14aa8-291">Az alábbi C# kódrészletben láthatja, hogy korábban létre vagy visszavonni a frissített e-mail címüket rendelkező ügyfél entitás.</span><span class="sxs-lookup"><span data-stu-id="14aa8-291">The following C# snippet shows a customer entity that was previously either created or retrieved having their email address updated.</span></span> <span data-ttu-id="14aa8-292">A kezdeti beszúrása vagy művelet tárolja a felhasználói objektum ETag érték beolvasása, és a minta a objektum példányt használja, a Csere műveletet végrehajtásakor, akkor automatikusan visszaküldi az ETag érték a table szolgáltatás, a szolgáltatás engedélyezése Egyidejűség megsértése kereséséhez.</span><span class="sxs-lookup"><span data-stu-id="14aa8-292">The initial insert or retrieve operation stores the ETag value in the customer object, and because the sample uses the same object instance when it executes the replace operation, it automatically sends the ETag value back to the table service, enabling the service to check for concurrency violations.</span></span> <span data-ttu-id="14aa8-293">Ha egy másik folyamat frissítette az entitás table storage-ban, a szolgáltatás egy HTTP 412 (előfeltétel nem teljesült) állapotüzenetet adja vissza.</span><span class="sxs-lookup"><span data-stu-id="14aa8-293">If another process has updated the entity in table storage, the service returns an HTTP 412 (Precondition Failed) status message.</span></span>  <span data-ttu-id="14aa8-294">Letöltheti a teljes mintát itt: [kezelése egyidejű használata az Azure Storage](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span><span class="sxs-lookup"><span data-stu-id="14aa8-294">You can download the full sample here: [Managing Concurrency using Azure Storage](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span></span>

```csharp
try
{
    customer.Email = "updatedEmail@contoso.org";
    TableOperation replaceCustomer = TableOperation.Replace(customer);
    customerTable.Execute(replaceCustomer);
    Console.WriteLine("Replace operation succeeded.");
}
catch (StorageException ex)
{
    if (ex.RequestInformation.HttpStatusCode == 412)
        Console.WriteLine("Optimistic concurrency violation – entity has changed since it was retrieved.");
    else
        throw;
}  
```

<span data-ttu-id="14aa8-295">Explicit módon letiltja a konkurencia ellenőrzése, célszerű a **ETag** tulajdonsága a **alkalmazott** objektum "*" a név felülírandó a művelet végrehajtása előtt.</span><span class="sxs-lookup"><span data-stu-id="14aa8-295">To explicitly disable the concurrency check, you should set the **ETag** property of the **employee** object to "*" before you execute the replace operation.</span></span>  

```csharp
customer.ETag = "*";  
```

<span data-ttu-id="14aa8-296">A következő táblázat összefoglalja, hogyan a tábla entitás műveletek ETag értékeket használja:</span><span class="sxs-lookup"><span data-stu-id="14aa8-296">The following table summarizes how the table entity operations use ETag values:</span></span>

| <span data-ttu-id="14aa8-297">Művelet</span><span class="sxs-lookup"><span data-stu-id="14aa8-297">Operation</span></span> | <span data-ttu-id="14aa8-298">ETag értéket ad vissza</span><span class="sxs-lookup"><span data-stu-id="14aa8-298">Returns ETag value</span></span> | <span data-ttu-id="14aa8-299">If-Match fejléc igényel</span><span class="sxs-lookup"><span data-stu-id="14aa8-299">Requires If-Match request header</span></span> |
|:--- |:--- |:--- |
| <span data-ttu-id="14aa8-300">Lekérdezés entitások</span><span class="sxs-lookup"><span data-stu-id="14aa8-300">Query Entities</span></span> |<span data-ttu-id="14aa8-301">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-301">Yes</span></span> |<span data-ttu-id="14aa8-302">Nem</span><span class="sxs-lookup"><span data-stu-id="14aa8-302">No</span></span> |
| <span data-ttu-id="14aa8-303">Entitás beszúrása</span><span class="sxs-lookup"><span data-stu-id="14aa8-303">Insert Entity</span></span> |<span data-ttu-id="14aa8-304">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-304">Yes</span></span> |<span data-ttu-id="14aa8-305">Nem</span><span class="sxs-lookup"><span data-stu-id="14aa8-305">No</span></span> |
| <span data-ttu-id="14aa8-306">Entitás frissítése</span><span class="sxs-lookup"><span data-stu-id="14aa8-306">Update Entity</span></span> |<span data-ttu-id="14aa8-307">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-307">Yes</span></span> |<span data-ttu-id="14aa8-308">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-308">Yes</span></span> |
| <span data-ttu-id="14aa8-309">Entitás egyesítése</span><span class="sxs-lookup"><span data-stu-id="14aa8-309">Merge Entity</span></span> |<span data-ttu-id="14aa8-310">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-310">Yes</span></span> |<span data-ttu-id="14aa8-311">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-311">Yes</span></span> |
| <span data-ttu-id="14aa8-312">Entitás törlése</span><span class="sxs-lookup"><span data-stu-id="14aa8-312">Delete Entity</span></span> |<span data-ttu-id="14aa8-313">Nem</span><span class="sxs-lookup"><span data-stu-id="14aa8-313">No</span></span> |<span data-ttu-id="14aa8-314">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-314">Yes</span></span> |
| <span data-ttu-id="14aa8-315">Entitás cseréje vagy beszúrása</span><span class="sxs-lookup"><span data-stu-id="14aa8-315">Insert or Replace Entity</span></span> |<span data-ttu-id="14aa8-316">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-316">Yes</span></span> |<span data-ttu-id="14aa8-317">Nem</span><span class="sxs-lookup"><span data-stu-id="14aa8-317">No</span></span> |
| <span data-ttu-id="14aa8-318">Az INSERT vagy egyesítés entitás</span><span class="sxs-lookup"><span data-stu-id="14aa8-318">Insert or Merge Entity</span></span> |<span data-ttu-id="14aa8-319">Igen</span><span class="sxs-lookup"><span data-stu-id="14aa8-319">Yes</span></span> |<span data-ttu-id="14aa8-320">Nem</span><span class="sxs-lookup"><span data-stu-id="14aa8-320">No</span></span> |

<span data-ttu-id="14aa8-321">Vegye figyelembe, hogy a **Insert vagy az entitás cseréje** és **Insert vagy az egyesítési entitás** műveletek tegye *nem* bármely párhuzamossági ellenőrzéseket hajtanak végre, mert a tábla nem küldenek egy ETag érték a szolgáltatás.</span><span class="sxs-lookup"><span data-stu-id="14aa8-321">Note that the **Insert or Replace Entity** and **Insert or Merge Entity** operations do *not* perform any concurrency checks because they do not send an ETag value to the table service.</span></span>  

<span data-ttu-id="14aa8-322">Általában a fejlesztők táblák használata hagyatkozzon kizárólag az egyidejű hozzáférések optimista méretezhető alkalmazások fejlesztése során.</span><span class="sxs-lookup"><span data-stu-id="14aa8-322">In general developers using tables should rely on optimistic concurrency when developing scalable applications.</span></span> <span data-ttu-id="14aa8-323">Pesszimista zárolás van szükség, ha egyik módszer fejlesztők táblák elérése esetén Rendeljen mindegyikhez kijelölt blob, majd próbálja meg érvénybe a címbérlet blobot, mielőtt azok a tábla is igénybe vehet.</span><span class="sxs-lookup"><span data-stu-id="14aa8-323">If pessimistic locking is needed, one approach developers can take when accessing Tables is to assign a designated blob for each table and try to take a lease on the blob before operating on the table.</span></span> <span data-ttu-id="14aa8-324">Ezt a módszert használja az alkalmazás összes adatok elérési utak beszerzése előtt a táblán működő bérleti biztosításához szükséges.</span><span class="sxs-lookup"><span data-stu-id="14aa8-324">This approach does require the application to ensure all data access paths obtain the lease prior to operating on the table.</span></span> <span data-ttu-id="14aa8-325">Meg kell vegye figyelembe azt is, amely a minimális bérleti idő 15 másodperc, amely kell gondosan meg kell fontolni a méretezhetőség érdekében.</span><span class="sxs-lookup"><span data-stu-id="14aa8-325">You should also note that the minimum lease time is 15 seconds which requires careful consideration for scalability.</span></span>  

<span data-ttu-id="14aa8-326">További információk:</span><span class="sxs-lookup"><span data-stu-id="14aa8-326">For more information see:</span></span>  

* [<span data-ttu-id="14aa8-327">Entitások műveletek</span><span class="sxs-lookup"><span data-stu-id="14aa8-327">Operations on Entities</span></span>](http://msdn.microsoft.com/library/azure/dd179375.aspx)  

## <a name="managing-concurrency-in-the-queue-service"></a><span data-ttu-id="14aa8-328">A Queue szolgáltatás az egyidejű kezelése</span><span class="sxs-lookup"><span data-stu-id="14aa8-328">Managing Concurrency in the Queue Service</span></span>
<span data-ttu-id="14aa8-329">Milyen párhuzamossági a fontos szolgáltatási várólista egy például az is, ha több ügyfelet keres üzenetek várólistából való várólistából.</span><span class="sxs-lookup"><span data-stu-id="14aa8-329">One scenario in which concurrency is a concern in the queueing service is where multiple clients are retrieving messages from a queue.</span></span> <span data-ttu-id="14aa8-330">Ha egy üzenetet a sorból beolvasott, a válasz tartalmazza, az üzenet és a fogadást a pop értéket, amely azonban szükséges az üzenet törlése.</span><span class="sxs-lookup"><span data-stu-id="14aa8-330">When a message is retrieved from the queue, the response includes the message and a pop receipt value, which is required to delete the message.</span></span> <span data-ttu-id="14aa8-331">Az üzenet nem automatikusan törli a várólistáról, de után azt beolvasása, nincs látható más ügyfelek számára a a visibilitytimeout paraméter által megadott időtartam alatt.</span><span class="sxs-lookup"><span data-stu-id="14aa8-331">The message is not automatically deleted from the queue, but after it has been retrieved, it is not visible to other clients for the time interval specified by the visibilitytimeout parameter.</span></span> <span data-ttu-id="14aa8-332">Az ügyfél, amely lekéri az üzenet az üzenet törlése után feldolgozása megtörtént, és a TimeNextVisible által megadott időpont előtt elem, amelynek kiszámítása a válasz alapján a visibilitytimeout paraméter várt.</span><span class="sxs-lookup"><span data-stu-id="14aa8-332">The client that retrieves the message is expected to delete the message after it has been processed, and before the time specified by the TimeNextVisible element of the response, which is calculated based on the value of the visibilitytimeout parameter.</span></span> <span data-ttu-id="14aa8-333">Visibilitytimeout értékének hozzáadódik az idő, amelynél a lekért TimeNextVisible értékének meghatározása.</span><span class="sxs-lookup"><span data-stu-id="14aa8-333">The value of visibilitytimeout is added to the time at which the message is retrieved to determine the value of TimeNextVisible.</span></span>  

<span data-ttu-id="14aa8-334">A queue szolgáltatás nem rendelkezik optimista vagy pesszimista egyidejű támogatása, és a feldolgozása a sorból beolvasott üzenetekből OK ügyfelek biztosítania kell az idempotent módon dolgozza fel az üzeneteket.</span><span class="sxs-lookup"><span data-stu-id="14aa8-334">The queue service does not have support for either optimistic or pessimistic concurrency and for this reason clients processing messages retrieved from a queue should ensure messages are processed in an idempotent manner.</span></span> <span data-ttu-id="14aa8-335">Utolsó író wins stratégia frissítési műveletek, például a SetQueueServiceProperties, SetQueueMetaData, SetQueueACL és UpdateMessage szolgál.</span><span class="sxs-lookup"><span data-stu-id="14aa8-335">A last writer wins strategy is used for update operations such as SetQueueServiceProperties, SetQueueMetaData, SetQueueACL and UpdateMessage.</span></span>  

<span data-ttu-id="14aa8-336">További információk:</span><span class="sxs-lookup"><span data-stu-id="14aa8-336">For more information see:</span></span>  

* [<span data-ttu-id="14aa8-337">Várólista szolgáltatás REST API</span><span class="sxs-lookup"><span data-stu-id="14aa8-337">Queue Service REST API</span></span>](http://msdn.microsoft.com/library/azure/dd179363.aspx)
* [<span data-ttu-id="14aa8-338">Üzenet</span><span class="sxs-lookup"><span data-stu-id="14aa8-338">Get Messages</span></span>](http://msdn.microsoft.com/library/azure/dd179474.aspx)  

## <a name="managing-concurrency-in-the-file-service"></a><span data-ttu-id="14aa8-339">A szolgáltatás a feldolgozási kezelése</span><span class="sxs-lookup"><span data-stu-id="14aa8-339">Managing Concurrency in the File Service</span></span>
<span data-ttu-id="14aa8-340">A szolgáltatás elérhető két különböző protokollvégpontokat – a többi pedig az SMB használatával.</span><span class="sxs-lookup"><span data-stu-id="14aa8-340">The file service can be accessed using two different protocol endpoints – SMB and REST.</span></span> <span data-ttu-id="14aa8-341">A többi szolgáltatás nem rendelkezik optimista zárolással vagy a pesszimista zárolás támogatása, és minden frissítés utolsó író wins stratégiát követi.</span><span class="sxs-lookup"><span data-stu-id="14aa8-341">The REST service does not have support for either optimistic locking or pessimistic locking and all updates will follow a last writer wins strategy.</span></span> <span data-ttu-id="14aa8-342">Csatlakoztassa a fájlmegosztások SMB-ügyfelek használhatják fel a fájl rendszer mechanizmusok megosztott fájlok – például a végrehajtásához a pesszimista zárolás elérése.</span><span class="sxs-lookup"><span data-stu-id="14aa8-342">SMB clients that mount file shares can leverage file system locking mechanisms to manage access to shared files – including the ability to perform pessimistic locking.</span></span> <span data-ttu-id="14aa8-343">Ha egy SMB-ügyfél megnyit egy fájlt, adja meg a fájl eléréséhez és a megosztáshoz mód.</span><span class="sxs-lookup"><span data-stu-id="14aa8-343">When an SMB client opens a file, it specifies both the file access and share mode.</span></span> <span data-ttu-id="14aa8-344">Egy fájl hozzáférés beállításnak a "Write" vagy "Olvasási/írási" egy fájlmegosztás módot együtt a "None" azt eredményezi, hogy a fájl egy SMB-ügyfél zárolta a fájlt bezárásáig.</span><span class="sxs-lookup"><span data-stu-id="14aa8-344">Setting a File Access option of "Write" or "Read/Write" along with a File Share mode of "None" will result in the file being locked by an SMB client until the file is closed.</span></span> <span data-ttu-id="14aa8-345">Ha REST-művelet kísérletet egy fájlt, amelyben egy SMB-ügyfél rendelkezik-e a fájl zárolva a többi szolgáltatás-állapotkódot (Ütközés) 409 hibakód SharingViolation vissza.</span><span class="sxs-lookup"><span data-stu-id="14aa8-345">If REST operation is attempted on a file where an SMB client has the file locked the REST service will return status code 409 (Conflict) with error code SharingViolation.</span></span>  

<span data-ttu-id="14aa8-346">Ha egy SMB-ügyfél megnyit egy fájlt törlésre, jelöli a fájlt, amíg más SMB-ügyfél törlése függőben lévő fájl megnyitott kezelőkkel be van zárva.</span><span class="sxs-lookup"><span data-stu-id="14aa8-346">When an SMB client opens a file for delete, it marks the file as pending delete until all other SMB client open handles on that file are closed.</span></span> <span data-ttu-id="14aa8-347">A fájl törlése függőben van megjelölve, amíg bármely REST művelet, hogy a fájl-állapotkódot (Ütközés) 409 hibakód SMBDeletePending ad vissza.</span><span class="sxs-lookup"><span data-stu-id="14aa8-347">While a file is marked as pending delete, any REST operation on that file will return status code 409 (Conflict) with error code SMBDeletePending.</span></span> <span data-ttu-id="14aa8-348">Állapotkód: 404-es (nem található) a rendszer nem adja vissza, mert lehetséges, hogy az SMB-ügyfél eltávolítása előtt a fájl bezárásakor a függőben lévő törlési jelzőt.</span><span class="sxs-lookup"><span data-stu-id="14aa8-348">Status code 404 (Not Found) is not returned since it is possible for the SMB client to remove the pending deletion flag prior to closing the file.</span></span> <span data-ttu-id="14aa8-349">Állapotkód: 404-es (nem található) más szóval csak várható, ha a fájl el lett távolítva.</span><span class="sxs-lookup"><span data-stu-id="14aa8-349">In other words, status code 404 (Not Found) is only expected when the file has been removed.</span></span> <span data-ttu-id="14aa8-350">Vegye figyelembe, hogy közben az egy SMB-vel, függőben lévő törlési állapot, azt nem szerepelni fog a tulajdonságlista-fájlok eredmények. Ne feledje, hogy a többi fájl törlése és a többi törlése Directory műveletek véglegesítése i és függőben lévő törlési állapota nem eredményeznek.</span><span class="sxs-lookup"><span data-stu-id="14aa8-350">Note that while a file is in a SMB pending delete state, it will not be included in the List Files results.Also note that the REST Delete File and REST Delete Directory operations are committed atomically and do not result in pending delete state.</span></span>  

<span data-ttu-id="14aa8-351">További információk:</span><span class="sxs-lookup"><span data-stu-id="14aa8-351">For more information see:</span></span>  

* [<span data-ttu-id="14aa8-352">Zárolja fájl kezelése</span><span class="sxs-lookup"><span data-stu-id="14aa8-352">Managing File Locks</span></span>](http://msdn.microsoft.com/library/azure/dn194265.aspx)  

## <a name="summary-and-next-steps"></a><span data-ttu-id="14aa8-353">Összegzés és további lépések</span><span class="sxs-lookup"><span data-stu-id="14aa8-353">Summary and Next Steps</span></span>
<span data-ttu-id="14aa8-354">A Microsoft Azure Storage szolgáltatás úgy tervezték, hibát okoz, vagy tervezési feltételezéseket például feldolgozási és, amely rendelkezik lépnek érvénybe adatok konzisztenciájának rethink fejlesztők kényszerítése nélkül igényeinek a legösszetettebb az online alkalmazások kapnak.</span><span class="sxs-lookup"><span data-stu-id="14aa8-354">The Microsoft Azure Storage service has been designed to meet the needs of the most complex online applications without forcing developers to compromise or rethink key design assumptions such as concurrency and data consistency that they have come to take for granted.</span></span>  

<span data-ttu-id="14aa8-355">Ebben a blogban hivatkozik a teljes mintaalkalmazás:</span><span class="sxs-lookup"><span data-stu-id="14aa8-355">For the complete sample application referenced in this blog:</span></span>  

* [<span data-ttu-id="14aa8-356">Azure Storage - mintaalkalmazás használatával párhuzamossági kezelése</span><span class="sxs-lookup"><span data-stu-id="14aa8-356">Managing Concurrency using Azure Storage - Sample Application</span></span>](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114)  

<span data-ttu-id="14aa8-357">További információ az Azure Storage lásd:</span><span class="sxs-lookup"><span data-stu-id="14aa8-357">For more information on Azure Storage see:</span></span>  

* [<span data-ttu-id="14aa8-358">A Microsoft Azure Storage kezdőlap</span><span class="sxs-lookup"><span data-stu-id="14aa8-358">Microsoft Azure Storage Home Page</span></span>](https://azure.microsoft.com/services/storage/)
* [<span data-ttu-id="14aa8-359">Az Azure Storage bemutatása</span><span class="sxs-lookup"><span data-stu-id="14aa8-359">Introduction to Azure Storage</span></span>](storage-introduction.md)
* <span data-ttu-id="14aa8-360">Bevezetés a tárolás [Blob](storage-dotnet-how-to-use-blobs.md), [tábla](storage-dotnet-how-to-use-tables.md), [várólisták](storage-dotnet-how-to-use-queues.md), és [fájlok](storage-dotnet-how-to-use-files.md)</span><span class="sxs-lookup"><span data-stu-id="14aa8-360">Storage Getting Started for [Blob](storage-dotnet-how-to-use-blobs.md), [Table](storage-dotnet-how-to-use-tables.md),  [Queues](storage-dotnet-how-to-use-queues.md), and [Files](storage-dotnet-how-to-use-files.md)</span></span>
* <span data-ttu-id="14aa8-361">Tároló-architektúra – [az Azure Storage: egy magas rendelkezésre állású felhőalapú tárolási szolgáltatásba erős konzisztencia](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx)</span><span class="sxs-lookup"><span data-stu-id="14aa8-361">Storage Architecture – [Azure Storage : A Highly Available Cloud Storage Service with Strong Consistency](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx)</span></span>

