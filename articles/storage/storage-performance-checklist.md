---
title: "aaaAzure tárolási teljesítményének és méretezhetőségének ellenőrzőlista |} Microsoft Docs"
description: "Egy ellenőrzőlista használható az Azure Storage performant-alkalmazások fejlesztésével bevált gyakorlatát."
services: storage
documentationcenter: 
author: robinsh
manager: timlt
editor: tysonn
ms.assetid: 959d831b-a4fd-4634-a646-0d2c0c462ef8
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 12/08/2016
ms.author: robinsh
ms.openlocfilehash: c0cd77da4a1abda42c018255ed93215b71f4fad8
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 10/06/2017
---
# <a name="microsoft-azure-storage-performance-and-scalability-checklist"></a><span data-ttu-id="7090f-103">A Microsoft Azure Storage teljesítmény- és méretezhetőségi ellenőrzőlistája</span><span class="sxs-lookup"><span data-stu-id="7090f-103">Microsoft Azure Storage Performance and Scalability Checklist</span></span>
## <a name="overview"></a><span data-ttu-id="7090f-104">Áttekintés</span><span class="sxs-lookup"><span data-stu-id="7090f-104">Overview</span></span>
<span data-ttu-id="7090f-105">Óta hello Microsoft Azure Storage szolgáltatás hello verziójában Microsoft performant módon ezen szolgáltatások használatára vonatkozó bevált gyakorlatok számos fejlesztett ki, és ez a cikk szolgál tooconsolidate hello egyik legfontosabb ellenőrzőlista stílusú listává.</span><span class="sxs-lookup"><span data-stu-id="7090f-105">Since hello release of hello Microsoft Azure Storage services, Microsoft has developed a number of proven practices for using these services in a performant manner, and this article serves tooconsolidate hello most important of them into a checklist-style list.</span></span> <span data-ttu-id="7090f-106">hello Ez a cikk célja toohelp alkalmazásfejlesztők annak ellenőrzése, hogy azok bevált gyakorlat az Azure Storage és toohelp-érdemes megfontolni a bevezetése egyéb bevált gyakorlatok azonosítása őket.</span><span class="sxs-lookup"><span data-stu-id="7090f-106">hello intention of this article is toohelp application developers verify they are using proven practices with Azure Storage and toohelp them identify other proven practices they should consider adopting.</span></span> <span data-ttu-id="7090f-107">Ez a cikk nem kísérli meg toocover minden lehetséges teljesítményének és méretezhetőségének optimalizálás – a művelet hatása a kis- és tágabb értelemben véve nem alkalmazható nem tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="7090f-107">This article does not attempt toocover every possible performance and scalability optimization — it excludes those that are small in their impact or not broadly applicable.</span></span> <span data-ttu-id="7090f-108">az alkalmazás viselkedését hello toohello mértékben előre jelezhető tervezés közben ezeket a következőket kell figyelembe venni a korai hasznos tookeep tooavoid terveket, amely a teljesítménybeli problémákat.</span><span class="sxs-lookup"><span data-stu-id="7090f-108">toohello extent that hello application's behavior can be predicted during design, it's useful tookeep these in mind early on tooavoid designs that will run into performance problems.</span></span>  

<span data-ttu-id="7090f-109">Minden Azure Storage használatával alkalmazásfejlesztő kell érvénybe hello idő tooread ebben a cikkben, és ellenőrizze, hogy saját alkalmazás egyes hello bizonyítása az alábbi eljárásokat a következő.</span><span class="sxs-lookup"><span data-stu-id="7090f-109">Every application developer using Azure Storage should take hello time tooread this article, and check that his or her application follows each of hello proven practices listed below.</span></span>  

## <a name="checklist"></a><span data-ttu-id="7090f-110">Feladatlista</span><span class="sxs-lookup"><span data-stu-id="7090f-110">Checklist</span></span>
<span data-ttu-id="7090f-111">Ez a cikk bizonyítása hello eljárások azokat a csoportokat a következő hello rendezi.</span><span class="sxs-lookup"><span data-stu-id="7090f-111">This article organizes hello proven practices into hello following groups.</span></span> <span data-ttu-id="7090f-112">Bevált gyakorlatok alkalmazható:</span><span class="sxs-lookup"><span data-stu-id="7090f-112">Proven practices applicable to:</span></span>  

* <span data-ttu-id="7090f-113">Minden Azure Storage szolgáltatás (BLOB, táblák, üzenetsorok és fájlok)</span><span class="sxs-lookup"><span data-stu-id="7090f-113">All Azure Storage services (blobs, tables, queues, and files)</span></span>
* <span data-ttu-id="7090f-114">Blobok</span><span class="sxs-lookup"><span data-stu-id="7090f-114">Blobs</span></span>
* <span data-ttu-id="7090f-115">Táblák</span><span class="sxs-lookup"><span data-stu-id="7090f-115">Tables</span></span>
* <span data-ttu-id="7090f-116">Üzenetsorok</span><span class="sxs-lookup"><span data-stu-id="7090f-116">Queues</span></span>  

| <span data-ttu-id="7090f-117">Kész</span><span class="sxs-lookup"><span data-stu-id="7090f-117">Done</span></span> | <span data-ttu-id="7090f-118">Terület</span><span class="sxs-lookup"><span data-stu-id="7090f-118">Area</span></span> | <span data-ttu-id="7090f-119">Kategória</span><span class="sxs-lookup"><span data-stu-id="7090f-119">Category</span></span> | <span data-ttu-id="7090f-120">Kérdés</span><span class="sxs-lookup"><span data-stu-id="7090f-120">Question</span></span> |
| --- | --- | --- | --- |
| &nbsp; | <span data-ttu-id="7090f-121">All Services (Minden szolgáltatás)</span><span class="sxs-lookup"><span data-stu-id="7090f-121">All Services</span></span> |<span data-ttu-id="7090f-122">Méretezhetőségi célok</span><span class="sxs-lookup"><span data-stu-id="7090f-122">Scalability Targets</span></span> |[<span data-ttu-id="7090f-123">Az alkalmazás, amelynek célja tooavoid közeledik hello méretezhetőségi célok?</span><span class="sxs-lookup"><span data-stu-id="7090f-123">Is your application designed tooavoid approaching hello scalability targets?</span></span>](#subheading1) |
| &nbsp; | <span data-ttu-id="7090f-124">All Services (Minden szolgáltatás)</span><span class="sxs-lookup"><span data-stu-id="7090f-124">All Services</span></span> |<span data-ttu-id="7090f-125">Méretezhetőségi célok</span><span class="sxs-lookup"><span data-stu-id="7090f-125">Scalability Targets</span></span> |[<span data-ttu-id="7090f-126">Az jobban az elnevezési egyezmény tervezett tooenable terheléselosztás?</span><span class="sxs-lookup"><span data-stu-id="7090f-126">Is your naming convention designed tooenable better load-balancing?</span></span>](#subheading47) |
| &nbsp; | <span data-ttu-id="7090f-127">All Services (Minden szolgáltatás)</span><span class="sxs-lookup"><span data-stu-id="7090f-127">All Services</span></span> |<span data-ttu-id="7090f-128">Hálózat</span><span class="sxs-lookup"><span data-stu-id="7090f-128">Networking</span></span> |[<span data-ttu-id="7090f-129">Rendelkeznek-e ügyféloldali ügyféleszközök elég nagy sávszélességet és alacsony késési igényű tooachieve hello teljesítményt?</span><span class="sxs-lookup"><span data-stu-id="7090f-129">Do client side devices have sufficiently high bandwidth and low latency tooachieve hello performance needed?</span></span>](#subheading2) |
| &nbsp; | <span data-ttu-id="7090f-130">All Services (Minden szolgáltatás)</span><span class="sxs-lookup"><span data-stu-id="7090f-130">All Services</span></span> |<span data-ttu-id="7090f-131">Hálózat</span><span class="sxs-lookup"><span data-stu-id="7090f-131">Networking</span></span> |[<span data-ttu-id="7090f-132">Ügyféloldali ügyféleszközök rendelkeznek elég kiváló minőségű hivatkozást?</span><span class="sxs-lookup"><span data-stu-id="7090f-132">Do client side devices have a high enough quality link?</span></span>](#subheading3) |
| &nbsp; | <span data-ttu-id="7090f-133">All Services (Minden szolgáltatás)</span><span class="sxs-lookup"><span data-stu-id="7090f-133">All Services</span></span> |<span data-ttu-id="7090f-134">Hálózat</span><span class="sxs-lookup"><span data-stu-id="7090f-134">Networking</span></span> |[<span data-ttu-id="7090f-135">"Közelében" hello storage-fiókban található hello ügyfélalkalmazás?</span><span class="sxs-lookup"><span data-stu-id="7090f-135">Is hello client application located "near" hello storage account?</span></span>](#subheading4) |
| &nbsp; | <span data-ttu-id="7090f-136">All Services (Minden szolgáltatás)</span><span class="sxs-lookup"><span data-stu-id="7090f-136">All Services</span></span> |<span data-ttu-id="7090f-137">Tartalomterjesztés</span><span class="sxs-lookup"><span data-stu-id="7090f-137">Content Distribution</span></span> |[<span data-ttu-id="7090f-138">Használja a CDN a tartalmak terjesztéséhez?</span><span class="sxs-lookup"><span data-stu-id="7090f-138">Are you using a CDN for content distribution?</span></span>](#subheading5) |
| &nbsp; | <span data-ttu-id="7090f-139">All Services (Minden szolgáltatás)</span><span class="sxs-lookup"><span data-stu-id="7090f-139">All Services</span></span> |<span data-ttu-id="7090f-140">Közvetlen ügyfélhozzáférés</span><span class="sxs-lookup"><span data-stu-id="7090f-140">Direct Client Access</span></span> |[<span data-ttu-id="7090f-141">Használ SAS, valamint a CORS tooallow közvetlen hozzáférést toostorage proxy helyett?</span><span class="sxs-lookup"><span data-stu-id="7090f-141">Are you using SAS and CORS tooallow direct access toostorage instead of proxy?</span></span>](#subheading6) |
| &nbsp; | <span data-ttu-id="7090f-142">All Services (Minden szolgáltatás)</span><span class="sxs-lookup"><span data-stu-id="7090f-142">All Services</span></span> |<span data-ttu-id="7090f-143">Gyorsítótárazás</span><span class="sxs-lookup"><span data-stu-id="7090f-143">Caching</span></span> |[<span data-ttu-id="7090f-144">A gyorsítótárazási alkalmazásadatok ismételten használt és módosítások ritkán van?</span><span class="sxs-lookup"><span data-stu-id="7090f-144">Is your application caching data that is repeatedly used and changes rarely?</span></span>](#subheading7) |
| &nbsp; | <span data-ttu-id="7090f-145">All Services (Minden szolgáltatás)</span><span class="sxs-lookup"><span data-stu-id="7090f-145">All Services</span></span> |<span data-ttu-id="7090f-146">Gyorsítótárazás</span><span class="sxs-lookup"><span data-stu-id="7090f-146">Caching</span></span> |[<span data-ttu-id="7090f-147">Az alkalmazás kötegelés van a frissítések (ügyféloldali gyorsítótárazás őket, és majd töltse fel a nagyobb készletek)?</span><span class="sxs-lookup"><span data-stu-id="7090f-147">Is your application batching updates (caching them client side and then uploading in larger sets)?</span></span>](#subheading8) |
| &nbsp; | <span data-ttu-id="7090f-148">All Services (Minden szolgáltatás)</span><span class="sxs-lookup"><span data-stu-id="7090f-148">All Services</span></span> |<span data-ttu-id="7090f-149">.NET-konfiguráció</span><span class="sxs-lookup"><span data-stu-id="7090f-149">.NET Configuration</span></span> |[<span data-ttu-id="7090f-150">Rendelkezik-e konfigurálva az ügyfél toouse egyidejű kapcsolat elegendő számú?</span><span class="sxs-lookup"><span data-stu-id="7090f-150">Have you configured your client toouse a sufficient number of concurrent connections?</span></span>](#subheading9) |
| &nbsp; | <span data-ttu-id="7090f-151">All Services (Minden szolgáltatás)</span><span class="sxs-lookup"><span data-stu-id="7090f-151">All Services</span></span> |<span data-ttu-id="7090f-152">.NET-konfiguráció</span><span class="sxs-lookup"><span data-stu-id="7090f-152">.NET Configuration</span></span> |[<span data-ttu-id="7090f-153">Állított .NET toouse szálak elegendő számú?</span><span class="sxs-lookup"><span data-stu-id="7090f-153">Have you configured .NET toouse a sufficient number of threads?</span></span>](#subheading10) |
| &nbsp; | <span data-ttu-id="7090f-154">All Services (Minden szolgáltatás)</span><span class="sxs-lookup"><span data-stu-id="7090f-154">All Services</span></span> |<span data-ttu-id="7090f-155">.NET-konfiguráció</span><span class="sxs-lookup"><span data-stu-id="7090f-155">.NET Configuration</span></span> |[<span data-ttu-id="7090f-156">.NET 4.5-ös verziójának használatával, vagy később, amely javult a szemétgyűjtés?</span><span class="sxs-lookup"><span data-stu-id="7090f-156">Are you using .NET 4.5 or later, which has improved garbage collection?</span></span>](#subheading11) |
| &nbsp; | <span data-ttu-id="7090f-157">All Services (Minden szolgáltatás)</span><span class="sxs-lookup"><span data-stu-id="7090f-157">All Services</span></span> |<span data-ttu-id="7090f-158">Párhuzamos végrehajtás</span><span class="sxs-lookup"><span data-stu-id="7090f-158">Parallelism</span></span> |[<span data-ttu-id="7090f-159">Biztosították, hogy párhuzamossági korlátozódik megfelelően, hogy az ügyfél képességek vagy a hello méretezhetőségi célok nem túlterhelés?</span><span class="sxs-lookup"><span data-stu-id="7090f-159">Have you ensured that parallelism is bounded appropriately so that you don't overload either your client capabilities or hello scalability targets?</span></span>](#subheading12) |
| &nbsp; | <span data-ttu-id="7090f-160">All Services (Minden szolgáltatás)</span><span class="sxs-lookup"><span data-stu-id="7090f-160">All Services</span></span> |<span data-ttu-id="7090f-161">Eszközök</span><span class="sxs-lookup"><span data-stu-id="7090f-161">Tools</span></span> |[<span data-ttu-id="7090f-162">Rendszer Microsoft hello legújabb verzióját használja a megadott ügyfél-kódtárak és eszközök?</span><span class="sxs-lookup"><span data-stu-id="7090f-162">Are you using hello latest version of Microsoft provided client libraries and tools?</span></span>](#subheading13) |
| &nbsp; | <span data-ttu-id="7090f-163">All Services (Minden szolgáltatás)</span><span class="sxs-lookup"><span data-stu-id="7090f-163">All Services</span></span> |<span data-ttu-id="7090f-164">Újrapróbálkozások</span><span class="sxs-lookup"><span data-stu-id="7090f-164">Retries</span></span> |[<span data-ttu-id="7090f-165">Azok az exponenciális leállítási használatával újra hibák és időtúllépéseket okoz szabályozás házirend?</span><span class="sxs-lookup"><span data-stu-id="7090f-165">Are you using an exponential backoff retry policy for throttling errors and timeouts?</span></span>](#subheading14) |
| &nbsp; | <span data-ttu-id="7090f-166">All Services (Minden szolgáltatás)</span><span class="sxs-lookup"><span data-stu-id="7090f-166">All Services</span></span> |<span data-ttu-id="7090f-167">Újrapróbálkozások</span><span class="sxs-lookup"><span data-stu-id="7090f-167">Retries</span></span> |[<span data-ttu-id="7090f-168">Az alkalmazás elkerülő újrapróbálkozások van – Újrapróbálkozást lehetővé nem tevő hibákat?</span><span class="sxs-lookup"><span data-stu-id="7090f-168">Is your application avoiding retries for non-retryable errors?</span></span>](#subheading15) |
| &nbsp; | <span data-ttu-id="7090f-169">Blobok</span><span class="sxs-lookup"><span data-stu-id="7090f-169">Blobs</span></span> |<span data-ttu-id="7090f-170">Méretezhetőségi célok</span><span class="sxs-lookup"><span data-stu-id="7090f-170">Scalability Targets</span></span> |[<span data-ttu-id="7090f-171">Rendelkezik egy adott objektum egyidejűleg hozzáférő ügyfelek nagy számú?</span><span class="sxs-lookup"><span data-stu-id="7090f-171">Do you have a large number of clients accessing a single object concurrently?</span></span>](#subheading46) |
| &nbsp; | <span data-ttu-id="7090f-172">Blobok</span><span class="sxs-lookup"><span data-stu-id="7090f-172">Blobs</span></span> |<span data-ttu-id="7090f-173">Méretezhetőségi célok</span><span class="sxs-lookup"><span data-stu-id="7090f-173">Scalability Targets</span></span> |[<span data-ttu-id="7090f-174">Az alkalmazás hello sávszélességet vagy a műveletek a méretezhetőség cél egyetlen BLOB tartózkodik?</span><span class="sxs-lookup"><span data-stu-id="7090f-174">Is your application staying within hello bandwidth or operations scalability target for a single blob?</span></span>](#subheading16) |
| &nbsp; | <span data-ttu-id="7090f-175">Blobok</span><span class="sxs-lookup"><span data-stu-id="7090f-175">Blobs</span></span> |<span data-ttu-id="7090f-176">Blobok másolása</span><span class="sxs-lookup"><span data-stu-id="7090f-176">Copying Blobs</span></span> |[<span data-ttu-id="7090f-177">Másolási blobok vannak hatékony módon?</span><span class="sxs-lookup"><span data-stu-id="7090f-177">Are you copying blobs in an efficient manner?</span></span>](#subheading17) |
| &nbsp; | <span data-ttu-id="7090f-178">Blobok</span><span class="sxs-lookup"><span data-stu-id="7090f-178">Blobs</span></span> |<span data-ttu-id="7090f-179">Blobok másolása</span><span class="sxs-lookup"><span data-stu-id="7090f-179">Copying Blobs</span></span> |[<span data-ttu-id="7090f-180">AzCopy használunk a blobok tömeges másolatot?</span><span class="sxs-lookup"><span data-stu-id="7090f-180">Are you using AzCopy for bulk copies of blobs?</span></span>](#subheading18) |
| &nbsp; | <span data-ttu-id="7090f-181">Blobok</span><span class="sxs-lookup"><span data-stu-id="7090f-181">Blobs</span></span> |<span data-ttu-id="7090f-182">Blobok másolása</span><span class="sxs-lookup"><span data-stu-id="7090f-182">Copying Blobs</span></span> |[<span data-ttu-id="7090f-183">Azure Import/Export tootransfer nagyon nagy adatkötetek használ?</span><span class="sxs-lookup"><span data-stu-id="7090f-183">Are you using Azure Import/Export tootransfer very large volumes of data?</span></span>](#subheading19) |
| &nbsp; | <span data-ttu-id="7090f-184">Blobok</span><span class="sxs-lookup"><span data-stu-id="7090f-184">Blobs</span></span> |<span data-ttu-id="7090f-185">Metaadatok</span><span class="sxs-lookup"><span data-stu-id="7090f-185">Use Metadata</span></span> |[<span data-ttu-id="7090f-186">Akkor tárolja a gyakran használt BLOB metaadatait a metaadatok?</span><span class="sxs-lookup"><span data-stu-id="7090f-186">Are you storing frequently used metadata about blobs in their metadata?</span></span>](#subheading20) |
| &nbsp; | <span data-ttu-id="7090f-187">Blobok</span><span class="sxs-lookup"><span data-stu-id="7090f-187">Blobs</span></span> |<span data-ttu-id="7090f-188">Gyors feltöltése</span><span class="sxs-lookup"><span data-stu-id="7090f-188">Uploading Fast</span></span> |[<span data-ttu-id="7090f-189">Mielőtt gyorsan tooupload egy blob, akkor feltölteni párhuzamos blokkok?</span><span class="sxs-lookup"><span data-stu-id="7090f-189">When trying tooupload one blob quickly, are you uploading blocks in parallel?</span></span>](#subheading21) |
| &nbsp; | <span data-ttu-id="7090f-190">Blobok</span><span class="sxs-lookup"><span data-stu-id="7090f-190">Blobs</span></span> |<span data-ttu-id="7090f-191">Gyors feltöltése</span><span class="sxs-lookup"><span data-stu-id="7090f-191">Uploading Fast</span></span> |[<span data-ttu-id="7090f-192">Mielőtt tooupload sok blobok gyorsan, akkor feltölteni párhuzamosan blobok?</span><span class="sxs-lookup"><span data-stu-id="7090f-192">When trying tooupload many blobs quickly, are you uploading blobs in parallel?</span></span>](#subheading22) |
| &nbsp; | <span data-ttu-id="7090f-193">Blobok</span><span class="sxs-lookup"><span data-stu-id="7090f-193">Blobs</span></span> |<span data-ttu-id="7090f-194">Javítsa ki a Blob típushoz</span><span class="sxs-lookup"><span data-stu-id="7090f-194">Correct Blob Type</span></span> |[<span data-ttu-id="7090f-195">Használ lapblobokat vagy adott esetben a blokkblobok?</span><span class="sxs-lookup"><span data-stu-id="7090f-195">Are you using page blobs or block blobs when appropriate?</span></span>](#subheading23) |
| &nbsp; | <span data-ttu-id="7090f-196">Táblák</span><span class="sxs-lookup"><span data-stu-id="7090f-196">Tables</span></span> |<span data-ttu-id="7090f-197">Méretezhetőségi célok</span><span class="sxs-lookup"><span data-stu-id="7090f-197">Scalability Targets</span></span> |[<span data-ttu-id="7090f-198">Vannak, megközelíti hello méretezhetőségi célok másodpercenként entitások?</span><span class="sxs-lookup"><span data-stu-id="7090f-198">Are you approaching hello scalability targets for entities per second?</span></span>](#subheading24) |
| &nbsp; | <span data-ttu-id="7090f-199">Táblák</span><span class="sxs-lookup"><span data-stu-id="7090f-199">Tables</span></span> |<span data-ttu-id="7090f-200">Konfiguráció</span><span class="sxs-lookup"><span data-stu-id="7090f-200">Configuration</span></span> |[<span data-ttu-id="7090f-201">Használ JSON-ban a tábla kérelmek?</span><span class="sxs-lookup"><span data-stu-id="7090f-201">Are you using JSON for your table requests?</span></span>](#subheading25) |
| &nbsp; | <span data-ttu-id="7090f-202">Táblák</span><span class="sxs-lookup"><span data-stu-id="7090f-202">Tables</span></span> |<span data-ttu-id="7090f-203">Konfiguráció</span><span class="sxs-lookup"><span data-stu-id="7090f-203">Configuration</span></span> |[<span data-ttu-id="7090f-204">Kikapcsolta-e kis kérelmek teljesítésének tooimprove hello Nagle?</span><span class="sxs-lookup"><span data-stu-id="7090f-204">Have you turned Nagle off tooimprove hello performance of small requests?</span></span>](#subheading26) |
| &nbsp; | <span data-ttu-id="7090f-205">Táblák</span><span class="sxs-lookup"><span data-stu-id="7090f-205">Tables</span></span> |<span data-ttu-id="7090f-206">Táblák és -partíciók</span><span class="sxs-lookup"><span data-stu-id="7090f-206">Tables and Partitions</span></span> |[<span data-ttu-id="7090f-207">Rendelkezik meg megfelelően particionálva az adatokat?</span><span class="sxs-lookup"><span data-stu-id="7090f-207">Have you properly partitioned your data?</span></span>](#subheading27) |
| &nbsp; | <span data-ttu-id="7090f-208">Táblák</span><span class="sxs-lookup"><span data-stu-id="7090f-208">Tables</span></span> |<span data-ttu-id="7090f-209">Működés közbeni partíciók</span><span class="sxs-lookup"><span data-stu-id="7090f-209">Hot Partitions</span></span> |[<span data-ttu-id="7090f-210">Fűzi, és csak illesztenie minták elkerülésére?</span><span class="sxs-lookup"><span data-stu-id="7090f-210">Are you avoiding append-only and prepend-only patterns?</span></span>](#subheading28) |
| &nbsp; | <span data-ttu-id="7090f-211">Táblák</span><span class="sxs-lookup"><span data-stu-id="7090f-211">Tables</span></span> |<span data-ttu-id="7090f-212">Működés közbeni partíciók</span><span class="sxs-lookup"><span data-stu-id="7090f-212">Hot Partitions</span></span> |[<span data-ttu-id="7090f-213">A Beszúrás/frissítés sok partíciót között van elosztva?</span><span class="sxs-lookup"><span data-stu-id="7090f-213">Are your inserts/updates spread across many partitions?</span></span>](#subheading29) |
| &nbsp; | <span data-ttu-id="7090f-214">Táblák</span><span class="sxs-lookup"><span data-stu-id="7090f-214">Tables</span></span> |<span data-ttu-id="7090f-215">Lekérdezés hatóköre</span><span class="sxs-lookup"><span data-stu-id="7090f-215">Query Scope</span></span> |[<span data-ttu-id="7090f-216">Rendelkezik a séma tooallow a legtöbb esetben és tábla lekérdezések toobe használja takarékosan használ pont lekérdezések toobe tervezett?</span><span class="sxs-lookup"><span data-stu-id="7090f-216">Have you designed your schema tooallow for point queries toobe used in most cases, and table queries toobe used sparingly?</span></span>](#subheading30) |
| &nbsp; | <span data-ttu-id="7090f-217">Táblák</span><span class="sxs-lookup"><span data-stu-id="7090f-217">Tables</span></span> |<span data-ttu-id="7090f-218">Lekérdezés sűrűség</span><span class="sxs-lookup"><span data-stu-id="7090f-218">Query Density</span></span> |[<span data-ttu-id="7090f-219">A lekérdezések általában csak vizsgálat, és térjen vissza a sorok, amelyekre az alkalmazás fogja használni?</span><span class="sxs-lookup"><span data-stu-id="7090f-219">Do your queries typically only scan and return rows that your application will use?</span></span>](#subheading31) |
| &nbsp; | <span data-ttu-id="7090f-220">Táblák</span><span class="sxs-lookup"><span data-stu-id="7090f-220">Tables</span></span> |<span data-ttu-id="7090f-221">Korlátozza az adatokat adott vissza</span><span class="sxs-lookup"><span data-stu-id="7090f-221">Limiting Returned Data</span></span> |[<span data-ttu-id="7090f-222">Nem szükséges szűrési tooavoid adatszolgáltató entitások használ?</span><span class="sxs-lookup"><span data-stu-id="7090f-222">Are you using filtering tooavoid returning entities that are not needed?</span></span>](#subheading32) |
| &nbsp; | <span data-ttu-id="7090f-223">Táblák</span><span class="sxs-lookup"><span data-stu-id="7090f-223">Tables</span></span> |<span data-ttu-id="7090f-224">Korlátozza az adatokat adott vissza</span><span class="sxs-lookup"><span data-stu-id="7090f-224">Limiting Returned Data</span></span> |[<span data-ttu-id="7090f-225">Nem szükséges tulajdonságok visszaadó leképezése tooavoid használ?</span><span class="sxs-lookup"><span data-stu-id="7090f-225">Are you using projection tooavoid returning properties that are not needed?</span></span>](#subheading33) |
| &nbsp; | <span data-ttu-id="7090f-226">Táblák</span><span class="sxs-lookup"><span data-stu-id="7090f-226">Tables</span></span> |<span data-ttu-id="7090f-227">Denormalization</span><span class="sxs-lookup"><span data-stu-id="7090f-227">Denormalization</span></span> |[<span data-ttu-id="7090f-228">Rendelkezik denormalizált az adatok úgy, hogy ne hatékony lekérdezések és több olvasási kéréseket tooget adatok közben?</span><span class="sxs-lookup"><span data-stu-id="7090f-228">Have you denormalized your data such that you avoid inefficient queries or multiple read requests when trying tooget data?</span></span>](#subheading34) |
| &nbsp; | <span data-ttu-id="7090f-229">Táblák</span><span class="sxs-lookup"><span data-stu-id="7090f-229">Tables</span></span> |<span data-ttu-id="7090f-230">Insert/Update/Delete</span><span class="sxs-lookup"><span data-stu-id="7090f-230">Insert/Update/Delete</span></span> |[<span data-ttu-id="7090f-231">Tranzakciós kell toobe vagy elvégezhető hello azonos kérelmek kötegelés tooreduce üzenetváltások idő?</span><span class="sxs-lookup"><span data-stu-id="7090f-231">Are you batching requests that need toobe transactional or can be done at hello same time tooreduce round-trips?</span></span>](#subheading35) |
| &nbsp; | <span data-ttu-id="7090f-232">Táblák</span><span class="sxs-lookup"><span data-stu-id="7090f-232">Tables</span></span> |<span data-ttu-id="7090f-233">Insert/Update/Delete</span><span class="sxs-lookup"><span data-stu-id="7090f-233">Insert/Update/Delete</span></span> |[<span data-ttu-id="7090f-234">Vannak, szükségtelenné téve az entitás csak toodetermine beolvasása e toocall beszúrásához vagy frissítéséhez?</span><span class="sxs-lookup"><span data-stu-id="7090f-234">Are you avoiding retrieving an entity just toodetermine whether toocall insert or update?</span></span>](#subheading36) |
| &nbsp; | <span data-ttu-id="7090f-235">Táblák</span><span class="sxs-lookup"><span data-stu-id="7090f-235">Tables</span></span> |<span data-ttu-id="7090f-236">Insert/Update/Delete</span><span class="sxs-lookup"><span data-stu-id="7090f-236">Insert/Update/Delete</span></span> |[<span data-ttu-id="7090f-237">Tekintette tárolja azokat a gyakran letöltött adatok együtt egyetlen entitás több entitás helyett tulajdonságként?</span><span class="sxs-lookup"><span data-stu-id="7090f-237">Have you considered storing series of data that will frequently be retrieved together in a single entity as properties instead of multiple entities?</span></span>](#subheading37) |
| &nbsp; | <span data-ttu-id="7090f-238">Táblák</span><span class="sxs-lookup"><span data-stu-id="7090f-238">Tables</span></span> |<span data-ttu-id="7090f-239">Insert/Update/Delete</span><span class="sxs-lookup"><span data-stu-id="7090f-239">Insert/Update/Delete</span></span> |[<span data-ttu-id="7090f-240">Mindig veszi együtt, és kötegekben (pl. idő adatsor) csak írható entitások akkor tekintette a blobs használata helyett táblák?</span><span class="sxs-lookup"><span data-stu-id="7090f-240">For entities that will always be retrieved together and can be written in batches (e.g. time series data), have you considered using blobs instead of tables?</span></span>](#subheading38) |
| &nbsp; | <span data-ttu-id="7090f-241">Üzenetsorok</span><span class="sxs-lookup"><span data-stu-id="7090f-241">Queues</span></span> |<span data-ttu-id="7090f-242">Méretezhetőségi célok</span><span class="sxs-lookup"><span data-stu-id="7090f-242">Scalability Targets</span></span> |[<span data-ttu-id="7090f-243">Üzenetek / másodperc vonatkoznak, megközelíti hello méretezhetőségi célok?</span><span class="sxs-lookup"><span data-stu-id="7090f-243">Are you approaching hello scalability targets for messages per second?</span></span>](#subheading39) |
| &nbsp; | <span data-ttu-id="7090f-244">Üzenetsorok</span><span class="sxs-lookup"><span data-stu-id="7090f-244">Queues</span></span> |<span data-ttu-id="7090f-245">Konfiguráció</span><span class="sxs-lookup"><span data-stu-id="7090f-245">Configuration</span></span> |[<span data-ttu-id="7090f-246">Kikapcsolta-e kis kérelmek teljesítésének tooimprove hello Nagle?</span><span class="sxs-lookup"><span data-stu-id="7090f-246">Have you turned Nagle off tooimprove hello performance of small requests?</span></span>](#subheading40) |
| &nbsp; | <span data-ttu-id="7090f-247">Üzenetsorok</span><span class="sxs-lookup"><span data-stu-id="7090f-247">Queues</span></span> |<span data-ttu-id="7090f-248">Üzenet mérete</span><span class="sxs-lookup"><span data-stu-id="7090f-248">Message Size</span></span> |[<span data-ttu-id="7090f-249">Azok az üzenetek kompakt tooimprove hello teljesítmény hello várólista?</span><span class="sxs-lookup"><span data-stu-id="7090f-249">Are your messages compact tooimprove hello performance of hello queue?</span></span>](#subheading41) |
| &nbsp; | <span data-ttu-id="7090f-250">Üzenetsorok</span><span class="sxs-lookup"><span data-stu-id="7090f-250">Queues</span></span> |<span data-ttu-id="7090f-251">Tömeges beolvasása</span><span class="sxs-lookup"><span data-stu-id="7090f-251">Bulk Retrieve</span></span> |[<span data-ttu-id="7090f-252">Egy "Get" művelettel több üzenetek fogadása?</span><span class="sxs-lookup"><span data-stu-id="7090f-252">Are you retrieving multiple messages in a single "Get" operation?</span></span>](#subheading42) |
| &nbsp; | <span data-ttu-id="7090f-253">Üzenetsorok</span><span class="sxs-lookup"><span data-stu-id="7090f-253">Queues</span></span> |<span data-ttu-id="7090f-254">Lekérdezési gyakorisága</span><span class="sxs-lookup"><span data-stu-id="7090f-254">Polling Frequency</span></span> |[<span data-ttu-id="7090f-255">Gyakran elegendő az alkalmazás késés érzékelt tooreduce hello lekérdezési?</span><span class="sxs-lookup"><span data-stu-id="7090f-255">Are you polling frequently enough tooreduce hello perceived latency of your application?</span></span>](#subheading43) |
| &nbsp; | <span data-ttu-id="7090f-256">Üzenetsorok</span><span class="sxs-lookup"><span data-stu-id="7090f-256">Queues</span></span> |<span data-ttu-id="7090f-257">Üzenet frissítése</span><span class="sxs-lookup"><span data-stu-id="7090f-257">Update Message</span></span> |[<span data-ttu-id="7090f-258">Használ UpdateMessage toostore folyamatban lévő üzenetek feldolgozása kerülése tooreprocess teljes üdvözlőüzenetére hiba esetén?</span><span class="sxs-lookup"><span data-stu-id="7090f-258">Are you using UpdateMessage toostore progress in processing messages, avoiding having tooreprocess hello entire message if an error occurs?</span></span>](#subheading44) |
| &nbsp; | <span data-ttu-id="7090f-259">Üzenetsorok</span><span class="sxs-lookup"><span data-stu-id="7090f-259">Queues</span></span> |<span data-ttu-id="7090f-260">Architektúra</span><span class="sxs-lookup"><span data-stu-id="7090f-260">Architecture</span></span> |[<span data-ttu-id="7090f-261">Használja a várólisták toomake a teljes alkalmazás több méretezhető lekapcsolva hosszan futó munkaterhelések hello kritikus elérési út és a skála majd egymástól függetlenül?</span><span class="sxs-lookup"><span data-stu-id="7090f-261">Are you using queues toomake your entire application more scalable by keeping long-running workloads out of hello critical path and scale then independently?</span></span>](#subheading45) |

## <span data-ttu-id="7090f-262"><a name="allservices"></a>Minden szolgáltatás</span><span class="sxs-lookup"><span data-stu-id="7090f-262"><a name="allservices"></a>All Services</span></span>
<span data-ttu-id="7090f-263">Ez a rész felsorolja a bevált gyakorlat, amelyek megfelelő toohello használata hello Azure Storage szolgáltatás (BLOB, táblák, üzenetsorok vagy fájlok).</span><span class="sxs-lookup"><span data-stu-id="7090f-263">This section lists proven practices that are applicable toohello use of any of hello Azure Storage services (blobs, tables, queues, or files).</span></span>  

### <span data-ttu-id="7090f-264"><a name="subheading1"></a>Méretezhetőségi célok</span><span class="sxs-lookup"><span data-stu-id="7090f-264"><a name="subheading1"></a>Scalability Targets</span></span>
<span data-ttu-id="7090f-265">Hello Azure Storage szolgáltatás mindegyikén méretezhetőségi célok kapacitás (GB), a tranzakciók sebességét és a sávszélesség.</span><span class="sxs-lookup"><span data-stu-id="7090f-265">Each of hello Azure Storage services has scalability targets for capacity (GB), transaction rate, and bandwidth.</span></span> <span data-ttu-id="7090f-266">Ha az alkalmazás megközelíti vagy meghaladja a bármely hello méretezhetőségi célok, észlelhetnek megnövekedett tranzakció késések vagy a sávszélesség-szabályozás.</span><span class="sxs-lookup"><span data-stu-id="7090f-266">If your application approaches or exceeds any of hello scalability targets, it may encounter increased transaction latencies or throttling.</span></span> <span data-ttu-id="7090f-267">Ha egy társzolgáltatás azelőtt gyorsítja fel, az alkalmazás, hello szolgáltatás megkezdi az tooreturn "503-as kiszolgáló elfoglalt" vagy "500 művelet időtúllépése" hibakódok néhány storage-tranzakció.</span><span class="sxs-lookup"><span data-stu-id="7090f-267">When a Storage service throttles your application, hello service begins tooreturn "503 Server busy" or "500 Operation timeout" error codes for some storage transactions.</span></span> <span data-ttu-id="7090f-268">Ez a szakasz ismerteti mind hello általános megközelítés toodealing méretezhetőségi célok és a sávszélesség méretezhetőségi célok különösen.</span><span class="sxs-lookup"><span data-stu-id="7090f-268">This section discusses both hello general approach toodealing with scalability targets and bandwidth scalability targets in particular.</span></span> <span data-ttu-id="7090f-269">A későbbi fejezetek, amely az egyéni tárolószolgáltatások kezelését ismertetik a méretezhetőségi célok hello környezetben, hogy adott szolgáltatás:</span><span class="sxs-lookup"><span data-stu-id="7090f-269">Later sections that deal with individual storage services discuss scalability targets in hello context of that specific service:</span></span>  

* [<span data-ttu-id="7090f-270">A BLOB sávszélesség és a kérelmek / másodperc</span><span class="sxs-lookup"><span data-stu-id="7090f-270">Blob bandwidth and requests per second</span></span>](#subheading16)
* [<span data-ttu-id="7090f-271">Táblaentitásokat / másodperc</span><span class="sxs-lookup"><span data-stu-id="7090f-271">Table entities per second</span></span>](#subheading24)
* [<span data-ttu-id="7090f-272">Várólista-üzenetek / másodperc</span><span class="sxs-lookup"><span data-stu-id="7090f-272">Queue messages per second</span></span>](#subheading39)  

#### <span data-ttu-id="7090f-273"><a name="sub1bandwidth"></a>Sávszélesség méretezhetőség cél minden szolgáltatáshoz</span><span class="sxs-lookup"><span data-stu-id="7090f-273"><a name="sub1bandwidth"></a>Bandwidth Scalability Target for All Services</span></span>
<span data-ttu-id="7090f-274">Hello írásának időpontjában, hello sávszélesség hello USA egy georedundáns tárolás (GRS) fiók célpontjai 10 Gigabit / másodperc (Gbps) – érkező (adatok küldése toohello tárfiók) és a kimenő forgalom (hello tárfiókból küldött adatok) 20 GB/s.</span><span class="sxs-lookup"><span data-stu-id="7090f-274">At hello time of writing, hello bandwidth targets in hello US for a geo-redundant storage (GRS) account are 10 gigabits per second (Gbps) for ingress (data sent toohello storage account) and 20 Gbps for egress (data sent from hello storage account).</span></span> <span data-ttu-id="7090f-275">A helyileg redundáns tárolás (LRS) fiók hello korlátok magasabbak – 20 GB/s a bemenő és kimenő forgalom esetében 30 GB/s.</span><span class="sxs-lookup"><span data-stu-id="7090f-275">For a locally redundant storage (LRS) account, hello limits are higher – 20 Gbps for ingress and 30 Gbps for egress.</span></span>  <span data-ttu-id="7090f-276">Nemzetközi sávszélességkorlátok alacsonyabb lehet, és megtalálható a [méretezhetőségi célok lap](http://msdn.microsoft.com/library/azure/dn249410.aspx).</span><span class="sxs-lookup"><span data-stu-id="7090f-276">International bandwidth limits may be lower and can be found on our [scalability targets page](http://msdn.microsoft.com/library/azure/dn249410.aspx).</span></span>  <span data-ttu-id="7090f-277">Hello redundancia tárolásáról további információkért lásd: hello hivatkozások [hasznos források](#sub1useful) alatt.</span><span class="sxs-lookup"><span data-stu-id="7090f-277">For more information on hello storage redundancy options, see hello links in [Useful Resources](#sub1useful) below.</span></span>  

#### <a name="what-toodo-when-approaching-a-scalability-target"></a><span data-ttu-id="7090f-278">Milyen toodo, amikor eléri a méretezhetőség cél</span><span class="sxs-lookup"><span data-stu-id="7090f-278">What toodo when approaching a scalability target</span></span>
<span data-ttu-id="7090f-279">Ha az alkalmazás hello méretezhetőségi célok egyetlen tárfiók közeledik, fontolja meg bevezetése hello a következő módszerek egyikét:</span><span class="sxs-lookup"><span data-stu-id="7090f-279">If your application is approaching hello scalability targets for a single storage account, consider adopting one of hello following approaches:</span></span>  

* <span data-ttu-id="7090f-280">Vizsgálja felül az alkalmazás tooapproach okozó hello munkaterhelés, vagy túlteljesíti hello méretezhetőség cél.</span><span class="sxs-lookup"><span data-stu-id="7090f-280">Reconsider hello workload that causes your application tooapproach or exceed hello scalability target.</span></span> <span data-ttu-id="7090f-281">Is tervez, másképp kisebb sávszélességet vagy a kapacitás, illetve kevesebb tranzakciók toouse?</span><span class="sxs-lookup"><span data-stu-id="7090f-281">Can you design it differently toouse less bandwidth or capacity, or fewer transactions?</span></span>
* <span data-ttu-id="7090f-282">Ha egy alkalmazás haladhatja meg a hello méretezhetőségi célok egyikét, érdemes létrehozni storage-fiókok és a partíció az alkalmazásadatok ezeket több tárfiókok között.</span><span class="sxs-lookup"><span data-stu-id="7090f-282">If an application must exceed one of hello scalability targets, you should create multiple storage accounts and partition your application data across those multiple storage accounts.</span></span> <span data-ttu-id="7090f-283">Ha ezt a mintát használja, akkor meg arról, hogy toodesign az alkalmazás, hogy a jövőbeni terheléselosztás hello további tárfiókokat adhat hozzá.</span><span class="sxs-lookup"><span data-stu-id="7090f-283">If you use this pattern, then be sure toodesign your application so that you can add more storage accounts in hello future for load balancing.</span></span> <span data-ttu-id="7090f-284">Írásának időpontjában az egyes Azure-előfizetések legfeljebb too100 tárfiókok tartalmazhat.</span><span class="sxs-lookup"><span data-stu-id="7090f-284">At time of writing, each Azure subscription can have up too100 storage accounts.</span></span>  <span data-ttu-id="7090f-285">Storage-fiókok is a használati tárolt adatokat, a végrehajtott tranzakciók vagy az átvitt adatok tekintetében eltérő költség nélkül.</span><span class="sxs-lookup"><span data-stu-id="7090f-285">Storage accounts also have no cost other than your usage in terms of data stored, transactions made, or data transferred.</span></span>
* <span data-ttu-id="7090f-286">Ha az alkalmazás találatok hello sávszélesség célozza, érdemes lehet hello tooreduce hello szükséges sávszélesség toosend hello adatok toohello tárolási ügyfélszolgáltatás az adatok tömörítése.</span><span class="sxs-lookup"><span data-stu-id="7090f-286">If your application hits hello bandwidth targets, consider compressing data in hello client tooreduce hello bandwidth required toosend hello data toohello storage service.</span></span>  <span data-ttu-id="7090f-287">Vegye figyelembe, hogy a sávszélességet, és hálózati teljesítmény javításához, azt is beállíthatja, hogy néhány negatív hatások.</span><span class="sxs-lookup"><span data-stu-id="7090f-287">Note that while this may save bandwidth and improve network performance, it can also have some negative impacts.</span></span>  <span data-ttu-id="7090f-288">Azt ki kell értékelnie hello teljesítményre gyakorolt hatását a toohello további feldolgozás követelményei tömörítése és kibontása hello ügyfél adatok miatt.</span><span class="sxs-lookup"><span data-stu-id="7090f-288">You should evaluate hello performance impact of this due toohello additional processing requirements for compressing and decompressing data in hello client.</span></span> <span data-ttu-id="7090f-289">Emellett a tömörített adatok tárolása teheti nehezebb tootroubleshoot problémák óta nehezebb tooview tárolt adatok szabványos eszközökkel lehet.</span><span class="sxs-lookup"><span data-stu-id="7090f-289">In addition, storing compressed data can make it more difficult tootroubleshoot issues since it could be more difficult tooview stored data using standard tools.</span></span>
* <span data-ttu-id="7090f-290">Ha az alkalmazás hello méretezhetőségi célok találatok, majd győződjön meg arról, hogy egy exponenciális leállítási újrapróbálkozások használ (lásd: [újrapróbálkozások](#subheading14)).</span><span class="sxs-lookup"><span data-stu-id="7090f-290">If your application hits hello scalability targets, then ensure that you are using an exponential backoff for retries (see [Retries](#subheading14)).</span></span>  <span data-ttu-id="7090f-291">Annak jobb toomake meg arról, hogy soha nem megközelíti az hello méretezhetőségi célok (egyikével hello módszerek fent), de ezzel biztosíthatja, hogy az alkalmazás nem csak tartsa gyorsan újrapróbálkozás biztosít, ami még rosszabb szabályozás hello.</span><span class="sxs-lookup"><span data-stu-id="7090f-291">It's better toomake sure you never approach hello scalability targets (by using one of hello above methods), but this will ensure your application won't just keep retrying rapidly, making hello throttling worse.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="7090f-292">Hasznos segédanyagok</span><span class="sxs-lookup"><span data-stu-id="7090f-292">Useful Resources</span></span>
<span data-ttu-id="7090f-293">a következő hivatkozások hello méretezhetőségi célok részletesebben is biztosítanak:</span><span class="sxs-lookup"><span data-stu-id="7090f-293">hello following links provide additional detail on scalability targets:</span></span>

* <span data-ttu-id="7090f-294">Lásd: [Azure Storage méretezhetőségi és teljesítménycéloknak](storage-scalability-targets.md) méretezhetőségi célok kapcsolatos információkat.</span><span class="sxs-lookup"><span data-stu-id="7090f-294">See [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md) for information about scalability targets.</span></span>
* <span data-ttu-id="7090f-295">Lásd: [Azure Storage replikációs](storage-redundancy.md) és hello blogbejegyzés [Azure tárolási redundancia lehetőségek és az írásvédett Georedundáns redundáns tárolás](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/11/introducing-read-access-geo-replicated-storage-ra-grs-for-windows-azure-storage.aspx) tárolási redundancia beállításokkal kapcsolatos információkért.</span><span class="sxs-lookup"><span data-stu-id="7090f-295">See [Azure Storage replication](storage-redundancy.md) and hello blog post [Azure Storage Redundancy Options and Read Access Geo Redundant Storage](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/11/introducing-read-access-geo-replicated-storage-ra-grs-for-windows-azure-storage.aspx) for information about storage redundancy options.</span></span>
* <span data-ttu-id="7090f-296">Az Azure szolgáltatások árazással kapcsolatos aktuális információkért lásd: [Azure-beli árakról](https://azure.microsoft.com/pricing/overview/).</span><span class="sxs-lookup"><span data-stu-id="7090f-296">For current information about pricing for Azure services, see [Azure pricing](https://azure.microsoft.com/pricing/overview/).</span></span>  

### <span data-ttu-id="7090f-297"><a name="subheading47"></a>Partíció elnevezési egyezmény</span><span class="sxs-lookup"><span data-stu-id="7090f-297"><a name="subheading47"></a>Partition Naming Convention</span></span>
<span data-ttu-id="7090f-298">Az Azure Storage használja a tartomány particionálási séma tooscale és a terhelés elosztása hello rendszerbe.</span><span class="sxs-lookup"><span data-stu-id="7090f-298">Azure Storage uses a range-based partitioning scheme tooscale and load balance hello system.</span></span> <span data-ttu-id="7090f-299">hello partíciókulcs tartományok használt toopartition adatokat pedig a tartományok terhelésű hello rendszer között.</span><span class="sxs-lookup"><span data-stu-id="7090f-299">hello partition key is used toopartition data into ranges and these ranges are load-balanced across hello system.</span></span> <span data-ttu-id="7090f-300">Ez azt jelenti, hogy elnevezési konvenciókat például lexikális rendezés (pl. msftpayroll, msftperformance, msftemployees stb) vagy időbélyegeket (log20160101, log20160102, log20160102, stb.) használatával lesz alkalmasnak alatt esetlegesen közös elhelyezésű hello toohello partíciók ugyanazon partíció a kiszolgálón, amíg egy terheléselosztási művelet felosztja a őket ki kisebb tartományt.</span><span class="sxs-lookup"><span data-stu-id="7090f-300">This means naming conventions such as lexical ordering (e.g. msftpayroll, msftperformance, msftemployees, etc) or using time-stamps (log20160101, log20160102, log20160102, etc) will lend itself toohello partitions being potentially co-located on hello same partition server, until a load balancing operation splits them out into smaller ranges.</span></span> <span data-ttu-id="7090f-301">Például a tárolóban lévő összes BLOB szolgáltatható egyetlen kiszolgáló amíg hello a blobok terhelése szükséges további újraelosztás hello partíció tartományait.</span><span class="sxs-lookup"><span data-stu-id="7090f-301">For example, all blobs within a container can be served by a single server until hello load on these blobs requires further rebalancing of hello partition ranges.</span></span> <span data-ttu-id="7090f-302">Ehhez hasonlóan a nevük lexikális sorrendbe rendezve enyhén betöltött fiókoknak csoport kezdeményezheti a egyetlen kiszolgáló hello csak egy betöltése vagy az összes ezeket a fiókokat szükségesek őket toobe felosztása több partíció-kiszolgálón.</span><span class="sxs-lookup"><span data-stu-id="7090f-302">Similarly, a group of lightly loaded accounts with their names arranged in lexical order may be served by a single server until hello load on one or all of these accounts require them toobe split across multiple partitions servers.</span></span> <span data-ttu-id="7090f-303">Minden terheléselosztási művelet hatással lehet a hello késés tárolási hívások hello művelet során.</span><span class="sxs-lookup"><span data-stu-id="7090f-303">Each load balancing operation may impact hello latency of storage calls during hello operation.</span></span> <span data-ttu-id="7090f-304">hello rendszer képes toohandle forgalom tooa partíció hirtelen kapacitásnövelés korlátozza az egypartíciós kiszolgáló hello méretezhetőség hello terheléselosztási művelet csak megrúgni-a, és újra egyensúlyba hozza a hello kulcs partíciótartomány.</span><span class="sxs-lookup"><span data-stu-id="7090f-304">hello system's ability toohandle a sudden burst of traffic tooa partition is limited by hello scalability of a single partition server until hello load balancing operation kicks-in and rebalances hello partition key range.</span></span>  

<span data-ttu-id="7090f-305">Néhány ajánlott eljárások tooreduce hello gyakorisága az ilyen műveletek követésével.</span><span class="sxs-lookup"><span data-stu-id="7090f-305">You can follow some best practices tooreduce hello frequency of such operations.</span></span>  

* <span data-ttu-id="7090f-306">Vizsgálja meg a hello elnevezési konvenciót kell használni a fiókok, tárolók, blobok, táblák és várólisták, kiszűrése alapos figyelmet igényel.</span><span class="sxs-lookup"><span data-stu-id="7090f-306">Examine hello naming convention you use for accounts, containers, blobs, tables and queues, closely.</span></span> <span data-ttu-id="7090f-307">Fontolja meg a kivonatoló függvénnyel az igényeinek leginkább megfelelő 3 számjegyű kivonatát a fióknevek előtag.</span><span class="sxs-lookup"><span data-stu-id="7090f-307">Consider prefixing account names with a 3-digit hash using a hashing function that best suits your needs.</span></span>  
* <span data-ttu-id="7090f-308">Időbélyeg helyi időre vagy numerikus azonosítók használata esetén az adatok rendezéséhez nem használ egy csak append (vagy csak illesztenie) forgalmat tooensure lesz.</span><span class="sxs-lookup"><span data-stu-id="7090f-308">If you organize your data using timestamps or numerical identifiers, you have tooensure you are not using an append-only (or prepend-only) traffic patterns.</span></span> <span data-ttu-id="7090f-309">Ezek a minták nincsenek megfelelő-e a tartomány-alapú particionálási rendszert, és sikerült átfutási tooall hello forgalom folyamatos tooa egyetlen partícióra és a korlátozó hello rendszer hatékonyan terheléselosztás.</span><span class="sxs-lookup"><span data-stu-id="7090f-309">These patterns are not suitable for a range -based partitioning system, and could lead tooall hello traffic going tooa single partition and limiting hello system from effectively load balancing.</span></span> <span data-ttu-id="7090f-310">Például ha naponta egy blob objektumot az időbélyegzőnek ÉÉÉÉHHNN, majd az összes hello adatforgalmat például napi művelet használó műveletek tooa egyetlen objektumon, amelynek egyetlen partíció-kiszolgáló által kiszolgált irányítja.</span><span class="sxs-lookup"><span data-stu-id="7090f-310">For instance, if you have daily operations that use a blob object with a timestamp such as yyyymmdd, then all hello traffic for that daily operation is directed tooa single object which is served by a single partition server.</span></span> <span data-ttu-id="7090f-311">Tekintse meg e hello blob korlátokat és partíciónként korlátozza megfelel az igényeinek, és vegye figyelembe, ez a művelet ossza több blobokat, ha szükséges.</span><span class="sxs-lookup"><span data-stu-id="7090f-311">Look at whether hello per blob limits and per partition limits meet your needs, and consider breaking this operation into multiple blobs if needed.</span></span> <span data-ttu-id="7090f-312">Ehhez hasonlóan idő adatsorozat adat tárolása a táblák, ha minden hello forgalom lehet hello kulcs névtér utolsó része toohello irányítva.</span><span class="sxs-lookup"><span data-stu-id="7090f-312">Similarly, if you store time series data in your tables, all hello traffic could be directed toohello last part of hello key namespace.</span></span> <span data-ttu-id="7090f-313">Időbélyeg helyi időre vagy numerikus azonosítót kell használnia, ha előtag hello azonosító 3 számjegyű kivonatát, illetve időbélyegeket előtag hello másodperc részét hello idő például ssyyyymmdd hello esetében.</span><span class="sxs-lookup"><span data-stu-id="7090f-313">If you must use timestamps or numerical IDs, prefix hello id with a 3-digit hash, or in hello case of timestamps prefix hello seconds part of hello time such as ssyyyymmdd.</span></span> <span data-ttu-id="7090f-314">Ha listázása, és lekérdezi-műveleteket rendszeresen hajtja végre, válassza ki a kivonatoló függvényt, amely korlátozza a lekérdezések száma.</span><span class="sxs-lookup"><span data-stu-id="7090f-314">If listing and querying operations are routinely performed, choose a hashing function that will limit your number of queries.</span></span> <span data-ttu-id="7090f-315">Egyéb esetben véletlenszerű előtag elegendő lehet.</span><span class="sxs-lookup"><span data-stu-id="7090f-315">In other cases, a random prefix may be sufficient.</span></span>  
* <span data-ttu-id="7090f-316">Az Azure Storage használt séma particionálás hello további információkért olvassa el a hello SOSP paper [Itt](http://sigops.org/sosp/sosp11/current/2011-Cascais/printable/11-calder.pdf).</span><span class="sxs-lookup"><span data-stu-id="7090f-316">For additional information on hello partitioning scheme used in Azure Storage, read hello SOSP paper [here](http://sigops.org/sosp/sosp11/current/2011-Cascais/printable/11-calder.pdf).</span></span>

### <a name="networking"></a><span data-ttu-id="7090f-317">Hálózat</span><span class="sxs-lookup"><span data-stu-id="7090f-317">Networking</span></span>
<span data-ttu-id="7090f-318">Amíg hello API függetlenül attól, hogy hívja, gyakran hello fizikai hálózati megkötések hello alkalmazás jelentős hatást a teljesítményre.</span><span class="sxs-lookup"><span data-stu-id="7090f-318">While hello API calls matter, often hello physical network constraints of hello application have a significant impact on performance.</span></span> <span data-ttu-id="7090f-319">hello alábbiakban ismertetjük azok néhány felhasználók szembesülhetnek korlátozások.</span><span class="sxs-lookup"><span data-stu-id="7090f-319">hello following describe some of limitations users may encounter.</span></span>  

#### <a name="client-network-capability"></a><span data-ttu-id="7090f-320">Ügyfél hálózati funkció</span><span class="sxs-lookup"><span data-stu-id="7090f-320">Client Network Capability</span></span>
##### <span data-ttu-id="7090f-321"><a name="subheading2"></a>Átviteli sebesség</span><span class="sxs-lookup"><span data-stu-id="7090f-321"><a name="subheading2"></a>Throughput</span></span>
<span data-ttu-id="7090f-322">A sávszélesség-hello probléma legtöbbször hello ügyfél hello képességeit.</span><span class="sxs-lookup"><span data-stu-id="7090f-322">For bandwidth, hello problem is often hello capabilities of hello client.</span></span> <span data-ttu-id="7090f-323">Például egy tárfiók kezelni tud a 10 GB/s, vagy több érkező közben (lásd: [sávszélesség méretezhetőségi célok](#sub1bandwidth)), hálózati sebesség hello a "Kicsi" Azure feldolgozói szerepkör példánya csak képes a körülbelül 100 MB/s.</span><span class="sxs-lookup"><span data-stu-id="7090f-323">For example, while a single storage account can handle 10 Gbps or more of ingress (see [bandwidth scalability targets](#sub1bandwidth)), hello network speed in a "Small" Azure Worker Role instance is only capable of approximately 100 Mbps.</span></span> <span data-ttu-id="7090f-324">Nagyobb méretű Azure-példányokon a hálózati adapterek nagyobb kapacitással rendelkező rendelkezik, ezért érdemes egy nagyobb példányt, vagy több virtuális gép használ, ha nagyobb hálózati korlátok egyetlen számítógépről van szüksége.</span><span class="sxs-lookup"><span data-stu-id="7090f-324">Larger Azure instances have NICs with greater capacity, so you should consider using a larger instance or more VM's if you need higher network limits from a single machine.</span></span> <span data-ttu-id="7090f-325">Ha egy társzolgáltatás on-premises alkalmazásból fér hozzá, akkor hello ugyanaz a szabály vonatkozik: hello hálózati képességekről hello ügyféleszköz- és hello hálózati kapcsolat toohello Azure tárolási helye az és vagy-javítása céljából igény szerint vagy Tervezze meg az alkalmazás toowork belül képességeit.</span><span class="sxs-lookup"><span data-stu-id="7090f-325">If you are accessing a Storage service from an on premises application, then hello same rule applies: understand hello network capabilities of hello client device and hello network connectivity toohello Azure Storage location and either improve them as needed or design your application toowork within their capabilities.</span></span>  

##### <span data-ttu-id="7090f-326"><a name="subheading3"></a>Hivatkozás minősége</span><span class="sxs-lookup"><span data-stu-id="7090f-326"><a name="subheading3"></a>Link Quality</span></span>
<span data-ttu-id="7090f-327">Csakúgy, mint bármely hálózathasználatot, vegye figyelembe, hogy hálózati körülmények hibák és a csomagveszteség lassú-e a hatékony átviteli sebességet.</span><span class="sxs-lookup"><span data-stu-id="7090f-327">As with any network usage, be aware that network conditions resulting in errors and packet loss will slow effective throughput.</span></span>  <span data-ttu-id="7090f-328">WireShark vagy NetMon segítséget nyújthat a probléma diagnosztizálásához.</span><span class="sxs-lookup"><span data-stu-id="7090f-328">Using WireShark or NetMon may help in diagnosing this issue.</span></span>  

##### <a name="useful-resources"></a><span data-ttu-id="7090f-329">Hasznos segédanyagok</span><span class="sxs-lookup"><span data-stu-id="7090f-329">Useful Resources</span></span>
<span data-ttu-id="7090f-330">További információ a virtuálisgép-méretek és a hozzárendelt sávszélesség: [Windows Virtuálisgép-méretek](../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) vagy [Linux Virtuálisgép-méretek](../virtual-machines/linux/sizes.md?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).</span><span class="sxs-lookup"><span data-stu-id="7090f-330">For more information about virtual machine sizes and allocated bandwidth, see [Windows VM sizes](../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) or [Linux VM sizes](../virtual-machines/linux/sizes.md?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).</span></span>  

#### <span data-ttu-id="7090f-331"><a name="subheading4"></a>Hely</span><span class="sxs-lookup"><span data-stu-id="7090f-331"><a name="subheading4"></a>Location</span></span>
<span data-ttu-id="7090f-332">Minden elosztott környezetben hello ügyfél közelében toohello kiszolgáló elhelyezése nyújt a hello lehető legjobb teljesítményt.</span><span class="sxs-lookup"><span data-stu-id="7090f-332">In any distributed environment, placing hello client near toohello server delivers in hello best performance.</span></span> <span data-ttu-id="7090f-333">Az Azure Storage elérése hello legkisebb mértékű késleltetést, hello ajánlott az ügyfél helye hello belül azonos Azure-régiót.</span><span class="sxs-lookup"><span data-stu-id="7090f-333">For accessing Azure Storage with hello lowest latency, hello best location for your client is within hello same Azure region.</span></span> <span data-ttu-id="7090f-334">Például ha egy Azure Storage használó Azure-webhelyet, akkor kell helyezni őket mindkét (például US nyugati vagy Ázsia délkeleti) egyetlen régión belül.</span><span class="sxs-lookup"><span data-stu-id="7090f-334">For example, if you have an Azure Web Site that uses Azure Storage, you should locate them both within a single region (for example, US West or Asia Southeast).</span></span> <span data-ttu-id="7090f-335">Ez csökkenti a hello késést és a költségeket, hello – hello írásának időpontjában, sávszélesség-használat egy szabad.</span><span class="sxs-lookup"><span data-stu-id="7090f-335">This reduces hello latency and hello cost — at hello time of writing, bandwidth usage within a single region is free.</span></span>  

<span data-ttu-id="7090f-336">Ha az alkalmazások nem található Azure-ban (például a mobileszköz-alkalmazások vagy a helyi vállalati szolgáltatások), majd újra ügyfél hello tárfiókot, elérő toohello eszközt közeli régióban helyezi el lesz általában késés csökkentésére.</span><span class="sxs-lookup"><span data-stu-id="7090f-336">If your client applications are not hosted within Azure (such as mobile device apps or on premises enterprise services), then again placing hello storage account in a region near toohello devices that will access it, will generally reduce latency.</span></span> <span data-ttu-id="7090f-337">Ha az ügyfelek széles körű terjesztése (a példában, néhány Észak-Amerikában, és néhány, az Európai), akkor érdemes több tárfiókot használ: egy Észak-amerikai régió, a másik egy Európai régióban található.</span><span class="sxs-lookup"><span data-stu-id="7090f-337">If your clients are broadly distributed (for example, some in North America, and some in Europe), then you should consider using multiple storage accounts: one located in a North American region and one in a European region.</span></span> <span data-ttu-id="7090f-338">Ez segít tooreduce késés mindkét régióban lévő felhasználók számára.</span><span class="sxs-lookup"><span data-stu-id="7090f-338">This will help tooreduce latency for users in both regions.</span></span> <span data-ttu-id="7090f-339">Ez a megközelítés esetén általában egyszerűbb tooimplement hello hello alkalmazás adattárolókhoz adott tooindividual felhasználók, és nem igényel storage-fiókok közötti adatreplikálás.</span><span class="sxs-lookup"><span data-stu-id="7090f-339">This approach is usually easier tooimplement if hello data hello application stores is specific tooindividual users, and does not require replicating data between storage accounts.</span></span>  <span data-ttu-id="7090f-340">A széles körű tartalmak terjesztéséhez CDN ajánlott – hello további részleteket a következő szakaszban talál.</span><span class="sxs-lookup"><span data-stu-id="7090f-340">For broad content distribution, a CDN is recommended – see hello next section for more details.</span></span>  

### <span data-ttu-id="7090f-341"><a name="subheading5"></a>Tartalom terjesztése</span><span class="sxs-lookup"><span data-stu-id="7090f-341"><a name="subheading5"></a>Content Distribution</span></span>
<span data-ttu-id="7090f-342">Egyes esetekben az alkalmazás igényeinek tooserve hello azonos tartalom toomany felhasználók (például a termék bemutató videó hello kezdőlap webhely használt), vagy található hello azonos, vagy több.</span><span class="sxs-lookup"><span data-stu-id="7090f-342">Sometimes, an application needs tooserve hello same content toomany users (e.g. a product demo video used in hello home page of a website), located in either hello same or multiple regions.</span></span> <span data-ttu-id="7090f-343">Ebben a forgatókönyvben egy Content Delivery Network (CDN) például az Azure CDN-t kell használnia, hello CDN volna használják, az Azure storage hello hello adatok forrása.</span><span class="sxs-lookup"><span data-stu-id="7090f-343">In this scenario, you should use a Content Delivery Network (CDN) such as Azure CDN, and hello CDN would use Azure storage as hello origin of hello data.</span></span> <span data-ttu-id="7090f-344">Egy Azure Storage-fiókot, amely egy régió létezik, és, hogy nem továbbítanak tartalmat, kisebb késést tooother régiók, eltérően Azure CDN hello világ több adatközpontokban kiszolgálót használ.</span><span class="sxs-lookup"><span data-stu-id="7090f-344">Unlike an Azure Storage account that exists in a single region and that cannot deliver content with low latency tooother regions, Azure CDN uses servers in multiple data centers around hello world.</span></span> <span data-ttu-id="7090f-345">Emellett a CDN általában támogathat egyetlen tárfiók sokkal nagyobb kimenő korlátokat.</span><span class="sxs-lookup"><span data-stu-id="7090f-345">Additionally, a CDN can typically support much higher egress limits than a single storage account.</span></span>  

<span data-ttu-id="7090f-346">Azure CDN kapcsolatos további információkért lásd: [Azure CDN](https://azure.microsoft.com/services/cdn/).</span><span class="sxs-lookup"><span data-stu-id="7090f-346">For more information about Azure CDN, see [Azure CDN](https://azure.microsoft.com/services/cdn/).</span></span>  

### <span data-ttu-id="7090f-347"><a name="subheading6"></a>SAS és a CORS használatával</span><span class="sxs-lookup"><span data-stu-id="7090f-347"><a name="subheading6"></a>Using SAS and CORS</span></span>
<span data-ttu-id="7090f-348">Tooauthorize kód például a JavaScriptek egy webes böngésző vagy a mobiltelefon tooaccess alkalmazásadatok az Azure Storage van szüksége, amikor egyik módszer-e az alkalmazás webes szerepkör proxyként toouse: hello felhasználó eszközén végzi a hitelesítést hello webes szerepkör, amely a bekapcsolása hello tároló szolgáltatás végzi a hitelesítést.</span><span class="sxs-lookup"><span data-stu-id="7090f-348">When you need tooauthorize code such as JavaScript in a user's web browser or a mobile phone app tooaccess data in Azure Storage, one approach is toouse an application in web role as a proxy: hello user's device authenticates with hello web role, which in turn authenticates with hello storage service.</span></span> <span data-ttu-id="7090f-349">Ezzel a módszerrel elkerülhetők a teszi ki a tárfiók kulcsait a nem biztonságos eszközökön.</span><span class="sxs-lookup"><span data-stu-id="7090f-349">In this way, you can avoid exposing your storage account keys on insecure devices.</span></span> <span data-ttu-id="7090f-350">Azonban ez elhelyez egy nagy terhelés hello webes szerepkör hello felhasználó-eszköz között továbbított összes hello adatot, mert a hello társzolgáltatás kell haladnia hello webes szerepkör.</span><span class="sxs-lookup"><span data-stu-id="7090f-350">However, this places a big overhead on hello web role because all hello data transferred between hello user's device and hello storage service must pass through hello web role.</span></span> <span data-ttu-id="7090f-351">Elkerülheti a webes szerepkör alapján proxyként hello társzolgáltatás megosztott hozzáférési aláírásokkal (SAS), egyes esetekben a fejlécek eltérő eredetű erőforrások megosztása (CORS) együtt.</span><span class="sxs-lookup"><span data-stu-id="7090f-351">You can avoid using a web role as a proxy for hello storage service by using Shared Access Signatures (SAS), sometimes in conjunction with Cross-Origin Resource Sharing headers (CORS).</span></span> <span data-ttu-id="7090f-352">Az SAS segítségével engedélyezheti a felhasználói eszköz toomake kérelmek közvetlen tooa storage szolgáltatást egy korlátozott hozzáférési jogkivonat segítségével.</span><span class="sxs-lookup"><span data-stu-id="7090f-352">Using SAS, you can allow your user's device toomake requests directly tooa storage service by means of a limited access token.</span></span> <span data-ttu-id="7090f-353">Például ha egy felhasználó azt szeretné, hogy egy fényképező tooyour alkalmazás tooupload, a webes szerepkör is létrehozó és küldő toohello felhasználó eszközén egy SAS-jogkivonatot, amely engedélyezi a következő 30 perc (amely után hello SAS-jogkivonat lejár) toowrite tooa adott engedélyblobja vagy hello tárolója.</span><span class="sxs-lookup"><span data-stu-id="7090f-353">For example, if a user wants tooupload a photo tooyour application, your web role can generate and send toohello user's device a SAS token that grants permission toowrite tooa specific blob or container for hello next 30 minutes (after which hello SAS token expires).</span></span>

<span data-ttu-id="7090f-354">Általában a böngésző nem engedélyezi a JavaScript egy webhelyet egy tartományi tooperform bizonyos műveletek, például a "PUT" tooanother tartomány által üzemeltetett lapon.</span><span class="sxs-lookup"><span data-stu-id="7090f-354">Normally, a browser will not allow JavaScript in a page hosted by a website on one domain tooperform specific operations such as a "PUT" tooanother domain.</span></span> <span data-ttu-id="7090f-355">Például, ha a webes szerepkör "contosomarketing.cloudapp.net" és a kívánt toouse ügyfél ügyféloldali JavaScript tooupload egy blob tooyour tárfiók "contosoproducts.blob.core.windows.net" működteti, hello böngésző "azonos származási policy" fog megtiltják a a műveletet.</span><span class="sxs-lookup"><span data-stu-id="7090f-355">For example, if you host a web role at "contosomarketing.cloudapp.net," and want toouse client side JavaScript tooupload a blob tooyour storage account at "contosoproducts.blob.core.windows.net," hello browser's "same origin policy" will forbid this operation.</span></span> <span data-ttu-id="7090f-356">A CORS egy funkciója, amely lehetővé teszi a hello cél tartományában (Ez esetben hello a tárfiók) toocommunicate toohello böngésző megbízhatónak hello forrástartomány (a kis hello webes szerepkör) származó kérelmek.</span><span class="sxs-lookup"><span data-stu-id="7090f-356">CORS is a browser feature that allows hello target domain (in this case hello storage account) toocommunicate toohello browser that it trusts requests originating in hello source domain (in this case hello web role).</span></span>  

<span data-ttu-id="7090f-357">Mindkét technológiát segítségével elkerülhető szükségtelen terhelés (és a szűk keresztmetszeteket) a webalkalmazáshoz.</span><span class="sxs-lookup"><span data-stu-id="7090f-357">Both of these technologies can help you avoid unnecessary load (and bottlenecks) on your web application.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="7090f-358">Hasznos segédanyagok</span><span class="sxs-lookup"><span data-stu-id="7090f-358">Useful Resources</span></span>
<span data-ttu-id="7090f-359">További információ a SAS: [megosztott hozzáférési aláírásokkal, 1. rész: Understanding hello SAS-modell](storage-dotnet-shared-access-signature-part-1.md).</span><span class="sxs-lookup"><span data-stu-id="7090f-359">For more information about SAS, see [Shared Access Signatures, Part 1: Understanding hello SAS Model](storage-dotnet-shared-access-signature-part-1.md).</span></span>  

<span data-ttu-id="7090f-360">További információ a CORS: [hello Azure Storage szolgáltatásainak Cross-Origin Resource Sharing (CORS) támogatása](http://msdn.microsoft.com/library/azure/dn535601.aspx).</span><span class="sxs-lookup"><span data-stu-id="7090f-360">For more information about CORS, see [Cross-Origin Resource Sharing (CORS) Support for hello Azure Storage Services](http://msdn.microsoft.com/library/azure/dn535601.aspx).</span></span>  

### <a name="caching"></a><span data-ttu-id="7090f-361">Gyorsítótárazás</span><span class="sxs-lookup"><span data-stu-id="7090f-361">Caching</span></span>
#### <span data-ttu-id="7090f-362"><a name="subheading7"></a>Adatok beolvasása</span><span class="sxs-lookup"><span data-stu-id="7090f-362"><a name="subheading7"></a>Getting Data</span></span>
<span data-ttu-id="7090f-363">Adatok lekérése egy szolgáltatás egyszer általában jobb, mint az első azt kétszer.</span><span class="sxs-lookup"><span data-stu-id="7090f-363">In general, getting data from a service once is better than getting it twice.</span></span> <span data-ttu-id="7090f-364">Fontolja meg egy webes szerepkör, amely már rendelkezik 50MB blob beolvasni hello tárolási szolgáltatás tooserve tartalom tooa felhasználóként fut MVC webalkalmazás hello példát.</span><span class="sxs-lookup"><span data-stu-id="7090f-364">Consider hello example of an MVC web application running in a web role that has already retrieved a 50MB blob from hello storage service tooserve as content tooa user.</span></span> <span data-ttu-id="7090f-365">hello alkalmazás sikerült beolvasásához, hogy ugyanazt a blob minden alkalommal, amikor a felhasználó azt kéri, vagy azt sikerült gyorsítótárazása azt helyileg toodisk és újbóli hello gyorsítótárazott verzió a következő felhasználói kéréseket.</span><span class="sxs-lookup"><span data-stu-id="7090f-365">hello application could then retrieve that same blob every time a user requests it, or it could cache it locally toodisk and reuse hello cached version for subsequent user requests.</span></span> <span data-ttu-id="7090f-366">Továbbá amikor egy felhasználó hello adatokat kér, hello alkalmazás problémát sikerült feltételes fejlécet beállítani a módosítás időpontja, amelyek a volna hello teljes blob lekérése, ha még nem lett módosítva.</span><span class="sxs-lookup"><span data-stu-id="7090f-366">Furthermore, whenever a user requests hello data, hello application could issue GET with a conditional header for modification time, which would avoid getting hello entire blob if it hasn't been modified.</span></span> <span data-ttu-id="7090f-367">A táblaentitásokat a azonos mintát tooworking is alkalmazhatja.</span><span class="sxs-lookup"><span data-stu-id="7090f-367">You can apply this same pattern tooworking with table entities.</span></span>  

<span data-ttu-id="7090f-368">Bizonyos esetekben dönthet úgy, hogy az alkalmazás-emeléssel felveheti azt, és a során ez idő alatt hello alkalmazást nem kell toocheck hello blob módosításakor beolvasása után rövid ideig érvényes marad, hogy a hello blob.</span><span class="sxs-lookup"><span data-stu-id="7090f-368">In some cases, you may decide that your application can assume that hello blob remains valid for a short period after retrieving it, and that during this period hello application does not need toocheck if hello blob was modified.</span></span>

<span data-ttu-id="7090f-369">Konfiguráció, a keresési és az egyéb adatok mindig hello alkalmazás által használt rendszer deduplikációra kiválóan alkalmas jelöltek a gyorsítótárazáshoz.</span><span class="sxs-lookup"><span data-stu-id="7090f-369">Configuration, lookup, and other data that are always used by hello application are great candidates for caching.</span></span>  

<span data-ttu-id="7090f-370">Például hogyan tooget egy blob tulajdonságai toodiscover hello utolsó módosításának dátuma használata a .NET, lásd: [Set, a Tulajdonságok beolvasása és a metaadatok](storage-properties-metadata.md).</span><span class="sxs-lookup"><span data-stu-id="7090f-370">For an example of how tooget a blob's properties toodiscover hello last modified date using .NET, see [Set and Retrieve Properties and Metadata](storage-properties-metadata.md).</span></span> <span data-ttu-id="7090f-371">Feltételes letöltéseire vonatkozó további információkért lásd: [feltételesen frissítése a helyi másolat készítése a Blob](http://msdn.microsoft.com/library/azure/dd179371.aspx).</span><span class="sxs-lookup"><span data-stu-id="7090f-371">For more information about conditional downloads, see [Conditionally Refresh a Local Copy of a Blob](http://msdn.microsoft.com/library/azure/dd179371.aspx).</span></span>  

#### <span data-ttu-id="7090f-372"><a name="subheading8"></a>Adatok kötegelt feltöltése</span><span class="sxs-lookup"><span data-stu-id="7090f-372"><a name="subheading8"></a>Uploading Data in Batches</span></span>
<span data-ttu-id="7090f-373">Néhány alkalmazás esetben összesíteni az adatokat helyileg, és majd rendszeres időközönként töltse fel egy kötegben minden adat azonnal feltöltése helyett.</span><span class="sxs-lookup"><span data-stu-id="7090f-373">In some application scenarios, you can aggregate data locally, and then periodically upload it in a batch instead of uploading each piece of data immediately.</span></span> <span data-ttu-id="7090f-374">Például egy webes alkalmazás előfordulhat, hogy tartsa a tevékenységek naplófájl: hello alkalmazás sikerült vagy feltöltése minden tevékenység részleteinek akkor fordul elő, a tábla egységként (amelyhez szükséges számos tárolási műveletek), vagy azt sikerült tevékenység részletei tooa helyi naplófájl mentése, majd rendszeres időközönként töltse fel az összes tevékenység részletei tagolt fájl tooa blob-ként.</span><span class="sxs-lookup"><span data-stu-id="7090f-374">For example, a web application might keep a log file of activities: hello application could either upload details of every activity as it happens as a table entity (which requires many storage operations), or it could save activity details tooa local log file, and then periodically upload all activity details as a delimited file tooa blob.</span></span> <span data-ttu-id="7090f-375">Ha minden naplóbejegyzés 1KB-nál, feltöltheti a több ezer (tölthet fel egy tranzakción belül mérete too64MB a blob) egy "Put Blob" tranzakción belül.</span><span class="sxs-lookup"><span data-stu-id="7090f-375">If each log entry is 1KB in size, you can upload thousands in a single "Put Blob" transaction (you can upload a blob of up too64MB in size in a single transaction).</span></span> <span data-ttu-id="7090f-376">Természetesen hello helyi számítógép összeomlik előzetes toohello feltöltési, potenciálisan elvész néhány naplóadatok: hello alkalmazásfejlesztő kell az ügyféleszközön hello lehetőségét tervezi vagy annak feltöltése sikertelen.</span><span class="sxs-lookup"><span data-stu-id="7090f-376">Of course, if hello local machine crashes prior toohello upload, you will potentially lose some log data: hello application developer must design for hello possibility of client device or upload failures.</span></span>  <span data-ttu-id="7090f-377">Ha hello tevékenység adatok toobe timespans (csak egyetlen tevékenység) le van szüksége, majd blobok javasoltak táblák keresztül.</span><span class="sxs-lookup"><span data-stu-id="7090f-377">If hello activity data needs toobe downloaded for timespans (not just single activity), then blobs are recommended over tables.</span></span>

### <a name="net-configuration"></a><span data-ttu-id="7090f-378">.NET-konfiguráció</span><span class="sxs-lookup"><span data-stu-id="7090f-378">.NET Configuration</span></span>
<span data-ttu-id="7090f-379">Ha a .NET-keretrendszer használatával hello, ez a szakasz számos gyors konfigurációs beállítások, amelyeket felhasználhat toomake jelentős teljesítményjavulást eredményezhet.</span><span class="sxs-lookup"><span data-stu-id="7090f-379">If using hello .NET Framework, this section lists several quick configuration settings that you can use toomake significant performance improvements.</span></span>  <span data-ttu-id="7090f-380">Ha használ egyéb nyelvek, toosee ellenőrizze, hogy a hasonló fogalmak alkalmazza a kiválasztott nyelven.</span><span class="sxs-lookup"><span data-stu-id="7090f-380">If using other languages, check toosee if similar concepts apply in your chosen language.</span></span>  

#### <span data-ttu-id="7090f-381"><a name="subheading9"></a>Alapértelmezett korlát növelése</span><span class="sxs-lookup"><span data-stu-id="7090f-381"><a name="subheading9"></a>Increase default connection limit</span></span>
<span data-ttu-id="7090f-382">A .NET, a következő kód hello növeli a hello alapértelmezett kapcsolathoz megadott korlátot (amely általában 2 ügyfél környezetben vagy 10 kiszolgálói környezetben) too100.</span><span class="sxs-lookup"><span data-stu-id="7090f-382">In .NET, hello following code increases hello default connection limit (which is usually 2 in a client environment or 10 in a server environment) too100.</span></span> <span data-ttu-id="7090f-383">Általában célszerű hello érték tooapproximately hello a szálak számát, amelyet az alkalmazás.</span><span class="sxs-lookup"><span data-stu-id="7090f-383">Typically, you should set hello value tooapproximately hello number of threads used by your application.</span></span>  

```csharp
ServicePointManager.DefaultConnectionLimit = 100; //(Or More)  
```

<span data-ttu-id="7090f-384">Meg kell adni a kapcsolatokat megnyitása előtt hello kapcsolathoz megadott korlátot.</span><span class="sxs-lookup"><span data-stu-id="7090f-384">You must set hello connection limit before opening any connections.</span></span>  

<span data-ttu-id="7090f-385">Más programozási nyelven tekintse meg a nyelvi dokumentáció toodetermine hogyan tooset hello kapcsolat korlátozására.</span><span class="sxs-lookup"><span data-stu-id="7090f-385">For other programming languages, see that language's documentation toodetermine how tooset hello connection limit.</span></span>  

<span data-ttu-id="7090f-386">További információkért lásd: hello blogbejegyzésben [webszolgáltatások: létesített egyidejű kapcsolatok](http://blogs.msdn.com/b/darrenj/archive/2005/03/07/386655.aspx).</span><span class="sxs-lookup"><span data-stu-id="7090f-386">For additional information, see hello blog post [Web Services: Concurrent Connections](http://blogs.msdn.com/b/darrenj/archive/2005/03/07/386655.aspx).</span></span>  

#### <span data-ttu-id="7090f-387"><a name="subheading10"></a>Növelje a szálkészlet Min szálak, ha aszinkron és szinkron kód használatával</span><span class="sxs-lookup"><span data-stu-id="7090f-387"><a name="subheading10"></a>Increase ThreadPool Min Threads if using synchronous code with Async Tasks</span></span>
<span data-ttu-id="7090f-388">Ez a kód megnöveli a hello szál készlet min szálak:</span><span class="sxs-lookup"><span data-stu-id="7090f-388">This code will increase hello thread pool min threads:</span></span>  

```csharp
ThreadPool.SetMinThreads(100,100); //(Determine hello right number for your application)  
```

<span data-ttu-id="7090f-389">További információkért lásd: [ThreadPool.SetMinThreads metódus](http://msdn.microsoft.com/library/system.threading.threadpool.setminthreads%28v=vs.110%29.aspx).</span><span class="sxs-lookup"><span data-stu-id="7090f-389">For more information, see [ThreadPool.SetMinThreads Method](http://msdn.microsoft.com/library/system.threading.threadpool.setminthreads%28v=vs.110%29.aspx).</span></span>  

#### <span data-ttu-id="7090f-390"><a name="subheading11"></a>.NET 4.5 szemétgyűjtés előnyeinek kihasználása</span><span class="sxs-lookup"><span data-stu-id="7090f-390"><a name="subheading11"></a>Take advantage of .NET 4.5 Garbage Collection</span></span>
<span data-ttu-id="7090f-391">Használjon .NET 4.5-ös vagy újabb hello ügyfél alkalmazás tootake előnyeit, teljesítménnyel kapcsolatos fejlesztések a kiszolgáló szemétgyűjtés.</span><span class="sxs-lookup"><span data-stu-id="7090f-391">Use .NET 4.5 or later for hello client application tootake advantage of performance improvements in server garbage collection.</span></span>

<span data-ttu-id="7090f-392">További információkért lásd: hello cikk [az Áttekintés a teljesítménnyel kapcsolatos fejlesztések a .NET 4.5](http://msdn.microsoft.com/magazine/hh882452.aspx).</span><span class="sxs-lookup"><span data-stu-id="7090f-392">For more information, see hello article [An Overview of Performance Improvements in .NET 4.5](http://msdn.microsoft.com/magazine/hh882452.aspx).</span></span>  

### <span data-ttu-id="7090f-393"><a name="subheading12"></a>Unbounded párhuzamossági</span><span class="sxs-lookup"><span data-stu-id="7090f-393"><a name="subheading12"></a>Unbounded Parallelism</span></span>
<span data-ttu-id="7090f-394">Párhuzamossági kiváló teljesítmény lehetnek, körültekintően adatokkal unbounded párhuzamossági (szálak, illetve párhuzamos kérelmek hello száma korlátozva) tooupload vagy letöltési, több munkavállalók tooaccess használatával több partíciót (tárolók, várólisták, vagy tábla partíciók) a hello ugyanazon tárfiók vagy tooaccess hello elemei egyazon partícióra kerüljenek.</span><span class="sxs-lookup"><span data-stu-id="7090f-394">While parallelism can be great for performance, be careful about using unbounded parallelism (no limit on hello number of threads and/or parallel requests) tooupload or download data, using multiple workers tooaccess multiple partitions (containers, queues, or table partitions) in hello same storage account or tooaccess multiple items in hello same partition.</span></span> <span data-ttu-id="7090f-395">Ha hello párhuzamossági unbounded, az alkalmazás haladhatja meg a hello ügyfél eszközök képességei, vagy hello storage-fiók méretezhetőségi célok hosszabb késések eredményez, és a szabályozás.</span><span class="sxs-lookup"><span data-stu-id="7090f-395">If hello parallelism is unbounded, your application can exceed hello client device's capabilities or hello storage account's scalability targets resulting in longer latencies and throttling.</span></span>  

### <span data-ttu-id="7090f-396"><a name="subheading13"></a>Storage Ügyfélkódtáraival és eszközök</span><span class="sxs-lookup"><span data-stu-id="7090f-396"><a name="subheading13"></a>Storage Client Libraries and Tools</span></span>
<span data-ttu-id="7090f-397">Mindig használjon hello legújabb Microsoft által biztosított ügyfél kódtárak és eszközök.</span><span class="sxs-lookup"><span data-stu-id="7090f-397">Always use hello latest Microsoft provided client libraries and tools.</span></span> <span data-ttu-id="7090f-398">Hello írásának időpontjában nincsenek .NET, Windows Phone, Windows-Futtatókörnyezetű, Java és C++ elérhető klienskódtárait, valamint más nyelvekre preview szalagtárak.</span><span class="sxs-lookup"><span data-stu-id="7090f-398">At hello time of writing, there are client libraries available for .NET, Windows Phone, Windows Runtime, Java, and C++, as well as preview libraries for other languages.</span></span> <span data-ttu-id="7090f-399">Ezenkívül a Microsoft közzétette PowerShell-parancsmagok és az Azure Storage használatához Azure parancssori felület parancsait.</span><span class="sxs-lookup"><span data-stu-id="7090f-399">In addition, Microsoft has released PowerShell cmdlets and Azure CLI commands for working with Azure Storage.</span></span> <span data-ttu-id="7090f-400">Microsoft aktívan házon belül fejlesztett alkalmazásokra teljesítménnyel szem előtt ezeket az eszközöket, toodate hello legújabb verziót a mentést biztosít, és biztosítja azokat kezelni, belső bizonyítása teljesítmény eljárások hello számos.</span><span class="sxs-lookup"><span data-stu-id="7090f-400">Microsoft actively develops these tools with performance in mind, keeps them up toodate with hello latest service versions, and ensures they handle many of hello proven performance practices internally.</span></span>  

### <a name="retries"></a><span data-ttu-id="7090f-401">Újrapróbálkozások</span><span class="sxs-lookup"><span data-stu-id="7090f-401">Retries</span></span>
#### <span data-ttu-id="7090f-402"><a name="subheading14"></a>Sávszélesség-szabályozás/ServerBusy</span><span class="sxs-lookup"><span data-stu-id="7090f-402"><a name="subheading14"></a>Throttling/ServerBusy</span></span>
<span data-ttu-id="7090f-403">Bizonyos esetekben hello tároló szolgáltatás szabályozása az alkalmazás vagy előfordulhat, hogy egyszerűen nem tooserve hello kérelem miatt toosome átmeneti állapotról és történhet "503-as kiszolgáló elfoglalt" üzenet vagy az "500 időtúllépése" visszaadása.</span><span class="sxs-lookup"><span data-stu-id="7090f-403">In some cases, hello storage service may throttle your application or may simply be unable tooserve hello request due toosome transient condition and return a "503 Server busy" message or "500 Timeout".</span></span>  <span data-ttu-id="7090f-404">Ez akkor fordulhat elő, ha az alkalmazás felé közelít hello méretezhetőségi célok bármelyikét, vagy ha hello rendszer van újraelosztás a particionált adatok tooallow nagyobb átviteli sebesség eléréséhez.</span><span class="sxs-lookup"><span data-stu-id="7090f-404">This can happen if your application is approaching any of hello scalability targets, or if hello system is rebalancing your partitioned data tooallow for higher throughput.</span></span>  <span data-ttu-id="7090f-405">hello ügyfélalkalmazás általában újra kell próbálkoznia ilyen hibát okozó hello művelet: hello azonos később kérelem kísérlet sikeres lehet.</span><span class="sxs-lookup"><span data-stu-id="7090f-405">hello client application should typically retry hello operation that causes such an error: attempting hello same request later can succeed.</span></span> <span data-ttu-id="7090f-406">Ha hello társzolgáltatás van az alkalmazás szabályozását, mert a méretezhetőségi célok túllépte, vagy ha a hello szolgáltatást a valamilyen más okból nem tooserve hello irányuló kérelem volt, az agresszív újrapróbálkozások általában ellenőrizze hello probléma ami még rosszabb.</span><span class="sxs-lookup"><span data-stu-id="7090f-406">However, if hello storage service is throttling your application because it is exceeding scalability targets, or even if hello service was unable tooserve hello request for some other reason, aggressive retries usually make hello problem worse.</span></span> <span data-ttu-id="7090f-407">Emiatt az exponenciális vissza (hello szalagtárak alapértelmezett toothis ügyfélviselkedést) ki kell használnia.</span><span class="sxs-lookup"><span data-stu-id="7090f-407">For this reason, you should use an exponential back off (hello client libraries default toothis behavior).</span></span> <span data-ttu-id="7090f-408">Például az alkalmazás előfordulhat, hogy 2 másodperc, majd 4 másodperc 10 másodpercet, majd a 30 másodperc után próbálkozzon újra, és majd teljesen feladták.</span><span class="sxs-lookup"><span data-stu-id="7090f-408">For example, your application may retry after 2 seconds, then 4 seconds, then 10 seconds, then 30 seconds, and then give up completely.</span></span> <span data-ttu-id="7090f-409">Ezt a viselkedést eredményezi, az alkalmazás jelentősen csökkenti annak terhelésétől hello szolgáltatás helyett súlyosbodott problémákat.</span><span class="sxs-lookup"><span data-stu-id="7090f-409">This behavior results in your application significantly reducing its load on hello service rather than exacerbating any problems.</span></span>  

<span data-ttu-id="7090f-410">Vegye figyelembe, hogy kapcsolódási hibák követően újra megkísérelhető a azonnal, mivel nincsenek hello eredménye sávszélesség-szabályozás, illetve átmeneti várt toobe.</span><span class="sxs-lookup"><span data-stu-id="7090f-410">Note that connectivity errors can be retried immediately, because they are not hello result of throttling and are expected toobe transient.</span></span>  

#### <span data-ttu-id="7090f-411"><a name="subheading15"></a>– Újrapróbálkozást lehetővé nem tevő hibák</span><span class="sxs-lookup"><span data-stu-id="7090f-411"><a name="subheading15"></a>Non-Retryable Errors</span></span>
<span data-ttu-id="7090f-412">hello klienskódtárak mely hibák újrapróbálkozási-, és nem ismerik.</span><span class="sxs-lookup"><span data-stu-id="7090f-412">hello client libraries are aware of which errors are retry-able and which are not.</span></span> <span data-ttu-id="7090f-413">Ha saját kódot hello storage REST API-t, ne feledje azonban, hogy nem kell újra hibák vannak a: például a 400-as válasz azt jelzi, hogy hello ügyfélalkalmazás (hibás kérés) nem lehet feldolgozni, mert a kérés érkezett, nem várt formában.</span><span class="sxs-lookup"><span data-stu-id="7090f-413">However, if you are writing your own code against hello storage REST API, remember there are some errors that you should not retry: for example, a 400 (Bad Request) response indicates that hello client application sent a request that could not be processed because it was not in an expected form.</span></span> <span data-ttu-id="7090f-414">Küldje el újra a kéréssel hatására hello a minden alkalommal ugyanaz a válasz, nincs újrapróbálkozás azt a pont.</span><span class="sxs-lookup"><span data-stu-id="7090f-414">Resending this request will result hello same response every time, so there is no point in retrying it.</span></span> <span data-ttu-id="7090f-415">Elleni hello storage REST API-t saját kód írását, vegye figyelembe, hogy milyen hello hibakódjai középérték és hello megfelelő módon tooretry (vagy nem) esetében.</span><span class="sxs-lookup"><span data-stu-id="7090f-415">If you are writing your own code against hello storage REST API, be aware of what hello error codes mean and hello proper way tooretry (or not) for each of them.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="7090f-416">Hasznos segédanyagok</span><span class="sxs-lookup"><span data-stu-id="7090f-416">Useful Resources</span></span>
<span data-ttu-id="7090f-417">Tárolási hibakódokkal kapcsolatban további információkért lásd: [állapotát és hibakódok](http://msdn.microsoft.com/library/azure/dd179382.aspx) hello Microsoft Azure-webhelyen.</span><span class="sxs-lookup"><span data-stu-id="7090f-417">For more information about storage error codes, see [Status and Error Codes](http://msdn.microsoft.com/library/azure/dd179382.aspx) on hello Microsoft Azure web site.</span></span>  

## <a name="blobs"></a><span data-ttu-id="7090f-418">Blobok</span><span class="sxs-lookup"><span data-stu-id="7090f-418">Blobs</span></span>
<span data-ttu-id="7090f-419">Az eljárások bizonyítása hozzáadása toohello [minden szolgáltatás](#allservices) a fentiekben ismertetett eljárásokat bizonyítása hello következő kifejezetten toohello blob szolgáltatás alkalmazása.</span><span class="sxs-lookup"><span data-stu-id="7090f-419">In addition toohello proven practices for [All Services](#allservices) described previously, hello following proven practices apply specifically toohello blob service.</span></span>  

### <a name="blob-specific-scalability-targets"></a><span data-ttu-id="7090f-420">A BLOB-specifikus méretezhetőségi célok</span><span class="sxs-lookup"><span data-stu-id="7090f-420">Blob-Specific Scalability Targets</span></span>
#### <span data-ttu-id="7090f-421"><a name="subheading46"></a>Egy adott objektum eléréséhez egyidejűleg több ügyfél</span><span class="sxs-lookup"><span data-stu-id="7090f-421"><a name="subheading46"></a>Multiple clients accessing a single object concurrently</span></span>
<span data-ttu-id="7090f-422">Ha egy adott objektum egyidejűleg hozzáférő ügyfelek nagy számú szüksége lesz egy objektum és a storage méretezhetőségi célok tooconsider.</span><span class="sxs-lookup"><span data-stu-id="7090f-422">If you have a large number of clients accessing a single object concurrently you will need tooconsider per object and storage account scalability targets.</span></span> <span data-ttu-id="7090f-423">hello pontos számát egy adott objektum hozzáférő ügyfelek fogja például hello objektum egyszerre kérő ügyfelek hello objektum mérete hello hello száma tényezőktől függően változnak, hálózati feltételek stb.</span><span class="sxs-lookup"><span data-stu-id="7090f-423">hello exact number of clients that can access a single object will vary depending on factors such as hello number of clients requesting hello object simultaneously, hello size of hello object, network conditions etc.</span></span>

<span data-ttu-id="7090f-424">Ha hello objektum keresztül terjeszthető például képek és videók CDN kiszolgálása egy webhelyről, majd a CDN-t kell használnia.</span><span class="sxs-lookup"><span data-stu-id="7090f-424">If hello object can be distributed through a CDN such as images or videos served from a website then you should use a CDN.</span></span> <span data-ttu-id="7090f-425">Lásd: [Itt](#subheading5).</span><span class="sxs-lookup"><span data-stu-id="7090f-425">See [here](#subheading5).</span></span>

<span data-ttu-id="7090f-426">Más esetekben, például bizalmas adatokat hello esetén tudományos szimulációja két választási lehetősége van.</span><span class="sxs-lookup"><span data-stu-id="7090f-426">In other scenarios such as scientific simulations where hello data is confidential you have two options.</span></span> <span data-ttu-id="7090f-427">hello először toostagger a számítási hozzáférési ilyen objektum hello érhető el egy meghatározott időtartamra vonatkozóan válaszidővel egyidejűleg használatban.</span><span class="sxs-lookup"><span data-stu-id="7090f-427">hello first is toostagger your workload's access such that hello object is accessed over a period of time vs being accessed simultaneously.</span></span> <span data-ttu-id="7090f-428">Azt is megteheti ideiglenesen másolhatja hello objektum toomultiple tárfiókok hello és növelhetik a teljes IOPS objektumonként és tárfiókok között.</span><span class="sxs-lookup"><span data-stu-id="7090f-428">Alternatively, you can temporarily copy hello object toomultiple storage accounts thus increasing hello total IOPS per object and across storage accounts.</span></span> <span data-ttu-id="7090f-429">A korlátozott tesztelése észleltünk, hogy körülbelül 25 virtuális gépek egyidejűleg tölthető le 100GB blob párhuzamos (a virtuális gépek lett parallelizing hello letöltési 32 szálat használ).</span><span class="sxs-lookup"><span data-stu-id="7090f-429">In limited testing we found that around 25 VMs could simultaneously download a 100GB blob in parallel (each VM was parallelizing hello download using 32 threads).</span></span> <span data-ttu-id="7090f-430">Ha tooaccess hello objektum kellene 100 ügyféllel, először tooa második tárfiók másolásához rendelkezik hello első 50 virtuális gépek hozzáférési hello első blob és hello második 50 virtuális gépek hozzáférési hello második blob.</span><span class="sxs-lookup"><span data-stu-id="7090f-430">If you had 100 clients needing tooaccess hello object, first copy it tooa second storage account and then have hello first 50 VMs access hello first blob and hello second 50 VMs access hello second blob.</span></span> <span data-ttu-id="7090f-431">Eredmények függ az alkalmazások viselkedését, tesztelje a tervezés során.</span><span class="sxs-lookup"><span data-stu-id="7090f-431">Results will vary depending on your applications behavior so you should test this during design.</span></span> 

#### <span data-ttu-id="7090f-432"><a name="subheading16"></a>Sávszélesség és a műveletek másodpercenkénti Blob</span><span class="sxs-lookup"><span data-stu-id="7090f-432"><a name="subheading16"></a>Bandwidth and operations per Blob</span></span>
<span data-ttu-id="7090f-433">Olvassa el, vagy írható tooa egyetlen blob-, mentése tooa legfeljebb 60 MB/s (Ez körülbelül 480 MB/s ami hello képességek sok ügyfél oldalán hálózatok meghaladja az (beleértve a hello hello ügyféleszközön a fizikai hálózati Adapterre).</span><span class="sxs-lookup"><span data-stu-id="7090f-433">You can read or write tooa single blob at up tooa maximum of 60 MB/second (this is approximately 480 Mbps which exceeds hello capabilities of many client side networks (including hello physical NIC on hello client device).</span></span> <span data-ttu-id="7090f-434">Emellett egyetlen blob támogatja too500 kérelmek száma másodpercenként.</span><span class="sxs-lookup"><span data-stu-id="7090f-434">In addition, a single blob supports up too500 requests per second.</span></span> <span data-ttu-id="7090f-435">Ha több ügyféllel tooread igénylő hello azonos blob, és előfordulhat, hogy meghaladja ezt a korlátot, fontolja meg a CDN hello blob terjesztéséhez.</span><span class="sxs-lookup"><span data-stu-id="7090f-435">If you have multiple clients that need tooread hello same blob and you might exceed these limits, you should consider using a CDN for distributing hello blob.</span></span>  

<span data-ttu-id="7090f-436">A blobok cél átviteli kapcsolatos további információkért lásd: [Azure Storage méretezhetőségi és teljesítménycéloknak](storage-scalability-targets.md).</span><span class="sxs-lookup"><span data-stu-id="7090f-436">For more information about target throughput for blobs, see [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span></span>  

### <a name="copying-and-moving-blobs"></a><span data-ttu-id="7090f-437">Másolásának és áthelyezésének Blobok</span><span class="sxs-lookup"><span data-stu-id="7090f-437">Copying and Moving Blobs</span></span>
#### <span data-ttu-id="7090f-438"><a name="subheading17"></a>A Blob másolása</span><span class="sxs-lookup"><span data-stu-id="7090f-438"><a name="subheading17"></a>Copy Blob</span></span>
<span data-ttu-id="7090f-439">hello storage REST API 2012-02-12-es verzió hello hasznos képességét toocopy blobok bevezetett fiókok között: ügyfélalkalmazás utasítani hello tárolási szolgáltatás toocopy blob más forrásból (valószínűleg a során eltérő tárfiók), és hagyja hello szolgáltatás árnyékmásolata hello aszinkron módon történik.</span><span class="sxs-lookup"><span data-stu-id="7090f-439">hello storage REST API version 2012-02-12 introduced hello useful ability toocopy blobs across accounts: a client application can instruct hello storage service toocopy a blob from another source (possibly in a different storage account), and then let hello service perform hello copy asynchronously.</span></span> <span data-ttu-id="7090f-440">Ez jelentősen csökkenti más tárfiókok az adatok áttelepítése esetén, mert nem kell toodownload és hello adatok feltöltése hello alkalmazáshoz szükséges hello sávszélesség.</span><span class="sxs-lookup"><span data-stu-id="7090f-440">This can significantly reduce hello bandwidth needed for hello application when you are migrating data from other storage accounts because you do not need toodownload and upload hello data.</span></span>  

<span data-ttu-id="7090f-441">Egy figyelembe azonban, hogy másolás storage-fiókok között, ha nincs idő garancia hello példány befejeződik, ha a.</span><span class="sxs-lookup"><span data-stu-id="7090f-441">One consideration, however, is that, when copying between storage accounts, there is no time guarantee on when hello copy will complete.</span></span> <span data-ttu-id="7090f-442">Ha az alkalmazásnak toocomplete blob gyorsan másolja az ellenőrzése alatt, valószínűleg jobb toocopy hello blob tooa VM letöltheti és toohello cél feltöltése.</span><span class="sxs-lookup"><span data-stu-id="7090f-442">If your application needs toocomplete a blob copy quickly under your control, it may be better toocopy hello blob by downloading it tooa VM and then uploading it toohello destination.</span></span>  <span data-ttu-id="7090f-443">Ebben a helyzetben teljes kiszámíthatóságot győződjön meg arról, hogy történik-e hello másolási hello futó virtuális gép által azonos Azure-régió, vagy pedig hálózati körülmények lehet (és valószínűleg fog) hatással a másolási teljesítményére.</span><span class="sxs-lookup"><span data-stu-id="7090f-443">For full predictability in that situation, ensure that hello copy is performed by a VM running in hello same Azure region, or else network conditions may (and probably will) affect your copy performance.</span></span>  <span data-ttu-id="7090f-444">Ezenkívül kísérheti hello egy aszinkron példány programozott módon.</span><span class="sxs-lookup"><span data-stu-id="7090f-444">In addition, you can monitor hello progress of an asynchronous copy programmatically.</span></span>  

<span data-ttu-id="7090f-445">Figyelje meg, hogy ugyanazt a tárfiókot maga általában gyorsan befejeződött hello belül másolja.</span><span class="sxs-lookup"><span data-stu-id="7090f-445">Note that copies within hello same storage account itself are generally completed quickly.</span></span>  

<span data-ttu-id="7090f-446">További információkért lásd: [másolási Blob](http://msdn.microsoft.com/library/azure/dd894037.aspx).</span><span class="sxs-lookup"><span data-stu-id="7090f-446">For more information, see [Copy Blob](http://msdn.microsoft.com/library/azure/dd894037.aspx).</span></span>  

#### <span data-ttu-id="7090f-447"><a name="subheading18"></a>AzCopy használata</span><span class="sxs-lookup"><span data-stu-id="7090f-447"><a name="subheading18"></a>Use AzCopy</span></span>
<span data-ttu-id="7090f-448">hello Azure Storage csapat kiadott egy parancssori eszközt "AzCopy", amely jelentette toohelp a tömeges, valamint a tárfiókok között számos blobok átvitele.</span><span class="sxs-lookup"><span data-stu-id="7090f-448">hello Azure Storage team has released a command-line tool "AzCopy" that is meant toohelp with bulk transferring many blobs to, from, and across storage accounts.</span></span>  <span data-ttu-id="7090f-449">Ezt az eszközt ebben a forgatókönyvben van optimalizálva, és nagy átviteli sebesség érhető el.</span><span class="sxs-lookup"><span data-stu-id="7090f-449">This tool is optimized for this scenario, and can achieve high transfer rates.</span></span>  <span data-ttu-id="7090f-450">A tömeges feltöltés, a letöltésről és a másolással használata javasolt.</span><span class="sxs-lookup"><span data-stu-id="7090f-450">Its use is encouraged for bulk upload, download, and copy scenarios.</span></span> <span data-ttu-id="7090f-451">További információk toolearn és le is, lásd: [adatátvitel az AzCopy parancssori segédprogram hello](storage-use-azcopy.md).</span><span class="sxs-lookup"><span data-stu-id="7090f-451">toolearn more about it and download it, see [Transfer data with hello AzCopy Command-Line Utility](storage-use-azcopy.md).</span></span>  

#### <span data-ttu-id="7090f-452"><a name="subheading19"></a>Az Azure Import/Export szolgáltatás</span><span class="sxs-lookup"><span data-stu-id="7090f-452"><a name="subheading19"></a>Azure Import/Export Service</span></span>
<span data-ttu-id="7090f-453">A rendkívül nagy mennyiségű adatok (legfeljebb 1 TB-os) a hello Azure Storage kínál hello Import/Export szolgáltatás, amely lehetővé teszi a feltöltés és letöltés a blob storage által szállítási merevlemez-meghajtókat.</span><span class="sxs-lookup"><span data-stu-id="7090f-453">For very large volumes of data (more than 1TB), hello Azure Storage offers hello Import/Export service, which allows for uploading and downloading from blob storage by shipping hard drives.</span></span>  <span data-ttu-id="7090f-454">Helyezte el az adatokat egy merevlemezre és elküldi a feltöltésének tooMicrosoft, vagy egy üres merevlemez-meghajtóról tooMicrosoft toodownload adatküldéshez.</span><span class="sxs-lookup"><span data-stu-id="7090f-454">You can put your data on a hard drive and send it tooMicrosoft for upload, or send a blank hard drive tooMicrosoft toodownload data.</span></span>  <span data-ttu-id="7090f-455">További információkért lásd: [hello a Microsoft Azure Import/Export szolgáltatás tooTransfer adatok tooBlob Storage használata](storage-import-export-service.md).</span><span class="sxs-lookup"><span data-stu-id="7090f-455">For more information, see [Use hello Microsoft Azure Import/Export Service tooTransfer Data tooBlob Storage](storage-import-export-service.md).</span></span>  <span data-ttu-id="7090f-456">Ez lehet sokkal hatékonyabb, mint feltöltése/letöltése az adatok mennyiségét hello hálózaton keresztül.</span><span class="sxs-lookup"><span data-stu-id="7090f-456">This can be much more efficient than uploading/downloading this volume of data over hello network.</span></span>  

### <span data-ttu-id="7090f-457"><a name="subheading20"></a>Metaadatok</span><span class="sxs-lookup"><span data-stu-id="7090f-457"><a name="subheading20"></a>Use metadata</span></span>
<span data-ttu-id="7090f-458">hello blob szolgáltatás támogatja a head kérelmek, amelyek magukban foglalhatják hello blob metaadatait.</span><span class="sxs-lookup"><span data-stu-id="7090f-458">hello blob service supports head requests, which can include metadata about hello blob.</span></span> <span data-ttu-id="7090f-459">Például ha az alkalmazás hello EXIF adatokat fénykép szükséges, az olvashat be hello fénykép és bontsa ki.</span><span class="sxs-lookup"><span data-stu-id="7090f-459">For example, if your application needed hello EXIF data out of a photo, it could retrieve hello photo and extract it.</span></span> <span data-ttu-id="7090f-460">toosave sávszélesség és a teljesítmény javítása érdekében az alkalmazás sikerült hello EXIF adat tárolása hello blob metaadatai feltöltéskor hello alkalmazás hello fénykép: majd le hello EXIF adatokat a metaadatok csak olyan HEAD kérelem jelentős sávszélesség mentése illetve hello feldolgozási időt tooextract hello EXIF adatokat minden egyes alkalommal hello blob olvasható.</span><span class="sxs-lookup"><span data-stu-id="7090f-460">toosave bandwidth and improve performance, your application could store hello EXIF data in hello blob's metadata when hello application uploaded hello photo: you can then retrieve hello EXIF data in metadata using only a HEAD request, saving significant bandwidth and hello processing time needed tooextract hello EXIF data each time hello blob is read.</span></span> <span data-ttu-id="7090f-461">Akkor hasznos, ahol csak kell hello metaadatok, és nem hello teljes tartalma blob forgatókönyvekben.</span><span class="sxs-lookup"><span data-stu-id="7090f-461">This would be useful in scenarios where you only need hello metadata, and not hello full content of a blob.</span></span>  <span data-ttu-id="7090f-462">Vegye figyelembe, hogy a metaadatok csak 8 KB-os tárolható egy blob (hello szolgáltatás nem fogadja el a kérelmet toostore ennél nagyobb), így ha hello adatok nem fér el ez a méret, akkor előfordulhat, hogy nem tudja toouse kell ezt a módszert használja.</span><span class="sxs-lookup"><span data-stu-id="7090f-462">Note that only 8 KB of metadata can be stored per blob (hello service will not accept a request toostore more than that), so if hello data does not fit in that size, you may not be able toouse this approach.</span></span>  

<span data-ttu-id="7090f-463">A példa bemutatja, hogyan tooget egy blob metaadatok használatával a .NET, lásd: [Set, a Tulajdonságok beolvasása és a metaadatok](storage-properties-metadata.md).</span><span class="sxs-lookup"><span data-stu-id="7090f-463">For an example of how tooget a blob's metadata using .NET, see [Set and Retrieve Properties and Metadata](storage-properties-metadata.md).</span></span>  

### <a name="uploading-fast"></a><span data-ttu-id="7090f-464">Gyors feltöltése</span><span class="sxs-lookup"><span data-stu-id="7090f-464">Uploading Fast</span></span>
<span data-ttu-id="7090f-465">gyors tooupload blobokat, hello első kérdés tooanswer van: Ön egy blob vagy nagy feltöltésével?</span><span class="sxs-lookup"><span data-stu-id="7090f-465">tooupload blobs fast, hello first question tooanswer is: are you uploading one blob or many?</span></span>  <span data-ttu-id="7090f-466">Hello alatt útmutatást toodetermine hello helyes metódus toouse a forgatókönyvtől függően használja.</span><span class="sxs-lookup"><span data-stu-id="7090f-466">Use hello below guidance toodetermine hello correct method toouse depending on your scenario.</span></span>  

#### <span data-ttu-id="7090f-467"><a name="subheading21"></a>Egy nagy blob gyors feltöltése</span><span class="sxs-lookup"><span data-stu-id="7090f-467"><a name="subheading21"></a>Uploading one large blob quickly</span></span>
<span data-ttu-id="7090f-468">nagy egyetlen blob gyorsan tooupload, az ügyfélalkalmazás kell töltse fel a blokkok vagy lapok párhuzamos (az egyes blobok és hello tárfiók egész hello méretezhetőségi célok szem előtt tartva alatt).</span><span class="sxs-lookup"><span data-stu-id="7090f-468">tooupload a single large blob quickly, your client application should upload its blocks or pages in parallel (being mindful of hello scalability targets for individual blobs and hello storage account as a whole).</span></span>  <span data-ttu-id="7090f-469">Ne feledje, hogy hello hivatalos Microsoft által biztosított RTM Storage ügyfélkódtáraival (.NET, Java) hello képességét toodo ez.</span><span class="sxs-lookup"><span data-stu-id="7090f-469">Note that hello official Microsoft-provided RTM Storage Client libraries (.NET, Java) have hello ability toodo this.</span></span>  <span data-ttu-id="7090f-470">Az egyes hello szalagtárak használja a hello megadott objektumtulajdonság tooset hello szint egyidejű alatt:</span><span class="sxs-lookup"><span data-stu-id="7090f-470">For each of hello libraries, use hello below specified object/property tooset hello level of concurrency:</span></span>  

* <span data-ttu-id="7090f-471">.NET: Set ParallelOperationThreadCount a egy BlobRequestOptions objektum toobe használt.</span><span class="sxs-lookup"><span data-stu-id="7090f-471">.NET: Set ParallelOperationThreadCount on a BlobRequestOptions object toobe used.</span></span>
* <span data-ttu-id="7090f-472">Java/Android: BlobRequestOptions.setConcurrentRequestCount() használata</span><span class="sxs-lookup"><span data-stu-id="7090f-472">Java/Android: Use BlobRequestOptions.setConcurrentRequestCount()</span></span>
* <span data-ttu-id="7090f-473">NODE.js: ParallelOperationThreadCount vagy hello lehetőségek és hello blob szolgáltatás használható.</span><span class="sxs-lookup"><span data-stu-id="7090f-473">Node.js: Use parallelOperationThreadCount on either hello request options or on hello blob service.</span></span>
* <span data-ttu-id="7090f-474">C++: Hello blob_request_options::set_parallelism_factor módszert használja.</span><span class="sxs-lookup"><span data-stu-id="7090f-474">C++: Use hello blob_request_options::set_parallelism_factor method.</span></span>

#### <span data-ttu-id="7090f-475"><a name="subheading22"></a>Sok blobok gyors feltöltése</span><span class="sxs-lookup"><span data-stu-id="7090f-475"><a name="subheading22"></a>Uploading many blobs quickly</span></span>
<span data-ttu-id="7090f-476">számos gyorsan, blobok tooupload párhuzamosan blobok feltöltése.</span><span class="sxs-lookup"><span data-stu-id="7090f-476">tooupload many blobs quickly, upload blobs in parallel.</span></span> <span data-ttu-id="7090f-477">Ez a gyorsabb, mint a feltöltés egyetlen blobok egyszerre a párhuzamos blokk feltöltések mert hello feltöltés terjedése több partíciót hello tárolási szolgáltatás között.</span><span class="sxs-lookup"><span data-stu-id="7090f-477">This is faster than uploading single blobs at a time with parallel block uploads because it spreads hello upload across multiple partitions of hello storage service.</span></span> <span data-ttu-id="7090f-478">Egy blob csak 60 MB/s (körülbelül 480 Mbps sebességű) átviteli támogatja.</span><span class="sxs-lookup"><span data-stu-id="7090f-478">A single blob only supports a throughput of 60 MB/second (approximately 480 Mbps).</span></span> <span data-ttu-id="7090f-479">Hello írásának időpontjában egy Egyesült államokbeli LRS fiók legfeljebb támogat too20 GB/s érkező, amely jóval több, mint a hello egy egyedi blob által támogatott.</span><span class="sxs-lookup"><span data-stu-id="7090f-479">At hello time of writing, a US-based LRS account supports up too20 Gbps ingress which is far more than hello throughput supported by an individual blob.</span></span>  <span data-ttu-id="7090f-480">[AzCopy](#subheading18) párhuzamos feltöltések alapértelmezés szerint hajt végre, és ehhez a forgatókönyvhöz ajánlott.</span><span class="sxs-lookup"><span data-stu-id="7090f-480">[AzCopy](#subheading18) performs uploads in parallel by default, and is recommended for this scenario.</span></span>  

### <span data-ttu-id="7090f-481"><a name="subheading23"></a>Hello megfelelő típusú blob kiválasztása</span><span class="sxs-lookup"><span data-stu-id="7090f-481"><a name="subheading23"></a>Choosing hello correct type of blob</span></span>
<span data-ttu-id="7090f-482">Az Azure Storage támogatja a blob kétféle: *lap* blobok és *blokk* blobokat.</span><span class="sxs-lookup"><span data-stu-id="7090f-482">Azure Storage supports two types of blob: *page* blobs and *block* blobs.</span></span> <span data-ttu-id="7090f-483">Adott használati forgatókönyvek esetében a választott blob típushoz hello teljesítményét és méretezhetőségét, a megoldás hatással lesz.</span><span class="sxs-lookup"><span data-stu-id="7090f-483">For a given usage scenario, your choice of blob type will affect hello performance and scalability of your solution.</span></span> <span data-ttu-id="7090f-484">Blokkblobok megfelelőek, ha azt szeretné, tooupload nagy mennyiségű adat hatékonyan: például ügyfélalkalmazás esetleg tooupload fénykép vagy videó tooblob tárolási.</span><span class="sxs-lookup"><span data-stu-id="7090f-484">Block blobs are appropriate when you want tooupload large amounts of data efficiently: for example, a client application may need tooupload photos or video tooblob storage.</span></span> <span data-ttu-id="7090f-485">Lapblobokat megfelelőek, ha hello alkalmazásnak kell tooperform véletlenszerű írások hello adatokon: például Azure virtuális merevlemezek lapblobokat tárolódnak.</span><span class="sxs-lookup"><span data-stu-id="7090f-485">Page blobs are appropriate if hello application needs tooperform random writes on hello data: for example, Azure VHDs are stored as page blobs.</span></span>  

<span data-ttu-id="7090f-486">További információkért lásd: [ismertetése Blokkblobokat, hozzáfűző blobokat és Lapblobokat](http://msdn.microsoft.com/library/azure/ee691964.aspx).</span><span class="sxs-lookup"><span data-stu-id="7090f-486">For more information, see [Understanding Block Blobs, Append Blobs, and Page Blobs](http://msdn.microsoft.com/library/azure/ee691964.aspx).</span></span>  

## <a name="tables"></a><span data-ttu-id="7090f-487">Táblák</span><span class="sxs-lookup"><span data-stu-id="7090f-487">Tables</span></span>
<span data-ttu-id="7090f-488">Az eljárások bizonyítása hozzáadása toohello [minden szolgáltatás](#allservices) a fentiekben ismertetett eljárásokat bizonyítása hello következő kifejezetten toohello tábla szolgáltatás alkalmazása.</span><span class="sxs-lookup"><span data-stu-id="7090f-488">In addition toohello proven practices for [All Services](#allservices) described previously, hello following proven practices apply specifically toohello table service.</span></span>  

### <span data-ttu-id="7090f-489"><a name="subheading24"></a>Tábla vonatkozó méretezhetőségi célok</span><span class="sxs-lookup"><span data-stu-id="7090f-489"><a name="subheading24"></a>Table-Specific Scalability Targets</span></span>
<span data-ttu-id="7090f-490">Továbbá toohello sávszélességgel kapcsolatos korlátozásai egy teljes tárfiókja, a kell hello a következő egyedi méretezhetőségi korlátot.</span><span class="sxs-lookup"><span data-stu-id="7090f-490">In addition toohello bandwidth limitations of an entire storage account, tables have hello following specific scalability limit.</span></span>  <span data-ttu-id="7090f-491">Vegye figyelembe, hogy hello rendszer egyenleg betölti a a forgalom növekedése, de ha a forgalom hirtelen felszakadásáig, akkor előfordulhat, hogy nem kell tudni tooget átviteli kötet azonnal.</span><span class="sxs-lookup"><span data-stu-id="7090f-491">Note that hello system will load balance as your traffic increases, but if your traffic has sudden bursts, you may not be able tooget this volume of throughput immediately.</span></span>  <span data-ttu-id="7090f-492">Ha a minta van felszakadásáig, számíthat toosee sávszélesség-szabályozás és/vagy időtúllépések alatt hello kapacitásnövelés hello tárolási szolgáltatásként automatikusan ki a tábla egyenlegének betöltése.</span><span class="sxs-lookup"><span data-stu-id="7090f-492">If your pattern has bursts, you should expect toosee throttling and/or timeouts during hello burst as hello storage service automatically load balances out your table.</span></span>  <span data-ttu-id="7090f-493">Jobb eredményeket hello rendszer tooload egyenlege megfelelően nyújtja lassan általában ramping rendelkezik.</span><span class="sxs-lookup"><span data-stu-id="7090f-493">Ramping up slowly generally has better results as it gives hello system time tooload balance appropriately.</span></span>  

#### <a name="entities-per-second-account"></a><span data-ttu-id="7090f-494">Entitások / másodperc (fiók)</span><span class="sxs-lookup"><span data-stu-id="7090f-494">Entities per Second (Account)</span></span>
<span data-ttu-id="7090f-495">hello skálázhatósági korlátot táblák eléréséhez too20, egy olyan fiók másodpercenként 000 entitások (1KB minden) működik.</span><span class="sxs-lookup"><span data-stu-id="7090f-495">hello scalability limit for accessing tables is up too20,000 entities (1KB each) per second for an account.</span></span>  <span data-ttu-id="7090f-496">Általában minden entitás beszúrt, frissítése, törlése, vagy beolvasott számát, ez a cél felé.</span><span class="sxs-lookup"><span data-stu-id="7090f-496">In general, each entity that is inserted, updated, deleted, or scanned counts toward this target.</span></span>  <span data-ttu-id="7090f-497">Ezért egy 100 entitást tartalmazó kötegelt Beszúrás 100 entitást számít.</span><span class="sxs-lookup"><span data-stu-id="7090f-497">So a batch insert that contains 100 entities would count as 100 entities.</span></span>  <span data-ttu-id="7090f-498">Egy lekérdezést, amely 1000 entitások vizsgálja, és visszaadja az 5 1000 entitások számít.</span><span class="sxs-lookup"><span data-stu-id="7090f-498">A query that scans 1000 entities and returns 5 would count as 1000 entities.</span></span>  

#### <a name="entities-per-second-partition"></a><span data-ttu-id="7090f-499">Entitások / másodperc (partíció:)</span><span class="sxs-lookup"><span data-stu-id="7090f-499">Entities per Second (Partition)</span></span>
<span data-ttu-id="7090f-500">Hello belül egyetlen partícióra, a méretezhetőség cél táblák elérése: 2000 entitások (1KB minden) másodpercenként, használatával hello azonos számbavételi hello előző szakaszban leírtak szerint.</span><span class="sxs-lookup"><span data-stu-id="7090f-500">Within a single partition, hello scalability target for accessing tables is 2,000 entities (1KB each) per second, using hello same counting as described in hello previous section.</span></span>  

### <a name="configuration"></a><span data-ttu-id="7090f-501">Konfiguráció</span><span class="sxs-lookup"><span data-stu-id="7090f-501">Configuration</span></span>
<span data-ttu-id="7090f-502">Ez a rész felsorolja használható toomake jelentős teljesítményjavulást eredményezhet a hello table szolgáltatás több gyors konfigurációs beállítások:</span><span class="sxs-lookup"><span data-stu-id="7090f-502">This section lists several quick configuration settings that you can use toomake significant performance improvements in hello table service:</span></span>  

#### <span data-ttu-id="7090f-503"><a name="subheading25"></a>JSON használata</span><span class="sxs-lookup"><span data-stu-id="7090f-503"><a name="subheading25"></a>Use JSON</span></span>
<span data-ttu-id="7090f-504">Tárolási verziójú 2013-08-15 kezdve hello table szolgáltatás támogatja a JSON hello XML-alapú AtomPub formátum helyett a táblabeli adatok átviteléhez.</span><span class="sxs-lookup"><span data-stu-id="7090f-504">Beginning with storage service version 2013-08-15, hello table service supports using JSON instead of hello XML-based AtomPub format for transferring table data.</span></span> <span data-ttu-id="7090f-505">Ez csökkentheti a tartalom méretét szerint 75 %, és jelentősen növelheti az alkalmazás hello teljesítményét.</span><span class="sxs-lookup"><span data-stu-id="7090f-505">This can reduce payload sizes by as much as 75% and can significantly improve hello performance of your application.</span></span>

<span data-ttu-id="7090f-506">További információkért lásd: hello utáni [Microsoft Azure-táblákat: bevezetéséről JSON](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/05/windows-azure-tables-introducing-json.aspx) és [Table szolgáltatási műveletek az adattartalom formátuma](http://msdn.microsoft.com/library/azure/dn535600.aspx).</span><span class="sxs-lookup"><span data-stu-id="7090f-506">For more information, see hello post [Microsoft Azure Tables: Introducing JSON](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/05/windows-azure-tables-introducing-json.aspx) and [Payload Format for Table Service Operations](http://msdn.microsoft.com/library/azure/dn535600.aspx).</span></span>

#### <span data-ttu-id="7090f-507"><a name="subheading26"></a>Nagle kikapcsolása</span><span class="sxs-lookup"><span data-stu-id="7090f-507"><a name="subheading26"></a>Nagle Off</span></span>
<span data-ttu-id="7090f-508">Nagle tartozó algoritmus széles körben egy azt jelenti, hogy tooimprove hálózati teljesítményt, megvalósítva TCP/IP-hálózatokon keresztül.</span><span class="sxs-lookup"><span data-stu-id="7090f-508">Nagle's algorithm is widely implemented across TCP/IP networks as a means tooimprove network performance.</span></span> <span data-ttu-id="7090f-509">Azonban nincs optimalizálva, minden körülmények között (például magas interaktív környezetekben).</span><span class="sxs-lookup"><span data-stu-id="7090f-509">However, it is not optimal in all circumstances (such as highly interactive environments).</span></span> <span data-ttu-id="7090f-510">Az Azure Storage Nagle tartozó algoritmus negatív hatással rendelkezik kérelmek toohello tábla és a queue szolgáltatások hello teljesítményét, és tiltsa le, ha lehetséges.</span><span class="sxs-lookup"><span data-stu-id="7090f-510">For Azure Storage, Nagle's algorithm has a negative impact on hello performance of requests toohello table and queue services, and you should disable it if possible.</span></span>  

<span data-ttu-id="7090f-511">További információkért tekintse meg a következő blogbejegyzésben található [Nagle tartozó algoritmus nem rövid kis kérelmek felé](http://blogs.msdn.com/b/windowsazurestorage/archive/2010/06/25/nagle-s-algorithm-is-not-friendly-towards-small-requests.aspx), amely ismerteti, miért Nagle tartozó algoritmus tábla- és várólista kérelmek rosszul kommunikál, és mutatja hogyan toodisable azt az ügyfél az alkalmazás.</span><span class="sxs-lookup"><span data-stu-id="7090f-511">For more information, see our blog post [Nagle's Algorithm is Not Friendly towards Small Requests](http://blogs.msdn.com/b/windowsazurestorage/archive/2010/06/25/nagle-s-algorithm-is-not-friendly-towards-small-requests.aspx), which explains why Nagle's algorithm interacts poorly with table and queue requests, and shows how toodisable it in your client application.</span></span>  

### <a name="schema"></a><span data-ttu-id="7090f-512">Séma</span><span class="sxs-lookup"><span data-stu-id="7090f-512">Schema</span></span>
<span data-ttu-id="7090f-513">Hogyan jelöl, és az adatok lekérdezése hello legnagyobb egyetlen tényező, amely befolyásolja a hello table szolgáltatás hello teljesítményét.</span><span class="sxs-lookup"><span data-stu-id="7090f-513">How you represent and query your data is hello biggest single factor that affects hello performance of hello table service.</span></span> <span data-ttu-id="7090f-514">Míg minden más, ez a szakasz ismerteti néhány általános bevált gyakorlatokat vonatkoznak:</span><span class="sxs-lookup"><span data-stu-id="7090f-514">While every application is different, this section outlines some general proven practices that relate to:</span></span>  

* <span data-ttu-id="7090f-515">Táblatervezés</span><span class="sxs-lookup"><span data-stu-id="7090f-515">Table design</span></span>
* <span data-ttu-id="7090f-516">Hatékony lekérdezések</span><span class="sxs-lookup"><span data-stu-id="7090f-516">Efficient queries</span></span>
* <span data-ttu-id="7090f-517">Hatékony adatfrissítések</span><span class="sxs-lookup"><span data-stu-id="7090f-517">Efficient data updates</span></span>  

#### <span data-ttu-id="7090f-518"><a name="subheading27"></a>Táblák és -partíciók</span><span class="sxs-lookup"><span data-stu-id="7090f-518"><a name="subheading27"></a>Tables and partitions</span></span>
<span data-ttu-id="7090f-519">Táblák partíciókra oszlik meg.</span><span class="sxs-lookup"><span data-stu-id="7090f-519">Tables are divided into partitions.</span></span> <span data-ttu-id="7090f-520">Minden entitás tárolt partícióra megosztások hello ugyanazzal a partíciókulccsal, és rendelkezik egy egyedi sorazonosítóként kulcs tooidentify azt, hogy a partíción belül.</span><span class="sxs-lookup"><span data-stu-id="7090f-520">Every entity stored in a partition shares hello same partition key and has a unique row key tooidentify it within that partition.</span></span> <span data-ttu-id="7090f-521">Partíciók előnyt nyújtanak, de méretezhetőségének korlátai is vezethet.</span><span class="sxs-lookup"><span data-stu-id="7090f-521">Partitions provide benefits but also introduce scalability limits.</span></span>  

* <span data-ttu-id="7090f-522">Előnyei: Entitásokat is frissítheti a hello azonos too100 külön tárolási műveletek (4MB teljes mérete legfeljebb) másolatot tartalmazó egyetlen, atomi, kötegelt tranzakció partíciójához.</span><span class="sxs-lookup"><span data-stu-id="7090f-522">Benefits: You can update entities in hello same partition in a single, atomic, batch transaction that contains up too100 separate storage operations (limit of 4MB total size).</span></span> <span data-ttu-id="7090f-523">Feltéve, hogy ugyanannyi hello entitások toobe beolvasni, a lekérdezheti is belül egyetlen partícióra adatok (de mutatunk be további ajánlások tábla adatok lekérdezése) partíciók kiterjedő adatok hatékonyabban.</span><span class="sxs-lookup"><span data-stu-id="7090f-523">Assuming hello same number of entities toobe retrieved, you can also query data within a single partition more efficiently than data that spans partitions (though read on for further recommendations on querying table data).</span></span>
* <span data-ttu-id="7090f-524">A méretezhetőségi korlátot: egyetlen partícióra tárolt hozzáférés tooentities nem lehet elosztott terhelésű mert partíciók támogatja a atomi kötegelt tranzakciókat.</span><span class="sxs-lookup"><span data-stu-id="7090f-524">Scalability limit: Access tooentities stored in a single partition cannot be load-balanced because partitions support atomic batch transactions.</span></span> <span data-ttu-id="7090f-525">Emiatt hello méretezhetőség egyedi tábla partícióhoz célja alacsonyabb, mint a hello table szolgáltatás egészére.</span><span class="sxs-lookup"><span data-stu-id="7090f-525">For this reason, hello scalability target for an individual table partition is lower than for hello table service as a whole.</span></span>  

<span data-ttu-id="7090f-526">Miatt a következő jellemzőkkel táblák és-partíciók el kell fogadnia a következő tervezési alapelvek hello:</span><span class="sxs-lookup"><span data-stu-id="7090f-526">Because of these characteristics of tables and partitions, you should adopt hello following design principles:</span></span>  

* <span data-ttu-id="7090f-527">Az ügyfélalkalmazás gyakran frissíteni vagy ugyanazon logikai egység munka kell elhelyezkedniük hello kérdezhetők le adatokat hello egyazon partícióra kerüljenek.</span><span class="sxs-lookup"><span data-stu-id="7090f-527">Data that your client application frequently updated or queried in hello same logical unit of work should be located in hello same partition.</span></span>  <span data-ttu-id="7090f-528">Ennek az lehet az oka az alkalmazás van összesítése írási műveleteket, vagy azt szeretné, hogy atomi kötegműveletek tootake előnyeit.</span><span class="sxs-lookup"><span data-stu-id="7090f-528">This may be because your application is aggregating writes, or because you want tootake advantage of atomic batch operations.</span></span>  <span data-ttu-id="7090f-529">Is egy olyan partíciót adatok hatékonyabban lekérhetők az egyetlen lekérdezés mint adat partíciók között.</span><span class="sxs-lookup"><span data-stu-id="7090f-529">Also, data in a single partition can be more efficiently queried in a single query than data across partitions.</span></span>
* <span data-ttu-id="7090f-530">Az ügyfélalkalmazás nem beszúrásához vagy frissítéséhez vagy adatok lekérdezés hello ugyanazon logikai egység munka (egyetlen lekérdezés vagy kötegelt frissítése) kell elhelyezni, a különböző partíciók.</span><span class="sxs-lookup"><span data-stu-id="7090f-530">Data that your client application does not insert/update or query in hello same logical unit of work (single query or batch update) should be located in separate partitions.</span></span>  <span data-ttu-id="7090f-531">Egy fontos: az, hogy nincs nincs korlát toohello számú partíciós kulcsok található egyetlen táblában, így több millió partíciós kulcsok esetében nem jelent problémát, és nem lesz hatással a teljesítményre.</span><span class="sxs-lookup"><span data-stu-id="7090f-531">One important note is that there is no limit toohello number of partition keys in a single table, so having millions of partition keys is not a problem and will not impact performance.</span></span>  <span data-ttu-id="7090f-532">Például ha az alkalmazás rendelkező felhasználói bejelentkezés népszerű webhely, hello felhasználói azonosítót használja, mint hello partíciókulcs lehet érdemes választani.</span><span class="sxs-lookup"><span data-stu-id="7090f-532">For example, if your application is a popular website with user login, using hello User Id as hello partition key could be a good choice.</span></span>  

#### <a name="hot-partitions"></a><span data-ttu-id="7090f-533">Működés közbeni partíciók</span><span class="sxs-lookup"><span data-stu-id="7090f-533">Hot Partitions</span></span>
<span data-ttu-id="7090f-534">A működés közbeni partíció egyik fogadó egy hello forgalom tooan fiók le aránytalanul nagy részét, és nem kell az elosztott terhelésű mert egyetlen partíció.</span><span class="sxs-lookup"><span data-stu-id="7090f-534">A hot partition is one that is receiving a disproportionate percentage of hello traffic tooan account, and cannot be load balanced because it is a single partition.</span></span>  <span data-ttu-id="7090f-535">Általában a működés közbeni partíciók létrejönnek két módszer egyikével:</span><span class="sxs-lookup"><span data-stu-id="7090f-535">In general, hot partitions are created one of two ways:</span></span>  

##### <span data-ttu-id="7090f-536"><a name="subheading28"></a>Csak hozzáfűzés és illesztenie csak minták</span><span class="sxs-lookup"><span data-stu-id="7090f-536"><a name="subheading28"></a>Append Only and Prepend Only patterns</span></span>
<span data-ttu-id="7090f-537">hello "Hozzáfűzése csak" minta egyike ahol összes (vagy szinte minden) hello forgalom tooa PK megadott növeli, és csökkenti a függően toohello aktuális idő.</span><span class="sxs-lookup"><span data-stu-id="7090f-537">hello "Append Only" pattern is one where all (or nearly all) of hello traffic tooa given PK increases and decreases according toohello current time.</span></span>  <span data-ttu-id="7090f-538">Például akkor, ha az alkalmazás használt hello aktuális dátumot a naplóadatok partíciókulcsként.</span><span class="sxs-lookup"><span data-stu-id="7090f-538">An example is if your application used hello current date as a partition key for log data.</span></span>  <span data-ttu-id="7090f-539">Ennek eredményeképpen minden hello Beszúrások toohello a tábla utolsó partíciója fog, és hello rendszer nem lehet terhelést elosztani, mert hello írási műveletek mindegyike a táblázat további folyamatos toohello vége.</span><span class="sxs-lookup"><span data-stu-id="7090f-539">This results in all of hello inserts going toohello last partition in your table, and hello system cannot load balance because all of hello writes are going toohello end of your table.</span></span>  <span data-ttu-id="7090f-540">Ha hello forgalom toothat partíció meghaladják hello partíció szintű méretezhetőség célként, majd azt eredményez szabályozási.</span><span class="sxs-lookup"><span data-stu-id="7090f-540">If hello volume of traffic toothat partition exceeds hello partition-level scalability target, then it will result in throttling.</span></span>  <span data-ttu-id="7090f-541">Jobb tooensure elküldött forgalom toomultiple partíciók, célszerű a tooenable load balance hello keresztül a tábla kéri.</span><span class="sxs-lookup"><span data-stu-id="7090f-541">It's better tooensure that traffic is sent toomultiple partitions, tooenable load balance hello requests across your table.</span></span>  

##### <span data-ttu-id="7090f-542"><a name="subheading29"></a>Nagy forgalmú adatok</span><span class="sxs-lookup"><span data-stu-id="7090f-542"><a name="subheading29"></a>High-Traffic Data</span></span>
<span data-ttu-id="7090f-543">Ha a particionálási sémát eredményezi egy olyan partíciót, amelyek csak adatok, mint a többi partíció sokkal használt, is találkozhat sávszélesség-szabályozás, az adott partíció megközelíti hello méretezhetőség célja egy olyan partíciót.</span><span class="sxs-lookup"><span data-stu-id="7090f-543">If your partitioning scheme results in a single partition that just has data that is far more used than other partitions, you may also see throttling as that partition approaches hello scalability target for a single partition.</span></span>  <span data-ttu-id="7090f-544">Jobb toomake meg arról, hogy a partíció sémát eredményezi nincs egyetlen partition megközelíti hello méretezhetőségi célok.</span><span class="sxs-lookup"><span data-stu-id="7090f-544">It's better toomake sure that your partition scheme results in no single partition approaching hello scalability targets.</span></span>  

#### <a name="querying"></a><span data-ttu-id="7090f-545">Lekérdezése</span><span class="sxs-lookup"><span data-stu-id="7090f-545">Querying</span></span>
<span data-ttu-id="7090f-546">Ez a szakasz ismerteti a bevált gyakorlat hello table szolgáltatás lekérdezése.</span><span class="sxs-lookup"><span data-stu-id="7090f-546">This section describes proven practices for querying hello table service.</span></span>  

##### <span data-ttu-id="7090f-547"><a name="subheading30"></a>Lekérdezés hatóköre</span><span class="sxs-lookup"><span data-stu-id="7090f-547"><a name="subheading30"></a>Query Scope</span></span>
<span data-ttu-id="7090f-548">Számos különböző módokon toospecify hello entitások tooquery.</span><span class="sxs-lookup"><span data-stu-id="7090f-548">There are several ways toospecify hello range of entities tooquery.</span></span>  <span data-ttu-id="7090f-549">hello az alábbiakban az egyes hello használatát tárgyalja.</span><span class="sxs-lookup"><span data-stu-id="7090f-549">hello following is a discussion of hello uses of each.</span></span>  

<span data-ttu-id="7090f-550">Általában elkerülése érdekében a vizsgálatok (lekérdezések nagyobb, mint egyetlen entitás), de kell beolvasni, ha próbálja tooorganize az adatokat, hogy a vizsgálatok vagy a felesleges entitások jelentős mennyiségű visszaadó nélkül kell hello adatainak beolvasása.</span><span class="sxs-lookup"><span data-stu-id="7090f-550">In general, avoid scans (queries larger than a single entity), but if you must scan, try tooorganize your data so that your scans retrieve hello data you need without scanning or returning significant amounts of entities you don't need.</span></span>  

###### <a name="point-queries"></a><span data-ttu-id="7090f-551">Pont lekérdezések</span><span class="sxs-lookup"><span data-stu-id="7090f-551">Point Queries</span></span>
<span data-ttu-id="7090f-552">Egy pont lekérdezés lekéri pontosan egy entitást.</span><span class="sxs-lookup"><span data-stu-id="7090f-552">A point query retrieves exactly one entity.</span></span> <span data-ttu-id="7090f-553">Ennek érdekében hello partíciókulcs és hello entitás tooretrieve sor kulcsa.</span><span class="sxs-lookup"><span data-stu-id="7090f-553">It does this by specifying both hello partition key and row key of hello entity tooretrieve.</span></span> <span data-ttu-id="7090f-554">Ezeket a lekérdezéseket, nagyon hatékony, és ajánlott őket, amikor csak lehetséges.</span><span class="sxs-lookup"><span data-stu-id="7090f-554">These queries are very efficient, and you should use them wherever possible.</span></span>  

###### <a name="partition-queries"></a><span data-ttu-id="7090f-555">Partíció lekérdezések</span><span class="sxs-lookup"><span data-stu-id="7090f-555">Partition Queries</span></span>
<span data-ttu-id="7090f-556">A partíciólekérdezés osztja meg a közös partíciókulcsot adatok olyan készlete, amely.</span><span class="sxs-lookup"><span data-stu-id="7090f-556">A partition query is a query that retrieves a set of data that shares a common partition key.</span></span> <span data-ttu-id="7090f-557">Általában hello lekérdezés határozza meg a sor értékek tartománya vagy néhány entitás tulajdonság értéktartománya hozzáadása tooa partíciós kulcs.</span><span class="sxs-lookup"><span data-stu-id="7090f-557">Typically, hello query specifies a range of row key values or a range of values for some entity property in addition tooa partition key.</span></span> <span data-ttu-id="7090f-558">Ezek pont lekérdezések-nél kevésbé hatékonyak, és takarékosan.</span><span class="sxs-lookup"><span data-stu-id="7090f-558">These are less efficient than point queries, and should be used sparingly.</span></span>  

###### <a name="table-queries"></a><span data-ttu-id="7090f-559">Tábla lekérdezések</span><span class="sxs-lookup"><span data-stu-id="7090f-559">Table Queries</span></span>
<span data-ttu-id="7090f-560">A lekérdezés, amely nem ugyanazt a közös partíciókulcsot az entitások készletének, amely.</span><span class="sxs-lookup"><span data-stu-id="7090f-560">A table query is a query that retrieves a set of entities that does not share a common partition key.</span></span> <span data-ttu-id="7090f-561">Ezeket a lekérdezéseket nem hatékony, és lehetőség szerint kerülje azokat.</span><span class="sxs-lookup"><span data-stu-id="7090f-561">These queries are not efficient and you should avoid them if possible.</span></span>  

##### <span data-ttu-id="7090f-562"><a name="subheading31"></a>Lekérdezés sűrűség</span><span class="sxs-lookup"><span data-stu-id="7090f-562"><a name="subheading31"></a>Query Density</span></span>
<span data-ttu-id="7090f-563">Egy másik lekérdezés hatékonyságát kulcsfontosságú tényező beolvasott toofind hello visszaadott beállított entitások összehasonlított toohello számát adja vissza a entitások hello számát jelenti.</span><span class="sxs-lookup"><span data-stu-id="7090f-563">Another key factor in query efficiency is hello number of entities returned as compared toohello number of entities scanned toofind hello returned set.</span></span> <span data-ttu-id="7090f-564">Ha az alkalmazást, hogy csak 1 % hello adatok megosztások, hello lekérdezés megvizsgálja összes adja vissza egy entitás 100 entitást tulajdonság értéke szűrőt tartalmazó tábla lekérdezést hajt végre.</span><span class="sxs-lookup"><span data-stu-id="7090f-564">If your application performs a table query with a filter for a property value that only 1% of hello data shares, hello query will scan 100 entities for every one entity it returns.</span></span> <span data-ttu-id="7090f-565">hello tábla méretezhetőségi célok tárgyalt korábban az összes kapcsolódó beolvasott entitások toohello száma, és nem hello visszaadott entitások száma: lekérdezés kis sűrűségű könnyen okozhat hello tábla szolgáltatás toothrottle az alkalmazás, mert olyan sok kell vizsgálata entitások tooretrieve hello entitásra keres.</span><span class="sxs-lookup"><span data-stu-id="7090f-565">hello table scalability targets discussed previously all relate toohello number of entities scanned, and not hello number of entities returned: a low query density can easily cause hello table service toothrottle your application because it must scan so many entities tooretrieve hello entity you are looking for.</span></span>  <span data-ttu-id="7090f-566">Lásd az alábbi szakasz hello a [denormalization](#subheading34) további információt a tooavoid ez.</span><span class="sxs-lookup"><span data-stu-id="7090f-566">See hello section below on [denormalization](#subheading34) for more information on how tooavoid this.</span></span>  

##### <a name="limiting-hello-amount-of-data-returned"></a><span data-ttu-id="7090f-567">Mennyi az adatok visszaadásához hello korlátozása</span><span class="sxs-lookup"><span data-stu-id="7090f-567">Limiting hello Amount of Data Returned</span></span>
###### <span data-ttu-id="7090f-568"><a name="subheading32"></a>Szűrés</span><span class="sxs-lookup"><span data-stu-id="7090f-568"><a name="subheading32"></a>Filtering</span></span>
<span data-ttu-id="7090f-569">Ha tudja, hogy a lekérdezés entitások ne hello ügyfélalkalmazás visszatér, fontolja meg egy szűrő tooreduce hello mérete hello beállítása adott vissza.</span><span class="sxs-lookup"><span data-stu-id="7090f-569">Where you know that a query will return entities that you don't need in hello client application, consider using a filter tooreduce hello size of hello returned set.</span></span> <span data-ttu-id="7090f-570">Közben hello entitások nem toohello ügyfél továbbra is száma hello méretezhetőségi korlátok felé, az alkalmazások teljesítményéről fog miatt hello kisebb hálózati terhelés méretének növelése és a hello arról, hogy az ügyfélalkalmazás kell folyamat entitások csökkentett száma .</span><span class="sxs-lookup"><span data-stu-id="7090f-570">While hello entities not returned toohello client still count toward hello scalability limits, your application performance will improve because of hello reduced network payload size and hello reduced number of entities that your client application must process.</span></span>  <span data-ttu-id="7090f-571">A Megjegyzés fent látható [lekérdezés sűrűség](#subheading31), azonban – hello méretezhetőségi célok vonatkoznak-e a beolvasott, entitások toohello száma, a lekérdezés, amely a számos entitás továbbra is eredményezhet sávszélesség-szabályozás, még akkor is, ha néhány entitásokat ad vissza.</span><span class="sxs-lookup"><span data-stu-id="7090f-571">See above note on [Query Density](#subheading31), however – hello scalability targets relate toohello number of entities scanned, so a query that filters out many entities may still result in throttling, even if few entities are returned.</span></span>  

###### <span data-ttu-id="7090f-572"><a name="subheading33"></a>Leképezése</span><span class="sxs-lookup"><span data-stu-id="7090f-572"><a name="subheading33"></a>Projection</span></span>
<span data-ttu-id="7090f-573">Ha az ügyfélalkalmazást igényel, csak korlátozott számú tulajdonságok a hello entitásokból a táblázatban, leképezés toolimit hello hello visszaadott adatok méretétől is használhatja.</span><span class="sxs-lookup"><span data-stu-id="7090f-573">If your client application needs only a limited set of properties from hello entities in your table, you can use projection toolimit hello size of hello returned data set.</span></span> <span data-ttu-id="7090f-574">Csakúgy, mint a szűrés, ez segít tooreduce hálózati terhelés és ügyfél feldolgozása.</span><span class="sxs-lookup"><span data-stu-id="7090f-574">As with filtering, this helps tooreduce network load and client processing.</span></span>  

##### <span data-ttu-id="7090f-575"><a name="subheading34"></a>Denormalization</span><span class="sxs-lookup"><span data-stu-id="7090f-575"><a name="subheading34"></a>Denormalization</span></span>
<span data-ttu-id="7090f-576">Ellentétben a relációs adatbázisok használata hello hatékonyan a tábla adatainak lekérdezése bevált gyakorlatok vezethet toodenormalizing adatait.</span><span class="sxs-lookup"><span data-stu-id="7090f-576">Unlike working with relational databases, hello proven practices for efficiently querying table data lead toodenormalizing your data.</span></span> <span data-ttu-id="7090f-577">Ez azt jelenti, hogy ugyanazokat az adatokat a több egység duplikálását hello (egy toofind hello adatok segítségével minden kulcs), hogy a lekérdezés toofind hello adatok hello ügyféloldali igények, ahelyett, hogy entitások toofind tooscan nagyszámú kell beolvasni entitások toominimize hello száma hello adatoknak az alkalmazás kell.</span><span class="sxs-lookup"><span data-stu-id="7090f-577">That is, duplicating hello same data in multiple entities (one for each key you may use toofind hello data) toominimize hello number of entities that a query must scan toofind hello data hello client needs, rather than having tooscan large numbers of entities toofind hello data your application needs.</span></span>  <span data-ttu-id="7090f-578">Például az elektronikus kereskedelmi webhely, érdemes lehet toofind egy rendezési mindkét hello ügyfél-azonosítója (, adja meg a megrendelések) és hello dátum (engedi rendelések napon).</span><span class="sxs-lookup"><span data-stu-id="7090f-578">For example, in an e-commerce website, you may want toofind an order both by hello customer ID (give me this customer's orders) and by hello date (give me orders on a date).</span></span>  <span data-ttu-id="7090f-579">A Table Storage esetében ajánlott toostore hello entitás (vagy egy hivatkozás tooit) kétszer – egyszer az ügyfél-azonosító, egyszer toofacilitate találja hello dátum szerint táblanév PK és RK toofacilitate találja.</span><span class="sxs-lookup"><span data-stu-id="7090f-579">In Table Storage, it is best toostore hello entity (or a reference tooit) twice – once with Table Name, PK, and RK toofacilitate finding by customer ID, once toofacilitate finding it by hello date.</span></span>  

#### <a name="insertupdatedelete"></a><span data-ttu-id="7090f-580">Insert/Update/Delete</span><span class="sxs-lookup"><span data-stu-id="7090f-580">Insert/Update/Delete</span></span>
<span data-ttu-id="7090f-581">Ez a szakasz ismerteti a bevált eljárásokat a hello table szolgáltatás tárolt entitásokat módosítását.</span><span class="sxs-lookup"><span data-stu-id="7090f-581">This section describes proven practices for modifying entities stored in hello table service.</span></span>  

##### <span data-ttu-id="7090f-582"><a name="subheading35"></a>Kötegelés</span><span class="sxs-lookup"><span data-stu-id="7090f-582"><a name="subheading35"></a>Batching</span></span>
<span data-ttu-id="7090f-583">Kötegelt tranzakciókat ismert, entitás csoport tranzakciók (ETG) az Azure Storage; minden hello műveletet egy ETG belül egyetlen partícióra található egyetlen táblában kell lennie.</span><span class="sxs-lookup"><span data-stu-id="7090f-583">Batch transactions are known as Entity Group Transactions (ETG) in Azure Storage; all hello operations within an ETG must be on a single partition in a single table.</span></span> <span data-ttu-id="7090f-584">Ahol lehetséges, használjon ETGs tooperform Beszúrások, a frissítések és törlések kötegekben.</span><span class="sxs-lookup"><span data-stu-id="7090f-584">Where possible, use ETGs tooperform inserts, updates, and deletes in batches.</span></span> <span data-ttu-id="7090f-585">Ez csökkenti a kiszolgálókkal való adatváltások számát hello számát az ügyfél alkalmazás toohello kiszolgálóról, csökkenti (egy ETG más célra egyetlen tranzakció számít, és tartalmazhat too100 tárolási műveletek mentése) számlázható tranzakciók hello száma, és lehetővé teszi a atomi frissítések (sikeres minden műveletnél vagy az összes sikertelen egy ETG belül).</span><span class="sxs-lookup"><span data-stu-id="7090f-585">This reduces hello number of round trips from your client application toohello server, reduces hello number of billable transactions (an ETG counts as a single transaction for billing purposes and can contain up too100 storage operations), and enables atomic updates (all operations succeed or all fail within an ETG).</span></span> <span data-ttu-id="7090f-586">Például a mobil eszközök nagy késleltetésű környezetek nagy mértékben előnyösek, ETGs használatával.</span><span class="sxs-lookup"><span data-stu-id="7090f-586">Environments with high latencies such as mobile devices will benefit greatly from using ETGs.</span></span>  

##### <span data-ttu-id="7090f-587"><a name="subheading36"></a>Upsert</span><span class="sxs-lookup"><span data-stu-id="7090f-587"><a name="subheading36"></a>Upsert</span></span>
<span data-ttu-id="7090f-588">Használjon tábla **Upsert** műveletek lehetőség.</span><span class="sxs-lookup"><span data-stu-id="7090f-588">Use table **Upsert** operations wherever possible.</span></span> <span data-ttu-id="7090f-589">Két típusa van **Upsert**, mindkettőnek hatékonyabb, mint egy hagyományos lehet **beszúrása** és **frissítés** műveletek:</span><span class="sxs-lookup"><span data-stu-id="7090f-589">There are two types of **Upsert**, both of which can be more efficient than a traditional **Insert** and **Update** operations:</span></span>  

* <span data-ttu-id="7090f-590">**InsertOrMerge**: ezzel, ha azt szeretné, hogy tooupload hello entitás tulajdonságok részhalmazát, de nem biztos benne, hogy hello entitás már létezik.</span><span class="sxs-lookup"><span data-stu-id="7090f-590">**InsertOrMerge**: Use this when you want tooupload a subset of hello entity's properties, but aren't sure whether hello entity already exists.</span></span> <span data-ttu-id="7090f-591">Ha hello entitás létezik, a hívás frissíti hello szereplő hello tulajdonságok **Upsert** műveletet, és minden meglévő tulajdonságainak bízza, mint azok, ha hello entitás nem létezik, hello új entitás beilleszti.</span><span class="sxs-lookup"><span data-stu-id="7090f-591">If hello entity exists, this call updates hello properties included in hello **Upsert** operation, and leaves all existing properties as they are, if hello entity does not exist, it inserts hello new entity.</span></span> <span data-ttu-id="7090f-592">Ez hasonló toousing leképezése egy lekérdezésben abban, hogy csak a tooupload hello tulajdonságokhoz módosítani kell.</span><span class="sxs-lookup"><span data-stu-id="7090f-592">This is similar toousing projection in a query, in that you only need tooupload hello properties that are changing.</span></span>
* <span data-ttu-id="7090f-593">**InsertOrReplace**: ezt használja, ha azt szeretné, hogy egy teljesen új entitás tooupload, de azt nem biztos benne, hogy létezik-e.</span><span class="sxs-lookup"><span data-stu-id="7090f-593">**InsertOrReplace**: Use this when you want tooupload an entirely new entity, but you aren't sure whether it already exists.</span></span> <span data-ttu-id="7090f-594">Ön csak akkor használható Ha ismeri a adott hello újonnan feltöltött entitás nem teljes mértékben megfelelő, mert a régi entitás hello teljesen felülírja.</span><span class="sxs-lookup"><span data-stu-id="7090f-594">You should only use this when you know that hello newly uploaded entity is entirely correct because it completely overwrites hello old entity.</span></span> <span data-ttu-id="7090f-595">Például azt szeretné, hogy tooupdate hello entitás, amely tárolja a felhasználó aktuális helye függetlenül-e hello alkalmazás korábban találhatók meg a helyadatok hello felhasználó; Új hely entitás befejeződött, és nincs szükség az adatok minden korábbi entitás hello.</span><span class="sxs-lookup"><span data-stu-id="7090f-595">For example, you want tooupdate hello entity that stores a user's current location regardless of whether or not hello application has previously stored location data for hello user; hello new location entity is complete, and you do not need any information from any previous entity.</span></span>

##### <span data-ttu-id="7090f-596"><a name="subheading37"></a>Az Adatsorozatban tárolja egyetlen entitás</span><span class="sxs-lookup"><span data-stu-id="7090f-596"><a name="subheading37"></a>Storing Data Series in a Single Entity</span></span>
<span data-ttu-id="7090f-597">Egyes esetekben az alkalmazás tárolja, hogy gyakran szükséges adatokat tooretrieve egyszerre több: például egy alkalmazás előfordulhat, hogy nyomon CPU-használat idővel rendelés tooplot hello adatok a működés közbeni diagram hello utolsó 24 órában.</span><span class="sxs-lookup"><span data-stu-id="7090f-597">Sometimes, an application stores a series of data that it frequently needs tooretrieve all at once: for example, an application might track CPU usage over time in order tooplot a rolling chart of hello data from hello last 24 hours.</span></span> <span data-ttu-id="7090f-598">Egy megoldás, toohave egy olyan táblát, óránként rendelkező entitás minden egyes entitás egy adott órát jelölő és a CPU-használat hello tárolása, hogy egy óra.</span><span class="sxs-lookup"><span data-stu-id="7090f-598">One approach is toohave one table entity per hour, with each entity representing a specific hour and storing hello CPU usage for that hour.</span></span> <span data-ttu-id="7090f-599">tooplot ezeket az adatokat, hello alkalmazás kell tooretrieve hello entitások okozó hello hello adatait legutóbbi 24 órában.</span><span class="sxs-lookup"><span data-stu-id="7090f-599">tooplot this data, hello application needs tooretrieve hello entities holding hello data from hello 24 most recent hours.</span></span>  

<span data-ttu-id="7090f-600">Azt is megteheti, az alkalmazás sikerült tárolni hello CPU-használat minden órában egyetlen entitás külön tulajdonságként: tooupdate minden órában, az alkalmazás használhat egyetlen **InsertOrMerge Upsert** hello tooupdate hello érték meghívása legutóbbi órában.</span><span class="sxs-lookup"><span data-stu-id="7090f-600">Alternatively, your application could store hello CPU usage for each hour as a separate property of a single entity: tooupdate each hour, your application can use a single **InsertOrMerge Upsert** call tooupdate hello value for hello most recent hour.</span></span> <span data-ttu-id="7090f-601">tooplot hello adatokat, a hello alkalmazást csak kell tooretrieve 24, így egy nagyon hatékony lekérdezés helyett egyetlen entitás (lásd fentebb vitafórum a [hatókör lekérdezése](#subheading30)).</span><span class="sxs-lookup"><span data-stu-id="7090f-601">tooplot hello data, hello application only needs tooretrieve a single entity instead of 24, making for a very efficient query (see above discussion on [query scope](#subheading30)).</span></span>

##### <span data-ttu-id="7090f-602"><a name="subheading38"></a>A blobok strukturált adatok tárolására</span><span class="sxs-lookup"><span data-stu-id="7090f-602"><a name="subheading38"></a>Storing structured data in blobs</span></span>
<span data-ttu-id="7090f-603">Egyes esetekben strukturált adatok érzi, például táblázatokban, el kell, de az entitások tartományok mindig olvassa együtt, és kötegelt szúrható be.</span><span class="sxs-lookup"><span data-stu-id="7090f-603">Sometimes structured data feels like it should go in tables, but ranges of entities are always retrieved together and can be batch inserted.</span></span>  <span data-ttu-id="7090f-604">Egy jó példa erre, egy naplófájlt.</span><span class="sxs-lookup"><span data-stu-id="7090f-604">A good example of this is a log file.</span></span>  <span data-ttu-id="7090f-605">Ebben az esetben a batch-naplók néhány percig, tegye őket, és majd mindig keres, valamint egyszerre több percnyi.</span><span class="sxs-lookup"><span data-stu-id="7090f-605">In this case, you can batch several minutes of logs, insert them, and then you are always retrieving several minutes of logs at a time as well.</span></span>  <span data-ttu-id="7090f-606">Ebben az esetben a teljesítmény, ez a beállítás nagyobb toouse blobok helyett táblák, mivel Ön is jelentősen csökkentheti a objektumok írt/visszaadott hello számát, valamint általában a kérelmek száma, amelyeket hello.</span><span class="sxs-lookup"><span data-stu-id="7090f-606">In this case, for performance, it's better toouse blobs instead of tables, since you can significantly reduce hello number of objects written/returned, as well as usually hello number of requests that need made.</span></span>  

## <a name="queues"></a><span data-ttu-id="7090f-607">Üzenetsorok</span><span class="sxs-lookup"><span data-stu-id="7090f-607">Queues</span></span>
<span data-ttu-id="7090f-608">Az eljárások bizonyítása hozzáadása toohello [minden szolgáltatás](#allservices) a fentiekben ismertetett eljárásokat bizonyítása hello következő kifejezetten toohello várólista szolgáltatás alkalmazása.</span><span class="sxs-lookup"><span data-stu-id="7090f-608">In addition toohello proven practices for [All Services](#allservices) described previously, hello following proven practices apply specifically toohello queue service.</span></span>  

### <span data-ttu-id="7090f-609"><a name="subheading39"></a>Méretezhetőségi korlátok</span><span class="sxs-lookup"><span data-stu-id="7090f-609"><a name="subheading39"></a>Scalability Limits</span></span>
<span data-ttu-id="7090f-610">Egy adott sorba körülbelül 2000 üzenetek (1KB minden) (egyes AddMessage GetMessage és DeleteMessage száma itt üzenetként) másodpercenként feldolgozásához.</span><span class="sxs-lookup"><span data-stu-id="7090f-610">A single queue can process approximately 2,000 messages (1KB each) per second (each AddMessage, GetMessage, and DeleteMessage count as a message here).</span></span> <span data-ttu-id="7090f-611">Ha ez nem elegendő az alkalmazáshoz, több üzenetsorok használata, és köszönőüzenetei elosztva.</span><span class="sxs-lookup"><span data-stu-id="7090f-611">If this is insufficient for your application, you should use multiple queues and spread hello messages across them.</span></span>  

<span data-ttu-id="7090f-612">A jelenlegi méretezhetőségi célok megtekintése [Azure Storage méretezhetőségi és teljesítménycéloknak](storage-scalability-targets.md).</span><span class="sxs-lookup"><span data-stu-id="7090f-612">View current scalability targets at [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span></span>  

### <span data-ttu-id="7090f-613"><a name="subheading40"></a>Nagle kikapcsolása</span><span class="sxs-lookup"><span data-stu-id="7090f-613"><a name="subheading40"></a>Nagle Off</span></span>
<span data-ttu-id="7090f-614">Hello című rész ismerteti, amelyek hello Nagle algoritmus tábla-konfigurációban – hello Nagle algoritmus hello teljesítmény várólista kérelmek általában hibás, és tiltsa le azt.</span><span class="sxs-lookup"><span data-stu-id="7090f-614">See hello section on table configuration that discusses hello Nagle algorithm — hello Nagle algorithm is generally bad for hello performance of queue requests, and you should disable it.</span></span>  

### <span data-ttu-id="7090f-615"><a name="subheading41"></a>Üzenet mérete</span><span class="sxs-lookup"><span data-stu-id="7090f-615"><a name="subheading41"></a>Message Size</span></span>
<span data-ttu-id="7090f-616">Várólista teljesítményének és méretezhetőségének csökken a üzenet méretének növekedése.</span><span class="sxs-lookup"><span data-stu-id="7090f-616">Queue performance and scalability decreases as message size increases.</span></span> <span data-ttu-id="7090f-617">Az üzenet csak hello hello fogadó kell kell elhelyezni.</span><span class="sxs-lookup"><span data-stu-id="7090f-617">You should place only hello information hello receiver needs in a message.</span></span>  

### <span data-ttu-id="7090f-618"><a name="subheading42"></a>Kötegelt lekérése</span><span class="sxs-lookup"><span data-stu-id="7090f-618"><a name="subheading42"></a>Batch Retrieval</span></span>
<span data-ttu-id="7090f-619">Too32 üzenetek várólistából való várólistából egy művelettel kérheti le.</span><span class="sxs-lookup"><span data-stu-id="7090f-619">You can retrieve up too32 messages from a queue in a single operation.</span></span> <span data-ttu-id="7090f-620">Ez csökkentheti használatával hello száma hello ügyfélalkalmazás, ami különösen hasznos az olyan környezetekben, mobileszközök, például a nagy késleltetésű.</span><span class="sxs-lookup"><span data-stu-id="7090f-620">This can reduce hello number of roundtrips from hello client application, which is especially useful for environments, such as mobile devices, with high latency.</span></span>  

### <span data-ttu-id="7090f-621"><a name="subheading43"></a>Várólista lekérdezési időköz</span><span class="sxs-lookup"><span data-stu-id="7090f-621"><a name="subheading43"></a>Queue Polling Interval</span></span>
<span data-ttu-id="7090f-622">A legtöbb alkalmazás kérdezze le az üzenetek várólistából való várólistából, amely lehet hello legnagyobb forrásokból tranzakciók az adott alkalmazáshoz.</span><span class="sxs-lookup"><span data-stu-id="7090f-622">Most applications poll for messages from a queue, which can be one of hello largest sources of transactions for that application.</span></span> <span data-ttu-id="7090f-623">Válassza ki a lekérdezési időköz georeplikációt: lekérdezés túl gyakran okozhat az alkalmazás tooapproach hello méretezhetőségi célok hello várólista.</span><span class="sxs-lookup"><span data-stu-id="7090f-623">Select your polling interval wisely: polling too frequently could cause your application tooapproach hello scalability targets for hello queue.</span></span> <span data-ttu-id="7090f-624">Azonban 200 000 tranzakciók $0,01 (hello írásának időpontjában), a lekérdezési követően egy hónapig másodpercenként volna költség költségeket, így kevesebb mint 15 cent egyprocesszoros nincs általában egy tényező, amely befolyásolja a kiválasztott lekérdezési időközt.</span><span class="sxs-lookup"><span data-stu-id="7090f-624">However, at 200,000 transactions for $0.01 (at hello time of writing), a single processor polling once every second for a month would cost less than 15 cents so cost is not typically a factor that affects your choice of polling interval.</span></span>  

<span data-ttu-id="7090f-625">Naprakész költség információkért lásd: [Azure Storage szolgáltatás díjszabása](https://azure.microsoft.com/pricing/details/storage/).</span><span class="sxs-lookup"><span data-stu-id="7090f-625">For up-to-date cost information, see [Azure Storage Pricing](https://azure.microsoft.com/pricing/details/storage/).</span></span>  

### <span data-ttu-id="7090f-626"><a name="subheading44"></a>UpdateMessage</span><span class="sxs-lookup"><span data-stu-id="7090f-626"><a name="subheading44"></a>UpdateMessage</span></span>
<span data-ttu-id="7090f-627">Használhat **UpdateMessage** tooincrease hello láthatatlansági időtúllépés vagy tooupdate állapotadatokat üzenet.</span><span class="sxs-lookup"><span data-stu-id="7090f-627">You can use **UpdateMessage** tooincrease hello invisibility timeout or tooupdate state information of a message.</span></span> <span data-ttu-id="7090f-628">Ez nem hatékony, ne feledje, hogy minden egyes **UpdateMessage** művelet módszert hello méretezhetőség cél felé számolnak.</span><span class="sxs-lookup"><span data-stu-id="7090f-628">While this is powerful, remember that each **UpdateMessage** operation counts towards hello scalability target.</span></span> <span data-ttu-id="7090f-629">Azonban ez nem egy sokkal hatékonyabb módszert alkalmaz, mint hogy olyan munkafolyamatot, amely továbbítja a feladat egy olyan sort toohello a a következő lépésre hello feladat befejezését követően.</span><span class="sxs-lookup"><span data-stu-id="7090f-629">However, this can be a much more efficient approach than having a workflow that passes a job from one queue toohello next, as each step of hello job is completed.</span></span> <span data-ttu-id="7090f-630">Hello segítségével **UpdateMessage** művelet lehetővé teszi, hogy az alkalmazás toosave hello feladat toohello állapotüzenetet, és majd folytathatja a munkát, újra Üzenetsor-kezelés üdvözlőüzenetére hello feladat minden alkalommal, amikor egy lépés befejezése hello a következő lépéshez helyett.</span><span class="sxs-lookup"><span data-stu-id="7090f-630">Using hello **UpdateMessage** operation allows your application toosave hello job state toohello message and then continue working, instead of re-queuing hello message for hello next step of hello job every time a step completes.</span></span>  

<span data-ttu-id="7090f-631">További információkért lásd: hello cikk [hogyan: hello aszinkron üzenet tartalmának módosítása](storage-dotnet-how-to-use-queues.md#change-the-contents-of-a-queued-message).</span><span class="sxs-lookup"><span data-stu-id="7090f-631">For more information, see hello article [How to: Change hello contents of a queued message](storage-dotnet-how-to-use-queues.md#change-the-contents-of-a-queued-message).</span></span>  

### <span data-ttu-id="7090f-632"><a name="subheading45"></a>Alkalmazás-architektúra</span><span class="sxs-lookup"><span data-stu-id="7090f-632"><a name="subheading45"></a>Application architecture</span></span>
<span data-ttu-id="7090f-633">Az alkalmazás méretezhető architektúra várólisták toomake kell használnia.</span><span class="sxs-lookup"><span data-stu-id="7090f-633">You should use queues toomake your application architecture scalable.</span></span> <span data-ttu-id="7090f-634">hello következő egyes módszereket, várólisták toomake az alkalmazás több méretezhető sorolja fel:</span><span class="sxs-lookup"><span data-stu-id="7090f-634">hello following lists some ways you can use queues toomake your application more scalable:</span></span>  

* <span data-ttu-id="7090f-635">Várólisták toocreate várakozási sora munkahelyi feldolgozásához használja, és a munkaterhelések simítja az alkalmazásban.</span><span class="sxs-lookup"><span data-stu-id="7090f-635">You can use queues toocreate backlogs of work for processing and smooth out workloads in your application.</span></span> <span data-ttu-id="7090f-636">Például hogy sikerült sorba felhasználók tooperform processzor intenzív munkahelyi például feltöltött képek átméretezése érkező kérelmeket.</span><span class="sxs-lookup"><span data-stu-id="7090f-636">For example, you could queue up requests from users tooperform processor intensive work such as resizing uploaded images.</span></span>
* <span data-ttu-id="7090f-637">Az alkalmazás részei várólisták toodecouple használhatja, hogy egymástól függetlenül méretezheti őket.</span><span class="sxs-lookup"><span data-stu-id="7090f-637">You can use queues toodecouple parts of your application so that you can scale them independently.</span></span> <span data-ttu-id="7090f-638">Például egy előtér-webkiszolgáló sikerült helyezzen el felméréseket, a felhasználók egy várólista újabb elemzés és tárolására.</span><span class="sxs-lookup"><span data-stu-id="7090f-638">For example, a web front-end could place survey results from users into a queue for later analysis and storage.</span></span> <span data-ttu-id="7090f-639">Érdemes felvenni több feldolgozói szerepkör példányok tooprocess hello várólista adatokat szükség szerint.</span><span class="sxs-lookup"><span data-stu-id="7090f-639">You could add more worker role instances tooprocess hello queue data as required.</span></span>  

## <a name="conclusion"></a><span data-ttu-id="7090f-640">Összegzés</span><span class="sxs-lookup"><span data-stu-id="7090f-640">Conclusion</span></span>
<span data-ttu-id="7090f-641">Ez a cikk ismertet néhány általános, hello bizonyítása eljárások az Azure Storage használata esetén a teljesítmény optimalizálása.</span><span class="sxs-lookup"><span data-stu-id="7090f-641">This article discussed some of hello most common, proven practices for optimizing performance when using Azure Storage.</span></span> <span data-ttu-id="7090f-642">Azt minden alkalmazás fejlesztői tooassess ösztönözze az egyes eljárások fent hello alkalmazásokban, és vegye figyelembe a ható hello javaslatok tooget kiváló teljesítményt az Azure Storage használó alkalmazások esetén.</span><span class="sxs-lookup"><span data-stu-id="7090f-642">We encourage every application developer tooassess their application against each of hello above practices and consider acting on hello recommendations tooget great performance for their applications that use Azure Storage.</span></span>
