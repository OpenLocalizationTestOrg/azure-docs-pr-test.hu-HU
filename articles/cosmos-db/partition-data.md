---
title: "aaaPartitioning és Azure Cosmos DB horizontális skálázás |} Microsoft Docs"
description: "Ismerje meg, hogyan particionálási működését az Azure Cosmos Adatbázisba, hogyan tooconfigure particionálás és partíciókulcsok, és hogyan toopick jobb hello partícióazonosító kulcs az alkalmazáshoz."
services: cosmos-db
author: arramac
manager: jhubbard
editor: monicar
documentationcenter: 
ms.assetid: cac9a8cd-b5a3-4827-8505-d40bb61b2416
ms.service: cosmos-db
ms.workload: data-services
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 05/10/2017
ms.author: arramac
ms.custom: H1Hack27Feb2017
ms.openlocfilehash: 87d56db8c4ccc6b94b1650baff0fcfb3db6d1777
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 10/06/2017
---
# <a name="how-toopartition-and-scale-in-azure-cosmos-db"></a><span data-ttu-id="68ee5-103">Hogyan toopartition és az Azure Cosmos-Adatbázisba</span><span class="sxs-lookup"><span data-stu-id="68ee5-103">How toopartition and scale in Azure Cosmos DB</span></span>

<span data-ttu-id="68ee5-104">[A Microsoft Azure Cosmos DB](https://azure.microsoft.com/services/cosmos-db/) van a globális elosztott, több modellre adatbázis-szolgáltatás, amely toohelp elérni gyors és kiszámítható teljesítmény és méretezhetőség zökkenőmentesen együtt az alkalmazás növekedésével azt.</span><span class="sxs-lookup"><span data-stu-id="68ee5-104">[Microsoft Azure Cosmos DB](https://azure.microsoft.com/services/cosmos-db/) is a global distributed, multi-model database service designed toohelp you achieve fast, predictable performance and scale seamlessly along with your application as it grows.</span></span> <span data-ttu-id="68ee5-105">A cikkben megtudhatja, hogyan működik az összes hello adat particionálás modellek az Azure Cosmos Adatbázisba, és ismerteti, hogyan konfigurálhat Azure Cosmos DB tárolók tooeffectively méretezési az alkalmazások áttekintése.</span><span class="sxs-lookup"><span data-stu-id="68ee5-105">This article provides an overview of how partitioning works for all hello data models in Azure Cosmos DB, and describes how you can configure Azure Cosmos DB containers tooeffectively scale your applications.</span></span>

<span data-ttu-id="68ee5-106">Particionálás és partíciókulcsok is tartoznak az Azure-ban a Scott Hanselman és Azure Cosmos DB egyszerű mérnöki Manager, Shireesh Thota videó péntekig.</span><span class="sxs-lookup"><span data-stu-id="68ee5-106">Partitioning and partition keys are also covered in this Azure Friday video with Scott Hanselman and Azure Cosmos DB Principal Engineering Manager, Shireesh Thota.</span></span>

> [!VIDEO https://channel9.msdn.com/Shows/Azure-Friday/Azure-DocumentDB-Elastic-Scale-Partitioning/player]
> 

## <a name="partitioning-in-azure-cosmos-db"></a><span data-ttu-id="68ee5-107">Az Azure Cosmos DB particionálás</span><span class="sxs-lookup"><span data-stu-id="68ee5-107">Partitioning in Azure Cosmos DB</span></span>
<span data-ttu-id="68ee5-108">Az Azure Cosmos Adatbázisba tárolására és az ahhoz az ezredmásodperces válaszidők bármilyen léptékben séma nélküli adatait.</span><span class="sxs-lookup"><span data-stu-id="68ee5-108">In Azure Cosmos DB, you can store and query schema-less data with order-of-millisecond response times at any scale.</span></span> <span data-ttu-id="68ee5-109">Adattárolás nevű nyújt tárolók cosmos DB **gyűjtemények (a dokumentum), a diagramok és a táblázatok**.</span><span class="sxs-lookup"><span data-stu-id="68ee5-109">Cosmos DB provides containers for storing data called **collections (for document), graphs, or tables**.</span></span> <span data-ttu-id="68ee5-110">Tárolók logikai erőforrások, és egy vagy több fizikai partíciók, sem kiszolgálók is kiterjedhetnek.</span><span class="sxs-lookup"><span data-stu-id="68ee5-110">Containers are logical resources and can span one or more physical partitions or servers.</span></span> <span data-ttu-id="68ee5-111">a partíciók számának hello Cosmos DB hello tárméret és hello hello tároló kiosztott átviteli sebesség alapján határozza meg.</span><span class="sxs-lookup"><span data-stu-id="68ee5-111">hello number of partitions is determined by Cosmos DB based on hello storage size and hello provisioned throughput of hello container.</span></span> <span data-ttu-id="68ee5-112">Minden partíció Cosmos DB SSD-biztonsági tárolási társítva a rögzített méretű rendelkezik, és a magas rendelkezésre állású replikálódik.</span><span class="sxs-lookup"><span data-stu-id="68ee5-112">Every partition in Cosmos DB has a fixed amount of SSD-backed storage associated with it, and is replicated for high availability.</span></span> <span data-ttu-id="68ee5-113">Partíció felügyeleti teljes mértékben felügyelt Azure Cosmos DB, és nem rendelkezik toowrite komplex kódot, vagy a partíciók kezeléséhez.</span><span class="sxs-lookup"><span data-stu-id="68ee5-113">Partition management is fully managed by Azure Cosmos DB, and you do not have toowrite complex code or manage your partitions.</span></span> <span data-ttu-id="68ee5-114">Cosmos DB tárolók olyan tárolási és átviteli korlátlan.</span><span class="sxs-lookup"><span data-stu-id="68ee5-114">Cosmos DB containers are unlimited in terms of storage and throughput.</span></span> 

![vízszintes](./media/introduction/azure-cosmos-db-partitioning.png) 

<span data-ttu-id="68ee5-116">Particionálás: átlátszó tooyour alkalmazás.</span><span class="sxs-lookup"><span data-stu-id="68ee5-116">Partitioning is transparent tooyour application.</span></span> <span data-ttu-id="68ee5-117">Cosmos DB támogatja a gyors olvasást és írási műveleteket, lekérdezéseket, tranzakciós logika, konzisztenciaszintek, és minden részletre kiterjedő hozzáférés-vezérlés keresztül módszerek/API-k tooa egyetlen tároló-erőforrás.</span><span class="sxs-lookup"><span data-stu-id="68ee5-117">Cosmos DB supports fast reads and writes, queries, transactional logic, consistency levels, and fine-grained access control via methods/APIs tooa single container resource.</span></span> <span data-ttu-id="68ee5-118">hello szolgáltatás kezeli a terjesztés adatokat és útválasztási lekérdezési kérelmek toohello jobb partíciót között.</span><span class="sxs-lookup"><span data-stu-id="68ee5-118">hello service handles distributing data across partitions and routing query requests toohello right partition.</span></span> 

<span data-ttu-id="68ee5-119">Particionálás működése</span><span class="sxs-lookup"><span data-stu-id="68ee5-119">How does partitioning work?</span></span> <span data-ttu-id="68ee5-120">Minden elem rendelkeznie kell egy partíció és sor kulcsot, amely egyedileg azonosítja.</span><span class="sxs-lookup"><span data-stu-id="68ee5-120">Each item must have a partition key and a row key, which uniquely identify it.</span></span> <span data-ttu-id="68ee5-121">A partíciós kulcs úgy működik, mint az adatok logikai partíció, és a természetes határ Cosmos DB biztosít osztja el az adatok között partíciókat.</span><span class="sxs-lookup"><span data-stu-id="68ee5-121">Your partition key acts as a logical partition for your data, and provides Cosmos DB with a natural boundary for distributing data across partitions.</span></span> <span data-ttu-id="68ee5-122">Röviden itt található particionálási hogyan működik az Azure Cosmos DB:</span><span class="sxs-lookup"><span data-stu-id="68ee5-122">In brief, here is how partitioning works in Azure Cosmos DB:</span></span>

* <span data-ttu-id="68ee5-123">A Cosmos DB tárolóhoz kiépítése `T` kérelmek/s átviteli sebesség</span><span class="sxs-lookup"><span data-stu-id="68ee5-123">You provision a Cosmos DB container with `T` requests/s throughput</span></span>
* <span data-ttu-id="68ee5-124">Hello háttérben Cosmos DB rendelkezések partíciók szükséges tooserve `T` kérelmek/s.</span><span class="sxs-lookup"><span data-stu-id="68ee5-124">Behind hello scenes, Cosmos DB provisions partitions needed tooserve `T` requests/s.</span></span> <span data-ttu-id="68ee5-125">Ha `T` magasabb, mint a maximális átviteli hello partíciónként `t`, majd Cosmos DB rendelkezések `N`  =  `T/t` partíciók</span><span class="sxs-lookup"><span data-stu-id="68ee5-125">If `T` is higher than hello maximum throughput per partition `t`, then Cosmos DB provisions `N` = `T/t` partitions</span></span>
* <span data-ttu-id="68ee5-126">Cosmos DB foglal le hello kulcsfontosságú terület partíció kulcs kivonatok egyenletesen között hello `N` partíciókat.</span><span class="sxs-lookup"><span data-stu-id="68ee5-126">Cosmos DB allocates hello key space of partition key hashes evenly across hello `N` partitions.</span></span> <span data-ttu-id="68ee5-127">Igen minden partíció (fizikai partíció) tároló 1-N partíciókulcs-értékek (logikai partíciót)</span><span class="sxs-lookup"><span data-stu-id="68ee5-127">So, each partition (physical partition) hosts 1-N partition key values (logical partitions)</span></span>
* <span data-ttu-id="68ee5-128">Ha egy fizikai partíció `p` eléri a tárolási korlátját, Cosmos DB zökkenőmentesen felosztja a `p` két új partíciókra `p1` és `p2` és tooroughly fele hello kulcsok tooeach hello a megfelelő értékeket továbbítja partíciók.</span><span class="sxs-lookup"><span data-stu-id="68ee5-128">When a physical partition `p` reaches its storage limit, Cosmos DB seamlessly splits `p` into two new partitions `p1` and `p2` and distributes values corresponding tooroughly half hello keys tooeach of hello partitions.</span></span> <span data-ttu-id="68ee5-129">Ez split művelet akkor, láthatatlan tooyour alkalmazás.</span><span class="sxs-lookup"><span data-stu-id="68ee5-129">This split operation is invisible tooyour application.</span></span>
* <span data-ttu-id="68ee5-130">Ha ehhez hasonlóan a nagyobb átviteli sebesség kiépítése `t*N` átviteli sebességet Cosmos DB felosztja a legalább egy, a partíciók toosupport hello nagyobb átviteli sebesség</span><span class="sxs-lookup"><span data-stu-id="68ee5-130">Similarly, when you provision throughput higher than `t*N` throughput, Cosmos DB splits one or more of your partitions toosupport hello higher throughput</span></span>

<span data-ttu-id="68ee5-131">hello szemantikája partíciós kulcsok némileg eltérő toomatch hello szemantikáját minden API-t, hello a következő táblázatban ismertetett módon:</span><span class="sxs-lookup"><span data-stu-id="68ee5-131">hello semantics for partition keys are slightly different toomatch hello semantics of each API, as shown in hello following table:</span></span>

| <span data-ttu-id="68ee5-132">API</span><span class="sxs-lookup"><span data-stu-id="68ee5-132">API</span></span> | <span data-ttu-id="68ee5-133">Partíciókulcs</span><span class="sxs-lookup"><span data-stu-id="68ee5-133">Partition Key</span></span> | <span data-ttu-id="68ee5-134">Sorkulcsa</span><span class="sxs-lookup"><span data-stu-id="68ee5-134">Row Key</span></span> |
| --- | --- | --- |
| <span data-ttu-id="68ee5-135">DocumentDB</span><span class="sxs-lookup"><span data-stu-id="68ee5-135">DocumentDB</span></span> | <span data-ttu-id="68ee5-136">egyéni partíciós kulcs elérési útja</span><span class="sxs-lookup"><span data-stu-id="68ee5-136">custom partition key path</span></span> | <span data-ttu-id="68ee5-137">rögzített`id`</span><span class="sxs-lookup"><span data-stu-id="68ee5-137">fixed `id`</span></span> | 
| <span data-ttu-id="68ee5-138">MongoDB</span><span class="sxs-lookup"><span data-stu-id="68ee5-138">MongoDB</span></span> | <span data-ttu-id="68ee5-139">egyéni shard kulcs</span><span class="sxs-lookup"><span data-stu-id="68ee5-139">custom shard key</span></span>  | <span data-ttu-id="68ee5-140">rögzített`_id`</span><span class="sxs-lookup"><span data-stu-id="68ee5-140">fixed `_id`</span></span> | 
| <span data-ttu-id="68ee5-141">Graph</span><span class="sxs-lookup"><span data-stu-id="68ee5-141">Graph</span></span> | <span data-ttu-id="68ee5-142">egyéni partíció kulcstulajdonság</span><span class="sxs-lookup"><span data-stu-id="68ee5-142">custom partition key property</span></span> | <span data-ttu-id="68ee5-143">rögzített`id`</span><span class="sxs-lookup"><span data-stu-id="68ee5-143">fixed `id`</span></span> | 
| <span data-ttu-id="68ee5-144">Tábla</span><span class="sxs-lookup"><span data-stu-id="68ee5-144">Table</span></span> | <span data-ttu-id="68ee5-145">rögzített`PartitionKey`</span><span class="sxs-lookup"><span data-stu-id="68ee5-145">fixed `PartitionKey`</span></span> | <span data-ttu-id="68ee5-146">rögzített`RowKey`</span><span class="sxs-lookup"><span data-stu-id="68ee5-146">fixed `RowKey`</span></span> | 

<span data-ttu-id="68ee5-147">Cosmos DB használ, a particionálás kivonat-alapú.</span><span class="sxs-lookup"><span data-stu-id="68ee5-147">Cosmos DB uses hash-based partitioning.</span></span> <span data-ttu-id="68ee5-148">Egy cikk írásakor Cosmos DB kivonatolják hello partíciókulcs-értékkel, és használjon hello kivonatolt eredmény toodetermine melyik partíció toostore hello elem.</span><span class="sxs-lookup"><span data-stu-id="68ee5-148">When you write an item, Cosmos DB hashes hello partition key value and use hello hashed result toodetermine which partition toostore hello item in.</span></span> <span data-ttu-id="68ee5-149">Az összes elem található ugyanazzal a partíciókulccsal hello cosmos DB tárolók hello ugyanazon fizikai partícióján.</span><span class="sxs-lookup"><span data-stu-id="68ee5-149">Cosmos DB stores all items with hello same partition key in hello same physical partition.</span></span> <span data-ttu-id="68ee5-150">hello választott hello partíciós kulcs nem egy fontos döntés, hogy rendelkezik-e toomake tervezési időben.</span><span class="sxs-lookup"><span data-stu-id="68ee5-150">hello choice of hello partition key is an important decision that you have toomake at design time.</span></span> <span data-ttu-id="68ee5-151">Válasszon ki egy tulajdonság neve, amely számos különböző értékeket tartalmaz, és nem is memóriahozzáférési mintáitól.</span><span class="sxs-lookup"><span data-stu-id="68ee5-151">You must pick a property name that has a wide range of values and has even access patterns.</span></span>

> [!NOTE]
> <span data-ttu-id="68ee5-152">A bevált gyakorlat toohave (100 db-1000 egység minimális) számos különböző értékekkel partíciós kulcs is.</span><span class="sxs-lookup"><span data-stu-id="68ee5-152">It is a best practice toohave a partition key with many distinct values (100s-1000s at a minimum).</span></span>
>

<span data-ttu-id="68ee5-153">Az Azure Cosmos DB tárolók hozhatók létre "fixed" vagy "korlátlan."</span><span class="sxs-lookup"><span data-stu-id="68ee5-153">Azure Cosmos DB containers can be created as "fixed" or "unlimited."</span></span> <span data-ttu-id="68ee5-154">Rögzített méretű tárolók rendelkezik egy legfeljebb 10 GB és 10000 RU/s átviteli sebesség.</span><span class="sxs-lookup"><span data-stu-id="68ee5-154">Fixed-size containers have a maximum limit of 10 GB and 10,000 RU/s throughput.</span></span> <span data-ttu-id="68ee5-155">Egyes API-k engedélyezése hello partíciós kulcs toobe nincs megadva, a rögzített méretű tárolók.</span><span class="sxs-lookup"><span data-stu-id="68ee5-155">Some APIs allow hello partition key toobe omitted for fixed-size containers.</span></span> <span data-ttu-id="68ee5-156">egy tároló korlátlan mint toocreate, meg kell adnia egy minimális átviteli sebességgel 2500 RU/mp.</span><span class="sxs-lookup"><span data-stu-id="68ee5-156">toocreate a container as unlimited, you must specify a minimum throughput of 2500 RU/s.</span></span>

## <a name="partitioning-and-provisioned-throughput"></a><span data-ttu-id="68ee5-157">Particionálási és kiosztott átviteli sebesség</span><span class="sxs-lookup"><span data-stu-id="68ee5-157">Partitioning and provisioned throughput</span></span>
<span data-ttu-id="68ee5-158">Kiszámítható teljesítmény cosmos DB készült.</span><span class="sxs-lookup"><span data-stu-id="68ee5-158">Cosmos DB is designed for predictable performance.</span></span> <span data-ttu-id="68ee5-159">Amikor létrehoz egy tárolót, a teljesítményt a lefoglalni  **[egységek kérelem](request-units.md) (RU) percenkénti RU egy potenciális bővítmény másodpercenként**.</span><span class="sxs-lookup"><span data-stu-id="68ee5-159">When you create a container, you reserve throughput in terms of **[request units](request-units.md) (RU) per second with a potential add-on for RU per minute**.</span></span> <span data-ttu-id="68ee5-160">Minden, például a Processzor, memória és I/O hello művelet által felhasznált rendszererőforrás arányos toohello mennyiségű kérést egység díj felelős.</span><span class="sxs-lookup"><span data-stu-id="68ee5-160">Each request is assigned a request unit charge that is proportionate toohello amount of system resources like CPU, Memory, and IO consumed by hello operation.</span></span> <span data-ttu-id="68ee5-161">Egy 1 KB-os dokumentum munkamenet-konzisztencia olvasási egy kérelem egységet használ fel.</span><span class="sxs-lookup"><span data-stu-id="68ee5-161">A read of a 1-KB document with Session consistency consumes one request unit.</span></span> <span data-ttu-id="68ee5-162">Egy olvasási 1 RU függetlenül hello elemszáma tárolt vagy hello futó egyidejű kérelmek száma hello ugyanannyi időt vesz igénybe.</span><span class="sxs-lookup"><span data-stu-id="68ee5-162">A read is 1 RU regardless of hello number of items stored or hello number of concurrent requests running at hello same time.</span></span> <span data-ttu-id="68ee5-163">Nagyobb elemek szükség magasabb kérelemegység hello méretétől függően.</span><span class="sxs-lookup"><span data-stu-id="68ee5-163">Larger items require higher request units depending on hello size.</span></span> <span data-ttu-id="68ee5-164">Ha ismeri az entitások hello méretét és olvasások száma hello toosupport van szüksége az alkalmazás, az alkalmazás csomagazonosítóját kell olvasni a szükséges átviteli pontos mennyisége hello oszthat.</span><span class="sxs-lookup"><span data-stu-id="68ee5-164">If you know hello size of your entities and hello number of reads you need toosupport for your application, you can provision hello exact amount of throughput required for your application's read needs.</span></span> 

> [!NOTE]
> <span data-ttu-id="68ee5-165">tooachieve hello teljes átviteli képessége – hello tároló, ki kell választania, amely lehetővé teszi tooevenly partíciós kulcs terjesztése kérelmek néhány különböző partíciókulcs-értékek között.</span><span class="sxs-lookup"><span data-stu-id="68ee5-165">tooachieve hello full throughput of hello container, you must choose a partition key that allows you tooevenly distribute requests among some distinct partition key values.</span></span>
> 
> 

<a name="designing-for-partitioning"></a>
## <a name="working-with-hello-azure-cosmos-db-apis"></a><span data-ttu-id="68ee5-166">Hello Azure Cosmos DB API-k használata</span><span class="sxs-lookup"><span data-stu-id="68ee5-166">Working with hello Azure Cosmos DB APIs</span></span>
<span data-ttu-id="68ee5-167">Hello Azure-portálon vagy az Azure parancssori felület toocreate tárolók használata, és bármikor skálázni őket.</span><span class="sxs-lookup"><span data-stu-id="68ee5-167">You can use hello Azure portal or Azure CLI toocreate containers and scale them at any time.</span></span> <span data-ttu-id="68ee5-168">Ez a szakasz bemutatja, hogyan toocreate tárolókat, és adja meg a hello átviteli sebesség és a partíciós kulcs definíciójában minden hello támogatott API-k.</span><span class="sxs-lookup"><span data-stu-id="68ee5-168">This section shows how toocreate containers and specify hello throughput and partition key definition in each of hello supported APIs.</span></span>

### <a name="documentdb-api"></a><span data-ttu-id="68ee5-169">DocumentDB API</span><span class="sxs-lookup"><span data-stu-id="68ee5-169">DocumentDB API</span></span>
<span data-ttu-id="68ee5-170">a következő minta hello jeleníti meg, hogyan a tároló (gyűjtemény) használatával toocreate hello DocumentDB API.</span><span class="sxs-lookup"><span data-stu-id="68ee5-170">hello following sample shows how toocreate a container (collection) using hello DocumentDB API.</span></span> <span data-ttu-id="68ee5-171">További részletek találhatók [DocumentDB API-val particionálás](partition-data.md).</span><span class="sxs-lookup"><span data-stu-id="68ee5-171">You can find more details in [Partitioning with DocumentDB API](partition-data.md).</span></span>

```csharp
DocumentClient client = new DocumentClient(new Uri(endpoint), authKey);
await client.CreateDatabaseAsync(new Database { Id = "db" });

DocumentCollection myCollection = new DocumentCollection();
myCollection.Id = "coll";
myCollection.PartitionKey.Paths.Add("/deviceId");

await client.CreateDocumentCollectionAsync(
    UriFactory.CreateDatabaseUri("db"),
    myCollection,
    new RequestOptions { OfferThroughput = 20000 });
```

<span data-ttu-id="68ee5-172">Egy elem (dokumentumok) hello segítségével érheti el `GET` hello REST API-t vagy a segítségével metódus `ReadDocumentAsync` hello SDK-k egyikén.</span><span class="sxs-lookup"><span data-stu-id="68ee5-172">You can read an item (document) using hello `GET` method in hello REST API or using `ReadDocumentAsync` in one of hello SDKs.</span></span>

```csharp
// Read document. Needs hello partition key and hello ID toobe specified
DeviceReading document = await client.ReadDocumentAsync<DeviceReading>(
  UriFactory.CreateDocumentUri("db", "coll", "XMS-001-FE24C"), 
  new RequestOptions { PartitionKey = new PartitionKey("XMS-0001") });
```

### <a name="mongodb-api"></a><span data-ttu-id="68ee5-173">MongoDB API</span><span class="sxs-lookup"><span data-stu-id="68ee5-173">MongoDB API</span></span>
<span data-ttu-id="68ee5-174">A kedvenc eszköz, az illesztőprogram, vagy az SDK szilánkos gyűjtemény hello MongoDB API, hozhat létre.</span><span class="sxs-lookup"><span data-stu-id="68ee5-174">With hello MongoDB API, you can create a sharded collection through your favorite tool, driver, or SDK.</span></span> <span data-ttu-id="68ee5-175">Ebben a példában a Mongo rendszerhéj hello hello gyűjtemény létrehozásához használjuk.</span><span class="sxs-lookup"><span data-stu-id="68ee5-175">In this example, we use hello Mongo Shell for hello collection creation.</span></span>

<span data-ttu-id="68ee5-176">A Mongo rendszerhéj hello:</span><span class="sxs-lookup"><span data-stu-id="68ee5-176">In hello Mongo Shell:</span></span>

```
db.runCommand( { shardCollection: "admin.people", key: { region: "hashed" } } )
```
    
<span data-ttu-id="68ee5-177">Eredmények:</span><span class="sxs-lookup"><span data-stu-id="68ee5-177">Results:</span></span>

```JSON
{
    "_t" : "ShardCollectionResponse",
    "ok" : 1,
    "collectionsharded" : "admin.people"
}
```

### <a name="table-api"></a><span data-ttu-id="68ee5-178">Tábla API</span><span class="sxs-lookup"><span data-stu-id="68ee5-178">Table API</span></span>

<span data-ttu-id="68ee5-179">A tábla API hello megadja hello átviteli táblák hello appSettings konfigurációs az alkalmazáshoz:</span><span class="sxs-lookup"><span data-stu-id="68ee5-179">With hello Table API, you specify hello throughput for tables in hello appSettings configuration for your application:</span></span>

```xml
<configuration>
    <appSettings>
      <!--Table creation options -->
      <add key="TableThroughput" value="700"/>
    </appSettings>
</configuration>
```

<span data-ttu-id="68ee5-180">Ezután hozzon létre egy táblához hello Azure Table storage SDK használatával.</span><span class="sxs-lookup"><span data-stu-id="68ee5-180">Then you create a table using hello Azure Table storage SDK.</span></span> <span data-ttu-id="68ee5-181">hello partíciókulcs implicit módon létrehozva, hello `PartitionKey` érték.</span><span class="sxs-lookup"><span data-stu-id="68ee5-181">hello partition key is implicitly created as hello `PartitionKey` value.</span></span> 

```csharp
CloudTableClient tableClient = storageAccount.CreateCloudTableClient();

CloudTable table = tableClient.GetTableReference("people");
table.CreateIfNotExists();
```

<span data-ttu-id="68ee5-182">A következő kódrészletet hello segítségével egyetlen entitás le:</span><span class="sxs-lookup"><span data-stu-id="68ee5-182">You can retrieve a single entity using hello following snippet:</span></span>

```csharp
// Create a retrieve operation that takes a customer entity.
TableOperation retrieveOperation = TableOperation.Retrieve<CustomerEntity>("Smith", "Ben");

// Execute hello retrieve operation.
TableResult retrievedResult = table.Execute(retrieveOperation);
```
<span data-ttu-id="68ee5-183">Lásd: [fejlesztés az hello tábla API](tutorial-develop-table-dotnet.md) további részleteket.</span><span class="sxs-lookup"><span data-stu-id="68ee5-183">See [Developing with hello Table API](tutorial-develop-table-dotnet.md) for more details.</span></span>

### <a name="graph-api"></a><span data-ttu-id="68ee5-184">Graph API</span><span class="sxs-lookup"><span data-stu-id="68ee5-184">Graph API</span></span>

<span data-ttu-id="68ee5-185">A Graph API hello hello Azure-portálon vagy a CLI toocreate tárolókat kell használnia.</span><span class="sxs-lookup"><span data-stu-id="68ee5-185">With hello Graph API, you must use hello Azure portal or CLI toocreate containers.</span></span> <span data-ttu-id="68ee5-186">Azt is megteheti mivel Azure Cosmos DB több modellre, használhat hello egyik más modellek toocreate és a graph tároló méretezni.</span><span class="sxs-lookup"><span data-stu-id="68ee5-186">Alternatively, since Azure Cosmos DB is multi-model, you can use one of hello other models toocreate and scale your graph container.</span></span>

<span data-ttu-id="68ee5-187">Bármely csúcspont vagy edge Gremlin hello partíciókulcs és azonosító használatával érheti el.</span><span class="sxs-lookup"><span data-stu-id="68ee5-187">You can read any vertex or edge using hello partition key and id in Gremlin.</span></span> <span data-ttu-id="68ee5-188">A régióban ("USA) hello partíciós kulcs, és a"Seattle"hello sor kulcsként van grafikon, megtalálhatja például a hello a következő szintaxis használatával csúcspont:</span><span class="sxs-lookup"><span data-stu-id="68ee5-188">For example, for a graph with region ("USA") as hello partition key, and "Seattle" as hello row key, you can find a vertex using hello following syntax:</span></span>

```
g.V(['USA', 'Seattle'])
```

<span data-ttu-id="68ee5-189">Azonos olvasáskor, hello partíciókulcs és sorkulcsa él is hivatkozik.</span><span class="sxs-lookup"><span data-stu-id="68ee5-189">Same with edges, you can reference an edge using hello partition key and row key.</span></span>

```
g.E(['USA', 'I5'])
```

<span data-ttu-id="68ee5-190">Lásd: [Cosmos DB Gremlin támogatása](gremlin-support.md) további részleteket.</span><span class="sxs-lookup"><span data-stu-id="68ee5-190">See [Gremlin support for Cosmos DB](gremlin-support.md) for more details.</span></span>


<a name="designing-for-partitioning"></a>
## <a name="designing-for-partitioning"></a><span data-ttu-id="68ee5-191">A particionálás tervezése</span><span class="sxs-lookup"><span data-stu-id="68ee5-191">Designing for partitioning</span></span>
<span data-ttu-id="68ee5-192">gyakorlatilag az Azure Cosmos DB tooscale, kell toopick remek partíciókulcs a tároló létrehozásakor.</span><span class="sxs-lookup"><span data-stu-id="68ee5-192">tooscale effectively with Azure Cosmos DB, you need toopick a good partition key when you create your container.</span></span> <span data-ttu-id="68ee5-193">Nincsenek a partíciós kulcs két fő szempontjait:</span><span class="sxs-lookup"><span data-stu-id="68ee5-193">There are two key considerations for choosing a partition key:</span></span>

* <span data-ttu-id="68ee5-194">**A lekérdezés és a tranzakciókért határ**: A partíciós kulcs választott kell egyensúlyba hello kell tooenable hello tranzakciók használata elleni hello követelmény toodistribute az entitások több partíciós kulcsok tooensure méretezhető megoldás.</span><span class="sxs-lookup"><span data-stu-id="68ee5-194">**Boundary for query and transactions**: Your choice of partition key should balance hello need tooenable hello use of transactions against hello requirement toodistribute your entities across multiple partition keys tooensure a scalable solution.</span></span> <span data-ttu-id="68ee5-195">Egy rendkívüli, a beállíthat hello ugyanazzal a partíciókulccsal, az összes elem, de ez a megoldás hello méretezhetőség korlátozhatja.</span><span class="sxs-lookup"><span data-stu-id="68ee5-195">At one extreme, you could set hello same partition key for all your items, but this may limit hello scalability of your solution.</span></span> <span data-ttu-id="68ee5-196">A hello más extreme rendelheti minden elem, amely magas szinten méretezhető lenne, de akadályozzák meg közötti dokumentum tranzakciók tárolt eljárások és eseményindítók használata az egyedi partíciós kulcs.</span><span class="sxs-lookup"><span data-stu-id="68ee5-196">At hello other extreme, you could assign a unique partition key for each item, which would be highly scalable but would prevent you from using cross document transactions via stored procedures and triggers.</span></span> <span data-ttu-id="68ee5-197">Az ideális partíciókulcs egyike, amelyek segítségével toouse hatékony lekérdezések és, hogy elegendő számossága tooensure a megoldás, méretezhető.</span><span class="sxs-lookup"><span data-stu-id="68ee5-197">An ideal partition key is one that enables you toouse efficient queries and that has sufficient cardinality tooensure your solution is scalable.</span></span> 
* <span data-ttu-id="68ee5-198">**Nincs tárterületi és teljesítménybeli szűk keresztmetszetek**: fontos toopick olyan tulajdonságon, amely lehetővé teszi a különböző értékeket különböző pontjain toobe ír.</span><span class="sxs-lookup"><span data-stu-id="68ee5-198">**No storage and performance bottlenecks**: It is important toopick a property that allows writes toobe distributed across various distinct values.</span></span> <span data-ttu-id="68ee5-199">Kérelmek toohello ugyanazzal a partíciókulccsal nem haladhatja meg a hello sebességét, egy partíciót, és szabályozott.</span><span class="sxs-lookup"><span data-stu-id="68ee5-199">Requests toohello same partition key cannot exceed hello throughput of a single partition, and are throttled.</span></span> <span data-ttu-id="68ee5-200">Ezért fontos toopick a partíciós kulcs, amely nem eredményez "interaktív területek" az alkalmazáson belül.</span><span class="sxs-lookup"><span data-stu-id="68ee5-200">So it is important toopick a partition key that does not result in "hot spots" within your application.</span></span> <span data-ttu-id="68ee5-201">Minden hello adat óta a partíción belül kell lennie tárolt egypartíciós kulcsok is ajánlott tooavoid partíciós kulcsok, amelyek nagy mennyiségű adatot a hello ugyanazt az értéket.</span><span class="sxs-lookup"><span data-stu-id="68ee5-201">Since all hello data for a single partition key must be stored within a partition, it is also recommended tooavoid partition keys that have high volumes of data for hello same value.</span></span> 

<span data-ttu-id="68ee5-202">Vizsgáljuk meg néhány valós forgatókönyv, és jó partíciós kulcsok minden egyes:</span><span class="sxs-lookup"><span data-stu-id="68ee5-202">Let's look at a few real-world scenarios, and good partition keys for each:</span></span>
* <span data-ttu-id="68ee5-203">Ha a felhasználói profil backend megvalósításához, hello Felhasználóazonosító jól funkcionálnak a partíciós kulcs.</span><span class="sxs-lookup"><span data-stu-id="68ee5-203">If you’re implementing a user profile backend, then hello user ID is a good choice for partition key.</span></span>
* <span data-ttu-id="68ee5-204">Ha például az eszköz állapotát az IoT-adatokat tárolja, áll jól funkcionálnak a partíciós kulcs.</span><span class="sxs-lookup"><span data-stu-id="68ee5-204">If you’re storing IoT data for example, device state, a device ID is a good choice for partition key.</span></span>
* <span data-ttu-id="68ee5-205">Azure Cosmos DB-idősoros adatok naplózásának használata, majd hello állomásnév vagy Folyamatazonosító partíciókulcs érdemes választani.</span><span class="sxs-lookup"><span data-stu-id="68ee5-205">If you’re using Azure Cosmos DB for logging time-series data, then hello hostname or process ID is a good choice for partition key.</span></span>
* <span data-ttu-id="68ee5-206">Ha egy több-bérlős architektúrák, hello Bérlőazonosító partíciós kulcs érdemes választani.</span><span class="sxs-lookup"><span data-stu-id="68ee5-206">If you have a multi-tenant architecture, hello tenant ID is a good choice for partition key.</span></span>

<span data-ttu-id="68ee5-207">Bizonyos esetekben IoT és a felhasználói profilok, a hello partíciókulcs lehet, hogy használja hello ugyanaz az azonosító (a dokumentum kulcs).</span><span class="sxs-lookup"><span data-stu-id="68ee5-207">In some use cases like IoT and user profiles, hello partition key might be hello same as your id (document key).</span></span> <span data-ttu-id="68ee5-208">Más hello idő adatsor például lehetséges, hogy a partíciós kulcs, amely eltér attól hello azonosítója.</span><span class="sxs-lookup"><span data-stu-id="68ee5-208">In others like hello time series data, you might have a partition key that’s different than hello id.</span></span>

### <a name="partitioning-and-loggingtime-series-data"></a><span data-ttu-id="68ee5-209">A particionáló és naplózási/idősorozat adatok</span><span class="sxs-lookup"><span data-stu-id="68ee5-209">Partitioning and logging/time-series data</span></span>
<span data-ttu-id="68ee5-210">Hello gyakori alkalmazási esetei Cosmos-adatbázis egyik naplózási és telemetriai adatokat.</span><span class="sxs-lookup"><span data-stu-id="68ee5-210">One of hello common use cases of Cosmos DB is for logging and telemetry.</span></span> <span data-ttu-id="68ee5-211">Ez a fontos toopick remek partíciókulcs beállítás, mivel előfordulhat, hogy tooread/írás hatalmas mennyiségű adatot.</span><span class="sxs-lookup"><span data-stu-id="68ee5-211">It is important toopick a good partition key since you might need tooread/write vast volumes of data.</span></span> <span data-ttu-id="68ee5-212">hello függ az olvasási és írási sebesség és lekérdezések toorun várt típusú.</span><span class="sxs-lookup"><span data-stu-id="68ee5-212">hello choice depends on your read and write rates and kinds of queries you expect toorun.</span></span> <span data-ttu-id="68ee5-213">Néhány tipp hogyan toochoose remek partíciókulcs.</span><span class="sxs-lookup"><span data-stu-id="68ee5-213">Here are some tips on how toochoose a good partition key.</span></span>

* <span data-ttu-id="68ee5-214">Ha a használati eset szerint kis mértékét írja az időbélyegzőket és a többi szűrőt, megadott idő és a szükséges tooquery hosszú időn keresztül gyűlik az hello Timestamp, például egy összesítő használatával dátumánál, mert a partíciós kulcs egy jó módszer.</span><span class="sxs-lookup"><span data-stu-id="68ee5-214">If your use case involves a small rate of writes accumulating over a long period of time, and need tooquery by ranges of timestamps and other filters, then using a rollup of hello timestamp, for example,  date as a partition key is a good approach.</span></span> <span data-ttu-id="68ee5-215">Ez lehetővé teszi tooquery összes hello adatok számára egy olyan partíciót dátum.</span><span class="sxs-lookup"><span data-stu-id="68ee5-215">This allows you tooquery over all hello data for a date from a single partition.</span></span> 
* <span data-ttu-id="68ee5-216">Ha a számítási feladatok gyakori, amely több előfordul, a partíciós kulcs nem alapuló timestamp, hogy Cosmos DB is szét írások egyenletesen különféle partíciók kell használnia.</span><span class="sxs-lookup"><span data-stu-id="68ee5-216">If your workload is written heavy, which is more common, you should use a partition key that’s not based on timestamp so that Cosmos DB can distribute writes evenly across various partitions.</span></span> <span data-ttu-id="68ee5-217">Itt egy állomásnevet, Folyamatazonosító, Tevékenységazonosító vagy nagy számosságot egy másik tulajdonság akkor hasznos.</span><span class="sxs-lookup"><span data-stu-id="68ee5-217">Here a hostname, process ID, activity ID, or another property with high cardinality is a good choice.</span></span> 
* <span data-ttu-id="68ee5-218">Harmadik módszer egy hibrid egy ahol egy napi vagy havi több tároló van, és hello partíciós kulcs például állomásnév részletes tulajdonság.</span><span class="sxs-lookup"><span data-stu-id="68ee5-218">A third approach is a hybrid one where you have multiple containers, one for each day/month and hello partition key is a granular property like hostname.</span></span> <span data-ttu-id="68ee5-219">Ennek hello időkerete alapján különböző átviteli beállítható hello előnye van, például az aktuális hónap hello hello tároló ki van építve nagyobb átviteli sebességgel mert ez olvasási és írási, mivel az előző hónap alacsonyabb átviteli óta csak olvasási szolgál.</span><span class="sxs-lookup"><span data-stu-id="68ee5-219">This has hello benefit that you can set different throughput based on hello time window, for example, hello container for hello current month is provisioned with higher throughput since it serves reads and writes, whereas previous months with lower throughput since they only serve reads.</span></span>

### <a name="partitioning-and-multi-tenancy"></a><span data-ttu-id="68ee5-220">Particionálás és a több-bérlős</span><span class="sxs-lookup"><span data-stu-id="68ee5-220">Partitioning and multi-tenancy</span></span>
<span data-ttu-id="68ee5-221">Egy több-bérlős alkalmazás Cosmos DB használatával valósít meg, ha nincsenek két népszerű minták – bérlőnként egy partíciókulcsot, és bérlőnként több tároló.</span><span class="sxs-lookup"><span data-stu-id="68ee5-221">If you are implementing a multi-tenant application using Cosmos DB, there are two popular patterns – one partition key per tenant, and one container per tenant.</span></span> <span data-ttu-id="68ee5-222">Az alábbiakban hello és az egyes hátrányokkal jár:</span><span class="sxs-lookup"><span data-stu-id="68ee5-222">Here are hello pros and cons for each:</span></span>

* <span data-ttu-id="68ee5-223">Bérlőnként egy Partíciókulcsot: Ebben a modellben bérlők közös a elhelyezésű belül egyetlen tárolót.</span><span class="sxs-lookup"><span data-stu-id="68ee5-223">One Partition Key per tenant: In this model, tenants are collocated within a single container.</span></span> <span data-ttu-id="68ee5-224">De lekérdezések és egy egybérlős belül elemek beszúrása Indexalapú egyetlen partícióra.</span><span class="sxs-lookup"><span data-stu-id="68ee5-224">But queries and inserts for items within a single tenant can be performed against a single partition.</span></span> <span data-ttu-id="68ee5-225">Tranzakciós logika összes eleme belül a bérlők között is megvalósíthatja.</span><span class="sxs-lookup"><span data-stu-id="68ee5-225">You can also implement transactional logic across all items within a tenant.</span></span> <span data-ttu-id="68ee5-226">Több bérlő egy tároló megosztás, mivel tárolási és átviteli költségeket takaríthat készletezési erőforrásokat a bérlők számára belül egyetlen tárolót, nem pedig további belső magasságnak kiépítés az egyes bérlők számára.</span><span class="sxs-lookup"><span data-stu-id="68ee5-226">Since multiple tenants share a container, you can save storage and throughput costs by pooling resources for tenants within a single container rather than provisioning extra headroom for each tenant.</span></span> <span data-ttu-id="68ee5-227">hello hátránya, hogy nem rendelkezik bérlőnként teljesítmény-elszigetelés érdekében.</span><span class="sxs-lookup"><span data-stu-id="68ee5-227">hello drawback is that you do not have performance isolation per tenant.</span></span> <span data-ttu-id="68ee5-228">Teljesítmény/átviteli sebesség növekedése alkalmazása toohello teljes tároló célzott vs növeli a bérlők számára.</span><span class="sxs-lookup"><span data-stu-id="68ee5-228">Performance/throughput increases apply toohello entire container vs targeted increases for tenants.</span></span>
* <span data-ttu-id="68ee5-229">Egy tároló bérlőnként: mindegyik bérlő saját tároló rendelkezik.</span><span class="sxs-lookup"><span data-stu-id="68ee5-229">One Container per tenant: Each tenant has its own container.</span></span> <span data-ttu-id="68ee5-230">Ebben a modellben bérlőnként teljesítmény foglalhat.</span><span class="sxs-lookup"><span data-stu-id="68ee5-230">In this model, you can reserve performance per tenant.</span></span> <span data-ttu-id="68ee5-231">Cosmos DB új szolgáltatáskiépítéssel árképzési modellt, költséghatékonyabb, több-bérlős alkalmazásokhoz a néhány bérlőkkel ebben a modellben.</span><span class="sxs-lookup"><span data-stu-id="68ee5-231">With Cosmos DB's new provisioning pricing model, this model is more cost-effective for multi-tenant applications with a few tenants.</span></span>

<span data-ttu-id="68ee5-232">Egy kombináció/rétegzett megközelítés, amely kis bérlők collocates és áttelepíti a saját tároló nagyobb bérlők tootheir is használható.</span><span class="sxs-lookup"><span data-stu-id="68ee5-232">You can also use a combination/tiered approach that collocates small tenants and migrates larger tenants tootheir own container.</span></span>

## <a name="next-steps"></a><span data-ttu-id="68ee5-233">Következő lépések</span><span class="sxs-lookup"><span data-stu-id="68ee5-233">Next steps</span></span>
<span data-ttu-id="68ee5-234">Ez a cikk azt előírt áttekintése fogalmakat és ajánlott eljárások az Azure Cosmos DB API-k a particionálás áttekintése.</span><span class="sxs-lookup"><span data-stu-id="68ee5-234">In this article, we provided an overview for an overview of concepts and best practices for partitioning with any Azure Cosmos DB API.</span></span> 

* <span data-ttu-id="68ee5-235">További tudnivalók [Azure Cosmos DB a létesített átviteli sebesség](request-units.md)</span><span class="sxs-lookup"><span data-stu-id="68ee5-235">Learn about [provisioned throughput in Azure Cosmos DB](request-units.md)</span></span>
* <span data-ttu-id="68ee5-236">További tudnivalók [globális terjesztési az Azure Cosmos-Adatbázisba](distribute-data-globally.md)</span><span class="sxs-lookup"><span data-stu-id="68ee5-236">Learn about [global distribution in Azure Cosmos DB](distribute-data-globally.md)</span></span>



