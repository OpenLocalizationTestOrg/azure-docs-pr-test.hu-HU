---
title: "Teljesítmény tippek - Azure Cosmos DB NoSQL |} Microsoft Docs"
description: "Ismerje meg az ügyfél-konfigurációs beállítások Azure Cosmos DB adatbázis teljesítményének javítása érdekében"
keywords: "adatbázis teljesítményének javításával"
services: cosmos-db
author: mimig1
manager: jhubbard
editor: 
documentationcenter: 
ms.assetid: 94ff155e-f9bc-488f-8c7a-5e7037091bb9
ms.service: cosmos-db
ms.workload: data-services
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 02/23/2017
ms.author: mimig
ms.openlocfilehash: a94cda90eca9dca2b93adb8f5091d829e7375aa5
ms.sourcegitcommit: 02e69c4a9d17645633357fe3d46677c2ff22c85a
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 08/03/2017
---
# <a name="performance-tips-for-azure-cosmos-db"></a><span data-ttu-id="11daa-104">Teljesítmény tippek az Azure Cosmos DB rendszerhez</span><span class="sxs-lookup"><span data-stu-id="11daa-104">Performance tips for Azure Cosmos DB</span></span>
<span data-ttu-id="11daa-105">Azure Cosmos-adatbázis egy gyors és rugalmas elosztott adatbázis, amely zökkenőmentesen méretezi, garantált késéssel és átviteli sebesség.</span><span class="sxs-lookup"><span data-stu-id="11daa-105">Azure Cosmos DB is a fast and flexible distributed database that scales seamlessly with guaranteed latency and throughput.</span></span> <span data-ttu-id="11daa-106">Nincs a fő architektúra módosításokat, vagy írja meg az adatbázist az Cosmos DB méretezési komplex kódot.</span><span class="sxs-lookup"><span data-stu-id="11daa-106">You do not have to make major architecture changes or write complex code to scale your database with Cosmos DB.</span></span> <span data-ttu-id="11daa-107">Felfelé és lefelé skálázás be lehető legkönnyebben egyetlen API-hívás vagy [SDK metódus hívása](set-throughput.md#set-throughput-sdk).</span><span class="sxs-lookup"><span data-stu-id="11daa-107">Scaling up and down is as easy as making a single API call or [SDK method call](set-throughput.md#set-throughput-sdk).</span></span> <span data-ttu-id="11daa-108">Azonban mivel a Cosmos DB hálózati hívások keresztül érhető el nincsenek biztosíthatja, hogy a maximális teljesítmény érdekében az ügyféloldali optimalizálás.</span><span class="sxs-lookup"><span data-stu-id="11daa-108">However, because Cosmos DB is accessed via network calls there are client-side optimizations you can make to achieve peak performance.</span></span>

<span data-ttu-id="11daa-109">Ezért ha még kérése "Hogyan javítható az adatbázis teljesítménye?"</span><span class="sxs-lookup"><span data-stu-id="11daa-109">So if you're asking "How can I improve my database performance?"</span></span> <span data-ttu-id="11daa-110">Vegye figyelembe a következő lehetőségeket:</span><span class="sxs-lookup"><span data-stu-id="11daa-110">consider the following options:</span></span>

## <a name="networking"></a><span data-ttu-id="11daa-111">Hálózat</span><span class="sxs-lookup"><span data-stu-id="11daa-111">Networking</span></span>
<a id="direct-connection"></a>

1. <span data-ttu-id="11daa-112">**Kapcsolat házirend: közvetlen kapcsolat mód használata**</span><span class="sxs-lookup"><span data-stu-id="11daa-112">**Connection policy: Use direct connection mode**</span></span>

    <span data-ttu-id="11daa-113">Hogyan ügyfél csatlakozik-e Cosmos DB rendelkezik fontos gyakorolt hatása a teljesítményre, különös tekintettel az megfigyelt ügyféloldali késés.</span><span class="sxs-lookup"><span data-stu-id="11daa-113">How a client connects to Cosmos DB has important implications on performance, especially in terms of observed client-side latency.</span></span> <span data-ttu-id="11daa-114">Nincsenek elérhető az ügyfél kapcsolatkezelési házirendet – a kapcsolat konfigurálása két fő konfigurációs beállítások *mód* és a [kapcsolat *protokoll*](#connection-protocol).</span><span class="sxs-lookup"><span data-stu-id="11daa-114">There are two key configuration settings available for configuring client Connection Policy – the connection *mode* and the [connection *protocol*](#connection-protocol).</span></span>  <span data-ttu-id="11daa-115">A két rendelkezésre álló módok a következők:</span><span class="sxs-lookup"><span data-stu-id="11daa-115">The two available modes are:</span></span>

   1. <span data-ttu-id="11daa-116">Átjáró mód (alapértelmezés)</span><span class="sxs-lookup"><span data-stu-id="11daa-116">Gateway Mode (default)</span></span>
   2. <span data-ttu-id="11daa-117">Közvetlen mód</span><span class="sxs-lookup"><span data-stu-id="11daa-117">Direct Mode</span></span>

      <span data-ttu-id="11daa-118">Átjáró mód minden SDK-platformon támogatott, és a beállított alapértelmezett.</span><span class="sxs-lookup"><span data-stu-id="11daa-118">Gateway Mode is supported on all SDK platforms and is the configured default.</span></span>  <span data-ttu-id="11daa-119">Ha az alkalmazás fut a vállalati hálózatról szigorú tűzfal korlátozások, az átjáró mód azért, mert a szabványos HTTPS-port és egy végpontot használ a legjobb választás.</span><span class="sxs-lookup"><span data-stu-id="11daa-119">If your application runs within a corporate network with strict firewall restrictions, Gateway Mode is the best choice since it uses the standard HTTPS port and a single endpoint.</span></span> <span data-ttu-id="11daa-120">A teljesítmény kompromisszumot azonban, hogy az átjáró mód érint egy további hálózati ugrások minden alkalommal, amikor adatait olvasni vagy írni a Cosmos DB.</span><span class="sxs-lookup"><span data-stu-id="11daa-120">The performance tradeoff, however, is that Gateway Mode involves an additional network hop every time data is read or written to Cosmos DB.</span></span> <span data-ttu-id="11daa-121">Emiatt a közvetlen üzemmódban miatt kevesebb hálózati ugrásokat jobb teljesítményt nyújt.</span><span class="sxs-lookup"><span data-stu-id="11daa-121">Because of this, Direct Mode offers better performance due to fewer network hops.</span></span>
<a id="use-tcp"></a>
2. <span data-ttu-id="11daa-122">**Kapcsolat házirend: a TCP protokoll**</span><span class="sxs-lookup"><span data-stu-id="11daa-122">**Connection policy: Use the TCP protocol**</span></span>

    <span data-ttu-id="11daa-123">Ha közvetlen módot, két módon protokoll érhető el:</span><span class="sxs-lookup"><span data-stu-id="11daa-123">When using Direct Mode, there are two protocol options available:</span></span>

   * <span data-ttu-id="11daa-124">TCP</span><span class="sxs-lookup"><span data-stu-id="11daa-124">TCP</span></span>
   * <span data-ttu-id="11daa-125">HTTPS</span><span class="sxs-lookup"><span data-stu-id="11daa-125">HTTPS</span></span>

     <span data-ttu-id="11daa-126">Cosmos DB nyújt egy egyszerű, és nyissa meg a RESTful programozási modellt HTTPS-KAPCSOLATON keresztül.</span><span class="sxs-lookup"><span data-stu-id="11daa-126">Cosmos DB offers a simple and open RESTful programming model over HTTPS.</span></span> <span data-ttu-id="11daa-127">Emellett kínál egy hatékony TCP protokoll, amely egyben a RESTful a kommunikációs modellben és a .NET SDK ügyfélen keresztül érhető el.</span><span class="sxs-lookup"><span data-stu-id="11daa-127">Additionally, it offers an efficient TCP protocol, which is also RESTful in its communication model and is available through the .NET client SDK.</span></span> <span data-ttu-id="11daa-128">Közvetlen TCP és a HTTPS egyaránt SSL használata a kezdeti hitelesítési és titkosítási forgalom.</span><span class="sxs-lookup"><span data-stu-id="11daa-128">Both Direct TCP and HTTPS use SSL for initial authentication and encrypting traffic.</span></span> <span data-ttu-id="11daa-129">A legjobb teljesítmény érdekében használjon a TCP protokollt, ha lehetséges.</span><span class="sxs-lookup"><span data-stu-id="11daa-129">For best performance, use the TCP protocol when possible.</span></span>

     <span data-ttu-id="11daa-130">Ha TCP az átjáró módban, TCP 443-as portot a Cosmos DB portot, és 10255 a MongoDB API port.</span><span class="sxs-lookup"><span data-stu-id="11daa-130">When using TCP in Gateway Mode, TCP Port 443 is the Cosmos DB port, and 10255 is the MongoDB API port.</span></span> <span data-ttu-id="11daa-131">Ha TCP közvetlen módban átjáró portokon kívül, gondoskodnia kell arról a port 10000 és 20000 között nyitva, mert a Cosmos DB dinamikus TCP-portot használja.</span><span class="sxs-lookup"><span data-stu-id="11daa-131">When using TCP in Direct Mode, in addition to the Gateway ports, you need to ensure the port range between 10000 and 20000 is open because Cosmos DB uses dynamic TCP ports.</span></span> <span data-ttu-id="11daa-132">Ha ezeket a portokat nem nyitva, és próbálja meg használni a TCP, hibaüzenet 503-as szolgáltatás nem érhető el.</span><span class="sxs-lookup"><span data-stu-id="11daa-132">If these ports are not open and you attempt to use TCP, you receive a 503 Service Unavailable error.</span></span>

     <span data-ttu-id="11daa-133">A csatlakozási mód úgy van beállítva, a ConnectionPolicy paraméterrel DocumentClient példányának létrehozása során.</span><span class="sxs-lookup"><span data-stu-id="11daa-133">The Connectivity Mode is configured during the construction of the DocumentClient instance with the ConnectionPolicy parameter.</span></span> <span data-ttu-id="11daa-134">Közvetlen mód használata esetén a protokoll is megadható a ConnectionPolicy paraméter belül.</span><span class="sxs-lookup"><span data-stu-id="11daa-134">If Direct Mode is used, the Protocol can also be set within the ConnectionPolicy parameter.</span></span>

    ```C#
    var serviceEndpoint = new Uri("https://contoso.documents.net");
    var authKey = new "your authKey from the Azure portal";
    DocumentClient client = new DocumentClient(serviceEndpoint, authKey,
    new ConnectionPolicy
    {
        ConnectionMode = ConnectionMode.Direct,
        ConnectionProtocol = Protocol.Tcp
    });
    ```

    <span data-ttu-id="11daa-135">TCP csak akkor támogatott a közvetlen mód, ha átjáró módot használ, mert a HTTPS protokoll mindig segítségével található átjáróval kommunikálni, és a ConnectionPolicy protokoll értékét a rendszer figyelmen kívül hagyja.</span><span class="sxs-lookup"><span data-stu-id="11daa-135">Because TCP is only supported in Direct Mode, if Gateway Mode is used, then the HTTPS protocol is always used to communicate with the Gateway and the Protocol value in the ConnectionPolicy is ignored.</span></span>

    ![Az Azure Cosmos DB kapcsolatkezelési házirendet ábrája](./media/performance-tips/connection-policy.png)

3. <span data-ttu-id="11daa-137">**Az első kérelem indítási késleltetés elkerülése érdekében OpenAsync hívása**</span><span class="sxs-lookup"><span data-stu-id="11daa-137">**Call OpenAsync to avoid startup latency on first request**</span></span>

    <span data-ttu-id="11daa-138">Alapértelmezés szerint az első kérelem egy nagyobb késleltetéssel járhat van, mert a cím útvonaltábla beolvasása.</span><span class="sxs-lookup"><span data-stu-id="11daa-138">By default, the first request has a higher latency because it has to fetch the address routing table.</span></span> <span data-ttu-id="11daa-139">Ez az első kérésre indítási késleltetés elkerülése érdekében célszerű hívni OpenAsync() egyszer az inicializálás során az alábbiak szerint.</span><span class="sxs-lookup"><span data-stu-id="11daa-139">To avoid this startup latency on the first request, you should call OpenAsync() once during initialization as follows.</span></span>

        await client.OpenAsync();
   <a id="same-region"></a>
4. <span data-ttu-id="11daa-140">**A teljesítmény azonos Azure régióban ügyfelek elhelyezésének engedélyezése**</span><span class="sxs-lookup"><span data-stu-id="11daa-140">**Collocate clients in same Azure region for performance**</span></span>

    <span data-ttu-id="11daa-141">Ha lehetséges, helyezze a futó alkalmazások Cosmos adatbázis hívása a Cosmos DB adatbázis ugyanabban a régióban.</span><span class="sxs-lookup"><span data-stu-id="11daa-141">When possible, place any applications calling Cosmos DB in the same region as the Cosmos DB database.</span></span> <span data-ttu-id="11daa-142">Hozzávetőleges összehasonlításhoz belül ugyanabban a régióban Cosmos DB hívások 1-2 ms belül befejeződik, de nyugati és az Egyesült Államok, keleti part közötti késés > 50 ms.</span><span class="sxs-lookup"><span data-stu-id="11daa-142">For an approximate comparison, calls to Cosmos DB within the same region complete within 1-2 ms, but the latency between the West and East coast of the US is >50 ms.</span></span> <span data-ttu-id="11daa-143">Ez a késés valószínűleg eltérőek lehetnek kérelem kérelem attól függően, hogy az útvonal kérés hajtja végre, mivel az ügyfél az Azure-adatközpontban határ adja át.</span><span class="sxs-lookup"><span data-stu-id="11daa-143">This latency can likely vary from request to request depending on the route taken by the request as it passes from the client to the Azure datacenter boundary.</span></span> <span data-ttu-id="11daa-144">A lehető legkisebb késleltetést érhető el, biztosítva, hogy a hívó alkalmazás helyen belüli és a kiosztott Cosmos DB végpont Azure ugyanabban a régióban.</span><span class="sxs-lookup"><span data-stu-id="11daa-144">The lowest possible latency is achieved by ensuring the calling application is located within the same Azure region as the provisioned Cosmos DB endpoint.</span></span> <span data-ttu-id="11daa-145">Elérhető régiók listáját lásd: [Azure-régiókat](https://azure.microsoft.com/regions/#services).</span><span class="sxs-lookup"><span data-stu-id="11daa-145">For a list of available regions, see [Azure Regions](https://azure.microsoft.com/regions/#services).</span></span>

    <span data-ttu-id="11daa-146">![Az Azure Cosmos DB kapcsolatkezelési házirendet ábrája](./media/performance-tips/same-region.png)
   <a id="increase-threads"></a></span><span class="sxs-lookup"><span data-stu-id="11daa-146">![Illustration of the Azure Cosmos DB connection policy](./media/performance-tips/same-region.png)
<a id="increase-threads"></a></span></span>
5. <span data-ttu-id="11daa-147">**Növeli a szálak/feladatok száma**</span><span class="sxs-lookup"><span data-stu-id="11daa-147">**Increase number of threads/tasks**</span></span>

    <span data-ttu-id="11daa-148">Az Azure Cosmos Adatbázishoz hívások a hálózaton keresztül, mert szükség lehet a kérelmek párhuzamosságát fokának eltérőek, hogy az ügyfélalkalmazás fordít várakozó kérelmek között nagyon rövid ideig.</span><span class="sxs-lookup"><span data-stu-id="11daa-148">Since calls to Azure Cosmos DB are made over the network, you may need to vary the degree of parallelism of your requests so that the client application spends very little time waiting between requests.</span></span> <span data-ttu-id="11daa-149">Ha például használata. NET tartozó [feladat párhuzamos könyvtár](https://msdn.microsoft.com//library/dd460717.aspx), sorrendben 100-as egység olvasása vagy írása Cosmos DB feladatok létrehozása.</span><span class="sxs-lookup"><span data-stu-id="11daa-149">For example, if you're using .NET's [Task Parallel Library](https://msdn.microsoft.com//library/dd460717.aspx), create in the order of 100s of Tasks reading or writing to Cosmos DB.</span></span>

## <a name="sdk-usage"></a><span data-ttu-id="11daa-150">SDK használata</span><span class="sxs-lookup"><span data-stu-id="11daa-150">SDK Usage</span></span>
1. <span data-ttu-id="11daa-151">**A legutóbbi SDK telepítése**</span><span class="sxs-lookup"><span data-stu-id="11daa-151">**Install the most recent SDK**</span></span>

    <span data-ttu-id="11daa-152">A Cosmos DB SDK-k a rendszer folyamatosan javult a legjobb teljesítmény elérése érdekében.</span><span class="sxs-lookup"><span data-stu-id="11daa-152">The Cosmos DB SDKs are constantly being improved to provide the best performance.</span></span> <span data-ttu-id="11daa-153">Tekintse meg a [Cosmos DB SDK](documentdb-sdk-dotnet.md) lapok használatával állapítsa meg a legutóbbi SDK, és tekintse át a fejlesztései.</span><span class="sxs-lookup"><span data-stu-id="11daa-153">See the [Cosmos DB SDK](documentdb-sdk-dotnet.md) pages to determine the most recent SDK and review improvements.</span></span>
2. <span data-ttu-id="11daa-154">**Az alkalmazás teljes egypéldányos Cosmos DB ügyfél használata**</span><span class="sxs-lookup"><span data-stu-id="11daa-154">**Use a singleton Cosmos DB client for the lifetime of your application**</span></span>

    <span data-ttu-id="11daa-155">Vegye figyelembe, hogy minden DocumentClient példány szálbiztos, és végrehajtja a hatékony kapcsolat kezelése és a címek gyorsítótárazása, ha közvetlen módban működik.</span><span class="sxs-lookup"><span data-stu-id="11daa-155">Note that each DocumentClient instance is thread-safe and performs efficient connection management and address caching when operating in Direct Mode.</span></span> <span data-ttu-id="11daa-156">Engedélyezése hatékony kapcsolat kezelése és DocumentClient által jobb teljesítmény érdekében javasoljuk, hogy egyetlen példány futhat egy AppDomain DocumentClient használni az alkalmazás élettartamának.</span><span class="sxs-lookup"><span data-stu-id="11daa-156">To allow efficient connection management and better performance by DocumentClient, it is recommended to use a single instance of DocumentClient per AppDomain for the lifetime of the application.</span></span>

   <a id="max-connection"></a>
3. <span data-ttu-id="11daa-157">**Növelhető a System.NET névtérbeli MaxConnections állomásonként, ha az átjáró módban**</span><span class="sxs-lookup"><span data-stu-id="11daa-157">**Increase System.Net MaxConnections per host when using Gateway mode**</span></span>

    <span data-ttu-id="11daa-158">Cosmos DB-kérelmek keresztül HTTPS/REST átjáró üzemmódban, és az alapértelmezett kapcsolati felső határ az egyes állomásnév vagy IP-címet kell vizsgálni.</span><span class="sxs-lookup"><span data-stu-id="11daa-158">Cosmos DB requests are made over HTTPS/REST when using Gateway mode, and are subjected to the default connection limit per hostname or IP address.</span></span> <span data-ttu-id="11daa-159">Szükség lehet ahhoz a MaxConnections (100-1000) magasabb értékre, hogy az ügyféloldali kódtár nyújthatnak a Cosmos DB több egyidejű kapcsolatok.</span><span class="sxs-lookup"><span data-stu-id="11daa-159">You may need to set the MaxConnections to a higher value (100-1000) so that the client library can utilize multiple simultaneous connections to Cosmos DB.</span></span> <span data-ttu-id="11daa-160">A .NET SDK 1.8.0 és az alapértelmezett érték felett [ServicePointManager.DefaultConnectionLimit](https://msdn.microsoft.com/library/system.net.servicepointmanager.defaultconnectionlimit.aspx) 50, és módosítsa az értéket, beállíthatja a [Documents.Client.ConnectionPolicy.MaxConnectionLimit](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.client.connectionpolicy.maxconnectionlimit.aspx)magasabb értékre.</span><span class="sxs-lookup"><span data-stu-id="11daa-160">In the .NET SDK 1.8.0 and above, the default value for [ServicePointManager.DefaultConnectionLimit](https://msdn.microsoft.com/library/system.net.servicepointmanager.defaultconnectionlimit.aspx) is 50 and to change the value, you can set the [Documents.Client.ConnectionPolicy.MaxConnectionLimit](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.client.connectionpolicy.maxconnectionlimit.aspx) to a higher value.</span></span>   
4. <span data-ttu-id="11daa-161">**A particionált gyűjtemények párhuzamos lekérdezések hangolása**</span><span class="sxs-lookup"><span data-stu-id="11daa-161">**Tuning parallel queries for partitioned collections**</span></span>

     <span data-ttu-id="11daa-162">A DocumentDB .NET SDK 1.9.0 verzió vagy újabb támogatási párhuzamos lekérdezések, amelyek lehetővé teszik egy particionált gyűjtemény párhuzamos lekérdezés (lásd: [az SDK-k használata](documentdb-partition-data.md#working-with-the-azure-cosmos-db-sdks) és a kapcsolódó [Kódminták](https://github.com/Azure/azure-documentdb-dotnet/blob/master/samples/code-samples/Queries/Program.cs) további Info).</span><span class="sxs-lookup"><span data-stu-id="11daa-162">DocumentDB .NET SDK version 1.9.0 and above support parallel queries, which enable you to query a partitioned collection in parallel (see [Working with the SDKs](documentdb-partition-data.md#working-with-the-azure-cosmos-db-sdks) and the related [code samples](https://github.com/Azure/azure-documentdb-dotnet/blob/master/samples/code-samples/Queries/Program.cs) for more info).</span></span> <span data-ttu-id="11daa-163">Párhuzamos lekérdezések úgy tervezték, hogy a soros megfelelőjére javítja a lekérdezés-késleltetés és a teljesítményt.</span><span class="sxs-lookup"><span data-stu-id="11daa-163">Parallel queries are designed to improve query latency and throughput over their serial counterpart.</span></span> <span data-ttu-id="11daa-164">Párhuzamos lekérdezések adja meg, hogy a felhasználók észlelheti a rájuk vonatkozó követelményeket, a MaxDegreeOfParallelism egyéni méretezése két paramétert: szabályozhatja a maximális számú partíciót majd, és (b) MaxBufferedItemCount kérdezhetők le: a száma előre lehívott eredmények.</span><span class="sxs-lookup"><span data-stu-id="11daa-164">Parallel queries provide two parameters that users can tune to custom-fit their requirements, (a) MaxDegreeOfParallelism: to control the maximum number of partitions then can be queried in parallel, and (b) MaxBufferedItemCount: to control the number of pre-fetched results.</span></span>

    <span data-ttu-id="11daa-165">(a) ***hangolása MaxDegreeOfParallelism\: *** párhuzamos lekérdezés works több partíció párhuzamosan lekérdezésével.</span><span class="sxs-lookup"><span data-stu-id="11daa-165">(a) ***Tuning MaxDegreeOfParallelism\:*** Parallel query works by querying multiple partitions in parallel.</span></span> <span data-ttu-id="11daa-166">Azonban az egyes particionált összegyűjtendő adatok beolvassa Feladattervek tekintetében a lekérdezést.</span><span class="sxs-lookup"><span data-stu-id="11daa-166">However, data from an individual partitioned collect is fetched serially with respect to the query.</span></span> <span data-ttu-id="11daa-167">Igen a MaxDegreeOfParallelism beállítást a partíciók számának rendelkezik elérése érdekében a legtöbb performant lekérdezés maximális esélyét megadott egyéb rendszer feltételek változatlanok maradnak.</span><span class="sxs-lookup"><span data-stu-id="11daa-167">So, setting the MaxDegreeOfParallelism to the number of partitions has the maximum chance of achieving the most performant query, provided all other system conditions remain the same.</span></span> <span data-ttu-id="11daa-168">Ha nem ismeri a partíciók számát, a MaxDegreeOfParallelism állíthatja be a magas érték, és a rendszer úgy dönt, mint a MaxDegreeOfParallelism minimális (partíciók, felhasználó által megadott bemeneti száma).</span><span class="sxs-lookup"><span data-stu-id="11daa-168">If you don't know the number of partitions, you can set the MaxDegreeOfParallelism to a high number, and the system chooses the minimum (number of partitions, user provided input) as the MaxDegreeOfParallelism.</span></span>

    <span data-ttu-id="11daa-169">Fontos megjegyezni, hogy párhuzamos lekérdezések eredményez-e a legjobb előnyöket, ha az adatok tekintetében a lekérdezés összes partíciójára egyenletesen vannak elosztva.</span><span class="sxs-lookup"><span data-stu-id="11daa-169">It is important to note that parallel queries produce the best benefits if the data is evenly distributed across all partitions with respect to the query.</span></span> <span data-ttu-id="11daa-170">Ha a particionált gyűjtemény particionálva van-e olyan módon, hogy néhány partíciók (egy partíciót a legrosszabb esetben) az összes vagy egy lekérdezés által visszaadott adatok többsége van koncentrált, majd a lekérdezés teljesítményét volna kell szűk keresztmetszetét adja ki ezeket a partíció.</span><span class="sxs-lookup"><span data-stu-id="11daa-170">If the partitioned collection is partitioned such a way that all or a majority of the data returned by a query is concentrated in a few partitions (one partition in worst case), then the performance of the query would be bottlenecked by those partitions.</span></span>

    <span data-ttu-id="11daa-171">(b) ***hangolása MaxBufferedItemCount\: *** párhuzamos lekérdezések arra tervezték, hogy előre fetch eredmények, amíg a jelenlegi köteg eredményeinek feldolgozása folyamatban van az ügyfél által.</span><span class="sxs-lookup"><span data-stu-id="11daa-171">(b) ***Tuning MaxBufferedItemCount\:*** Parallel query is designed to pre-fetch results while the current batch of results is being processed by the client.</span></span> <span data-ttu-id="11daa-172">A lekérdezések teljes késést fokozása lehívását segít.</span><span class="sxs-lookup"><span data-stu-id="11daa-172">The pre-fetching helps in overall latency improvement of a query.</span></span> <span data-ttu-id="11daa-173">MaxBufferedItemCount megadása a paraméter előre lehívott eredmények számát.</span><span class="sxs-lookup"><span data-stu-id="11daa-173">MaxBufferedItemCount is the parameter to limit the number of pre-fetched results.</span></span> <span data-ttu-id="11daa-174">A várt számú eredményt adott vissza a MaxBufferedItemCount (vagy magasabb azonosítószámot) beállítás lehetővé teszi, hogy a lekérdezés maximális haszna nem származik, a lehívását.</span><span class="sxs-lookup"><span data-stu-id="11daa-174">Setting MaxBufferedItemCount to the expected number of results returned (or a higher number) allows the query to receive maximum benefit from pre-fetching.</span></span>

    <span data-ttu-id="11daa-175">Vegye figyelembe, hogy lehívását függetlenül a MaxDegreeOfParallelism ugyanúgy működik, és minden olyan partíciónak az adatait az egyetlen puffert.</span><span class="sxs-lookup"><span data-stu-id="11daa-175">Note that pre-fetching works the same way irrespective of the MaxDegreeOfParallelism, and there is a single buffer for the data from all partitions.</span></span>  
5. <span data-ttu-id="11daa-176">**Kiszolgálóoldali GC bekapcsolása**</span><span class="sxs-lookup"><span data-stu-id="11daa-176">**Turn on server-side GC**</span></span>

    <span data-ttu-id="11daa-177">Bizonyos esetekben segíthet a szemétgyűjtés gyakoriságának csökkentését.</span><span class="sxs-lookup"><span data-stu-id="11daa-177">Reducing the frequency of garbage collection may help in some cases.</span></span> <span data-ttu-id="11daa-178">A .NET, állítsa be [gcServer](https://msdn.microsoft.com/library/ms229357.aspx) igaz értékre.</span><span class="sxs-lookup"><span data-stu-id="11daa-178">In .NET, set [gcServer](https://msdn.microsoft.com/library/ms229357.aspx) to true.</span></span>
6. <span data-ttu-id="11daa-179">**Leállítási RetryAfter időközönként megvalósítása**</span><span class="sxs-lookup"><span data-stu-id="11daa-179">**Implement backoff at RetryAfter intervals**</span></span>

    <span data-ttu-id="11daa-180">Teljesítmény tesztelés során terhelés csak a kis mértékben kérelmek get halmozódni növelje meg.</span><span class="sxs-lookup"><span data-stu-id="11daa-180">During performance testing, you should increase load until a small rate of requests get throttled.</span></span> <span data-ttu-id="11daa-181">Ha szabályozva, az ügyfélalkalmazás kell a késleltetési leállítási a kiszolgáló által megadott újrapróbálkozási időköz.</span><span class="sxs-lookup"><span data-stu-id="11daa-181">If throttled, the client application should backoff on throttle for the server-specified retry interval.</span></span> <span data-ttu-id="11daa-182">A leállítási tiszteletben biztosítja, hogy az újrapróbálkozások közötti várakozási idő a lehető legrövidebb idő.</span><span class="sxs-lookup"><span data-stu-id="11daa-182">Respecting the backoff ensures that you spend minimal amount of time waiting between retries.</span></span> <span data-ttu-id="11daa-183">Újrapróbálkozási házirend támogatása a rendszer része, a verzió 1.8.0 és az újabb, a DocumentDB [.NET](documentdb-sdk-dotnet.md) és [Java](documentdb-sdk-java.md), 1.9.0 verzió vagy újabb verzió, a [Node.js](documentdb-sdk-node.md) és [Python ](documentdb-sdk-python.md), és az összes támogatott verziója a [.NET Core](documentdb-sdk-dotnet-core.md) SDK-k.</span><span class="sxs-lookup"><span data-stu-id="11daa-183">Retry policy support is included in Version 1.8.0 and above of the DocumentDB [.NET](documentdb-sdk-dotnet.md) and [Java](documentdb-sdk-java.md), version 1.9.0 and above of the [Node.js](documentdb-sdk-node.md) and [Python](documentdb-sdk-python.md), and all supported versions of the [.NET Core](documentdb-sdk-dotnet-core.md) SDKs.</span></span> <span data-ttu-id="11daa-184">További információkért lásd: [Exceeding fenntartott átviteli sebességének korlátai](request-units.md#RequestRateTooLarge) és [RetryAfter](https://msdn.microsoft.com/library/microsoft.azure.documents.documentclientexception.retryafter.aspx).</span><span class="sxs-lookup"><span data-stu-id="11daa-184">For more information, see [Exceeding reserved throughput limits](request-units.md#RequestRateTooLarge) and [RetryAfter](https://msdn.microsoft.com/library/microsoft.azure.documents.documentclientexception.retryafter.aspx).</span></span>
7. <span data-ttu-id="11daa-185">**Horizontális felskálázás az ügyfél-alkalmazások és szolgáltatások**</span><span class="sxs-lookup"><span data-stu-id="11daa-185">**Scale out your client-workload**</span></span>

    <span data-ttu-id="11daa-186">Ha nagy átviteli szinten teszteli (> 50 000 RU/mp), az ügyfélalkalmazás gép határértékét el a Processzor- vagy hálózati kihasználtsága miatt a szűk keresztmetszetek válhat.</span><span class="sxs-lookup"><span data-stu-id="11daa-186">If you are testing at high throughput levels (>50,000 RU/s), the client application may become the bottleneck due to the machine capping out on CPU or Network utilization.</span></span> <span data-ttu-id="11daa-187">Ha eléri ezt a pontot, továbbra is a Cosmos DB fiók további leküldéses által az ügyfélalkalmazások kiterjesztése több kiszolgáló között.</span><span class="sxs-lookup"><span data-stu-id="11daa-187">If you reach this point, you can continue to push the Cosmos DB account further by scaling out your client applications across multiple servers.</span></span>
8. <span data-ttu-id="11daa-188">**Gyorsítótár-dokumentum URI-azonosítók az alsó olvasási késleltetés**</span><span class="sxs-lookup"><span data-stu-id="11daa-188">**Cache document URIs for lower read latency**</span></span>

    <span data-ttu-id="11daa-189">Gyorsítótár-dokumentum URI-k, amikor csak lehetséges, a legjobb olvasási teljesítményt.</span><span class="sxs-lookup"><span data-stu-id="11daa-189">Cache document URIs whenever possible for the best read performance.</span></span>
   <a id="tune-page-size"></a>
9. <span data-ttu-id="11daa-190">**A jobb teljesítmény lekérdezések/olvasás hírcsatornák lapmérete hangolása**</span><span class="sxs-lookup"><span data-stu-id="11daa-190">**Tune the page size for queries/read feeds for better performance**</span></span>

    <span data-ttu-id="11daa-191">Olvasási hírcsatorna funkciók (például ReadDocumentFeedAsync) használó dokumentumokat, vagy a tömeges végrehajtása olvasási, a DocumentDB SQL-lekérdezést kiállításához, eredményeinek szegmentált módon ha eredménykészlet túl nagy.</span><span class="sxs-lookup"><span data-stu-id="11daa-191">When performing a bulk read of documents using read feed functionality (for example, ReadDocumentFeedAsync) or when issuing a DocumentDB SQL query, the results are returned in a segmented fashion if the result set is too large.</span></span> <span data-ttu-id="11daa-192">Alapértelmezés szerint eredményeinek 100 elemet vagy 1 MB adattömböket, bármelyik korlát találati első.</span><span class="sxs-lookup"><span data-stu-id="11daa-192">By default, results are returned in chunks of 100 items or 1 MB, whichever limit is hit first.</span></span>

    <span data-ttu-id="11daa-193">Adjon meg kevesebb hálózati kerekíteni való adatváltások számát az összes vonatkozó eredmények beolvasásához szükséges, növelheti az oldalméret, x-ms-maximális elem-darabszám kérelemfejléc legfeljebb 1000 használatával.</span><span class="sxs-lookup"><span data-stu-id="11daa-193">To reduce the number of network round trips required to retrieve all applicable results, you can increase the page size using x-ms-max-item-count request header to up to 1000.</span></span> <span data-ttu-id="11daa-194">Azokban az esetekben, ahol csak néhány eredmények megtekintése céljából kell például a felhasználói felület vagy a kérelem API visszatérési értéke csak 10 egyszerre annak az eredménye, csökkentheti a 10-re csökkenteni a teljesítményt, Olvasás, mind a lekérdezések felhasznált mérete.</span><span class="sxs-lookup"><span data-stu-id="11daa-194">In cases where you need to display only a few results, for example, if your user interface or application API returns only 10 results a time, you can also decrease the page size to 10 to reduce the throughput consumed for reads and queries.</span></span>

    <span data-ttu-id="11daa-195">Az oldalméret, a rendelkezésre álló Cosmos DB SDK-k használatával is megadhat.</span><span class="sxs-lookup"><span data-stu-id="11daa-195">You may also set the page size using the available Cosmos DB SDKs.</span></span>  <span data-ttu-id="11daa-196">Példa:</span><span class="sxs-lookup"><span data-stu-id="11daa-196">For example:</span></span>

        IQueryable<dynamic> authorResults = client.CreateDocumentQuery(documentCollection.SelfLink, "SELECT p.Author FROM Pages p WHERE p.Title = 'About Seattle'", new FeedOptions { MaxItemCount = 1000 });
10. <span data-ttu-id="11daa-197">**Növeli a szálak/feladatok száma**</span><span class="sxs-lookup"><span data-stu-id="11daa-197">**Increase number of threads/tasks**</span></span>

    <span data-ttu-id="11daa-198">Lásd: [szálak/feladatok számának növelése](#increase-threads) hálózatkezelés szakaszában.</span><span class="sxs-lookup"><span data-stu-id="11daa-198">See [Increase number of threads/tasks](#increase-threads) in the Networking section.</span></span>

11. <span data-ttu-id="11daa-199">**Használja a 64 bites állomás feldolgozása**</span><span class="sxs-lookup"><span data-stu-id="11daa-199">**Use 64-bit host processing**</span></span>

    <span data-ttu-id="11daa-200">A DocumentDB SDK működik egy 32 bites gazdafolyamat a DocumentDB .NET SDK 1.11.4 verzió használata esetén és újabb verzióit.</span><span class="sxs-lookup"><span data-stu-id="11daa-200">The DocumentDB SDK works in a 32-bit host process when you are using DocumentDB .NET SDK version 1.11.4 and above.</span></span> <span data-ttu-id="11daa-201">Azonban használatakor alhálózatok közötti partíció lekérdezések, 64 bites állomás feldolgozása ajánlott javítja a teljesítményt.</span><span class="sxs-lookup"><span data-stu-id="11daa-201">However, if you are using cross partition queries, 64-bit host processing is recommended for improved performance.</span></span> <span data-ttu-id="11daa-202">A következő típusú alkalmazásokat a 32 bites gazdafolyamat, alapértelmezés szerint rendelkezik, így ahhoz, hogy módosítsa, 64 bites, kövesse ezeket a lépéseket az alkalmazás típusától függően:</span><span class="sxs-lookup"><span data-stu-id="11daa-202">The following types of applications have 32-bit host process as the default, so in order to change that to 64-bit, follow these steps based on the type of your application:</span></span>

    - <span data-ttu-id="11daa-203">Végrehajtható alkalmazások, ehhez jelének a **előnyben részesítik a 32 bites** beállítást a **projekt Tulajdonságok** ablakban, a a **Build** lapon.</span><span class="sxs-lookup"><span data-stu-id="11daa-203">For Executable applications, this can be done by unchecking the **Prefer 32-bit** option in the **Project Properties** window, on the **Build** tab.</span></span>

    - <span data-ttu-id="11daa-204">VSTest alapú teszt projektek, ehhez kiválasztásával **tesztelése**->**beállítások ellenőrzése**->**X64 processzorarchitektúrát alapértelmezett**, az a **Visual Studio Test** menüjét.</span><span class="sxs-lookup"><span data-stu-id="11daa-204">For VSTest based test projects, this can be done by selecting **Test**->**Test Settings**->**Default Processor Architecture as X64**, from the **Visual Studio Test** menu option.</span></span>

    - <span data-ttu-id="11daa-205">Helyileg telepített ASP.NET webes alkalmazásokhoz, ehhez ellenőrzésével a **az IIS Express 64 bites verzióját használja a webhelyek és projektek**a **eszközök**->**beállítások**  -> **Projektek és megoldások**->**webes projektek**.</span><span class="sxs-lookup"><span data-stu-id="11daa-205">For locally deployed ASP.NET Web applications, this can be done by checking the **Use the 64-bit version of IIS Express for web sites and projects**, under **Tools**->**Options**->**Projects and Solutions**->**Web Projects**.</span></span>

    - <span data-ttu-id="11daa-206">ASP.NET webes alkalmazásokhoz, Azure rendszerbe, ehhez válassza ki a **64 bites platformok** a a **Alkalmazásbeállítások** az Azure portálon.</span><span class="sxs-lookup"><span data-stu-id="11daa-206">For ASP.NET Web applications deployed on Azure, this can be done by choosing the **Platform as 64-bit** in the **Application Settings** on the Azure portal.</span></span>

## <a name="indexing-policy"></a><span data-ttu-id="11daa-207">Indexelési házirendet</span><span class="sxs-lookup"><span data-stu-id="11daa-207">Indexing Policy</span></span>
1. <span data-ttu-id="11daa-208">**Használja a Lusta indexelő adatfeldolgozást díjszabás gyorsabb maximális idő**</span><span class="sxs-lookup"><span data-stu-id="11daa-208">**Use lazy indexing for faster peak time ingestion rates**</span></span>

    <span data-ttu-id="11daa-209">A cosmos DB – a gyűjtemény szintjén – adja meg az indexelési házirendet, amely lehetővé teszi, hogy adja meg, ha a dokumentumok automatikusan indexelése vagy nem egy gyűjtemény teszi lehetővé.</span><span class="sxs-lookup"><span data-stu-id="11daa-209">Cosmos DB allows you to specify – at the collection level – an indexing policy, which enables you to choose if you want the documents in a collection to be automatically indexed or not.</span></span>  <span data-ttu-id="11daa-210">Ezenkívül azt is választhatnak (Consistent) szinkron és aszinkron (Lazy) index frissítések.</span><span class="sxs-lookup"><span data-stu-id="11daa-210">In addition, you may also choose between synchronous (Consistent) and asynchronous (Lazy) index updates.</span></span> <span data-ttu-id="11daa-211">Alapértelmezés szerint az index frissítése szinkron módon minden insert, replace vagy egy dokumentumot – így a gyűjtemény törlése.</span><span class="sxs-lookup"><span data-stu-id="11daa-211">By default, the index is updated synchronously on each insert, replace, or delete of a document to the collection.</span></span> <span data-ttu-id="11daa-212">Szinkron módon módja lehetővé teszi a lekérdezések tiszteletben azonos [konzisztenciaszint](consistency-levels.md) módon, hogy a dokumentum beolvassa az index "szinkronizálásához" késedelem nélkül.</span><span class="sxs-lookup"><span data-stu-id="11daa-212">Synchronously mode enables the queries to honor the same [consistency level](consistency-levels.md) as that of the document reads without any delay for the index to “catch up".</span></span>

    <span data-ttu-id="11daa-213">A lusta indexelési forgatókönyvek, amelyben adatot ír a felszakadásáig tekinthetők, és egy hosszabb időtartamra vonatkozóan index tartalom szükséges munka amortize szeretné.</span><span class="sxs-lookup"><span data-stu-id="11daa-213">Lazy indexing may be considered for scenarios in which data is written in bursts, and you want to amortize the work required to index content over a longer period of time.</span></span> <span data-ttu-id="11daa-214">A lusta indexelési is lehetővé teszi hatékonyan használja a létesített átviteli sebesség és írási kérelmek kiszolgálását csúcsidőben minimális késéssel.</span><span class="sxs-lookup"><span data-stu-id="11daa-214">Lazy indexing also allows you to use your provisioned throughput effectively and serve write requests at peak times with minimal latency.</span></span> <span data-ttu-id="11daa-215">Fontos megjegyezni, azonban, hogy ha Lusta indexelő engedélyezve van, lekérdezési eredményeket idővel konzisztenssé a Cosmos DB fiókok konzisztenciaszint függetlenül.</span><span class="sxs-lookup"><span data-stu-id="11daa-215">It is important to note, however, that when lazy indexing is enabled, query results are eventually consistent regardless of the consistency level configured for the Cosmos DB account.</span></span>

    <span data-ttu-id="11daa-216">Azt eredményezi, ezért konzisztens indexelési mód (IndexingPolicy.IndexingMode Consistent tulajdonság értéke) a legmagasabb kérelem egység kell fizetni írásonkénti Lazy indexelő (IndexingPolicy.IndexingMode beállítása Lazy) módot, és nem az indexelés során azok háromszorosa (IndexingPolicy.Automatic beállítása Hamis) rendelkezik nulla indexelési költség írása idején.</span><span class="sxs-lookup"><span data-stu-id="11daa-216">Hence, Consistent indexing mode (IndexingPolicy.IndexingMode is set to Consistent) incurs the highest request unit charge per write, while Lazy indexing mode (IndexingPolicy.IndexingMode is set to Lazy) and no indexing (IndexingPolicy.Automatic is set to False) have zero indexing cost at the time of write.</span></span>
2. <span data-ttu-id="11daa-217">**Nem használt elérési utak kizárása a gyorsabb írási az indexelő**</span><span class="sxs-lookup"><span data-stu-id="11daa-217">**Exclude unused paths from indexing for faster writes**</span></span>

    <span data-ttu-id="11daa-218">Cosmos DB tartozó indexelési házirendet is lehetővé teszi, mely dokumentum elérési vagy kizárja a indexelő elérési utakon található (IndexingPolicy.IncludedPaths IndexingPolicy.ExcludedPaths), ami indexelésének megadásához.</span><span class="sxs-lookup"><span data-stu-id="11daa-218">Cosmos DB’s indexing policy also allows you to specify which document paths to include or exclude from indexing by leveraging Indexing Paths (IndexingPolicy.IncludedPaths and IndexingPolicy.ExcludedPaths).</span></span> <span data-ttu-id="11daa-219">Indexelő elérési utak használatát is kínál a javított teljesítménye és alacsonyabb index tárolási forgatókönyvek, ahol a lekérdezési mintáknak előzetesen ismert, mivel az indexelő költségek közvetlenül indexelt egyedi elérési utak száma közötti kapcsolatot.</span><span class="sxs-lookup"><span data-stu-id="11daa-219">The use of indexing paths can offer improved write performance and lower index storage for scenarios in which the query patterns are known beforehand, as indexing costs are directly correlated to the number of unique paths indexed.</span></span>  <span data-ttu-id="11daa-220">Például a következő kód bemutatja, hogyan egy teljes szakasz a dokumentumok (más néven kizárása</span><span class="sxs-lookup"><span data-stu-id="11daa-220">For example, the following code shows how to exclude an entire section of the documents (a.k.a.</span></span> <span data-ttu-id="11daa-221">egy részfája) indexelési használja a "*" helyettesítő karakter.</span><span class="sxs-lookup"><span data-stu-id="11daa-221">a subtree) from indexing using the "*" wildcard.</span></span>

    ```C#
    var collection = new DocumentCollection { Id = "excludedPathCollection" };
    collection.IndexingPolicy.IncludedPaths.Add(new IncludedPath { Path = "/*" });
    collection.IndexingPolicy.ExcludedPaths.Add(new ExcludedPath { Path = "/nonIndexedContent/*");
    collection = await client.CreateDocumentCollectionAsync(UriFactory.CreateDatabaseUri("db"), excluded);
    ```

    <span data-ttu-id="11daa-222">További információkért lásd: [Azure Cosmos DB házirendek indexelő](indexing-policies.md).</span><span class="sxs-lookup"><span data-stu-id="11daa-222">For more information, see [Azure Cosmos DB indexing policies](indexing-policies.md).</span></span>

## <a name="throughput"></a><span data-ttu-id="11daa-223">Teljesítmény</span><span class="sxs-lookup"><span data-stu-id="11daa-223">Throughput</span></span>
<a id="measure-rus"></a>

1. <span data-ttu-id="11daa-224">**Mérését meg és hangolható alacsonyabb kérelem egység/másodperc kihasználtsága**</span><span class="sxs-lookup"><span data-stu-id="11daa-224">**Measure and tune for lower request units/second usage**</span></span>

    <span data-ttu-id="11daa-225">Cosmos DB kínál széles választéka, beleértve a felhasználó által megadott függvények, tárolt eljárások és eseményindítók – összes működési egy adatbázis-gyűjteményben lévő dokumentumokon hierarchikus és relációs lekérdezések az adatbázis-művelet.</span><span class="sxs-lookup"><span data-stu-id="11daa-225">Cosmos DB offers a rich set of database operations including relational and hierarchical queries with UDFs, stored procedures, and triggers – all operating on the documents within a database collection.</span></span> <span data-ttu-id="11daa-226">E műveletek költsége attól függően változik, a CPU IO és memória a művelet befejezéséhez szükséges.</span><span class="sxs-lookup"><span data-stu-id="11daa-226">The cost associated with each of these operations varies based on the CPU, IO, and memory required to complete the operation.</span></span> <span data-ttu-id="11daa-227">Továbbléphetnek és hardver-erőforrások kezelése helyett tulajdonképpen egy kérelem egységet (RU) egyetlen intézkedésként az adatbázis különböző műveleteket végezhet, és az alkalmazás kérelem kiszolgálásához szükséges erőforrásokhoz.</span><span class="sxs-lookup"><span data-stu-id="11daa-227">Instead of thinking about and managing hardware resources, you can think of a request unit (RU) as a single measure for the resources required to perform various database operations and service an application request.</span></span>

    <span data-ttu-id="11daa-228">[Kérelem egységek](request-units.md) minden kapacitásegység megvásárolt száma alapján adatbázis fiókjához tartozó törlődnek.</span><span class="sxs-lookup"><span data-stu-id="11daa-228">[Request units](request-units.md) are provisioned for each database account based on the number of capacity units that you purchase.</span></span> <span data-ttu-id="11daa-229">Kérelem egység fogyasztás másodpercenkénti történik.</span><span class="sxs-lookup"><span data-stu-id="11daa-229">Request unit consumption is evaluated as a rate per second.</span></span> <span data-ttu-id="11daa-230">Olyan alkalmazások, amelyek mérete meghaladja a kiépített kérelmek egység aránya fiókjuk korlátozva, amíg a fiók fenntartott szint alatt esik sebessége.</span><span class="sxs-lookup"><span data-stu-id="11daa-230">Applications that exceed the provisioned request unit rate for their account is limited until the rate drops below the reserved level for the account.</span></span> <span data-ttu-id="11daa-231">Ha az alkalmazás egy magasabb szintű teljesítmény, vásárolhat további kapacitást egység.</span><span class="sxs-lookup"><span data-stu-id="11daa-231">If your application requires a higher level of throughput, you can purchase additional capacity units.</span></span>

    <span data-ttu-id="11daa-232">A lekérdezés összetettsége hatással van kérelem egységek művelet végrehajtásánál.</span><span class="sxs-lookup"><span data-stu-id="11daa-232">The complexity of a query impacts how many Request Units are consumed for an operation.</span></span> <span data-ttu-id="11daa-233">Predikátumok a száma, a predikátum, felhasználó által megadott függvények száma és a forrás adatkészlet összes mérete befolyásolja a lekérdezési műveletek költségét.</span><span class="sxs-lookup"><span data-stu-id="11daa-233">The number of predicates, nature of the predicates, number of UDFs, and the size of the source data set all influence the cost of query operations.</span></span>

    <span data-ttu-id="11daa-234">A terhelést növelni az összes műveletet mérésére (létrehozása, frissítése vagy törlése), vizsgálja meg az x-ms-kérelem-kell fizetni fejléc (vagy a megfelelő RequestCharge tulajdonságot az ResourceResponse<T> vagy FeedResponse<T> a .NET SDK-ban) számának mérésére a kérelemegység használni ezeket a műveleteket.</span><span class="sxs-lookup"><span data-stu-id="11daa-234">To measure the overhead of any operation (create, update, or delete), inspect the x-ms-request-charge header (or the equivalent RequestCharge property in ResourceResponse<T> or FeedResponse<T> in the .NET SDK) to measure the number of request units consumed by these operations.</span></span>

    ```C#
    // Measure the performance (request units) of writes
    ResourceResponse<Document> response = await client.CreateDocumentAsync(collectionSelfLink, myDocument);
    Console.WriteLine("Insert of document consumed {0} request units", response.RequestCharge);
    // Measure the performance (request units) of queries
    IDocumentQuery<dynamic> queryable = client.CreateDocumentQuery(collectionSelfLink, queryString).AsDocumentQuery();
    while (queryable.HasMoreResults)
         {
              FeedResponse<dynamic> queryResponse = await queryable.ExecuteNextAsync<dynamic>();
              Console.WriteLine("Query batch consumed {0} request units", queryResponse.RequestCharge);
         }
    ```             

    <span data-ttu-id="11daa-235">A kérelem kell fizetni, ezt a fejlécet a visszaadott részét a létesített átviteli sebesség (azaz 2000 RUs / másodperc).</span><span class="sxs-lookup"><span data-stu-id="11daa-235">The request charge returned in this header is a fraction of your provisioned throughput (i.e., 2000 RUs / second).</span></span> <span data-ttu-id="11daa-236">Például ha az előző lekérdezés függvény 1000 1KB-dokumentumok, a költség, a művelet érték 1000.</span><span class="sxs-lookup"><span data-stu-id="11daa-236">For example, if the preceding query returns 1000 1KB-documents, the cost of the operation is 1000.</span></span> <span data-ttu-id="11daa-237">Ilyen belül egy második, a kiszolgáló eleget tegyen csak két ilyen kérelmeket előtt szabályozás későbbi kérelmeket.</span><span class="sxs-lookup"><span data-stu-id="11daa-237">As such, within one second, the server honors only two such requests before throttling subsequent requests.</span></span> <span data-ttu-id="11daa-238">További információkért lásd: [egységek kérelem](request-units.md) és a [kérelem egység Számológép](https://www.documentdb.com/capacityplanner).</span><span class="sxs-lookup"><span data-stu-id="11daa-238">For more information, see [Request units](request-units.md) and the [request unit calculator](https://www.documentdb.com/capacityplanner).</span></span>
<a id="429"></a>
2. <span data-ttu-id="11daa-239">**Kezeli a sebesség korlátozása/kérelmek aránya túl nagy**</span><span class="sxs-lookup"><span data-stu-id="11daa-239">**Handle rate limiting/request rate too large**</span></span>

    <span data-ttu-id="11daa-240">Amikor az ügyfél meghaladja a fenntartott átviteli sebesség egy olyan fiók, nincs teljesítmény csökkenése nélkül működhet a kiszolgálón, és felül a fenntartott átviteli sebesség nincs használatban.</span><span class="sxs-lookup"><span data-stu-id="11daa-240">When a client attempts to exceed the reserved throughput for an account, there is no performance degradation at the server and no use of throughput capacity beyond the reserved level.</span></span> <span data-ttu-id="11daa-241">A kiszolgáló megelőző jelleggel end RequestRateTooLarge (HTTP-állapotkód: 429) a kérelmet, és az x-ms-újrapróbálkozási-után-ms-fejléc jelző idő ezredmásodpercben, ameddig a kérelem megoldódhat előtt a felhasználónak kell visszaadnia.</span><span class="sxs-lookup"><span data-stu-id="11daa-241">The server will preemptively end the request with RequestRateTooLarge (HTTP status code 429) and return the x-ms-retry-after-ms header indicating the amount of time, in milliseconds, that the user must wait before reattempting the request.</span></span>

        HTTP Status 429,
        Status Line: RequestRateTooLarge
        x-ms-retry-after-ms :100

    <span data-ttu-id="11daa-242">Az SDK-k minden implicit módon dolgozza fel ezt a választ, tiszteletben tartják a kiszolgáló által megadott újrapróbálkozási után fejlécet, és próbálkozzon újra a kéréssel.</span><span class="sxs-lookup"><span data-stu-id="11daa-242">The SDKs all implicitly catch this response, respect the server-specified retry-after header, and retry the request.</span></span> <span data-ttu-id="11daa-243">Kivéve, ha a fiók több ügyfélnek egyszerre használja, a következő újrapróbálkozási sikeres lesz.</span><span class="sxs-lookup"><span data-stu-id="11daa-243">Unless your account is being accessed concurrently by multiple clients, the next retry will succeed.</span></span>

    <span data-ttu-id="11daa-244">Ha egynél több ügyfél felett a kérelmek aránya következetesen összesítve működő, az alapértelmezett újrapróbálkozások száma pillanatnyilag beállított 9 belső az ügyfél nem lehetséges, hogy elegendő; Ebben az esetben az ügyfél egy DocumentClientException állapotkóddal 429 jelez az alkalmazást.</span><span class="sxs-lookup"><span data-stu-id="11daa-244">If you have more than one client cumulatively operating consistently above the request rate, the default retry count currently set to 9 internally by the client may not suffice; in this case, the client throws a DocumentClientException with status code 429 to the application.</span></span> <span data-ttu-id="11daa-245">Az alapértelmezett újrapróbálkozások száma módosítható úgy, hogy a RetryOptions ConnectionPolicy-példányon.</span><span class="sxs-lookup"><span data-stu-id="11daa-245">The default retry count can be changed by setting the RetryOptions on the ConnectionPolicy instance.</span></span> <span data-ttu-id="11daa-246">Alapértelmezés szerint a DocumentClientException 429. állapotkód: esetén visszaadott 30 másodperc halmozódó várakozási idő után a kérelem folytatja a működést a kérelmek aránya fent.</span><span class="sxs-lookup"><span data-stu-id="11daa-246">By default, the DocumentClientException with status code 429 is returned after a cumulative wait time of 30 seconds if the request continues to operate above the request rate.</span></span> <span data-ttu-id="11daa-247">Ez akkor fordul elő, még ha az aktuális újrapróbálkozások maximális számát nem éri el az újrapróbálkozások maximális száma, hogy azt az alapértelmezett 9 vagy egy felhasználó által definiált értéket.</span><span class="sxs-lookup"><span data-stu-id="11daa-247">This occurs even when the current retry count is less than the max retry count, be it the default of 9 or a user-defined value.</span></span>

    <span data-ttu-id="11daa-248">Az automatizált újrapróbálkozásra segít a rugalmasság és a legtöbb alkalmazás használhatóság javítása érdekében, miközben, előfordulhat, hogy térjen bármikor odds teljesítménymutatókat, során, különösen akkor, ha a késleltetés mérése.</span><span class="sxs-lookup"><span data-stu-id="11daa-248">While the automated retry behavior helps to improve resiliency and usability for the most applications, it might come at odds when doing performance benchmarks, especially when measuring latency.</span></span>  <span data-ttu-id="11daa-249">Az ügyfél-megfigyelt késés fog lefoglalását, ha a kísérlet a kiszolgáló szabályozásának találatok és következtében az ügyfél SDK használatával beavatkozás nélkül próbálja meg újra.</span><span class="sxs-lookup"><span data-stu-id="11daa-249">The client-observed latency will spike if the experiment hits the server throttle and causes the client SDK to silently retry.</span></span> <span data-ttu-id="11daa-250">Teljesítmény kísérletek során késleltetés igényeiben jelentkező elkerüléséhez mérjük a díj minden művelet által visszaadott, és győződjön meg arról, hogy a kérelmek működnek-e a fenntartott kérelmek aránya alatt.</span><span class="sxs-lookup"><span data-stu-id="11daa-250">To avoid latency spikes during performance experiments, measure the charge returned by each operation and ensure that requests are operating below the reserved request rate.</span></span> <span data-ttu-id="11daa-251">További információkért lásd: [egységek kérelem](request-units.md).</span><span class="sxs-lookup"><span data-stu-id="11daa-251">For more information, see [Request units](request-units.md).</span></span>
3. <span data-ttu-id="11daa-252">**Nagyobb átviteli sebesség eléréséhez kisebb dokumentumok kialakítása**</span><span class="sxs-lookup"><span data-stu-id="11daa-252">**Design for smaller documents for higher throughput**</span></span>

    <span data-ttu-id="11daa-253">A kérelem költség (azaz Kérelemfeldolgozás költség) egy adott művelet közvetlenül visszamenőleges korrelációban állnak a dokumentum méretét.</span><span class="sxs-lookup"><span data-stu-id="11daa-253">The request charge (i.e. request processing cost) of a given operation is directly correlated to the size of the document.</span></span> <span data-ttu-id="11daa-254">Műveletek nagy dokumentumok drágább, mint műveletek kis dokumentumokhoz.</span><span class="sxs-lookup"><span data-stu-id="11daa-254">Operations on large documents cost more than operations for small documents.</span></span>

## <a name="next-steps"></a><span data-ttu-id="11daa-255">Következő lépések</span><span class="sxs-lookup"><span data-stu-id="11daa-255">Next steps</span></span>
<span data-ttu-id="11daa-256">Olyan mintaalkalmazásért, nagy teljesítményű forgatókönyvek néhány ügyfélszámítógépekre Cosmos DB értékeléséhez használt, lásd: [teljesítmény és méretezhetőség Cosmos DB tesztelték](performance-testing.md).</span><span class="sxs-lookup"><span data-stu-id="11daa-256">For a sample application used to evaluate Cosmos DB for high-performance scenarios on a few client machines, see [Performance and scale testing with Cosmos DB](performance-testing.md).</span></span>

<span data-ttu-id="11daa-257">Az alkalmazás a méretezés és magas teljesítménnyel megtervezésével kapcsolatos további tudnivalókért lásd még [particionálás és az Azure Cosmos Adatbázisba skálázás](partition-data.md).</span><span class="sxs-lookup"><span data-stu-id="11daa-257">Also, to learn more about designing your application for scale and high performance, see [Partitioning and scaling in Azure Cosmos DB](partition-data.md).</span></span>
