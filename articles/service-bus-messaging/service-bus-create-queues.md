---
title: "Alkalmazások írását, amelyek az Azure Service Bus-üzenetsorok használata |} Microsoft Docs"
description: "Egy egyszerű várólista-alapú alkalmazás Azure Service Bus módját."
services: service-bus-messaging
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: 754d91b3-1426-405e-84b4-fd36d65b114a
ms.service: service-bus-messaging
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 08/07/2017
ms.author: sethm
ms.openlocfilehash: 419caff7e8ceeb419c89a2ef9a6614c1accf3e52
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 08/18/2017
---
# <a name="create-applications-that-use-service-bus-queues"></a><span data-ttu-id="419bb-103">Service Bus-üzenetsorokat használó alkalmazások készítése</span><span class="sxs-lookup"><span data-stu-id="419bb-103">Create applications that use Service Bus queues</span></span>
<span data-ttu-id="419bb-104">Ez a témakör ismerteti a Service Bus-üzenetsorok, és bemutatja, hogyan használja a Service Bus egyszerű, a várólista-alapú alkalmazás.</span><span class="sxs-lookup"><span data-stu-id="419bb-104">This topic describes Service Bus queues and shows how to write a simple queue-based application that uses Service Bus.</span></span>

<span data-ttu-id="419bb-105">Fontolja meg egy olyan forgatókönyvet, amelyben egyes Point-of-Sale (POS) részére ábrázolhatja az értékesítési adatokat kell irányítani olyan készletkezelő rendszer esetén, amelyek az adatok az segítségével állapítja meg, ha készlet feltöltést kiskereskedelmi a globális nézetről.</span><span class="sxs-lookup"><span data-stu-id="419bb-105">Consider a scenario from the world of retail in which sales data from individual Point-of-Sale (POS) terminals must be routed to an inventory management system that uses the data to determine when stock has to be replenished.</span></span> <span data-ttu-id="419bb-106">A megoldás az, hogy a Service Bus üzenetkezelés a kapcsok és a készletkezelő rendszer esetén, közötti kommunikációhoz, az alábbi ábra mutatja be:</span><span class="sxs-lookup"><span data-stu-id="419bb-106">This solution uses Service Bus messaging for the communication between the terminals and the inventory management system, as illustrated in the following figure:</span></span>

![Service Bus-üzenetsorok kép 1](./media/service-bus-create-queues/IC657161.gif)

<span data-ttu-id="419bb-108">Minden egyes POS terminál jelentések az értékesítési adatokat küldött üzeneteket a **DataCollectionQueue**.</span><span class="sxs-lookup"><span data-stu-id="419bb-108">Each POS terminal reports its sales data by sending messages to the **DataCollectionQueue**.</span></span> <span data-ttu-id="419bb-109">Ezek az üzenetek ebből a várólistából maradni, amíg lehívás a készletkezelő rendszer által.</span><span class="sxs-lookup"><span data-stu-id="419bb-109">These messages remain in this queue until they are retrieved by the inventory management system.</span></span> <span data-ttu-id="419bb-110">Ezt a mintát gyakran nevezik *aszinkron üzenetkezelési*, mert a POS terminál nem rendelkezik a készletkezelő rendszer esetén a folytatáshoz feldolgozási válasz vár.</span><span class="sxs-lookup"><span data-stu-id="419bb-110">This pattern is often termed *asynchronous messaging*, because the POS terminal does not have to wait for a reply from the inventory management system to continue processing.</span></span>

## <a name="why-queuing"></a><span data-ttu-id="419bb-111">Ezért queuing?</span><span class="sxs-lookup"><span data-stu-id="419bb-111">Why queuing?</span></span>
<span data-ttu-id="419bb-112">Előtt úgy tekintünk, a kód szükséges ahhoz, hogy állítsa be ezt az alkalmazást, gondolja át, ebben a forgatókönyvben, ahelyett, hogy a POS kapcsok várólista előnye közvetlenül kommunikálni (szinkron) a készlet felügyeleti rendszerbe.</span><span class="sxs-lookup"><span data-stu-id="419bb-112">Before we look at the code that is required to set up this application, consider the advantages of using a queue in this scenario instead of having the POS terminals talk directly (synchronously) to the inventory management system.</span></span>

### <a name="temporal-decoupling"></a><span data-ttu-id="419bb-113">Időbeli elválasztás</span><span class="sxs-lookup"><span data-stu-id="419bb-113">Temporal decoupling</span></span>
<span data-ttu-id="419bb-114">Az aszinkron üzenettovábbítási mintának létrehozóknak és a felhasználóknak nem kell egyszerre online lenniük.</span><span class="sxs-lookup"><span data-stu-id="419bb-114">With the asynchronous messaging pattern, producers and consumers do not have to be online at the same time.</span></span> <span data-ttu-id="419bb-115">Az üzenetküldési infrastruktúra megbízhatóan tárolja az üzeneteket, amíg a fogyasztó fél készen áll a fogadásukra.</span><span class="sxs-lookup"><span data-stu-id="419bb-115">The messaging infrastructure reliably stores messages until the consuming party is ready to receive them.</span></span> <span data-ttu-id="419bb-116">Ez azt jelenti, hogy az elosztott alkalmazás összetevőinek is leválasztását, akár önkéntesen; például karbantartás céljából, vagy egy összetevő összeomlása miatt, anélkül érinti az egész rendszerhez.</span><span class="sxs-lookup"><span data-stu-id="419bb-116">This means the components of the distributed application can be disconnected, either voluntarily; for example, for maintenance, or due to a component crash, without affecting the whole system.</span></span> <span data-ttu-id="419bb-117">A fogyasztó alkalmazás továbbá csak lehet, hogy rendelkezik a nap bizonyos időpontjaiban online lennie.</span><span class="sxs-lookup"><span data-stu-id="419bb-117">Furthermore, the consuming application may only have to be online during certain times of the day.</span></span> <span data-ttu-id="419bb-118">Például kereskedelmi ebben a forgatókönyvben a készletkezelő rendszer esetén csak rendelkezhet a munkanapok végén online állapotba.</span><span class="sxs-lookup"><span data-stu-id="419bb-118">For example, in this retail scenario, the inventory management system may only have to come online after the end of the business day.</span></span>

### <a name="load-leveling"></a><span data-ttu-id="419bb-119">Terheléselosztás</span><span class="sxs-lookup"><span data-stu-id="419bb-119">Load leveling</span></span>
<span data-ttu-id="419bb-120">Számos alkalmazás rendszerterhelés időnként eltérő, mivel az egyes Munkaegységek szükséges feldolgozási idő jellemzően állandó marad.</span><span class="sxs-lookup"><span data-stu-id="419bb-120">In many applications system load varies over time, whereas the processing time required for each unit of work is typically constant.</span></span> <span data-ttu-id="419bb-121">Közé üzenetek létrehozói és felhasználói üzenetsorokat jelenti, hogy a felhasználó alkalmazást (a feldolgozót) csak a csúcsterhelés helyett az átlagos terheléssel szolgáltatás kell létrehozni.</span><span class="sxs-lookup"><span data-stu-id="419bb-121">Intermediating message producers and consumers with a queue means that the consuming application (the worker) only has to be provisioned to service an average load rather than a peak load.</span></span> <span data-ttu-id="419bb-122">A várólista mélységét nő, és a szerződést, mivel a bejövő terhelés változik.</span><span class="sxs-lookup"><span data-stu-id="419bb-122">The depth of the queue will grow and contract as the incoming load varies.</span></span> <span data-ttu-id="419bb-123">Ez közvetlen megtakarításokkal pénz alkalmazásterhelés kiszolgálásához szükséges infrastruktúraméret mennyiségének tekintetében.</span><span class="sxs-lookup"><span data-stu-id="419bb-123">This directly saves money with regard to the amount of infrastructure required to service the application load.</span></span>

![Service Bus-üzenetsorok kép 2](./media/service-bus-create-queues/IC657162.gif)

### <a name="load-balancing"></a><span data-ttu-id="419bb-125">Terheléselosztás</span><span class="sxs-lookup"><span data-stu-id="419bb-125">Load balancing</span></span>
<span data-ttu-id="419bb-126">Ha a terhelés növekszik, további feldolgozó folyamatok adhatók a worker-várólistájának olvasásakor.</span><span class="sxs-lookup"><span data-stu-id="419bb-126">As the load increases, more worker processes can be added to read from the worker queue.</span></span> <span data-ttu-id="419bb-127">Az egyes üzeneteket a feldolgozó folyamatoknak csak az egyike dolgozza fel.</span><span class="sxs-lookup"><span data-stu-id="419bb-127">Each message is processed by only one of the worker processes.</span></span> <span data-ttu-id="419bb-128">Ezenkívül a lekérésalapú terheléselosztás lehetővé teszi a munkavégző számítógépek optimális használat akkor is, ha a munkavégző számítógépek feldolgozási teljesítmény tekintetében különböznek, kérik le a saját maximális díj üzenetek.</span><span class="sxs-lookup"><span data-stu-id="419bb-128">Furthermore, this pull-based load balancing allows for optimum usage of the worker computers even if the worker computers differ with regard to processing power, as they will pull messages at their own maximum rate.</span></span> <span data-ttu-id="419bb-129">Ezt a mintát gyakran nevezik versengő fogyasztó mintát.</span><span class="sxs-lookup"><span data-stu-id="419bb-129">This pattern is often termed the competing consumer pattern.</span></span>

![Service Bus-üzenetsorok kép 3](./media/service-bus-create-queues/IC657163.gif)

### <a name="loose-coupling"></a><span data-ttu-id="419bb-131">Laza kapcsoló</span><span class="sxs-lookup"><span data-stu-id="419bb-131">Loose coupling</span></span>
<span data-ttu-id="419bb-132">Az összetevők közötti egy belső laza kapcsoló üzenetsor-kezelési üzenetek létrehozói és felhasználói között haladó segítségével biztosítja.</span><span class="sxs-lookup"><span data-stu-id="419bb-132">Using message queuing to intermediate between message producers and consumers provides an intrinsic loose coupling between the components.</span></span> <span data-ttu-id="419bb-133">Mivel létrehozói és felhasználói nem kompatibilis, minden más, a fogyasztó anélkül, hogy a hatása, ha a gyártó a frissítése.</span><span class="sxs-lookup"><span data-stu-id="419bb-133">Because producers and consumers are not aware of each other, a consumer can be upgraded without having any effect on the producer.</span></span> <span data-ttu-id="419bb-134">Ezenkívül a üzenetküldés topológiája is fejleszteni a meglévő végpontok befolyásolása nélkül.</span><span class="sxs-lookup"><span data-stu-id="419bb-134">Furthermore, the messaging topology can evolve without affecting the existing endpoints.</span></span> <span data-ttu-id="419bb-135">Mutatjuk Ez több amikor döntésről bővebben közzétételi/előfizetési.</span><span class="sxs-lookup"><span data-stu-id="419bb-135">We’ll discuss this more when we talk about publish/subscribe.</span></span>

## <a name="show-me-the-code"></a><span data-ttu-id="419bb-136">A kód bemutatása</span><span class="sxs-lookup"><span data-stu-id="419bb-136">Show me the code</span></span>
<span data-ttu-id="419bb-137">A következő szakasz bemutatja, hogyan hozható létre a alkalmazás Service Bus használatára.</span><span class="sxs-lookup"><span data-stu-id="419bb-137">The following section shows how to use Service Bus to build this application.</span></span>

### <a name="sign-up-for-an-azure-account"></a><span data-ttu-id="419bb-138">Regisztráljon az Azure-fiók</span><span class="sxs-lookup"><span data-stu-id="419bb-138">Sign up for an Azure account</span></span>
<span data-ttu-id="419bb-139">Ahhoz, hogy dolgozni a Service Bus egy Azure-fiókra lesz szüksége.</span><span class="sxs-lookup"><span data-stu-id="419bb-139">You’ll need an Azure account in order to start working with Service Bus.</span></span> <span data-ttu-id="419bb-140">Ha még nem rendelkezik egy, egy ingyenes fiókot regisztrálhat [Itt](https://azure.microsoft.com/pricing/free-trial/?WT.mc_id=A85619ABF).</span><span class="sxs-lookup"><span data-stu-id="419bb-140">If you do not already have one, you can sign up for a free account [here](https://azure.microsoft.com/pricing/free-trial/?WT.mc_id=A85619ABF).</span></span>

### <a name="create-a-namespace"></a><span data-ttu-id="419bb-141">Névtér létrehozása</span><span class="sxs-lookup"><span data-stu-id="419bb-141">Create a namespace</span></span>
<span data-ttu-id="419bb-142">Ha rendelkezik előfizetéssel, akkor [létre kell hoznia egy szolgáltatásnévteret](service-bus-create-namespace-portal.md).</span><span class="sxs-lookup"><span data-stu-id="419bb-142">Once you have a subscription, you can [create a service namespace](service-bus-create-namespace-portal.md).</span></span> <span data-ttu-id="419bb-143">Minden névtér egy hatókörkezelési tárolót állítja be a Service Bus-entitások funkcionál.</span><span class="sxs-lookup"><span data-stu-id="419bb-143">Each namespace acts as a scoping container for a set of Service Bus entities.</span></span> <span data-ttu-id="419bb-144">Az új névtér adjon meg egy egyedi nevet összes Service Bus-fiók.</span><span class="sxs-lookup"><span data-stu-id="419bb-144">Give your new namespace a unique name across all Service Bus accounts.</span></span> 

### <a name="install-the-nuget-package"></a><span data-ttu-id="419bb-145">Telepítse a NuGet-csomagot</span><span class="sxs-lookup"><span data-stu-id="419bb-145">Install the NuGet package</span></span>
<span data-ttu-id="419bb-146">A Service Bus-névtér használatához az alkalmazás a Service Bus-összeállításra, konkrétan Microsoft.ServiceBus.dll kell hivatkoznia.</span><span class="sxs-lookup"><span data-stu-id="419bb-146">To use the Service Bus namespace, an application must reference the Service Bus assembly, specifically Microsoft.ServiceBus.dll.</span></span> <span data-ttu-id="419bb-147">A Microsoft Azure SDK részeként a szerelvény található, és a letöltés érhető el: a [Azure SDK letöltési oldala](https://azure.microsoft.com/downloads/).</span><span class="sxs-lookup"><span data-stu-id="419bb-147">You can find this assembly as part of the Microsoft Azure SDK, and the download is available at the [Azure SDK download page](https://azure.microsoft.com/downloads/).</span></span> <span data-ttu-id="419bb-148">Azonban a [Service Bus NuGet-csomag](https://www.nuget.org/packages/WindowsAzure.ServiceBus) van a Service Bus API beszerzésének, valamint az alkalmazások az összes Service Bus-függőséggel való konfigurálásának legegyszerűbb módja.</span><span class="sxs-lookup"><span data-stu-id="419bb-148">However, the [Service Bus NuGet package](https://www.nuget.org/packages/WindowsAzure.ServiceBus) is the easiest way to get the Service Bus API and to configure your application with all of the Service Bus dependencies.</span></span>

### <a name="create-the-queue"></a><span data-ttu-id="419bb-149">Az üzenetsor létrehozása</span><span class="sxs-lookup"><span data-stu-id="419bb-149">Create the queue</span></span>
<span data-ttu-id="419bb-150">Felügyeleti műveletek a Service Bus üzenetküldési entitásokat (üzenetsorok és a közzétételi/előfizetési témakörök) keresztül hajtja végre a [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) osztály.</span><span class="sxs-lookup"><span data-stu-id="419bb-150">Management operations for Service Bus messaging entities (queues and publish/subscribe topics) are performed via the [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class.</span></span> <span data-ttu-id="419bb-151">A Service Bus használ egy [közös hozzáférésű Jogosultságkód (SAS)](service-bus-sas.md) -alapú biztonsági modellt.</span><span class="sxs-lookup"><span data-stu-id="419bb-151">Service Bus uses a [Shared Access Signature (SAS)](service-bus-sas.md) based security model.</span></span> <span data-ttu-id="419bb-152">A [TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider) osztály vissza néhány jól ismert jogkivonat-szolgáltatót beépített gyári metódusokat tartalmazó jelenti a biztonsági jogkivonat-szolgáltató.</span><span class="sxs-lookup"><span data-stu-id="419bb-152">The [TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider) class represents a security token provider with built-in factory methods returning some well-known token providers.</span></span> <span data-ttu-id="419bb-153">Fogjuk használni egy [CreateSharedAccessSignatureTokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#Microsoft_ServiceBus_TokenProvider_CreateSharedAccessSignatureTokenProvider_System_String_) módszer a SAS-hitelesítő adatok tárolásához.</span><span class="sxs-lookup"><span data-stu-id="419bb-153">We’ll use a [CreateSharedAccessSignatureTokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#Microsoft_ServiceBus_TokenProvider_CreateSharedAccessSignatureTokenProvider_System_String_) method to hold the SAS credentials.</span></span> <span data-ttu-id="419bb-154">A [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) példány majd össze a Service Bus-névtér és jogkivonat-szolgáltató alapszintű címéhez.</span><span class="sxs-lookup"><span data-stu-id="419bb-154">The [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) instance is then constructed with the base address of the Service Bus namespace and the token provider.</span></span>

<span data-ttu-id="419bb-155">A [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) osztály létrehozása, enumerálása és üzenetküldési entitások törlése metódusokat biztosít.</span><span class="sxs-lookup"><span data-stu-id="419bb-155">The [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class provides methods to create, enumerate and delete messaging entities.</span></span> <span data-ttu-id="419bb-156">A kód itt látható bemutatja hogyan a [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) példány létre, amellyel a **DataCollectionQueue** várólista.</span><span class="sxs-lookup"><span data-stu-id="419bb-156">The code that is shown here shows how the [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) instance is created and used to create the **DataCollectionQueue** queue.</span></span>

```csharp
Uri uri = ServiceBusEnvironment.CreateServiceUri("sb", 
                "test-blog", string.Empty);
string name = "RootManageSharedAccessKey";
string key = "abcdefghijklmopqrstuvwxyz";

TokenProvider tokenProvider = 
    TokenProvider.CreateSharedAccessSignatureTokenProvider(name, key);
NamespaceManager namespaceManager = 
    new NamespaceManager(uri, tokenProvider);
namespaceManager.CreateQueue("DataCollectionQueue");
```

<span data-ttu-id="419bb-157">Vegye figyelembe, hogy nincsenek a túlterhelések a [CreateQueue](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateQueue_System_String_) módszer, amelynek kell beállítani a várólista-tulajdonságok engedélyezése.</span><span class="sxs-lookup"><span data-stu-id="419bb-157">Note that there are overloads of the [CreateQueue](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateQueue_System_String_) method that enable properties of the queue to be tuned.</span></span> <span data-ttu-id="419bb-158">Például beállíthatja az alapértelmezett--élettartama (TTL) érték a várólistára küldött üzenetek.</span><span class="sxs-lookup"><span data-stu-id="419bb-158">For example, you can set the default time-to-live (TTL) value for messages sent to the queue.</span></span>

### <a name="send-messages-to-the-queue"></a><span data-ttu-id="419bb-159">Üzenetek küldése az üzenetsorba</span><span class="sxs-lookup"><span data-stu-id="419bb-159">Send messages to the queue</span></span>
<span data-ttu-id="419bb-160">A futásidejű műveletek a Service Bus-entitások; például üzenetek küldése és fogadása, egy alkalmazás először létre kell hoznia egy [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) objektum.</span><span class="sxs-lookup"><span data-stu-id="419bb-160">For run-time operations on Service Bus entities; for example, sending and receiving messages, an application must first create a [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) object.</span></span> <span data-ttu-id="419bb-161">Hasonló a [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) osztály, a [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) példány létrehozása az alapszintű címéből a szolgáltatásnévtér és a jogkivonat-szolgáltató.</span><span class="sxs-lookup"><span data-stu-id="419bb-161">Similar to the [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class, the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) instance is created from the base address of the service namespace and the token provider.</span></span>

```csharp
 BrokeredMessage bm = new BrokeredMessage(salesData);
 bm.Label = "SalesReport";
 bm.Properties["StoreName"] = "Redmond";
 bm.Properties["MachineID"] = "POS_1";
```

<span data-ttu-id="419bb-162">Küldött üzeneteket, és kapott a Service Bus üzenetsorok példánya a [BrokeredMessage](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage) osztály.</span><span class="sxs-lookup"><span data-stu-id="419bb-162">Messages sent to, and received from Service Bus queues are instances of the [BrokeredMessage](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage) class.</span></span> <span data-ttu-id="419bb-163">Ez az osztály áll szabványos tulajdonságait (például [címke](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Label) és [TimeToLive](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_TimeToLive)), alkalmazástulajdonságok tárolására használt, valamint egy tetszőleges alkalmazásadatokból álló törzzsel.</span><span class="sxs-lookup"><span data-stu-id="419bb-163">This class consists of a set of standard properties (such as [Label](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Label) and [TimeToLive](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_TimeToLive)), a dictionary that is used to hold application properties, and a body of arbitrary application data.</span></span> <span data-ttu-id="419bb-164">Az alkalmazás beállíthatja a szervezet történő bármilyen szerializálható objektumnak a (a következő példa továbbítja a egy **SalesData** objektum, amely az értékesítési adatait jelöli a POS terminál), amely fogja használni a [DataContractSerializer](https://msdn.microsoft.com/library/system.runtime.serialization.datacontractserializer.aspx) szerializálja az objektumot.</span><span class="sxs-lookup"><span data-stu-id="419bb-164">An application can set the body by passing in any serializable object (the following example passes in a **SalesData** object that represents the sales data from the POS terminal), which will use the [DataContractSerializer](https://msdn.microsoft.com/library/system.runtime.serialization.datacontractserializer.aspx) to serialize the object.</span></span> <span data-ttu-id="419bb-165">Másik megoldásként egy [adatfolyam](https://msdn.microsoft.com/library/system.io.stream.aspx) objektum megadható.</span><span class="sxs-lookup"><span data-stu-id="419bb-165">Alternatively, a [Stream](https://msdn.microsoft.com/library/system.io.stream.aspx) object can be provided.</span></span>

<span data-ttu-id="419bb-166">Üzenetek küldése egy adott várólistában, abban az esetben, ha a legegyszerűbb módja a **DataCollectionQueue**, használatával [CreateMessageSender](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageSender_System_String_) létrehozásához egy [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) közvetlenül objektum az a [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) példány.</span><span class="sxs-lookup"><span data-stu-id="419bb-166">The easiest way to send messages to a given queue, in our case the **DataCollectionQueue**, is to use [CreateMessageSender](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageSender_System_String_) to create a [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) object directly from the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) instance.</span></span>

```csharp
MessageSender sender = factory.CreateMessageSender("DataCollectionQueue");
sender.Send(bm);
```

### <a name="receiving-messages-from-the-queue"></a><span data-ttu-id="419bb-167">Üzenetek fogadása az üzenetsorból</span><span class="sxs-lookup"><span data-stu-id="419bb-167">Receiving messages from the queue</span></span>
<span data-ttu-id="419bb-168">Üzenetek fogadása az üzenetsorból, használhatja a [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) objektumhoz, melyhez közvetlenül hoz létre a [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) használatával [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_).</span><span class="sxs-lookup"><span data-stu-id="419bb-168">To receive messages from the queue, you can use a [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) object which you create directly from the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) using [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_).</span></span> <span data-ttu-id="419bb-169">Üzenet fogadók a két különböző módban tudnak működni: **ReceiveAndDelete** és **PeekLock**.</span><span class="sxs-lookup"><span data-stu-id="419bb-169">Message receivers can work in two different modes: **ReceiveAndDelete** and **PeekLock**.</span></span> <span data-ttu-id="419bb-170">A [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) van beállítva, amikor az üzenetet fogadó jön létre, mint egy paraméterrel a [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory?redirectedfrom=MSDN#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_Microsoft_ServiceBus_Messaging_ReceiveMode_) hívható meg.</span><span class="sxs-lookup"><span data-stu-id="419bb-170">The [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) is set when the message receiver is created, as a parameter to the [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory?redirectedfrom=MSDN#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_Microsoft_ServiceBus_Messaging_ReceiveMode_) call.</span></span>

<span data-ttu-id="419bb-171">Használatakor a **ReceiveAndDelete** , módot a fogadás egy egylépéses művelet –; Ez azt jelenti, hogy a Service Bus a kérelmet kap, ha azt az üzenetet, feldolgozottként jelöli meg, és visszaadja az alkalmazásnak.</span><span class="sxs-lookup"><span data-stu-id="419bb-171">When using the **ReceiveAndDelete** mode, the receive is a single-shot operation; that is, when Service Bus receives the request, it marks the message as being consumed and returns it to the application.</span></span> <span data-ttu-id="419bb-172">**ReceiveAndDelete** mód a legegyszerűbb modell, és működik a legjobban forgatókönyvek, amelyben az alkalmazás működését nem dolgoz fel üzenetet, ha hiba történik.</span><span class="sxs-lookup"><span data-stu-id="419bb-172">**ReceiveAndDelete** mode is the simplest model and works best for scenarios in which the application can tolerate not processing a message if a failure were to occur.</span></span> <span data-ttu-id="419bb-173">Ennek megértéséhez képzeljen el egy forgatókönyvet, amelyben a fogyasztó kiad egy fogadási kérést, majd összeomlik a feldolgozása előtt.</span><span class="sxs-lookup"><span data-stu-id="419bb-173">To understand this, consider a scenario in which the consumer issues the receive request and then crashes before processing it.</span></span> <span data-ttu-id="419bb-174">Mivel a Service Bus az üzenetet, feldolgozottként jelölte meg, ha az alkalmazás újraindulna és üzenetek újbóli felhasználása indítása ki fogja hagyni a az összeomlás előtt feldolgozott üzenetet.</span><span class="sxs-lookup"><span data-stu-id="419bb-174">Since Service Bus marked the message as being consumed, when the application restarts and starts consuming messages again, it will have missed the message that was consumed before the crash.</span></span>

<span data-ttu-id="419bb-175">A **PeekLock** módban, a fogadás válik a kétszakaszos művelet, amely lehetővé teszi az alkalmazások támogatását, amelyek működését zavarják a hiányzó üzenetek.</span><span class="sxs-lookup"><span data-stu-id="419bb-175">In **PeekLock** mode, the receive becomes a two-stage operation, which makes it possible to support applications that cannot tolerate missing messages.</span></span> <span data-ttu-id="419bb-176">Amikor a Service Bus a kérést kap, azt a következő feldolgozandó üzenetet talál, zárolja azt, hogy más fogyasztók ne fogadni és majd visszaadja az alkalmazásnak.</span><span class="sxs-lookup"><span data-stu-id="419bb-176">When Service Bus receives the request, it finds the next message to be consumed, locks it to prevent other consumers receiving it, and then returns it to the application.</span></span> <span data-ttu-id="419bb-177">Miután az alkalmazás befejezi az üzenet feldolgozását (vagy megbízható módon tárolja a jövőbeli feldolgozáshoz), végrehajtja a fogadási folyamat második a [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) meghívásával a fogadott üzenethez.</span><span class="sxs-lookup"><span data-stu-id="419bb-177">After the application finishes processing the message (or stores it reliably for future processing), it completes the second stage of the receive process by calling [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) on the received message.</span></span> <span data-ttu-id="419bb-178">Amikor a Service Bus látja a [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) hívás, azt az üzenetet, feldolgozottként jelöli.</span><span class="sxs-lookup"><span data-stu-id="419bb-178">When Service Bus sees the [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) call, it marks the message as being consumed.</span></span>

<span data-ttu-id="419bb-179">Két más eredményekkel is előfordulhatnak.</span><span class="sxs-lookup"><span data-stu-id="419bb-179">Two other outcomes are possible.</span></span> <span data-ttu-id="419bb-180">Először, ha az alkalmazás nem tudja feldolgozni az üzenetet valamilyen okból kifolyólag, akkor meghívhatja [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) metódus a fogadott üzenethez (ahelyett, hogy [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)).</span><span class="sxs-lookup"><span data-stu-id="419bb-180">First, if the application is unable to process the message for some reason, it can call [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) on the received message (instead of [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)).</span></span> <span data-ttu-id="419bb-181">Ennek hatására a Service Bus feloldja az üzenet zárolását, és lehetővé teszi az ugyanazon felhasználó vagy épp egy másik fogyasztó ismételt fogadását.</span><span class="sxs-lookup"><span data-stu-id="419bb-181">This causes Service Bus to unlock the message and make it available to be received again, either by the same consumer or by another completing consumer.</span></span> <span data-ttu-id="419bb-182">Második a zárolás társított egy időtúllépés van és ha az alkalmazás nem tudja feldolgozni az üzenetet a zárolási idő lejárta előtt (például, ha az alkalmazás összeomlik), majd Service Bus feloldja az üzenet zárolását, és meg fogja teszi érhető fogadott újra) lényegében hajt végre egy [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) művelet alapértelmezés szerint).</span><span class="sxs-lookup"><span data-stu-id="419bb-182">Second, there is a time-out associated with the lock and if the application cannot process the message before the lock time-out expires (for example, if the application crashes), then Service Bus will unlock the message and make it available to be received again (essentially performing an [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) operation by default).</span></span>

<span data-ttu-id="419bb-183">Vegye figyelembe, hogy ha az alkalmazás összeomlik után feldolgozza az üzenetet előtt azonban a [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) kérelmet adtak ki, az üzenet újból kézbesítve lesz az alkalmazás amikor újraindul.</span><span class="sxs-lookup"><span data-stu-id="419bb-183">Note that if the application crashes after it processes the message but before the [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) request was issued, the message will be redelivered to the application when it restarts.</span></span> <span data-ttu-id="419bb-184">Ezt gyakran nevezik * legalább egyszer * feldolgozása.</span><span class="sxs-lookup"><span data-stu-id="419bb-184">This is often termed *At Least Once * processing.</span></span> <span data-ttu-id="419bb-185">Ez azt jelenti, hogy minden üzenet legalább egyszer dolgoz fel, de bizonyos helyzetekben a a ugyanazon üzenet újbóli kézbesítése is lehet.</span><span class="sxs-lookup"><span data-stu-id="419bb-185">This means that each message will be processed at least once but in certain situations the same message may be redelivered.</span></span> <span data-ttu-id="419bb-186">Ha a forgatókönyvben nem lehetségesek, majd további logikát ismétlődések észlelése az alkalmazásban van szükség.</span><span class="sxs-lookup"><span data-stu-id="419bb-186">If the scenario cannot tolerate duplicate processing, then additional logic is required in the application to detect duplicates.</span></span> <span data-ttu-id="419bb-187">Ez megvalósítható alapján a [MessageId](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_MessageId) az üzenet tulajdonságát.</span><span class="sxs-lookup"><span data-stu-id="419bb-187">This can be achieved based on the [MessageId](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_MessageId) property of the message.</span></span> <span data-ttu-id="419bb-188">Ez a tulajdonság értékének állandó marad a kézbesítési kísérletek során.</span><span class="sxs-lookup"><span data-stu-id="419bb-188">The value of this property remains constant across delivery attempts.</span></span> <span data-ttu-id="419bb-189">Ezt nevezik *pontosan egyszer* feldolgozása.</span><span class="sxs-lookup"><span data-stu-id="419bb-189">This is termed *Exactly Once* processing.</span></span>

<span data-ttu-id="419bb-190">Az itt látható kóddal fogadja és dolgozza fel, egy üzenet használatával a **PeekLock** módját, amely az alapértelmezett beállítás, ha nincs [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) érték explicit módon valósul meg.</span><span class="sxs-lookup"><span data-stu-id="419bb-190">The code that is shown here receives and processes a message using the **PeekLock** mode, which is the default if no [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) value is explicitly provided.</span></span>

```csharp
MessageReceiver receiver = factory.CreateMessageReceiver("DataCollectionQueue");
BrokeredMessage receivedMessage = receiver.Receive();
try
{
    ProcessMessage(receivedMessage);
    receivedMessage.Complete();
}
catch (Exception e)
{
    receivedMessage.Abandon();
}
```

### <a name="use-the-queue-client"></a><span data-ttu-id="419bb-191">A várólista-ügyfél használata</span><span class="sxs-lookup"><span data-stu-id="419bb-191">Use the queue client</span></span>
<span data-ttu-id="419bb-192">A Példák korábbi részében létrehozott [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) és [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) közvetlenül a következő helyről objektumokat a [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) küldeni és fogadni az üzenetek a feldolgozási sor, illetve.</span><span class="sxs-lookup"><span data-stu-id="419bb-192">The examples earlier in this section created [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) and [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) objects directly from the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) to send and receive messages from the queue, respectively.</span></span> <span data-ttu-id="419bb-193">Egy másik módszert is, hogy használja a [QueueClient](/dotnet/api/microsoft.servicebus.messaging.queueclient) objektum, amely támogatja a műveletek küldésének és fogadásának összetettebb funkciók, például a munkamenetek mellett.</span><span class="sxs-lookup"><span data-stu-id="419bb-193">An alternative approach is to use a [QueueClient](/dotnet/api/microsoft.servicebus.messaging.queueclient) object, which supports both send and receive operations in addition to more advanced features, such as sessions.</span></span>

```csharp
QueueClient queueClient = factory.CreateQueueClient("DataCollectionQueue");
queueClient.Send(bm);

BrokeredMessage message = queueClient.Receive();

try
{
    ProcessMessage(message);
    message.Complete();
}
catch (Exception e)
{
    message.Abandon();
} 
```

## <a name="next-steps"></a><span data-ttu-id="419bb-194">Következő lépések</span><span class="sxs-lookup"><span data-stu-id="419bb-194">Next steps</span></span>
<span data-ttu-id="419bb-195">Most, hogy megismerte az üzenetsorok alapjait, lásd: [alkalmazásokat, amelyek a Service Bus-üzenettémák és előfizetések](service-bus-create-topics-subscriptions.md) folytatja az ismertető a Service Bus-üzenettémák és előfizetések közzététel/előfizetés képességeivel.</span><span class="sxs-lookup"><span data-stu-id="419bb-195">Now that you've learned the basics of queues, see [Create applications that use Service Bus topics and subscriptions](service-bus-create-topics-subscriptions.md) to continue this discussion using the publish/subscribe capabilities of Service Bus topics and subscriptions.</span></span>

