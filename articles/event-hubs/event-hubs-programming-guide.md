---
title: "az Azure Event Hubs aaaProgramming útmutató |} Microsoft Docs"
description: "Az Azure Event Hubs hello Azure .NET SDK használatával írhat kódot."
services: event-hubs
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: 64cbfd3d-4a0e-4455-a90a-7f3d4f080323
ms.service: event-hubs
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: tbd
ms.date: 08/17/2017
ms.author: sethm
ms.openlocfilehash: 43bebd126c2311af9e3daeb52324132b66cf0884
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 10/06/2017
---
# <a name="event-hubs-programming-guide"></a><span data-ttu-id="d6398-103">Event Hubs programozási útmutató</span><span class="sxs-lookup"><span data-stu-id="d6398-103">Event Hubs programming guide</span></span>

<span data-ttu-id="d6398-104">A cikk ismerteti az Azure Event Hubs és hello Azure .NET SDK használatával programozás olyan gyakori forgatókönyveket tartalmaz.</span><span class="sxs-lookup"><span data-stu-id="d6398-104">This article discusses some common scenarios in writing code using Azure Event Hubs and hello Azure .NET SDK.</span></span> <span data-ttu-id="d6398-105">A témakör feltételezi az Event Hubs szolgáltatással kapcsolatos előzetes ismeretek meglétét.</span><span class="sxs-lookup"><span data-stu-id="d6398-105">It assumes a preliminary understanding of Event Hubs.</span></span> <span data-ttu-id="d6398-106">Az Event Hubs fogalmi áttekintése, lásd: hello [Event Hubs – áttekintés](event-hubs-what-is-event-hubs.md).</span><span class="sxs-lookup"><span data-stu-id="d6398-106">For a conceptual overview of Event Hubs, see hello [Event Hubs overview](event-hubs-what-is-event-hubs.md).</span></span>

## <a name="event-publishers"></a><span data-ttu-id="d6398-107">Esemény-közzétevők</span><span class="sxs-lookup"><span data-stu-id="d6398-107">Event publishers</span></span>

<span data-ttu-id="d6398-108">Események tooan eseményközpont vagy HTTP POST használatával vagy egy AMQP 1.0-kapcsolaton keresztül küld.</span><span class="sxs-lookup"><span data-stu-id="d6398-108">You send events tooan event hub either using HTTP POST or via an AMQP 1.0 connection.</span></span> <span data-ttu-id="d6398-109">mely toouse választott hello és mikor hello adott forgatókönyv határozza függ.</span><span class="sxs-lookup"><span data-stu-id="d6398-109">hello choice of which toouse and when depends on hello specific scenario being addressed.</span></span> <span data-ttu-id="d6398-110">Az AMQP 1.0-kapcsolatok mérése közvetített kapcsolatként történik a Service Bus szolgáltatásban, és az olyan forgatókönyvekben megfelelőbbek, ahol gyakoriak a nagyobb üzenetmennyiségek és alacsony késés szükséges, mivel ezek állandó üzenetkezelési csatornát biztosítanak.</span><span class="sxs-lookup"><span data-stu-id="d6398-110">AMQP 1.0 connections are metered as brokered connections in Service Bus and are more appropriate in scenarios with frequent higher message volumes and lower latency requirements, as they provide a persistent messaging channel.</span></span>

<span data-ttu-id="d6398-111">Létrehozásához és kezeléséhez az Event Hubs használatával hello [NamespaceManager][] osztály.</span><span class="sxs-lookup"><span data-stu-id="d6398-111">You create and manage Event Hubs using hello [NamespaceManager][] class.</span></span> <span data-ttu-id="d6398-112">Hello .NET felügyelt API-k, amikor elsődleges hello hoz létre az adatok tooEvent közzétételéhez hubok hello [EventHubClient](/dotnet/api/microsoft.servicebus.messaging.eventhubclient) és [EventData][] osztályok.</span><span class="sxs-lookup"><span data-stu-id="d6398-112">When using hello .NET managed APIs, hello primary constructs for publishing data tooEvent Hubs are hello [EventHubClient](/dotnet/api/microsoft.servicebus.messaging.eventhubclient) and [EventData][] classes.</span></span> <span data-ttu-id="d6398-113">[EventHubClient][] hello amelyben az események küldhetők toohello event hubs AMQP kommunikációs csatornát biztosít.</span><span class="sxs-lookup"><span data-stu-id="d6398-113">[EventHubClient][] provides hello AMQP communication channel over which events are sent toohello event hub.</span></span> <span data-ttu-id="d6398-114">Hello [EventData][] osztály egy eseményt képvisel, és használt toopublish üzenetek tooan eseményközpontot.</span><span class="sxs-lookup"><span data-stu-id="d6398-114">hello [EventData][] class represents an event, and is used toopublish messages tooan event hub.</span></span> <span data-ttu-id="d6398-115">Ez az osztály hello törzs, bizonyos metaadatait és fejléc-információit hello esemény tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="d6398-115">This class includes hello body, some metadata, and header information about hello event.</span></span> <span data-ttu-id="d6398-116">Egyéb tulajdonságokkal is bővül toohello [EventData][] objektumot, ahogy keresztülhalad az eseményközpontban.</span><span class="sxs-lookup"><span data-stu-id="d6398-116">Other properties are added toohello [EventData][] object as it passes through an event hub.</span></span>

## <a name="get-started"></a><span data-ttu-id="d6398-117">Bevezetés</span><span class="sxs-lookup"><span data-stu-id="d6398-117">Get started</span></span>

<span data-ttu-id="d6398-118">amely támogatja az Event Hubs hello .NET-osztályok a Microsoft.ServiceBus.dll szerelvényben hello szerepelnek.</span><span class="sxs-lookup"><span data-stu-id="d6398-118">hello .NET classes that support Event Hubs are provided in hello Microsoft.ServiceBus.dll assembly.</span></span> <span data-ttu-id="d6398-119">Ennek legegyszerűbb módja tooreference hello Service Bus API és tooconfigure hello az alkalmazás az összes Service Bus-függőséggel hello toodownload hello [Service Bus NuGet-csomag](https://www.nuget.org/packages/WindowsAzure.ServiceBus).</span><span class="sxs-lookup"><span data-stu-id="d6398-119">hello easiest way tooreference hello Service Bus API and tooconfigure your application with all of hello Service Bus dependencies is toodownload hello [Service Bus NuGet package](https://www.nuget.org/packages/WindowsAzure.ServiceBus).</span></span> <span data-ttu-id="d6398-120">Másik lehetőségként használhatja a hello [Csomagkezelő konzol](http://docs.nuget.org/docs/start-here/using-the-package-manager-console) a Visual Studióban.</span><span class="sxs-lookup"><span data-stu-id="d6398-120">Alternatively, you can use hello [Package Manager Console](http://docs.nuget.org/docs/start-here/using-the-package-manager-console) in Visual Studio.</span></span> <span data-ttu-id="d6398-121">toodo tehát adja ki a következő parancs a hello hello [Csomagkezelő konzol](http://docs.nuget.org/docs/start-here/using-the-package-manager-console) ablakban:</span><span class="sxs-lookup"><span data-stu-id="d6398-121">toodo so, issue hello following command in hello [Package Manager Console](http://docs.nuget.org/docs/start-here/using-the-package-manager-console) window:</span></span>

```
Install-Package WindowsAzure.ServiceBus
```

## <a name="create-an-event-hub"></a><span data-ttu-id="d6398-122">Eseményközpont létrehozása</span><span class="sxs-lookup"><span data-stu-id="d6398-122">Create an event hub</span></span>
<span data-ttu-id="d6398-123">Használhatja a hello [NamespaceManager][] toocreate Event Hubs osztályban.</span><span class="sxs-lookup"><span data-stu-id="d6398-123">You can use hello [NamespaceManager][] class toocreate Event Hubs.</span></span> <span data-ttu-id="d6398-124">Példa:</span><span class="sxs-lookup"><span data-stu-id="d6398-124">For example:</span></span>

```csharp
var manager = new Microsoft.ServiceBus.NamespaceManager("mynamespace.servicebus.windows.net");
var description = manager.CreateEventHub("MyEventHub");
```

<span data-ttu-id="d6398-125">A legtöbb esetben ajánlott, hogy használja-e hello [CreateEventHubIfNotExists][] módszerek tooavoid kivételek generálása, ha hello szolgáltatás újraindul.</span><span class="sxs-lookup"><span data-stu-id="d6398-125">In most cases, it is recommended that you use hello [CreateEventHubIfNotExists][] methods tooavoid generating exceptions if hello service restarts.</span></span> <span data-ttu-id="d6398-126">Példa:</span><span class="sxs-lookup"><span data-stu-id="d6398-126">For example:</span></span>

```csharp
var description = manager.CreateEventHubIfNotExists("MyEventHub");
```

<span data-ttu-id="d6398-127">Minden Event Hubs létrehozási művelet, beleértve a [CreateEventHubIfNotExists][], szükséges **kezelése** hello névtérben engedélyeit.</span><span class="sxs-lookup"><span data-stu-id="d6398-127">All Event Hubs creation operations, including [CreateEventHubIfNotExists][], require **Manage** permissions on hello namespace in question.</span></span> <span data-ttu-id="d6398-128">Ha azt szeretné, hogy a közzétevő vagy felhasználó alkalmazások toolimit hello engedélyeit, elkerülheti ezeket létrehozásiművelet-hívásokat az éles kódban hitelesítő adatok korlátozott engedélyekkel való használatakor.</span><span class="sxs-lookup"><span data-stu-id="d6398-128">If you want toolimit hello permissions of your publisher or consumer applications, you can avoid these create operation calls in production code when you use credentials with limited permissions.</span></span>

<span data-ttu-id="d6398-129">Hello [EventHubDescription](/dotnet/api/microsoft.servicebus.messaging.eventhubdescription) osztály tartalmazza az eseményközpontban, beleértve a hello engedélyezési szabályokat, hello üzenetek megőrzési idejét, partíciók azonosítóit, állapota és az elérési utat.</span><span class="sxs-lookup"><span data-stu-id="d6398-129">hello [EventHubDescription](/dotnet/api/microsoft.servicebus.messaging.eventhubdescription) class contains details about an event hub, including hello authorization rules, hello message retention interval, partition IDs, status, and path.</span></span> <span data-ttu-id="d6398-130">Ez az osztály tooupdate hello metaadatok eseményközpontban is használhatja.</span><span class="sxs-lookup"><span data-stu-id="d6398-130">You can use this class tooupdate hello metadata on an event hub.</span></span>

## <a name="create-an-event-hubs-client"></a><span data-ttu-id="d6398-131">Event Hubs-ügyfél létrehozása</span><span class="sxs-lookup"><span data-stu-id="d6398-131">Create an Event Hubs client</span></span>
<span data-ttu-id="d6398-132">hello az elsődleges osztály az Event Hubs kommunikáció [Microsoft.ServiceBus.Messaging.EventHubClient][EventHubClient].</span><span class="sxs-lookup"><span data-stu-id="d6398-132">hello primary class for interacting with Event Hubs is [Microsoft.ServiceBus.Messaging.EventHubClient][EventHubClient].</span></span> <span data-ttu-id="d6398-133">Ez az osztály küldői és fogadói képességeket is biztosít.</span><span class="sxs-lookup"><span data-stu-id="d6398-133">This class provides both sender and receiver capabilities.</span></span> <span data-ttu-id="d6398-134">Ez az osztály hello használatával példányosítható [létrehozása](/dotnet/api/microsoft.servicebus.messaging.eventhubclient.create) módszer, ahogy az alábbi példa hello.</span><span class="sxs-lookup"><span data-stu-id="d6398-134">You can instantiate this class using hello [Create](/dotnet/api/microsoft.servicebus.messaging.eventhubclient.create) method, as shown in hello following example.</span></span>

```csharp
var client = EventHubClient.Create(description.Path);
```

<span data-ttu-id="d6398-135">Ez a módszer hello Service Bus kapcsolati információit használja hello App.config fájlban, hello `appSettings` szakasz.</span><span class="sxs-lookup"><span data-stu-id="d6398-135">This method uses hello Service Bus connection information in hello App.config file, in hello `appSettings` section.</span></span> <span data-ttu-id="d6398-136">Hello példát `appSettings` XML toostore hello Service Bus kapcsolati információit használja, hello hello dokumentációjában [Microsoft.ServiceBus.Messaging.EventHubClient.Create(System.String)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Create_System_String_) metódust.</span><span class="sxs-lookup"><span data-stu-id="d6398-136">For an example of hello `appSettings` XML used toostore hello Service Bus connection information, see hello documentation for hello [Microsoft.ServiceBus.Messaging.EventHubClient.Create(System.String)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Create_System_String_) method.</span></span>

<span data-ttu-id="d6398-137">Másik lehetőség is toocreate hello ügyfél egy kapcsolati karakterláncból.</span><span class="sxs-lookup"><span data-stu-id="d6398-137">Another option is toocreate hello client from a connection string.</span></span> <span data-ttu-id="d6398-138">Ez a beállítás jól működik, ha Azure feldolgozói szerepköröket használ mert hello konfigurációs tulajdonságok hello dolgozó hello karakterláncot tárolhatja.</span><span class="sxs-lookup"><span data-stu-id="d6398-138">This option works well when using Azure worker roles, because you can store hello string in hello configuration properties for hello worker.</span></span> <span data-ttu-id="d6398-139">Példa:</span><span class="sxs-lookup"><span data-stu-id="d6398-139">For example:</span></span>

```csharp
EventHubClient.CreateFromConnectionString("your_connection_string");
```

<span data-ttu-id="d6398-140">hello kapcsolati karakterlánc formátuma azonos hello korábbi metódusok App.config fájlt hello megjelenő hello lehet:</span><span class="sxs-lookup"><span data-stu-id="d6398-140">hello connection string will be in hello same format as it appears in hello App.config file for hello previous methods:</span></span>

```
Endpoint=sb://[namespace].servicebus.windows.net/;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=[key]
```

<span data-ttu-id="d6398-141">Végezetül fontos is lehetséges toocreate egy [EventHubClient][] objektum egy [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) példány, ahogy az alábbi példa hello.</span><span class="sxs-lookup"><span data-stu-id="d6398-141">Finally, it is also possible toocreate an [EventHubClient][] object from a [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) instance, as shown in hello following example.</span></span>

```csharp
var factory = MessagingFactory.CreateFromConnectionString("your_connection_string");
var client = factory.CreateEventHubClient("MyEventHub");
```

<span data-ttu-id="d6398-142">Fontos, hogy további toonote [EventHubClient][] egy üzenetkezelési gyár példányából létrehozott objektumokat szeretné újrafelhasználni hello ugyanazt az alapul szolgáló TCP-kapcsolatot.</span><span class="sxs-lookup"><span data-stu-id="d6398-142">It is important toonote that additional [EventHubClient][] objects created from a messaging factory instance will reuse hello same underlying TCP connection.</span></span> <span data-ttu-id="d6398-143">Ezért ezek az objektumok ügyféloldali korláttal rendelkeznek majd az átvitelre vonatkozóan.</span><span class="sxs-lookup"><span data-stu-id="d6398-143">Therefore, these objects have a client-side limit on throughput.</span></span> <span data-ttu-id="d6398-144">Hello [létrehozása](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Create_System_String_) metódus újból felhasználja az üzenetkezelési gyárat.</span><span class="sxs-lookup"><span data-stu-id="d6398-144">hello [Create](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Create_System_String_) method reuses a single messaging factory.</span></span> <span data-ttu-id="d6398-145">Amennyiben nagyon nagy átviteli kapacitás szükséges egyetlen küldőtől, létrehozhat több üzenetkezelési gyárat, illetve egy [EventHubClient][] objektumot mindegyik üzenetkezelési gyárból.</span><span class="sxs-lookup"><span data-stu-id="d6398-145">If you need very high throughput from a single sender, then you can create multiple message factories and one [EventHubClient][] object from each messaging factory.</span></span>

## <a name="send-events-tooan-event-hub"></a><span data-ttu-id="d6398-146">Események tooan eseményközpont küldése</span><span class="sxs-lookup"><span data-stu-id="d6398-146">Send events tooan event hub</span></span>
<span data-ttu-id="d6398-147">Küldött események tooan eseményközpont hozzon létre egy [EventData][] példányt, és küldje el azt keresztül hello [küldése](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_) metódust.</span><span class="sxs-lookup"><span data-stu-id="d6398-147">You send events tooan event hub by creating an [EventData][] instance and sending it via hello [Send](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_) method.</span></span> <span data-ttu-id="d6398-148">Ez a metódus egyetlen veszi [EventData][] példányparamétert és szinkron módon elküldi azt tooan eseményközpontot.</span><span class="sxs-lookup"><span data-stu-id="d6398-148">This method takes a single [EventData][] instance parameter and synchronously sends it tooan event hub.</span></span>

## <a name="event-serialization"></a><span data-ttu-id="d6398-149">Eseményszerializáció</span><span class="sxs-lookup"><span data-stu-id="d6398-149">Event serialization</span></span>
<span data-ttu-id="d6398-150">Hello [EventData][] osztályt [négy túlterhelt konstruktorral](/dotnet/api/microsoft.servicebus.messaging.eventdata#constructors_) , amely számos paraméter, például egy objektumot és szerializálót, egy bájttömböt vagy adatfolyam igénybe vehet.</span><span class="sxs-lookup"><span data-stu-id="d6398-150">hello [EventData][] class has [four overloaded constructors](/dotnet/api/microsoft.servicebus.messaging.eventdata#constructors_) that take a variety of parameters, such as an object and serializer, a byte array, or a stream.</span></span> <span data-ttu-id="d6398-151">Az is lehetséges tooinstantiate hello [EventData][] osztály, és állítsa be ezt követően hello törzs adatfolyam.</span><span class="sxs-lookup"><span data-stu-id="d6398-151">It is also possible tooinstantiate hello [EventData][] class and set hello body stream afterwards.</span></span> <span data-ttu-id="d6398-152">Amikor a JSON-t használ [EventData][], használhat **Encoding.UTF8.GetBytes()** tooretrieve hello bájttömböt a JSON-kódolású karakterlánc.</span><span class="sxs-lookup"><span data-stu-id="d6398-152">When using JSON with [EventData][], you can use **Encoding.UTF8.GetBytes()** tooretrieve hello byte array for a JSON-encoded string.</span></span>

## <a name="partition-key"></a><span data-ttu-id="d6398-153">Partíciókulcs</span><span class="sxs-lookup"><span data-stu-id="d6398-153">Partition key</span></span>
<span data-ttu-id="d6398-154">Hello [EventData][] osztály rendelkezik egy [PartitionKey][] tulajdonság, amely lehetővé teszi a hello küldő toospecify egy értéket, amely kivonatolt tooproduce egy partíció-hozzárendelés.</span><span class="sxs-lookup"><span data-stu-id="d6398-154">hello [EventData][] class has a [PartitionKey][] property that enables hello sender toospecify a value that is hashed tooproduce a partition assignment.</span></span> <span data-ttu-id="d6398-155">A partíciókulcsok használatával biztosítja, hogy az összes hello események ugyanazzal a kulccsal küldött hello toohello azonos hello eseményközpont partíciójához.</span><span class="sxs-lookup"><span data-stu-id="d6398-155">Using a partition key ensures that all hello events with hello same key are sent toohello same partition in hello event hub.</span></span> <span data-ttu-id="d6398-156">Az általános partíciókulcsok többek közt a felhasználói munkamenetek azonosítói és az egyedi küldőazonosítók.</span><span class="sxs-lookup"><span data-stu-id="d6398-156">Common partition keys include user session IDs and unique sender IDs.</span></span> <span data-ttu-id="d6398-157">Hello [PartitionKey][] tulajdonság megadása nem kötelező, és megadható a hello használatakor [Microsoft.ServiceBus.Messaging.EventHubClient.Send(Microsoft.ServiceBus.Messaging.EventData)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_) vagy [Microsoft.ServiceBus.Messaging.EventHubClient.SendAsync(Microsoft.ServiceBus.Messaging.EventData)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendAsync_Microsoft_ServiceBus_Messaging_EventData_) módszerek.</span><span class="sxs-lookup"><span data-stu-id="d6398-157">hello [PartitionKey][] property is optional and can be provided when using hello [Microsoft.ServiceBus.Messaging.EventHubClient.Send(Microsoft.ServiceBus.Messaging.EventData)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_) or [Microsoft.ServiceBus.Messaging.EventHubClient.SendAsync(Microsoft.ServiceBus.Messaging.EventData)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendAsync_Microsoft_ServiceBus_Messaging_EventData_) methods.</span></span> <span data-ttu-id="d6398-158">Ha nem ad meg értéket [PartitionKey][], küldött események olyan elosztott toopartitions egy Ciklikus időszeleteléses modell használatával.</span><span class="sxs-lookup"><span data-stu-id="d6398-158">If you do not provide a value for [PartitionKey][], sent events are distributed toopartitions using a round-robin model.</span></span>

### <a name="availability-considerations"></a><span data-ttu-id="d6398-159">Rendelkezésre állási szempontok</span><span class="sxs-lookup"><span data-stu-id="d6398-159">Availability considerations</span></span>

<span data-ttu-id="d6398-160">A partíciós kulcs használata nem kötelező, és gondosan érdemes-e egy toouse.</span><span class="sxs-lookup"><span data-stu-id="d6398-160">Using a partition key is optional, and you should consider carefully whether or not toouse one.</span></span> <span data-ttu-id="d6398-161">Sok esetben a partíciókulcsok használatával akkor hasznos, ha fontos esemény rendezés.</span><span class="sxs-lookup"><span data-stu-id="d6398-161">In many cases, using a partition key is a good choice if event ordering is important.</span></span> <span data-ttu-id="d6398-162">A partíciós kulcs használata esetén ezek a partíciók egycsomópontos rendelkezésre szükség, és kiesések is időbeli; például, ha a számítási csomópontok újraindítás és a javítás.</span><span class="sxs-lookup"><span data-stu-id="d6398-162">When you use a partition key, these partitions require availability on a single node, and outages can occur over time; for example, when compute nodes reboot and patch.</span></span> <span data-ttu-id="d6398-163">Ha el a Partícióazonosító és adott partíció valamilyen okból kifolyólag nem érhető el, egy kísérlet tooaccess hello adatok partícióban sikertelen lesz.</span><span class="sxs-lookup"><span data-stu-id="d6398-163">As such, if you set a partition ID and that partition becomes unavailable for some reason, an attempt tooaccess hello data in that partition will fail.</span></span> <span data-ttu-id="d6398-164">Ha magas rendelkezésre állású legfontosabb, nem ad meg partíciókulcsot; Ebben az esetben eseményeket a rendszer küld toopartitions a fentiekben ismertetett hello Ciklikus időszeleteléses modell használatával.</span><span class="sxs-lookup"><span data-stu-id="d6398-164">If high availability is most important, do not specify a partition key; in that case events will be sent toopartitions using hello round-robin model described previously.</span></span> <span data-ttu-id="d6398-165">Ebben a forgatókönyvben teszi rendelkezésre állási (nincs Partícióazonosító) és a konzisztencia (rögzítési események tooa Partícióazonosító) között kifejezett választást.</span><span class="sxs-lookup"><span data-stu-id="d6398-165">In this scenario, you are making an explicit choice between availability (no partition ID) and consistency (pinning events tooa partition ID).</span></span>

<span data-ttu-id="d6398-166">Egy másik szempont kezeli a késlelteti az események feldolgozásával.</span><span class="sxs-lookup"><span data-stu-id="d6398-166">Another consideration is handling delays in processing events.</span></span> <span data-ttu-id="d6398-167">Bizonyos esetekben az lehet, hogy jobb toodrop adatokat, és próbálja megismételni mint tootry és tartani a feldolgozás, amely további alárendelt feldolgozási késedelmeket okozhat.</span><span class="sxs-lookup"><span data-stu-id="d6398-167">In some cases it might be better toodrop data and retry than tootry and keep up with processing, which can potentially cause further downstream processing delays.</span></span> <span data-ttu-id="d6398-168">Például a tőzsdei árfolyamjelző jobb toowait teljes legfrissebb adatokat, de egy élő vagy gyors, hello adatokat ahelyett, hogy kellene VOIP a forgatókönyv akkor is, ha nem, akkor a teljes.</span><span class="sxs-lookup"><span data-stu-id="d6398-168">For example, with a stock ticker it's better toowait for complete up-to-date data, but in a live chat or VOIP scenario you'd rather have hello data quickly, even if it isn't complete.</span></span>

<span data-ttu-id="d6398-169">A rendelkezésre állási lehetőségekért megadott forgatókönyvekben választása hello következő hibakezelés stratégiák egyikét:</span><span class="sxs-lookup"><span data-stu-id="d6398-169">Given these availability considerations, in these scenarios you might choose one of hello following error handling strategies:</span></span>

- <span data-ttu-id="d6398-170">Leállítás (olvasásakor az Event Hubs dolgot megoldásáig leállítás)</span><span class="sxs-lookup"><span data-stu-id="d6398-170">Stop (stop reading from Event Hubs until things are fixed)</span></span>
- <span data-ttu-id="d6398-171">Közvetlen (üzenetek nem fontos, dobja el őket)</span><span class="sxs-lookup"><span data-stu-id="d6398-171">Drop (messages aren’t important, drop them)</span></span>
- <span data-ttu-id="d6398-172">Ismételje meg a (újrapróbálkozási hello üzenetek ismertető fér el)</span><span class="sxs-lookup"><span data-stu-id="d6398-172">Retry (retry hello messages as you see fit)</span></span>
- <span data-ttu-id="d6398-173">[Kézbesítetlen levelek](../service-bus-messaging/service-bus-dead-letter-queues.md) (használja a várólistára vagy egy másik event hub toodead betűs csak hello üzenetek nem tudta feldolgozni)</span><span class="sxs-lookup"><span data-stu-id="d6398-173">[Dead letter](../service-bus-messaging/service-bus-dead-letter-queues.md) (use a queue or another event hub toodead letter only hello messages you couldn’t process)</span></span>

<span data-ttu-id="d6398-174">További információt és kapcsolatos hello kompromisszumot között rendelkezésre állás és a konzisztencia döntéseken: [rendelkezésre állását és az Event Hubs következetes](event-hubs-availability-and-consistency.md).</span><span class="sxs-lookup"><span data-stu-id="d6398-174">For more information and a discussion about hello trade-offs between availability and consistency, see [Availability and consistency in Event Hubs](event-hubs-availability-and-consistency.md).</span></span> 

## <a name="batch-event-send-operations"></a><span data-ttu-id="d6398-175">Kötegelt eseményküldési műveletek</span><span class="sxs-lookup"><span data-stu-id="d6398-175">Batch event send operations</span></span>
<span data-ttu-id="d6398-176">Az események kötegekben való küldésével jelentősen növelhető az átvitel.</span><span class="sxs-lookup"><span data-stu-id="d6398-176">Sending events in batches can dramatically increase throughput.</span></span> <span data-ttu-id="d6398-177">Hello [SendBatch](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendBatch_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_EventData__) metódus egy **IEnumerable** típusú paramétert [EventData][] és küld hello atomi művelet toohello eseményközpontban, egész köteget.</span><span class="sxs-lookup"><span data-stu-id="d6398-177">hello [SendBatch](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendBatch_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_EventData__) method takes an **IEnumerable** parameter of type [EventData][] and sends hello entire batch as an atomic operation toohello event hub.</span></span>

```csharp
public void SendBatch(IEnumerable<EventData> eventDataList);
```

<span data-ttu-id="d6398-178">Vegye figyelembe, hogy a kötegek nem haladhatja meg az esemény hello 256 KB-os korlátját.</span><span class="sxs-lookup"><span data-stu-id="d6398-178">Note that a single batch must not exceed hello 256 KB limit of an event.</span></span> <span data-ttu-id="d6398-179">Emellett a hello kötegben lévő egyes üzenetek hello használ ugyanazzal a közzétevői identitással.</span><span class="sxs-lookup"><span data-stu-id="d6398-179">Additionally, each message in hello batch uses hello same publisher identity.</span></span> <span data-ttu-id="d6398-180">Hello felelőssége, hogy a kötegelt hello hello küldő tooensure nem haladja meg a maximális eseményméret hello.</span><span class="sxs-lookup"><span data-stu-id="d6398-180">It is hello responsibility of hello sender tooensure that hello batch does not exceed hello maximum event size.</span></span> <span data-ttu-id="d6398-181">Ha mégis meghaladja, az ügyfél **Küldési** hibát jelez.</span><span class="sxs-lookup"><span data-stu-id="d6398-181">If it does, a client **Send** error is generated.</span></span>

## <a name="send-asynchronously-and-send-at-scale"></a><span data-ttu-id="d6398-182">Aszinkron küldés és nagy léptékű küldés</span><span class="sxs-lookup"><span data-stu-id="d6398-182">Send asynchronously and send at scale</span></span>
<span data-ttu-id="d6398-183">Események tooan eseményközpont aszinkron módon is küldhet.</span><span class="sxs-lookup"><span data-stu-id="d6398-183">You can also send events tooan event hub asynchronously.</span></span> <span data-ttu-id="d6398-184">Aszinkron küldés növelheti a hello sebesség, amellyel az ügyfél akkor tudja toosend események.</span><span class="sxs-lookup"><span data-stu-id="d6398-184">Sending asynchronously can increase hello rate at which a client is able toosend events.</span></span> <span data-ttu-id="d6398-185">Mindkét hello [küldése](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_) és [SendBatch](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendBatch_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_EventData__) metódus egyaránt elérhetők aszinkron verzióban, amely vissza egy [feladat](https://msdn.microsoft.com/library/system.threading.tasks.task.aspx) objektum.</span><span class="sxs-lookup"><span data-stu-id="d6398-185">Both hello [Send](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_) and [SendBatch](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendBatch_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_EventData__) methods are available in asynchronous versions that return a [Task](https://msdn.microsoft.com/library/system.threading.tasks.task.aspx) object.</span></span> <span data-ttu-id="d6398-186">Ezzel a technikával növelhető az átvitel, amíg azt is eredményezheti, hogy hello ügyfél toocontinue toosend események hello Event Hubs szolgáltatás leszabályozta, és a hello ügyfél hibába ütközhet, vagy üzenetek veszhetnek eredményezhet közben is ha nem megfelelően megvalósított.</span><span class="sxs-lookup"><span data-stu-id="d6398-186">While this technique can increase throughput, it can also cause hello client toocontinue toosend events even while it is being throttled by hello Event Hubs service and can result in hello client experiencing failures or lost messages if not properly implemented.</span></span> <span data-ttu-id="d6398-187">Ezenkívül használhatja a hello [RetryPolicy](/dotnet/api/microsoft.servicebus.messaging.cliententity#Microsoft_ServiceBus_Messaging_ClientEntity_RetryPolicy) hello toocontrol ügyfél újrapróbálkozási beállításainak tulajdonságát.</span><span class="sxs-lookup"><span data-stu-id="d6398-187">In addition, you can use hello [RetryPolicy](/dotnet/api/microsoft.servicebus.messaging.cliententity#Microsoft_ServiceBus_Messaging_ClientEntity_RetryPolicy) property on hello client toocontrol client retry options.</span></span>

## <a name="create-a-partition-sender"></a><span data-ttu-id="d6398-188">Partícióküldő létrehozása</span><span class="sxs-lookup"><span data-stu-id="d6398-188">Create a partition sender</span></span>
<span data-ttu-id="d6398-189">Bár a leggyakrabban használt toosend események tooan event hubs nem tartozik partíciós kulcs, bizonyos esetekben érdemes lehet toosend események közvetlenül az adott partíció tooa.</span><span class="sxs-lookup"><span data-stu-id="d6398-189">Although it is most common toosend events tooan event hub without a partition key, in some cases you might want toosend events directly tooa given partition.</span></span> <span data-ttu-id="d6398-190">Példa:</span><span class="sxs-lookup"><span data-stu-id="d6398-190">For example:</span></span>

```csharp
var partitionedSender = client.CreatePartitionedSender(description.PartitionIds[0]);
```

<span data-ttu-id="d6398-191">[CreatePartitionedSender](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_CreatePartitionedSender_System_String_) adja vissza egy [EventHubSender](/dotnet/api/microsoft.servicebus.messaging.eventhubsender) toopublish események tooa adott event hub partíció használt objektum.</span><span class="sxs-lookup"><span data-stu-id="d6398-191">[CreatePartitionedSender](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_CreatePartitionedSender_System_String_) returns an [EventHubSender](/dotnet/api/microsoft.servicebus.messaging.eventhubsender) object that you can use toopublish events tooa specific event hub partition.</span></span>

## <a name="event-consumers"></a><span data-ttu-id="d6398-192">Eseményfelhasználók</span><span class="sxs-lookup"><span data-stu-id="d6398-192">Event consumers</span></span>
<span data-ttu-id="d6398-193">Az Event Hubs két elsődleges modellel rendelkezik az események felhasználásához: közvetlen fogadók és a magasabb szintű absztrakciók, például az [EventProcessorHost][].</span><span class="sxs-lookup"><span data-stu-id="d6398-193">Event Hubs has two primary models for event consumption: direct receivers and higher-level abstractions, such as [EventProcessorHost][].</span></span> <span data-ttu-id="d6398-194">Közvetlen fogadók felelőssége saját hozzáférés toopartitions egy fogyasztói csoporton belül összehangolását.</span><span class="sxs-lookup"><span data-stu-id="d6398-194">Direct receivers are responsible for their own coordination of access toopartitions within a consumer group.</span></span>

### <a name="direct-consumer"></a><span data-ttu-id="d6398-195">Közvetlen felhasználó</span><span class="sxs-lookup"><span data-stu-id="d6398-195">Direct consumer</span></span>
<span data-ttu-id="d6398-196">hello legközvetlenebb módja tooread egy partícióról egy fogyasztói csoporton belül toouse hello [EventHubReceiver](/dotnet/apie/microsoft.servicebus.messaging.eventhubreceiver) osztály.</span><span class="sxs-lookup"><span data-stu-id="d6398-196">hello most direct way tooread from a partition within a consumer group is toouse hello [EventHubReceiver](/dotnet/apie/microsoft.servicebus.messaging.eventhubreceiver) class.</span></span> <span data-ttu-id="d6398-197">Ez az osztály példánya egy toocreate, használnia kell hello példányának [EventHubConsumerGroup](/dotnet/api/microsoft.servicebus.messaging.eventhubconsumergroup) osztály.</span><span class="sxs-lookup"><span data-stu-id="d6398-197">toocreate an instance of this class, you must use an instance of hello [EventHubConsumerGroup](/dotnet/api/microsoft.servicebus.messaging.eventhubconsumergroup) class.</span></span> <span data-ttu-id="d6398-198">A következő példa hello hello Partícióazonosító kötelező hello hello felhasználói csoport fogadójának létrehozásakor.</span><span class="sxs-lookup"><span data-stu-id="d6398-198">In hello following example, hello partition ID must be specified when creating hello receiver for hello consumer group.</span></span>

```csharp
EventHubConsumerGroup group = client.GetDefaultConsumerGroup();
var receiver = group.CreateReceiver(client.GetRuntimeInformation().PartitionIds[0]);
```

<span data-ttu-id="d6398-199">Hello [CreateReceiver](/dotnet/api/microsoft.servicebus.messaging.eventhubconsumergroup#methods_summary) metódus több túlterheléssel rendelkezik, amelyek megkönnyítése hello olvasó vezérlését.</span><span class="sxs-lookup"><span data-stu-id="d6398-199">hello [CreateReceiver](/dotnet/api/microsoft.servicebus.messaging.eventhubconsumergroup#methods_summary) method has several overloads that facilitate control over hello reader being created.</span></span> <span data-ttu-id="d6398-200">Ezek a metódusok lehetnek egy eltolás megadása karakterlánc vagy időbélyeg, és hello toospecify képességét, hogy tooinclude a megadott eltolás a hello adatfolyam, vagy azt követően indítsa el.</span><span class="sxs-lookup"><span data-stu-id="d6398-200">These methods include specifying an offset as either a string or timestamp, and hello ability toospecify whether tooinclude this specified offset in hello returned stream, or start after it.</span></span> <span data-ttu-id="d6398-201">Hello fogadó létrehozása után megkezdheti az eseményeket a hello objektumot adott vissza.</span><span class="sxs-lookup"><span data-stu-id="d6398-201">After you create hello receiver, you can start receiving events on hello returned object.</span></span> <span data-ttu-id="d6398-202">Hello [Receive](/dotnet/api/microsoft.servicebus.messaging.eventhubreceiver#methods_summary) metódus négy túlterheléssel rendelkezik, hogy a vezérlő hello fogadási művelet paramétereit, például a kötegméretet és a várakozási időt.</span><span class="sxs-lookup"><span data-stu-id="d6398-202">hello [Receive](/dotnet/api/microsoft.servicebus.messaging.eventhubreceiver#methods_summary) method has four overloads that control hello receive operation parameters, such as batch size and wait time.</span></span> <span data-ttu-id="d6398-203">Használhat ezen módszerek tooincrease hello átviteli felhasználóinak aszinkron verzióinak hello.</span><span class="sxs-lookup"><span data-stu-id="d6398-203">You can use hello asynchronous versions of these methods tooincrease hello throughput of a consumer.</span></span> <span data-ttu-id="d6398-204">Példa:</span><span class="sxs-lookup"><span data-stu-id="d6398-204">For example:</span></span>

```csharp
bool receive = true;
string myOffset;
while(receive)
{
    var message = receiver.Receive();
    myOffset = message.Offset;
    string body = Encoding.UTF8.GetString(message.GetBytes());
    Console.WriteLine(String.Format("Received message offset: {0} \nbody: {1}", myOffset, body));
}
```

<span data-ttu-id="d6398-205">A tekintetben tooa adott partíciók hello üzenetek fogadása hello ahhoz, amelyben toohello eseményközpontba lettek küldve.</span><span class="sxs-lookup"><span data-stu-id="d6398-205">With respect tooa specific partition, hello messages are received in hello order in which they were sent toohello event hub.</span></span> <span data-ttu-id="d6398-206">hello eltolás egy karakterlánc-token használt tooidentify partícióra üzenet.</span><span class="sxs-lookup"><span data-stu-id="d6398-206">hello offset is a string token used tooidentify a message in a partition.</span></span>

<span data-ttu-id="d6398-207">Vegye figyelembe, hogy egy felhasználói csoportban egy adott partíció egy adott pillanatban nem rendelkezhet 5-nél több egyidejű olvasóval.</span><span class="sxs-lookup"><span data-stu-id="d6398-207">Note that a single partition within a consumer group cannot have more than 5 concurrent readers connected at any time.</span></span> <span data-ttu-id="d6398-208">Mivel az olvasók csatlakoznak vagy lecsatlakoznak, a munkamenetek aktívak maradhatnak hello szolgáltatás észleli, hogy lecsatlakoztak több percig.</span><span class="sxs-lookup"><span data-stu-id="d6398-208">As readers connect or become disconnected, their sessions might stay active for several minutes before hello service recognizes that they have disconnected.</span></span> <span data-ttu-id="d6398-209">Ebben az időszakban tooa partíció újracsatlakozás meghiúsulhat.</span><span class="sxs-lookup"><span data-stu-id="d6398-209">During this time, reconnecting tooa partition may fail.</span></span> <span data-ttu-id="d6398-210">Átfogó példát írása a közvetlen fogadóknak az Event Hubs számára, lásd: hello [Event Hubs közvetlen fogadók](https://code.msdn.microsoft.com/Event-Hub-Direct-Receivers-13fa95c6) minta.</span><span class="sxs-lookup"><span data-stu-id="d6398-210">For a complete example of writing a direct receiver for Event Hubs, see hello [Event Hubs Direct Receivers](https://code.msdn.microsoft.com/Event-Hub-Direct-Receivers-13fa95c6) sample.</span></span>

### <a name="event-processor-host"></a><span data-ttu-id="d6398-211">Event Processor Host</span><span class="sxs-lookup"><span data-stu-id="d6398-211">Event processor host</span></span>
<span data-ttu-id="d6398-212">Hello [EventProcessorHost][] osztály Eseményközpontokból származó adatokat dolgozza fel.</span><span class="sxs-lookup"><span data-stu-id="d6398-212">hello [EventProcessorHost][] class processes data from Event Hubs.</span></span> <span data-ttu-id="d6398-213">Ez a megvalósítás kell használni, amikor hello .NET platformon hoz létre eseményolvasókat.</span><span class="sxs-lookup"><span data-stu-id="d6398-213">You should use this implementation when building event readers on hello .NET platform.</span></span> <span data-ttu-id="d6398-214">Az [EventProcessorHost][] egy szálbiztos, több folyamatot lehetővé tevő, biztonságos futtatókörnyezetet biztosít az eseményfeldolgozói megvalósításokhoz, ami lehetővé teszi az ellenőrzőpontok használatát és a partícióbérlés-kezelést is.</span><span class="sxs-lookup"><span data-stu-id="d6398-214">[EventProcessorHost][] provides a thread-safe, multi-process, safe runtime environment for event processor implementations that also provides checkpointing and partition lease management.</span></span>

<span data-ttu-id="d6398-215">toouse hello [EventProcessorHost][] osztály, Megvalósíthat [IEventProcessor](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor).</span><span class="sxs-lookup"><span data-stu-id="d6398-215">toouse hello [EventProcessorHost][] class, you can implement [IEventProcessor](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor).</span></span> <span data-ttu-id="d6398-216">Ez a felület három metódust tartalmaz:</span><span class="sxs-lookup"><span data-stu-id="d6398-216">This interface contains three methods:</span></span>

* [<span data-ttu-id="d6398-217">OpenAsync</span><span class="sxs-lookup"><span data-stu-id="d6398-217">OpenAsync</span></span>](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor#Microsoft_ServiceBus_Messaging_IEventProcessor_OpenAsync_Microsoft_ServiceBus_Messaging_PartitionContext_)
* [<span data-ttu-id="d6398-218">CloseAsync</span><span class="sxs-lookup"><span data-stu-id="d6398-218">CloseAsync</span></span>](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor#Microsoft_ServiceBus_Messaging_IEventProcessor_CloseAsync_Microsoft_ServiceBus_Messaging_PartitionContext_Microsoft_ServiceBus_Messaging_CloseReason_)
* [<span data-ttu-id="d6398-219">ProcessEventsAsync</span><span class="sxs-lookup"><span data-stu-id="d6398-219">ProcessEventsAsync</span></span>](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor#Microsoft_ServiceBus_Messaging_IEventProcessor_ProcessEventsAsync_Microsoft_ServiceBus_Messaging_PartitionContext_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_EventData__)

<span data-ttu-id="d6398-220">toostart Eseményfeldolgozási, példányosítható [EventProcessorHost][], az eseményközpont hello megfelelő paraméterek megadása.</span><span class="sxs-lookup"><span data-stu-id="d6398-220">toostart event processing, instantiate [EventProcessorHost][], providing hello appropriate parameters for your event hub.</span></span> <span data-ttu-id="d6398-221">Majd, meghívják [RegisterEventProcessorAsync](/dotnet/api/microsoft.servicebus.messaging.eventprocessorhost#Microsoft_ServiceBus_Messaging_EventProcessorHost_RegisterEventProcessorAsync__1) tooregister a [IEventProcessor](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor) hello futásidejű végrehajtása.</span><span class="sxs-lookup"><span data-stu-id="d6398-221">Then, call [RegisterEventProcessorAsync](/dotnet/api/microsoft.servicebus.messaging.eventprocessorhost#Microsoft_ServiceBus_Messaging_EventProcessorHost_RegisterEventProcessorAsync__1) tooregister your [IEventProcessor](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor) implementation with hello runtime.</span></span> <span data-ttu-id="d6398-222">Ezen a ponton a hello állomás megpróbál tooacquire a címbérlet a "mohó" algoritmus használatával hello eseményközpont minden partícióján.</span><span class="sxs-lookup"><span data-stu-id="d6398-222">At this point, hello host will attempt tooacquire a lease on every partition in hello event hub using a "greedy" algorithm.</span></span> <span data-ttu-id="d6398-223">Ezek a bérletek egy adott időtartamra szólnak, és azt követően meg kell újítani őket.</span><span class="sxs-lookup"><span data-stu-id="d6398-223">These leases will last for a given timeframe and must then be renewed.</span></span> <span data-ttu-id="d6398-224">Ahogy újabb csomópontok worker-példány ebben az esetben ismét online elérhető, azok helyezze, bérletfoglalásokat végeznek, és idővel hello terhelés átvált csomópontok között, mindegyik kísérletek tooacquire több bérletet.</span><span class="sxs-lookup"><span data-stu-id="d6398-224">As new nodes, worker instances in this case, come online, they place lease reservations and over time hello load shifts between nodes as each attempts tooacquire more leases.</span></span>

![Event Processor Host](./media/event-hubs-programming-guide/IC759863.png)

<span data-ttu-id="d6398-226">Idővel kialakul egy egyensúlyi állapot.</span><span class="sxs-lookup"><span data-stu-id="d6398-226">Over time, an equilibrium is established.</span></span> <span data-ttu-id="d6398-227">A dinamikus képességnek a segítségével processzoralapú automatikus skálázás alkalmazott toobe tooconsumers a felfelé és lefelé méretezéshez egyaránt.</span><span class="sxs-lookup"><span data-stu-id="d6398-227">This dynamic capability enables CPU-based autoscaling toobe applied tooconsumers for both scale-up and scale-down.</span></span> <span data-ttu-id="d6398-228">Az Event Hubs nem rendelkeznek közvetlen megoldással az üzenetek számlálásához, mert átlagos processzorhasználat gyakran hello legjobb mechanizmus toomeasure hátsó vége vagy felhasználói lépték megállapítására.</span><span class="sxs-lookup"><span data-stu-id="d6398-228">Because Event Hubs do not have a direct concept of message counts, average CPU utilization is often hello best mechanism toomeasure back end or consumer scale.</span></span> <span data-ttu-id="d6398-229">Ha a közzétevők idővel képes a fogyasztók-nál több esemény toopublish, hello Processzor növelésével feldolgozópéldányok számának automatikus skálázása használt toocause lehet.</span><span class="sxs-lookup"><span data-stu-id="d6398-229">If publishers begin toopublish more events than consumers can process, hello CPU increase on consumers can be used toocause an auto-scale on worker instance count.</span></span>

<span data-ttu-id="d6398-230">Hello [EventProcessorHost][] osztály megvalósít továbbá egy Azure storage-alapú ellenőrzőpont-kezelési mechanizmust.</span><span class="sxs-lookup"><span data-stu-id="d6398-230">hello [EventProcessorHost][] class also implements an Azure storage-based checkpointing mechanism.</span></span> <span data-ttu-id="d6398-231">A mechanizmus tárolók hello eltolás partíciónkénti alapon, így mindegyik felhasználó megállapíthatja, hogy milyen hello hello előző felhasználó utolsó ellenőrzőpontja volt.</span><span class="sxs-lookup"><span data-stu-id="d6398-231">This mechanism stores hello offset on a per partition basis, so that each consumer can determine what hello last checkpoint from hello previous consumer was.</span></span> <span data-ttu-id="d6398-232">Ahogy a partíciók váltanak között a bérletek csomópontok, ez az hello szinkronizálási mechanizmus, amely elősegíti a terhelés áthelyezését.</span><span class="sxs-lookup"><span data-stu-id="d6398-232">As partitions transition between nodes via leases, this is hello synchronization mechanism that facilitates load shifting.</span></span>

## <a name="publisher-revocation"></a><span data-ttu-id="d6398-233">Közzétevők visszavonása</span><span class="sxs-lookup"><span data-stu-id="d6398-233">Publisher revocation</span></span>
<span data-ttu-id="d6398-234">Ezenkívül toohello speciális futásidejű szolgáltatásai [EventProcessorHost][], az Event Hubs lehetővé teszi, hogy a rendelés tooblock adott közzétevők esemény tooan eseményközpont küldjenek a közzétevők visszavonását.</span><span class="sxs-lookup"><span data-stu-id="d6398-234">In addition toohello advanced run-time features of [EventProcessorHost][], Event Hubs enables publisher revocation in order tooblock specific publishers from sending event tooan event hub.</span></span> <span data-ttu-id="d6398-235">Ezek a szolgáltatások akkor igazán hasznosak, ha egy közzétevői token biztonsága sérült, vagy egy szoftverfrissítés okozza-e őket toobehave helytelenül eljárva.</span><span class="sxs-lookup"><span data-stu-id="d6398-235">These features are particularly useful if a publisher token has been compromised, or a software update is causing them toobehave inappropriately.</span></span> <span data-ttu-id="d6398-236">Ezekben a helyzetekben hello közzétevő identitása, SAS-token részét képező blokkolható az események közzététele.</span><span class="sxs-lookup"><span data-stu-id="d6398-236">In these situations, hello publisher's identity, which is part of their SAS token, can be blocked from publishing events.</span></span>

<span data-ttu-id="d6398-237">További információ a közzétevők visszavonásával és hogyan toosend közzétevőként, tooEvent hubok: hello [Event Hubs nagy méretezési biztonságos közzétételi](https://code.msdn.microsoft.com/Service-Bus-Event-Hub-99ce67ab) minta.</span><span class="sxs-lookup"><span data-stu-id="d6398-237">For more information about publisher revocation and how toosend tooEvent Hubs as a publisher, see hello [Event Hubs Large Scale Secure Publishing](https://code.msdn.microsoft.com/Service-Bus-Event-Hub-99ce67ab) sample.</span></span>

## <a name="next-steps"></a><span data-ttu-id="d6398-238">Következő lépések</span><span class="sxs-lookup"><span data-stu-id="d6398-238">Next steps</span></span>
<span data-ttu-id="d6398-239">További információ az Event Hubs-forgatókönyvekkel toolearn látogasson el ezeket a hivatkozásokat:</span><span class="sxs-lookup"><span data-stu-id="d6398-239">toolearn more about Event Hubs scenarios, visit these links:</span></span>

* <span data-ttu-id="d6398-240">[Event Hubs API overview](event-hubs-api-overview.md) (Event Hubs API – áttekintés)</span><span class="sxs-lookup"><span data-stu-id="d6398-240">[Event Hubs API overview](event-hubs-api-overview.md)</span></span>
* [<span data-ttu-id="d6398-241">Mi az az Event Hubs</span><span class="sxs-lookup"><span data-stu-id="d6398-241">What is Event Hubs</span></span>](event-hubs-what-is-event-hubs.md)
* [<span data-ttu-id="d6398-242">Rendelkezésre állás és konzisztencia az Event Hubsban</span><span class="sxs-lookup"><span data-stu-id="d6398-242">Availability and consistency in Event Hubs</span></span>](event-hubs-availability-and-consistency.md)
* [<span data-ttu-id="d6398-243">Event Processor Host – API-referencia</span><span class="sxs-lookup"><span data-stu-id="d6398-243">Event processor host API reference</span></span>](/dotnet/api/microsoft.servicebus.messaging.eventprocessorhost)

[NamespaceManager]: /dotnet/api/microsoft.servicebus.namespacemanager
[EventHubClient]: /dotnet/api/microsoft.servicebus.messaging.eventhubclient
[EventData]: /dotnet/api/microsoft.servicebus.messaging.eventdata
[CreateEventHubIfNotExists]: /dotnet/api/microsoft.servicebus.namespacemanager.createeventhubifnotexists
[PartitionKey]: /dotnet/api/microsoft.servicebus.messaging.eventdata#Microsoft_ServiceBus_Messaging_EventData_PartitionKey
[EventProcessorHost]: /dotnet/api/microsoft.servicebus.messaging.eventprocessorhost
