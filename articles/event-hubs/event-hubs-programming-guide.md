---
title: "Az Azure Event Hubs programozási útmutatója | Microsoft Docs"
description: "Az Azure Event Hubs az Azure .NET SDK használatával írhat kódot."
services: event-hubs
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: 64cbfd3d-4a0e-4455-a90a-7f3d4f080323
ms.service: event-hubs
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: tbd
ms.date: 08/17/2017
ms.author: sethm
ms.openlocfilehash: 405ec2b27b488b570c4a5c86e4950ff98233360e
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 08/18/2017
---
# <a name="event-hubs-programming-guide"></a><span data-ttu-id="a75b2-103">Event Hubs programozási útmutató</span><span class="sxs-lookup"><span data-stu-id="a75b2-103">Event Hubs programming guide</span></span>

<span data-ttu-id="a75b2-104">A cikk ismerteti az Azure Event Hubs és az Azure .NET SDK használatával programozás olyan gyakori forgatókönyveket tartalmaz.</span><span class="sxs-lookup"><span data-stu-id="a75b2-104">This article discusses some common scenarios in writing code using Azure Event Hubs and the Azure .NET SDK.</span></span> <span data-ttu-id="a75b2-105">A témakör feltételezi az Event Hubs szolgáltatással kapcsolatos előzetes ismeretek meglétét.</span><span class="sxs-lookup"><span data-stu-id="a75b2-105">It assumes a preliminary understanding of Event Hubs.</span></span> <span data-ttu-id="a75b2-106">Az Event Hubs fogalmi áttekintése: [Event Hubs – áttekintés](event-hubs-what-is-event-hubs.md).</span><span class="sxs-lookup"><span data-stu-id="a75b2-106">For a conceptual overview of Event Hubs, see the [Event Hubs overview](event-hubs-what-is-event-hubs.md).</span></span>

## <a name="event-publishers"></a><span data-ttu-id="a75b2-107">Esemény-közzétevők</span><span class="sxs-lookup"><span data-stu-id="a75b2-107">Event publishers</span></span>

<span data-ttu-id="a75b2-108">Az eseményközpontok felé, vagy a HTTP POST használatával vagy egy AMQP 1.0-kapcsolaton keresztül küldött események.</span><span class="sxs-lookup"><span data-stu-id="a75b2-108">You send events to an event hub either using HTTP POST or via an AMQP 1.0 connection.</span></span> <span data-ttu-id="a75b2-109">A választott használandó és mikor függ az adott forgatókönyv határozza meg.</span><span class="sxs-lookup"><span data-stu-id="a75b2-109">The choice of which to use and when depends on the specific scenario being addressed.</span></span> <span data-ttu-id="a75b2-110">Az AMQP 1.0-kapcsolatok mérése közvetített kapcsolatként történik a Service Bus szolgáltatásban, és az olyan forgatókönyvekben megfelelőbbek, ahol gyakoriak a nagyobb üzenetmennyiségek és alacsony késés szükséges, mivel ezek állandó üzenetkezelési csatornát biztosítanak.</span><span class="sxs-lookup"><span data-stu-id="a75b2-110">AMQP 1.0 connections are metered as brokered connections in Service Bus and are more appropriate in scenarios with frequent higher message volumes and lower latency requirements, as they provide a persistent messaging channel.</span></span>

<span data-ttu-id="a75b2-111">Az Event Hubs a [NamespaceManager][] osztály használatával hozható létre és felügyelhető.</span><span class="sxs-lookup"><span data-stu-id="a75b2-111">You create and manage Event Hubs using the [NamespaceManager][] class.</span></span> <span data-ttu-id="a75b2-112">A .NET által felügyelt API-k használatakor az adatoknak az Event Hubs számára történő közzétételére szolgáló elsődleges szerkezetek az [EventHubClient](/dotnet/api/microsoft.servicebus.messaging.eventhubclient) és az [EventData][] osztály.</span><span class="sxs-lookup"><span data-stu-id="a75b2-112">When using the .NET managed APIs, the primary constructs for publishing data to Event Hubs are the [EventHubClient](/dotnet/api/microsoft.servicebus.messaging.eventhubclient) and [EventData][] classes.</span></span> <span data-ttu-id="a75b2-113">[EventHubClient][] biztosít, amelyben az események küldhetők az event hubs AMQP kommunikációs csatornát.</span><span class="sxs-lookup"><span data-stu-id="a75b2-113">[EventHubClient][] provides the AMQP communication channel over which events are sent to the event hub.</span></span> <span data-ttu-id="a75b2-114">A [EventData][] osztály egy eseményt képvisel, és üzeneteket az eseményközpontba közzétételére szolgál.</span><span class="sxs-lookup"><span data-stu-id="a75b2-114">The [EventData][] class represents an event, and is used to publish messages to an event hub.</span></span> <span data-ttu-id="a75b2-115">Ez az osztály az esemény törzsét, bizonyos metaadatait és fejléc-információit tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="a75b2-115">This class includes the body, some metadata, and header information about the event.</span></span> <span data-ttu-id="a75b2-116">Más tulajdonságokkal is bővül a [EventData][] objektumot, ahogy keresztülhalad az eseményközpontban.</span><span class="sxs-lookup"><span data-stu-id="a75b2-116">Other properties are added to the [EventData][] object as it passes through an event hub.</span></span>

## <a name="get-started"></a><span data-ttu-id="a75b2-117">Bevezetés</span><span class="sxs-lookup"><span data-stu-id="a75b2-117">Get started</span></span>

<span data-ttu-id="a75b2-118">Az Event Hubs szolgáltatást támogató .NET-osztályok a Microsoft.ServiceBus.dll szerelvényben találhatók.</span><span class="sxs-lookup"><span data-stu-id="a75b2-118">The .NET classes that support Event Hubs are provided in the Microsoft.ServiceBus.dll assembly.</span></span> <span data-ttu-id="a75b2-119">A Service Bus API-ra való hivatkozásnak és az alkalmazás az összes Service Bus-függőséggel való konfigurálásának a legegyszerűbb módja, ha letölti a [Service Bus NuGet-csomagot](https://www.nuget.org/packages/WindowsAzure.ServiceBus).</span><span class="sxs-lookup"><span data-stu-id="a75b2-119">The easiest way to reference the Service Bus API and to configure your application with all of the Service Bus dependencies is to download the [Service Bus NuGet package](https://www.nuget.org/packages/WindowsAzure.ServiceBus).</span></span> <span data-ttu-id="a75b2-120">Használhatja a Visual Studio [Csomagkezelő konzolját](http://docs.nuget.org/docs/start-here/using-the-package-manager-console) is.</span><span class="sxs-lookup"><span data-stu-id="a75b2-120">Alternatively, you can use the [Package Manager Console](http://docs.nuget.org/docs/start-here/using-the-package-manager-console) in Visual Studio.</span></span> <span data-ttu-id="a75b2-121">Ehhez adja ki a következő parancsot a [Csomagkezelő konzol](http://docs.nuget.org/docs/start-here/using-the-package-manager-console) ablakában:</span><span class="sxs-lookup"><span data-stu-id="a75b2-121">To do so, issue the following command in the [Package Manager Console](http://docs.nuget.org/docs/start-here/using-the-package-manager-console) window:</span></span>

```
Install-Package WindowsAzure.ServiceBus
```

## <a name="create-an-event-hub"></a><span data-ttu-id="a75b2-122">Eseményközpont létrehozása</span><span class="sxs-lookup"><span data-stu-id="a75b2-122">Create an event hub</span></span>
<span data-ttu-id="a75b2-123">A [NamespaceManager][] osztályt használhatja az eseményközpontok létrehozásához.</span><span class="sxs-lookup"><span data-stu-id="a75b2-123">You can use the [NamespaceManager][] class to create Event Hubs.</span></span> <span data-ttu-id="a75b2-124">Példa:</span><span class="sxs-lookup"><span data-stu-id="a75b2-124">For example:</span></span>

```csharp
var manager = new Microsoft.ServiceBus.NamespaceManager("mynamespace.servicebus.windows.net");
var description = manager.CreateEventHub("MyEventHub");
```

<span data-ttu-id="a75b2-125">A legtöbb esetben ajánlott a [CreateEventHubIfNotExists][] metódusok használata a kivételek elkerülése érdekében, ha a szolgáltatás újraindul.</span><span class="sxs-lookup"><span data-stu-id="a75b2-125">In most cases, it is recommended that you use the [CreateEventHubIfNotExists][] methods to avoid generating exceptions if the service restarts.</span></span> <span data-ttu-id="a75b2-126">Példa:</span><span class="sxs-lookup"><span data-stu-id="a75b2-126">For example:</span></span>

```csharp
var description = manager.CreateEventHubIfNotExists("MyEventHub");
```

<span data-ttu-id="a75b2-127">Minden Event Hubs létrehozási művelet, beleértve a [CreateEventHubIfNotExists][] műveletet is, **Kezelés** jogosultságokat igényel az adott névtérben.</span><span class="sxs-lookup"><span data-stu-id="a75b2-127">All Event Hubs creation operations, including [CreateEventHubIfNotExists][], require **Manage** permissions on the namespace in question.</span></span> <span data-ttu-id="a75b2-128">Amennyiben a közzétevő vagy felhasználó alkalmazások jogosultságait korlátozni kívánja, elkerülheti ezeket a létrehozásiművelet-hívásokat az éles kódban, ha korlátozott jogosultságokkal rendelkező hitelesítési adatokat használ.</span><span class="sxs-lookup"><span data-stu-id="a75b2-128">If you want to limit the permissions of your publisher or consumer applications, you can avoid these create operation calls in production code when you use credentials with limited permissions.</span></span>

<span data-ttu-id="a75b2-129">A [EventHubDescription](/dotnet/api/microsoft.servicebus.messaging.eventhubdescription) osztály tartalmazza az eseményközpontban, beleértve az engedélyezési szabályokat, az üzenetek megőrzési idejét, partíciók azonosítóit, állapota és az elérési utat.</span><span class="sxs-lookup"><span data-stu-id="a75b2-129">The [EventHubDescription](/dotnet/api/microsoft.servicebus.messaging.eventhubdescription) class contains details about an event hub, including the authorization rules, the message retention interval, partition IDs, status, and path.</span></span> <span data-ttu-id="a75b2-130">Ez az osztály használatával frissítse a metaadatokat az eseményközpontban.</span><span class="sxs-lookup"><span data-stu-id="a75b2-130">You can use this class to update the metadata on an event hub.</span></span>

## <a name="create-an-event-hubs-client"></a><span data-ttu-id="a75b2-131">Event Hubs-ügyfél létrehozása</span><span class="sxs-lookup"><span data-stu-id="a75b2-131">Create an Event Hubs client</span></span>
<span data-ttu-id="a75b2-132">Az elsődleges osztály az Event Hubs kommunikáció [Microsoft.ServiceBus.Messaging.EventHubClient][EventHubClient].</span><span class="sxs-lookup"><span data-stu-id="a75b2-132">The primary class for interacting with Event Hubs is [Microsoft.ServiceBus.Messaging.EventHubClient][EventHubClient].</span></span> <span data-ttu-id="a75b2-133">Ez az osztály küldői és fogadói képességeket is biztosít.</span><span class="sxs-lookup"><span data-stu-id="a75b2-133">This class provides both sender and receiver capabilities.</span></span> <span data-ttu-id="a75b2-134">Az osztály a [Create](/dotnet/api/microsoft.servicebus.messaging.eventhubclient.create) metódus használatával példányosítható, ahogy az alábbi példában látható.</span><span class="sxs-lookup"><span data-stu-id="a75b2-134">You can instantiate this class using the [Create](/dotnet/api/microsoft.servicebus.messaging.eventhubclient.create) method, as shown in the following example.</span></span>

```csharp
var client = EventHubClient.Create(description.Path);
```

<span data-ttu-id="a75b2-135">Ez a metódus a Service Bus szolgáltatásnak az App.config fájl `appSettings` szakaszában található kapcsolati információit használja.</span><span class="sxs-lookup"><span data-stu-id="a75b2-135">This method uses the Service Bus connection information in the App.config file, in the `appSettings` section.</span></span> <span data-ttu-id="a75b2-136">A Service Bus kapcsolati információit tároló `appSettings` XML egy példájáért tekintse meg a [Microsoft.ServiceBus.Messaging.EventHubClient.Create(System.String)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Create_System_String_) metódus dokumentációját.</span><span class="sxs-lookup"><span data-stu-id="a75b2-136">For an example of the `appSettings` XML used to store the Service Bus connection information, see the documentation for the [Microsoft.ServiceBus.Messaging.EventHubClient.Create(System.String)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Create_System_String_) method.</span></span>

<span data-ttu-id="a75b2-137">Egy másik lehetőség az ügyfél létrehozása egy kapcsolati karakterláncból.</span><span class="sxs-lookup"><span data-stu-id="a75b2-137">Another option is to create the client from a connection string.</span></span> <span data-ttu-id="a75b2-138">Ez a lehetőség akkor működik jól, ha Azure feldolgozói szerepköröket használ, mivel a karakterláncot tárolhatja a feldolgozó konfigurációs tulajdonságaiban.</span><span class="sxs-lookup"><span data-stu-id="a75b2-138">This option works well when using Azure worker roles, because you can store the string in the configuration properties for the worker.</span></span> <span data-ttu-id="a75b2-139">Példa:</span><span class="sxs-lookup"><span data-stu-id="a75b2-139">For example:</span></span>

```csharp
EventHubClient.CreateFromConnectionString("your_connection_string");
```

<span data-ttu-id="a75b2-140">A kapcsolati karakterlánc formátumba megegyezik a korábbi metódusok App.config fájljában használt formátummal:</span><span class="sxs-lookup"><span data-stu-id="a75b2-140">The connection string will be in the same format as it appears in the App.config file for the previous methods:</span></span>

```
Endpoint=sb://[namespace].servicebus.windows.net/;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=[key]
```

<span data-ttu-id="a75b2-141">Végül, [EventHubClient][] objektum létrehozható [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) példányból is, amint az alábbi példában látható.</span><span class="sxs-lookup"><span data-stu-id="a75b2-141">Finally, it is also possible to create an [EventHubClient][] object from a [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) instance, as shown in the following example.</span></span>

```csharp
var factory = MessagingFactory.CreateFromConnectionString("your_connection_string");
var client = factory.CreateEventHubClient("MyEventHub");
```

<span data-ttu-id="a75b2-142">Fontos megjegyezni, hogy az üzenetkezelési gyár példányából létrehozott további [EventHubClient][] objektumok ugyanazt az alapul szolgáló TCP-kapcsolatot használják majd.</span><span class="sxs-lookup"><span data-stu-id="a75b2-142">It is important to note that additional [EventHubClient][] objects created from a messaging factory instance will reuse the same underlying TCP connection.</span></span> <span data-ttu-id="a75b2-143">Ezért ezek az objektumok ügyféloldali korláttal rendelkeznek majd az átvitelre vonatkozóan.</span><span class="sxs-lookup"><span data-stu-id="a75b2-143">Therefore, these objects have a client-side limit on throughput.</span></span> <span data-ttu-id="a75b2-144">A [Create](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Create_System_String_) metódus újból felhasználja az üzenetkezelési gyárat.</span><span class="sxs-lookup"><span data-stu-id="a75b2-144">The [Create](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Create_System_String_) method reuses a single messaging factory.</span></span> <span data-ttu-id="a75b2-145">Amennyiben nagyon nagy átviteli kapacitás szükséges egyetlen küldőtől, létrehozhat több üzenetkezelési gyárat, illetve egy [EventHubClient][] objektumot mindegyik üzenetkezelési gyárból.</span><span class="sxs-lookup"><span data-stu-id="a75b2-145">If you need very high throughput from a single sender, then you can create multiple message factories and one [EventHubClient][] object from each messaging factory.</span></span>

## <a name="send-events-to-an-event-hub"></a><span data-ttu-id="a75b2-146">Események küldése az event hubs</span><span class="sxs-lookup"><span data-stu-id="a75b2-146">Send events to an event hub</span></span>
<span data-ttu-id="a75b2-147">Események küldött hozzon létre egy eseményközpontba egy [EventData][] példányt, és küldje el azt a [küldése](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_) metódust.</span><span class="sxs-lookup"><span data-stu-id="a75b2-147">You send events to an event hub by creating an [EventData][] instance and sending it via the [Send](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_) method.</span></span> <span data-ttu-id="a75b2-148">Ez a metódus egyetlen veszi [EventData][] példányparamétert és szinkron módon elküldi azt az eseményközpontba.</span><span class="sxs-lookup"><span data-stu-id="a75b2-148">This method takes a single [EventData][] instance parameter and synchronously sends it to an event hub.</span></span>

## <a name="event-serialization"></a><span data-ttu-id="a75b2-149">Eseményszerializáció</span><span class="sxs-lookup"><span data-stu-id="a75b2-149">Event serialization</span></span>
<span data-ttu-id="a75b2-150">Az [EventData][] osztály [négy túlterhelt konstruktorral](/dotnet/api/microsoft.servicebus.messaging.eventdata#constructors_) rendelkezik, amelyek különféle paramétereket vesznek fel, például egy objektumot és egy szerializálót, egy bájttömböt vagy egy streamet.</span><span class="sxs-lookup"><span data-stu-id="a75b2-150">The [EventData][] class has [four overloaded constructors](/dotnet/api/microsoft.servicebus.messaging.eventdata#constructors_) that take a variety of parameters, such as an object and serializer, a byte array, or a stream.</span></span> <span data-ttu-id="a75b2-151">Az [EventData][] osztály példányosítható is, és törzsstream beállítható ezt követően.</span><span class="sxs-lookup"><span data-stu-id="a75b2-151">It is also possible to instantiate the [EventData][] class and set the body stream afterwards.</span></span> <span data-ttu-id="a75b2-152">Ha JSON-t használ az [EventData][] osztállyal, az **Encoding.UTF8.GetBytes()** használatával kérheti le a bájttömböt a JSON-kódolású karakterlánchoz.</span><span class="sxs-lookup"><span data-stu-id="a75b2-152">When using JSON with [EventData][], you can use **Encoding.UTF8.GetBytes()** to retrieve the byte array for a JSON-encoded string.</span></span>

## <a name="partition-key"></a><span data-ttu-id="a75b2-153">Partíciókulcs</span><span class="sxs-lookup"><span data-stu-id="a75b2-153">Partition key</span></span>
<span data-ttu-id="a75b2-154">Az [EventData][] osztály a [PartitionKey][] tulajdonsággal rendelkezik, amelynek segítségével a küldő meghatározhat egy értéket, amelynek kivonatolásával létrehozható egy partíció-hozzárendelés.</span><span class="sxs-lookup"><span data-stu-id="a75b2-154">The [EventData][] class has a [PartitionKey][] property that enables the sender to specify a value that is hashed to produce a partition assignment.</span></span> <span data-ttu-id="a75b2-155">A partíciókulcsok használatával ugyanazzal a kulccsal rendelkező események küldött egyazon partícióra kerüljenek a központ biztosítja.</span><span class="sxs-lookup"><span data-stu-id="a75b2-155">Using a partition key ensures that all the events with the same key are sent to the same partition in the event hub.</span></span> <span data-ttu-id="a75b2-156">Az általános partíciókulcsok többek közt a felhasználói munkamenetek azonosítói és az egyedi küldőazonosítók.</span><span class="sxs-lookup"><span data-stu-id="a75b2-156">Common partition keys include user session IDs and unique sender IDs.</span></span> <span data-ttu-id="a75b2-157">A [PartitionKey][] tulajdonság nem kötelező, és a [Microsoft.ServiceBus.Messaging.EventHubClient.Send(Microsoft.ServiceBus.Messaging.EventData)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_) vagy a [Microsoft.ServiceBus.Messaging.EventHubClient.SendAsync(Microsoft.ServiceBus.Messaging.EventData)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendAsync_Microsoft_ServiceBus_Messaging_EventData_) metódus használatakor adható meg.</span><span class="sxs-lookup"><span data-stu-id="a75b2-157">The [PartitionKey][] property is optional and can be provided when using the [Microsoft.ServiceBus.Messaging.EventHubClient.Send(Microsoft.ServiceBus.Messaging.EventData)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_) or [Microsoft.ServiceBus.Messaging.EventHubClient.SendAsync(Microsoft.ServiceBus.Messaging.EventData)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendAsync_Microsoft_ServiceBus_Messaging_EventData_) methods.</span></span> <span data-ttu-id="a75b2-158">Ha nem ad meg értéket a [PartitionKey][] számára, a küldött események elosztása a partíciókra ciklikus időszeleteléses modell használatával fog történni.</span><span class="sxs-lookup"><span data-stu-id="a75b2-158">If you do not provide a value for [PartitionKey][], sent events are distributed to partitions using a round-robin model.</span></span>

### <a name="availability-considerations"></a><span data-ttu-id="a75b2-159">Rendelkezésre állási szempontok</span><span class="sxs-lookup"><span data-stu-id="a75b2-159">Availability considerations</span></span>

<span data-ttu-id="a75b2-160">A partíciós kulcs használata nem kötelező, és meg kell alaposan fontolja meg, hogy használhatja-e.</span><span class="sxs-lookup"><span data-stu-id="a75b2-160">Using a partition key is optional, and you should consider carefully whether or not to use one.</span></span> <span data-ttu-id="a75b2-161">Sok esetben a partíciókulcsok használatával akkor hasznos, ha fontos esemény rendezés.</span><span class="sxs-lookup"><span data-stu-id="a75b2-161">In many cases, using a partition key is a good choice if event ordering is important.</span></span> <span data-ttu-id="a75b2-162">A partíciós kulcs használata esetén ezek a partíciók egycsomópontos rendelkezésre szükség, és kiesések is időbeli; például, ha a számítási csomópontok újraindítás és a javítás.</span><span class="sxs-lookup"><span data-stu-id="a75b2-162">When you use a partition key, these partitions require availability on a single node, and outages can occur over time; for example, when compute nodes reboot and patch.</span></span> <span data-ttu-id="a75b2-163">Ilyen el a Partícióazonosító és adott partíció valamilyen okból kifolyólag nem érhető el, ha az adott partíció adatainak elérésére tett kísérlet sikertelen lesz.</span><span class="sxs-lookup"><span data-stu-id="a75b2-163">As such, if you set a partition ID and that partition becomes unavailable for some reason, an attempt to access the data in that partition will fail.</span></span> <span data-ttu-id="a75b2-164">Ha magas rendelkezésre állású legfontosabb, nem ad meg partíciókulcsot; Ebben az esetben a fentiekben említett Ciklikus időszeleteléses modell használatával partíciók események kapnak.</span><span class="sxs-lookup"><span data-stu-id="a75b2-164">If high availability is most important, do not specify a partition key; in that case events will be sent to partitions using the round-robin model described previously.</span></span> <span data-ttu-id="a75b2-165">Ebben a forgatókönyvben teszi rendelkezésre állási (nincs Partícióazonosító) és (a Partícióazonosító események rögzítése) konzisztencia között kifejezett választást.</span><span class="sxs-lookup"><span data-stu-id="a75b2-165">In this scenario, you are making an explicit choice between availability (no partition ID) and consistency (pinning events to a partition ID).</span></span>

<span data-ttu-id="a75b2-166">Egy másik szempont kezeli a késlelteti az események feldolgozásával.</span><span class="sxs-lookup"><span data-stu-id="a75b2-166">Another consideration is handling delays in processing events.</span></span> <span data-ttu-id="a75b2-167">Bizonyos esetekben előfordulhat, hogy célszerű dobja el az adatokat, és próbálkozzon újra, mint próbálja és feldolgozási tartani, amely potenciálisan okozhat további alárendelt feldolgozási késedelmeket.</span><span class="sxs-lookup"><span data-stu-id="a75b2-167">In some cases it might be better to drop data and retry than to try and keep up with processing, which can potentially cause further downstream processing delays.</span></span> <span data-ttu-id="a75b2-168">Például a tőzsdei árfolyamjelző célszerűbb várja meg a teljes legfrissebb adatokat, de egy élő vagy gyors, az adatok ahelyett, hogy kellene VOIP a forgatókönyv, még akkor is, ha nem, akkor a teljes.</span><span class="sxs-lookup"><span data-stu-id="a75b2-168">For example, with a stock ticker it's better to wait for complete up-to-date data, but in a live chat or VOIP scenario you'd rather have the data quickly, even if it isn't complete.</span></span>

<span data-ttu-id="a75b2-169">A rendelkezésre állási lehetőségekért megadott forgatókönyvekben választása a következő hiba egyik kezelési stratégiák:</span><span class="sxs-lookup"><span data-stu-id="a75b2-169">Given these availability considerations, in these scenarios you might choose one of the following error handling strategies:</span></span>

- <span data-ttu-id="a75b2-170">Leállítás (olvasásakor az Event Hubs dolgot megoldásáig leállítás)</span><span class="sxs-lookup"><span data-stu-id="a75b2-170">Stop (stop reading from Event Hubs until things are fixed)</span></span>
- <span data-ttu-id="a75b2-171">Közvetlen (üzenetek nem fontos, dobja el őket)</span><span class="sxs-lookup"><span data-stu-id="a75b2-171">Drop (messages aren’t important, drop them)</span></span>
- <span data-ttu-id="a75b2-172">Ismételje meg a (az üzenetek ismertető elférjen újrapróbálkozási)</span><span class="sxs-lookup"><span data-stu-id="a75b2-172">Retry (retry the messages as you see fit)</span></span>
- <span data-ttu-id="a75b2-173">[Kézbesítetlen levelek](../service-bus-messaging/service-bus-dead-letter-queues.md) (várólista használja, vagy egy másik eseményközpontnak azon halott levél csak azokat az üzeneteket nem tudta feldolgozni)</span><span class="sxs-lookup"><span data-stu-id="a75b2-173">[Dead letter](../service-bus-messaging/service-bus-dead-letter-queues.md) (use a queue or another event hub to dead letter only the messages you couldn’t process)</span></span>

<span data-ttu-id="a75b2-174">További információt és rendelkezésre állás és a konzisztencia közötti kompromisszumot kapcsolatos döntéseken: [rendelkezésre állását és az Event Hubs következetes](event-hubs-availability-and-consistency.md).</span><span class="sxs-lookup"><span data-stu-id="a75b2-174">For more information and a discussion about the trade-offs between availability and consistency, see [Availability and consistency in Event Hubs](event-hubs-availability-and-consistency.md).</span></span> 

## <a name="batch-event-send-operations"></a><span data-ttu-id="a75b2-175">Kötegelt eseményküldési műveletek</span><span class="sxs-lookup"><span data-stu-id="a75b2-175">Batch event send operations</span></span>
<span data-ttu-id="a75b2-176">Az események kötegekben való küldésével jelentősen növelhető az átvitel.</span><span class="sxs-lookup"><span data-stu-id="a75b2-176">Sending events in batches can dramatically increase throughput.</span></span> <span data-ttu-id="a75b2-177">A [SendBatch](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendBatch_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_EventData__) metódus egy **IEnumerable** típusú paramétert [EventData][] és az egész köteget elemi műveletként az event hubs küld.</span><span class="sxs-lookup"><span data-stu-id="a75b2-177">The [SendBatch](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendBatch_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_EventData__) method takes an **IEnumerable** parameter of type [EventData][] and sends the entire batch as an atomic operation to the event hub.</span></span>

```csharp
public void SendBatch(IEnumerable<EventData> eventDataList);
```

<span data-ttu-id="a75b2-178">Vegye figyelembe, hogy a kötegek mérete egyenként nem haladhatja meg az események 256 KB-os korlátját.</span><span class="sxs-lookup"><span data-stu-id="a75b2-178">Note that a single batch must not exceed the 256 KB limit of an event.</span></span> <span data-ttu-id="a75b2-179">Továbbá a kötegben lévő egyes üzenetek ugyanazzal a közzétevői identitással rendelkezik majd.</span><span class="sxs-lookup"><span data-stu-id="a75b2-179">Additionally, each message in the batch uses the same publisher identity.</span></span> <span data-ttu-id="a75b2-180">A küldő felelőssége annak biztosítása, hogy a köteg mérete nem haladja meg az események maximális méretét.</span><span class="sxs-lookup"><span data-stu-id="a75b2-180">It is the responsibility of the sender to ensure that the batch does not exceed the maximum event size.</span></span> <span data-ttu-id="a75b2-181">Ha mégis meghaladja, az ügyfél **Küldési** hibát jelez.</span><span class="sxs-lookup"><span data-stu-id="a75b2-181">If it does, a client **Send** error is generated.</span></span>

## <a name="send-asynchronously-and-send-at-scale"></a><span data-ttu-id="a75b2-182">Aszinkron küldés és nagy léptékű küldés</span><span class="sxs-lookup"><span data-stu-id="a75b2-182">Send asynchronously and send at scale</span></span>
<span data-ttu-id="a75b2-183">Is küldhet események eseményközpontokba való aszinkron módon történik.</span><span class="sxs-lookup"><span data-stu-id="a75b2-183">You can also send events to an event hub asynchronously.</span></span> <span data-ttu-id="a75b2-184">Az aszinkron küldés növelheti az ügyfelek üzenetküldési sebességét.</span><span class="sxs-lookup"><span data-stu-id="a75b2-184">Sending asynchronously can increase the rate at which a client is able to send events.</span></span> <span data-ttu-id="a75b2-185">A [Send](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_) és a [SendBatch](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendBatch_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_EventData__) metódus egyaránt elérhetők aszinkron verzióban, amely egy [Task](https://msdn.microsoft.com/library/system.threading.tasks.task.aspx) objektumot ad vissza.</span><span class="sxs-lookup"><span data-stu-id="a75b2-185">Both the [Send](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_) and [SendBatch](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendBatch_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_EventData__) methods are available in asynchronous versions that return a [Task](https://msdn.microsoft.com/library/system.threading.tasks.task.aspx) object.</span></span> <span data-ttu-id="a75b2-186">Jóllehet ezzel a technikával növelhető az átvitel, ugyanakkor azt is eredményezheti, hogy az ügyfél továbbra is küldi az eseményeket, miután az Event Hubs szolgáltatás leszabályozta, és így az ügyfél hibába ütközhet, vagy üzenetek veszhetnek el, ha a megvalósítás helytelenül ment végbe.</span><span class="sxs-lookup"><span data-stu-id="a75b2-186">While this technique can increase throughput, it can also cause the client to continue to send events even while it is being throttled by the Event Hubs service and can result in the client experiencing failures or lost messages if not properly implemented.</span></span> <span data-ttu-id="a75b2-187">Emellett használhatja a [RetryPolicy](/dotnet/api/microsoft.servicebus.messaging.cliententity#Microsoft_ServiceBus_Messaging_ClientEntity_RetryPolicy) tulajdonságot az ügyfélen az ügyfél újrapróbálkozási beállításainak vezérlésére.</span><span class="sxs-lookup"><span data-stu-id="a75b2-187">In addition, you can use the [RetryPolicy](/dotnet/api/microsoft.servicebus.messaging.cliententity#Microsoft_ServiceBus_Messaging_ClientEntity_RetryPolicy) property on the client to control client retry options.</span></span>

## <a name="create-a-partition-sender"></a><span data-ttu-id="a75b2-188">Partícióküldő létrehozása</span><span class="sxs-lookup"><span data-stu-id="a75b2-188">Create a partition sender</span></span>
<span data-ttu-id="a75b2-189">Bár a leggyakrabban használt üzenetküldési nem tartozik partíciós kulcs az eseményközpontok felé, bizonyos esetekben előfordulhat, hogy kívánt események küldése közvetlenül egy adott partícióra.</span><span class="sxs-lookup"><span data-stu-id="a75b2-189">Although it is most common to send events to an event hub without a partition key, in some cases you might want to send events directly to a given partition.</span></span> <span data-ttu-id="a75b2-190">Példa:</span><span class="sxs-lookup"><span data-stu-id="a75b2-190">For example:</span></span>

```csharp
var partitionedSender = client.CreatePartitionedSender(description.PartitionIds[0]);
```

<span data-ttu-id="a75b2-191">[CreatePartitionedSender](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_CreatePartitionedSender_System_String_) adja vissza egy [EventHubSender](/dotnet/api/microsoft.servicebus.messaging.eventhubsender) használható események közzétételére egy adott esemény hub partíció objektum.</span><span class="sxs-lookup"><span data-stu-id="a75b2-191">[CreatePartitionedSender](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_CreatePartitionedSender_System_String_) returns an [EventHubSender](/dotnet/api/microsoft.servicebus.messaging.eventhubsender) object that you can use to publish events to a specific event hub partition.</span></span>

## <a name="event-consumers"></a><span data-ttu-id="a75b2-192">Eseményfelhasználók</span><span class="sxs-lookup"><span data-stu-id="a75b2-192">Event consumers</span></span>
<span data-ttu-id="a75b2-193">Az Event Hubs két elsődleges modellel rendelkezik az események felhasználásához: közvetlen fogadók és a magasabb szintű absztrakciók, például az [EventProcessorHost][].</span><span class="sxs-lookup"><span data-stu-id="a75b2-193">Event Hubs has two primary models for event consumption: direct receivers and higher-level abstractions, such as [EventProcessorHost][].</span></span> <span data-ttu-id="a75b2-194">A közvetlen fogadók felelőssége koordinálni a saját hozzáférésüket az egyes partíciókhoz egy adott felhasználói csoportban.</span><span class="sxs-lookup"><span data-stu-id="a75b2-194">Direct receivers are responsible for their own coordination of access to partitions within a consumer group.</span></span>

### <a name="direct-consumer"></a><span data-ttu-id="a75b2-195">Közvetlen felhasználó</span><span class="sxs-lookup"><span data-stu-id="a75b2-195">Direct consumer</span></span>
<span data-ttu-id="a75b2-196">Az adott felhasználói csoportban lévő egyes partíciók olvasásának legközvetlenebb módja az [EventHubReceiver](/dotnet/apie/microsoft.servicebus.messaging.eventhubreceiver) osztály használata.</span><span class="sxs-lookup"><span data-stu-id="a75b2-196">The most direct way to read from a partition within a consumer group is to use the [EventHubReceiver](/dotnet/apie/microsoft.servicebus.messaging.eventhubreceiver) class.</span></span> <span data-ttu-id="a75b2-197">Az osztály egy példányának létrehozásához az [EventHubConsumerGroup](/dotnet/api/microsoft.servicebus.messaging.eventhubconsumergroup) osztály egy példányát kell használni.</span><span class="sxs-lookup"><span data-stu-id="a75b2-197">To create an instance of this class, you must use an instance of the [EventHubConsumerGroup](/dotnet/api/microsoft.servicebus.messaging.eventhubconsumergroup) class.</span></span> <span data-ttu-id="a75b2-198">A következő példában a felhasználói csoport fogadójának létrehozásakor a partícióazonosítót kell megadni.</span><span class="sxs-lookup"><span data-stu-id="a75b2-198">In the following example, the partition ID must be specified when creating the receiver for the consumer group.</span></span>

```csharp
EventHubConsumerGroup group = client.GetDefaultConsumerGroup();
var receiver = group.CreateReceiver(client.GetRuntimeInformation().PartitionIds[0]);
```

<span data-ttu-id="a75b2-199">A [CreateReceiver](/dotnet/api/microsoft.servicebus.messaging.eventhubconsumergroup#methods_summary) metódus több túlterheléssel rendelkezik, amelyek segítik a létrehozni kívánt olvasó vezérlését.</span><span class="sxs-lookup"><span data-stu-id="a75b2-199">The [CreateReceiver](/dotnet/api/microsoft.servicebus.messaging.eventhubconsumergroup#methods_summary) method has several overloads that facilitate control over the reader being created.</span></span> <span data-ttu-id="a75b2-200">Ezek a metódusok lehetnek egy eltolás megadása karakterlánc vagy időbélyeg használatával, valamint annak megadása, hogy a megadott eltolást tartalmazza-e a visszaadott stream, vagy azután kezdődjön.</span><span class="sxs-lookup"><span data-stu-id="a75b2-200">These methods include specifying an offset as either a string or timestamp, and the ability to specify whether to include this specified offset in the returned stream, or start after it.</span></span> <span data-ttu-id="a75b2-201">Miután létrehozta a fogadót, máris fogadhatja az eseményeket a visszaadott objektumon.</span><span class="sxs-lookup"><span data-stu-id="a75b2-201">After you create the receiver, you can start receiving events on the returned object.</span></span> <span data-ttu-id="a75b2-202">A [Receive](/dotnet/api/microsoft.servicebus.messaging.eventhubreceiver#methods_summary) metódus négy túlterheléssel rendelkezik, amelyek a fogadási művelet paramétereit szabályozzák, például a kötegméretet és a várakozási időt.</span><span class="sxs-lookup"><span data-stu-id="a75b2-202">The [Receive](/dotnet/api/microsoft.servicebus.messaging.eventhubreceiver#methods_summary) method has four overloads that control the receive operation parameters, such as batch size and wait time.</span></span> <span data-ttu-id="a75b2-203">A metódusok aszinkron verzióinak használatával itt is növelhető a felhasználók átvitele.</span><span class="sxs-lookup"><span data-stu-id="a75b2-203">You can use the asynchronous versions of these methods to increase the throughput of a consumer.</span></span> <span data-ttu-id="a75b2-204">Példa:</span><span class="sxs-lookup"><span data-stu-id="a75b2-204">For example:</span></span>

```csharp
bool receive = true;
string myOffset;
while(receive)
{
    var message = receiver.Receive();
    myOffset = message.Offset;
    string body = Encoding.UTF8.GetString(message.GetBytes());
    Console.WriteLine(String.Format("Received message offset: {0} \nbody: {1}", myOffset, body));
}
```

<span data-ttu-id="a75b2-205">Adott partíciók vonatkozásában az üzenetek fogadása ugyanabban a sorrendben, amelyben lettek küldve az eseményközpontba.</span><span class="sxs-lookup"><span data-stu-id="a75b2-205">With respect to a specific partition, the messages are received in the order in which they were sent to the event hub.</span></span> <span data-ttu-id="a75b2-206">Az eltolás egy karakterlánc-token, amely egy adott üzenetet azonosít a partíción.</span><span class="sxs-lookup"><span data-stu-id="a75b2-206">The offset is a string token used to identify a message in a partition.</span></span>

<span data-ttu-id="a75b2-207">Vegye figyelembe, hogy egy felhasználói csoportban egy adott partíció egy adott pillanatban nem rendelkezhet 5-nél több egyidejű olvasóval.</span><span class="sxs-lookup"><span data-stu-id="a75b2-207">Note that a single partition within a consumer group cannot have more than 5 concurrent readers connected at any time.</span></span> <span data-ttu-id="a75b2-208">Ahogy az olvasók csatlakoznak vagy lecsatlakoznak, a munkameneteik néhány percig még aktívak maradhatnak, mielőtt a szolgáltatás észleli, hogy lecsatlakoztak.</span><span class="sxs-lookup"><span data-stu-id="a75b2-208">As readers connect or become disconnected, their sessions might stay active for several minutes before the service recognizes that they have disconnected.</span></span> <span data-ttu-id="a75b2-209">Ezen időtartam során a partícióra való újracsatlakozás meghiúsulhat.</span><span class="sxs-lookup"><span data-stu-id="a75b2-209">During this time, reconnecting to a partition may fail.</span></span> <span data-ttu-id="a75b2-210">Átfogó példát a közvetlen fogadóknak az Event Hubs írása, tekintse meg a [Event Hubs közvetlen fogadók](https://code.msdn.microsoft.com/Event-Hub-Direct-Receivers-13fa95c6) minta.</span><span class="sxs-lookup"><span data-stu-id="a75b2-210">For a complete example of writing a direct receiver for Event Hubs, see the [Event Hubs Direct Receivers](https://code.msdn.microsoft.com/Event-Hub-Direct-Receivers-13fa95c6) sample.</span></span>

### <a name="event-processor-host"></a><span data-ttu-id="a75b2-211">Event Processor Host</span><span class="sxs-lookup"><span data-stu-id="a75b2-211">Event processor host</span></span>
<span data-ttu-id="a75b2-212">Az [EventProcessorHost][] osztály az eseményközpontokból származó adatokat dolgozza fel.</span><span class="sxs-lookup"><span data-stu-id="a75b2-212">The [EventProcessorHost][] class processes data from Event Hubs.</span></span> <span data-ttu-id="a75b2-213">Akkor használja ezt a megvalósítást, ha a .NET platformon hoz létre eseményolvasókat.</span><span class="sxs-lookup"><span data-stu-id="a75b2-213">You should use this implementation when building event readers on the .NET platform.</span></span> <span data-ttu-id="a75b2-214">Az [EventProcessorHost][] egy szálbiztos, több folyamatot lehetővé tevő, biztonságos futtatókörnyezetet biztosít az eseményfeldolgozói megvalósításokhoz, ami lehetővé teszi az ellenőrzőpontok használatát és a partícióbérlés-kezelést is.</span><span class="sxs-lookup"><span data-stu-id="a75b2-214">[EventProcessorHost][] provides a thread-safe, multi-process, safe runtime environment for event processor implementations that also provides checkpointing and partition lease management.</span></span>

<span data-ttu-id="a75b2-215">Az [EventProcessorHost][] osztály használatához megvalósítható az [IEventProcessor](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor).</span><span class="sxs-lookup"><span data-stu-id="a75b2-215">To use the [EventProcessorHost][] class, you can implement [IEventProcessor](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor).</span></span> <span data-ttu-id="a75b2-216">Ez a felület három metódust tartalmaz:</span><span class="sxs-lookup"><span data-stu-id="a75b2-216">This interface contains three methods:</span></span>

* [<span data-ttu-id="a75b2-217">OpenAsync</span><span class="sxs-lookup"><span data-stu-id="a75b2-217">OpenAsync</span></span>](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor#Microsoft_ServiceBus_Messaging_IEventProcessor_OpenAsync_Microsoft_ServiceBus_Messaging_PartitionContext_)
* [<span data-ttu-id="a75b2-218">CloseAsync</span><span class="sxs-lookup"><span data-stu-id="a75b2-218">CloseAsync</span></span>](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor#Microsoft_ServiceBus_Messaging_IEventProcessor_CloseAsync_Microsoft_ServiceBus_Messaging_PartitionContext_Microsoft_ServiceBus_Messaging_CloseReason_)
* [<span data-ttu-id="a75b2-219">ProcessEventsAsync</span><span class="sxs-lookup"><span data-stu-id="a75b2-219">ProcessEventsAsync</span></span>](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor#Microsoft_ServiceBus_Messaging_IEventProcessor_ProcessEventsAsync_Microsoft_ServiceBus_Messaging_PartitionContext_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_EventData__)

<span data-ttu-id="a75b2-220">Az események feldolgozásának indításához példányosítható [EventProcessorHost][], így a megfelelő paramétereket az eseményközpont.</span><span class="sxs-lookup"><span data-stu-id="a75b2-220">To start event processing, instantiate [EventProcessorHost][], providing the appropriate parameters for your event hub.</span></span> <span data-ttu-id="a75b2-221">Ezután a [RegisterEventProcessorAsync](/dotnet/api/microsoft.servicebus.messaging.eventprocessorhost#Microsoft_ServiceBus_Messaging_EventProcessorHost_RegisterEventProcessorAsync__1) meghívásával regisztrálja az [IEventProcessor](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor) megvalósítást a futtatókörnyezetben.</span><span class="sxs-lookup"><span data-stu-id="a75b2-221">Then, call [RegisterEventProcessorAsync](/dotnet/api/microsoft.servicebus.messaging.eventprocessorhost#Microsoft_ServiceBus_Messaging_EventProcessorHost_RegisterEventProcessorAsync__1) to register your [IEventProcessor](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor) implementation with the runtime.</span></span> <span data-ttu-id="a75b2-222">Ezen a ponton az állomás megpróbál bérletet a "mohó" algoritmus segítségével eseményközpont minden partícióján szerezni.</span><span class="sxs-lookup"><span data-stu-id="a75b2-222">At this point, the host will attempt to acquire a lease on every partition in the event hub using a "greedy" algorithm.</span></span> <span data-ttu-id="a75b2-223">Ezek a bérletek egy adott időtartamra szólnak, és azt követően meg kell újítani őket.</span><span class="sxs-lookup"><span data-stu-id="a75b2-223">These leases will last for a given timeframe and must then be renewed.</span></span> <span data-ttu-id="a75b2-224">Ahogy újabb csomópontok, esetünkben feldolgozópéldányok válnak online állapotúvá, bérletfoglalásokat végeznek, és idővel a terhelés elmozdul a csomópontok között, ahogy egyre több bérletet próbálnak szerezni.</span><span class="sxs-lookup"><span data-stu-id="a75b2-224">As new nodes, worker instances in this case, come online, they place lease reservations and over time the load shifts between nodes as each attempts to acquire more leases.</span></span>

![Event Processor Host](./media/event-hubs-programming-guide/IC759863.png)

<span data-ttu-id="a75b2-226">Idővel kialakul egy egyensúlyi állapot.</span><span class="sxs-lookup"><span data-stu-id="a75b2-226">Over time, an equilibrium is established.</span></span> <span data-ttu-id="a75b2-227">Ennek a dinamikus képességnek a segítségével processzoralapú automatikus skálázás alkalmazható a felhasználókra felfelé és lefelé méretezéshez egyaránt.</span><span class="sxs-lookup"><span data-stu-id="a75b2-227">This dynamic capability enables CPU-based autoscaling to be applied to consumers for both scale-up and scale-down.</span></span> <span data-ttu-id="a75b2-228">Mivel az eseményközpontok nem rendelkeznek közvetlen megoldással az üzenetek számlálásához, az átlagos processzorhasználat gyakran a legjobb módszer a háttérrendszeri vagy felhasználói lépték megállapítására.</span><span class="sxs-lookup"><span data-stu-id="a75b2-228">Because Event Hubs do not have a direct concept of message counts, average CPU utilization is often the best mechanism to measure back end or consumer scale.</span></span> <span data-ttu-id="a75b2-229">Ha a közzétevők idővel több eseményt tesznek közzé, mint amennyit a felhasználók fel tudnak dolgozni, a felhasználókon a processzor növelésével indítható el a feldolgozópéldányok számának automatikus skálázása.</span><span class="sxs-lookup"><span data-stu-id="a75b2-229">If publishers begin to publish more events than consumers can process, the CPU increase on consumers can be used to cause an auto-scale on worker instance count.</span></span>

<span data-ttu-id="a75b2-230">Az [EventProcessorHost][] osztály megvalósít továbbá egy Azure Storage-alapú ellenőrzőpont-kezelési mechanizmust is.</span><span class="sxs-lookup"><span data-stu-id="a75b2-230">The [EventProcessorHost][] class also implements an Azure storage-based checkpointing mechanism.</span></span> <span data-ttu-id="a75b2-231">A mechanizmus az eltolást partíciónkénti alapon tárolja, így mindegyik felhasználó megállapíthatja, hogy melyik volt az előző felhasználó utolsó ellenőrzőpontja.</span><span class="sxs-lookup"><span data-stu-id="a75b2-231">This mechanism stores the offset on a per partition basis, so that each consumer can determine what the last checkpoint from the previous consumer was.</span></span> <span data-ttu-id="a75b2-232">Ahogy a partíciók váltanak a csomópontok között a bérletek használatával, ez a szinkronizálási mechanizmus az, amely leginkább támogatja a terhelés áthelyezését.</span><span class="sxs-lookup"><span data-stu-id="a75b2-232">As partitions transition between nodes via leases, this is the synchronization mechanism that facilitates load shifting.</span></span>

## <a name="publisher-revocation"></a><span data-ttu-id="a75b2-233">Közzétevők visszavonása</span><span class="sxs-lookup"><span data-stu-id="a75b2-233">Publisher revocation</span></span>
<span data-ttu-id="a75b2-234">A speciális futásidejű szolgáltatásai mellett [EventProcessorHost][], az Event Hubs lehetővé teszi, hogy a közzétevők visszavonásával ahhoz, hogy adott közzétevők közzétételét egy eseményközpontba blokkolása.</span><span class="sxs-lookup"><span data-stu-id="a75b2-234">In addition to the advanced run-time features of [EventProcessorHost][], Event Hubs enables publisher revocation in order to block specific publishers from sending event to an event hub.</span></span> <span data-ttu-id="a75b2-235">Ezek a szolgáltatások akkor igazán hasznosak, ha egy közzétevői token biztonsága sérült, vagy egy szoftverfrissítés eredményeként nem megfelelően működik.</span><span class="sxs-lookup"><span data-stu-id="a75b2-235">These features are particularly useful if a publisher token has been compromised, or a software update is causing them to behave inappropriately.</span></span> <span data-ttu-id="a75b2-236">Ilyen helyzetekben a közzétevő identitása (amely a SAS-token részét képezi) blokkolható az események közzétételének a megakadályozásához.</span><span class="sxs-lookup"><span data-stu-id="a75b2-236">In these situations, the publisher's identity, which is part of their SAS token, can be blocked from publishing events.</span></span>

<span data-ttu-id="a75b2-237">A közzétevők visszavonásával és az eseményközpontokba közzétevőként való küldés módjával kapcsolatban a [Event Hubs Large Scale Secure Publishing](https://code.msdn.microsoft.com/Service-Bus-Event-Hub-99ce67ab) (Event Hubs nagyléptékű biztonságos közzététele) mintában tekinthet meg további információt.</span><span class="sxs-lookup"><span data-stu-id="a75b2-237">For more information about publisher revocation and how to send to Event Hubs as a publisher, see the [Event Hubs Large Scale Secure Publishing](https://code.msdn.microsoft.com/Service-Bus-Event-Hub-99ce67ab) sample.</span></span>

## <a name="next-steps"></a><span data-ttu-id="a75b2-238">Következő lépések</span><span class="sxs-lookup"><span data-stu-id="a75b2-238">Next steps</span></span>
<span data-ttu-id="a75b2-239">Az Event Hubs-forgatókönyvekkel kapcsolatos további információkért látogasson el a következő hivatkozásokra:</span><span class="sxs-lookup"><span data-stu-id="a75b2-239">To learn more about Event Hubs scenarios, visit these links:</span></span>

* [<span data-ttu-id="a75b2-240">Event Hubs API – áttekintés</span><span class="sxs-lookup"><span data-stu-id="a75b2-240">Event Hubs API overview</span></span>](event-hubs-api-overview.md)
* [<span data-ttu-id="a75b2-241">Mi az az Event Hubs</span><span class="sxs-lookup"><span data-stu-id="a75b2-241">What is Event Hubs</span></span>](event-hubs-what-is-event-hubs.md)
* [<span data-ttu-id="a75b2-242">Rendelkezésre állás és konzisztencia az Event Hubsban</span><span class="sxs-lookup"><span data-stu-id="a75b2-242">Availability and consistency in Event Hubs</span></span>](event-hubs-availability-and-consistency.md)
* [<span data-ttu-id="a75b2-243">Event Processor Host – API-referencia</span><span class="sxs-lookup"><span data-stu-id="a75b2-243">Event processor host API reference</span></span>](/dotnet/api/microsoft.servicebus.messaging.eventprocessorhost)

<span data-ttu-id="a75b2-244">[NamespaceManager]: /dotnet/api/microsoft.servicebus.namespacemanager</span><span class="sxs-lookup"><span data-stu-id="a75b2-244">[NamespaceManager]: /dotnet/api/microsoft.servicebus.namespacemanager</span></span>
<span data-ttu-id="a75b2-245">[EventHubClient]: /dotnet/api/microsoft.servicebus.messaging.eventhubclient</span><span class="sxs-lookup"><span data-stu-id="a75b2-245">[EventHubClient]: /dotnet/api/microsoft.servicebus.messaging.eventhubclient</span></span>
<span data-ttu-id="a75b2-246">[EventData]: /dotnet/api/microsoft.servicebus.messaging.eventdata</span><span class="sxs-lookup"><span data-stu-id="a75b2-246">[EventData]: /dotnet/api/microsoft.servicebus.messaging.eventdata</span></span>
<span data-ttu-id="a75b2-247">[CreateEventHubIfNotExists]: /dotnet/api/microsoft.servicebus.namespacemanager.createeventhubifnotexists</span><span class="sxs-lookup"><span data-stu-id="a75b2-247">[CreateEventHubIfNotExists]: /dotnet/api/microsoft.servicebus.namespacemanager.createeventhubifnotexists</span></span>
<span data-ttu-id="a75b2-248">[PartitionKey]: /dotnet/api/microsoft.servicebus.messaging.eventdata#Microsoft_ServiceBus_Messaging_EventData_PartitionKey</span><span class="sxs-lookup"><span data-stu-id="a75b2-248">[PartitionKey]: /dotnet/api/microsoft.servicebus.messaging.eventdata#Microsoft_ServiceBus_Messaging_EventData_PartitionKey</span></span>
<span data-ttu-id="a75b2-249">[EventProcessorHost]: /dotnet/api/microsoft.servicebus.messaging.eventprocessorhost</span><span class="sxs-lookup"><span data-stu-id="a75b2-249">[EventProcessorHost]: /dotnet/api/microsoft.servicebus.messaging.eventprocessorhost</span></span>
