---
title: "A Net # Neurális hálózatokat nyelv útmutató |} Microsoft Docs"
description: "A Net # Neurális szintaxisának hálózatok nyelv, és egy egyéni Neurális hálózat modell létrehozása a Microsoft Azure ML használatával Net # példák"
services: machine-learning
documentationcenter: 
author: jeannt
manager: jhubbard
editor: cgronlun
ms.assetid: cfd1454b-47df-4745-b064-ce5f9b3be303
ms.service: machine-learning
ms.workload: data-services
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 03/31/2017
ms.author: jeannt
ms.openlocfilehash: 965c60ffde55041cc3864d06d81f5590c7ea1c11
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 07/11/2017
---
# <a name="guide-to-net-neural-network-specification-language-for-azure-machine-learning"></a><span data-ttu-id="b3e05-103">Útmutató az Azure Machine Learning Net # Neurális hálózat nyelv</span><span class="sxs-lookup"><span data-stu-id="b3e05-103">Guide to Net# neural network specification language for Azure Machine Learning</span></span>
## <a name="overview"></a><span data-ttu-id="b3e05-104">Áttekintés</span><span class="sxs-lookup"><span data-stu-id="b3e05-104">Overview</span></span>
<span data-ttu-id="b3e05-105">NET #, amely a Neurális hálózat architektúrák azonosítására szolgál a Microsoft által kifejlesztett nyelvet.</span><span class="sxs-lookup"><span data-stu-id="b3e05-105">Net# is a language developed by Microsoft that is used to define neural network architectures.</span></span> <span data-ttu-id="b3e05-106">Használhatja a Net # a Microsoft Azure Machine Learning modulok Neurális hálózat.</span><span class="sxs-lookup"><span data-stu-id="b3e05-106">You can use Net# in neural network modules in Microsoft Azure Machine Learning.</span></span>

<!-- This function doesn't currentlyappear in the MicrosoftML documentation. If it is added in a future update, we can uncomment this text.

, or in the `rxNeuralNetwork()` function in [MicrosoftML](https://msdn.microsoft.com/microsoft-r/microsoftml/microsoftml). 

-->

<span data-ttu-id="b3e05-107">Ebből a cikkből megtudhatja, egy egyéni Neurális hálózat fejlesztéséhez szükséges alapvető fogalmait:</span><span class="sxs-lookup"><span data-stu-id="b3e05-107">In this article, you will learn basic concepts needed to develop a custom neural network:</span></span> 

* <span data-ttu-id="b3e05-108">Neurális hálózat követelményei és az elsődleges összetevők definiálása</span><span class="sxs-lookup"><span data-stu-id="b3e05-108">Neural network requirements and how to define the primary components</span></span>
* <span data-ttu-id="b3e05-109">A szintaxis és a Net # nyelv kulcsszavát</span><span class="sxs-lookup"><span data-stu-id="b3e05-109">The syntax and keywords of the Net# specification language</span></span>
* <span data-ttu-id="b3e05-110">Net # használatával létrehozott egyéni Neurális hálózatokat példák</span><span class="sxs-lookup"><span data-stu-id="b3e05-110">Examples of custom neural networks created using Net#</span></span> 

[!INCLUDE [machine-learning-free-trial](../../includes/machine-learning-free-trial.md)]

## <a name="neural-network-basics"></a><span data-ttu-id="b3e05-111">Neurális hálózat alapjai</span><span class="sxs-lookup"><span data-stu-id="b3e05-111">Neural network basics</span></span>
<span data-ttu-id="b3e05-112">Neurális hálózat struktúra áll ***csomópontok*** , amely vannak rendszerezve ***rétegek***, és súlyozott ***kapcsolatok*** (vagy ***szélek***) között a csomópontok.</span><span class="sxs-lookup"><span data-stu-id="b3e05-112">A neural network structure consists of ***nodes*** that are organized in ***layers***, and weighted ***connections*** (or ***edges***) between the nodes.</span></span> <span data-ttu-id="b3e05-113">A kapcsolatok irányt, és mindegyik kapcsolat egy ***forrás*** csomópont és a ***cél*** csomópont.</span><span class="sxs-lookup"><span data-stu-id="b3e05-113">The connections are directional, and each connection has a ***source*** node and a ***destination*** node.</span></span>  

<span data-ttu-id="b3e05-114">Minden egyes ***trainable réteg*** (egy rejtett vagy egy kimeneti réteg) rendelkezik egy vagy több ***kapcsolat kötegek***.</span><span class="sxs-lookup"><span data-stu-id="b3e05-114">Each ***trainable layer*** (a hidden or an output layer) has one or more ***connection bundles***.</span></span> <span data-ttu-id="b3e05-115">Egy kapcsolat köteg egy forrás réteg és a forrás réteg közötti kapcsolatok meghatározása áll.</span><span class="sxs-lookup"><span data-stu-id="b3e05-115">A connection bundle consists of a source layer and a specification of the connections from that source layer.</span></span> <span data-ttu-id="b3e05-116">Egy adott csomagban lévő összes kapcsolat megosztása azonos ***forrás réteg*** és azonos ***célfájl layer***.</span><span class="sxs-lookup"><span data-stu-id="b3e05-116">All the connections in a given bundle share the same ***source layer*** and the same ***destination layer***.</span></span> <span data-ttu-id="b3e05-117">Net # kapcsolat csomag egyik gyermekszoftver tekinthető, hogy a csomag cél réteg tartoznak.</span><span class="sxs-lookup"><span data-stu-id="b3e05-117">In Net#, a connection bundle is considered as belonging to the bundle's destination layer.</span></span>  

<span data-ttu-id="b3e05-118">NET # támogatja a különféle típusú csomagok segítségével szabhatja testre a módon bemenetek vannak leképezve a Rejtett réteg és a kimenetek leképezve.</span><span class="sxs-lookup"><span data-stu-id="b3e05-118">Net# supports various kinds of connection bundles, which lets you customize the way inputs are mapped to hidden layers and mapped to the outputs.</span></span>   

<span data-ttu-id="b3e05-119">Az alapértelmezett vagy a standard csomagot egy **teljes csomag**, az a forrás-réteg minden csomópontja csatlakozó minden csomópont, a cél rétegben.</span><span class="sxs-lookup"><span data-stu-id="b3e05-119">The default or standard bundle is a **full bundle**, in which each node in the source layer is connected to every node in the destination layer.</span></span>  

<span data-ttu-id="b3e05-120">Emellett Net # használatát támogatja a következő négy speciális kapcsolat csomagokat:</span><span class="sxs-lookup"><span data-stu-id="b3e05-120">Additionally, Net# supports the following four kinds of advanced connection bundles:</span></span>  

* <span data-ttu-id="b3e05-121">**Szűrt kötegek**.</span><span class="sxs-lookup"><span data-stu-id="b3e05-121">**Filtered bundles**.</span></span> <span data-ttu-id="b3e05-122">A felhasználó a réteg forráscsomópont és a réteg célcsomópont használatával adhatja meg a predikátum.</span><span class="sxs-lookup"><span data-stu-id="b3e05-122">The user can define a predicate by using the locations of the source layer node and the destination layer node.</span></span> <span data-ttu-id="b3e05-123">Csomópontok kapcsolódnak, amikor a predikátum értéke igaz.</span><span class="sxs-lookup"><span data-stu-id="b3e05-123">Nodes are connected whenever the predicate is True.</span></span>
* <span data-ttu-id="b3e05-124">**Convolutional csomagok**.</span><span class="sxs-lookup"><span data-stu-id="b3e05-124">**Convolutional bundles**.</span></span> <span data-ttu-id="b3e05-125">A felhasználó csomópontok kis környékeken definiálhat a forrás rétegben.</span><span class="sxs-lookup"><span data-stu-id="b3e05-125">The user can define small neighborhoods of nodes in the source layer.</span></span> <span data-ttu-id="b3e05-126">A cél rétegben minden csomópont csatlakozik-e a csomópontok a forrás rétegben egy hálózatok.</span><span class="sxs-lookup"><span data-stu-id="b3e05-126">Each node in the destination layer is connected to one neighborhood of nodes in the source layer.</span></span>
* <span data-ttu-id="b3e05-127">**Csomagok készletezését** és **válasz normalizálási kötegek**.</span><span class="sxs-lookup"><span data-stu-id="b3e05-127">**Pooling bundles** and **Response normalization bundles**.</span></span> <span data-ttu-id="b3e05-128">Ezek hasonlóak convolutional kötegek abban, hogy a felhasználó határozza meg a kis környékeken csomópontok, a forrás rétegben.</span><span class="sxs-lookup"><span data-stu-id="b3e05-128">These are similar to convolutional bundles in that the user defines small neighborhoods of nodes in the source layer.</span></span> <span data-ttu-id="b3e05-129">A különbség, hogy a súlyok ezeket a csomagokat a széleinek nincsenek trainable.</span><span class="sxs-lookup"><span data-stu-id="b3e05-129">The difference is that the weights of the edges in these bundles are not trainable.</span></span> <span data-ttu-id="b3e05-130">Ehelyett egy előre definiált függvény alkalmazzák a forrás csomópont értékek megadásával határozza meg a célként megadott értékét.</span><span class="sxs-lookup"><span data-stu-id="b3e05-130">Instead, a predefined function is applied to the source node values to determine the destination node value.</span></span>  

<span data-ttu-id="b3e05-131">Net # Neurális hálózat struktúra révén összetett struktúrák például mély Neurális hálózatokat vagy a tetszőleges dimenziók, vagyis a javításához kapcsolatos adatok, például a lemezkép, hang-, vagy videó convolutions definiálhat.</span><span class="sxs-lookup"><span data-stu-id="b3e05-131">Using Net# to define the structure of a neural network makes it possible to define complex structures such as deep neural networks or convolutions of arbitrary dimensions, which are known to improve learning on data such as image, audio, or video.</span></span>  

## <a name="supported-customizations"></a><span data-ttu-id="b3e05-132">Támogatott testreszabások</span><span class="sxs-lookup"><span data-stu-id="b3e05-132">Supported customizations</span></span>
<span data-ttu-id="b3e05-133">Az Azure Machine Learning létrehozott Neurális hálózat modellek architektúrájának nagymértékben testreszabható Net # használatával.</span><span class="sxs-lookup"><span data-stu-id="b3e05-133">The architecture of neural network models that you create in Azure Machine Learning can be extensively customized by using Net#.</span></span> <span data-ttu-id="b3e05-134">A következőket teheti:</span><span class="sxs-lookup"><span data-stu-id="b3e05-134">You can:</span></span>  

* <span data-ttu-id="b3e05-135">Rejtett rétegek készítését és minden egyes rétegben található csomópontok számának.</span><span class="sxs-lookup"><span data-stu-id="b3e05-135">Create hidden layers and control the number of nodes in each layer.</span></span>
* <span data-ttu-id="b3e05-136">Adja meg, hogyan rétegek csatlakozniuk kell egymáshoz.</span><span class="sxs-lookup"><span data-stu-id="b3e05-136">Specify how layers are to be connected to each other.</span></span>
* <span data-ttu-id="b3e05-137">Adja meg a Speciális kapcsolat struktúrák, például convolutions és a súlyozást csomagok megosztása.</span><span class="sxs-lookup"><span data-stu-id="b3e05-137">Define special connectivity structures, such as convolutions and weight sharing bundles.</span></span>
* <span data-ttu-id="b3e05-138">Adjon meg másik aktiválási funkciók.</span><span class="sxs-lookup"><span data-stu-id="b3e05-138">Specify different activation functions.</span></span>  

<span data-ttu-id="b3e05-139">További részletek a meghatározás nyelvi szintaxisa: [struktúra Specification](#Structure-specifications).</span><span class="sxs-lookup"><span data-stu-id="b3e05-139">For details of the specification language syntax, see [Structure Specification](#Structure-specifications).</span></span>  

<span data-ttu-id="b3e05-140">Néhány általános gépi tanulási a feladatok, simplex bonyolult, a Neurális hálózatokat meghatározásának tekintse meg a [példák](#Examples-of-Net#-usage).</span><span class="sxs-lookup"><span data-stu-id="b3e05-140">For examples of defining neural networks for some common machine learning tasks, from simplex to complex, see [Examples](#Examples-of-Net#-usage).</span></span>  

## <a name="general-requirements"></a><span data-ttu-id="b3e05-141">Általános követelmények</span><span class="sxs-lookup"><span data-stu-id="b3e05-141">General requirements</span></span>
* <span data-ttu-id="b3e05-142">Pontosan egy kimeneti réteg legalább egy bemeneti réteg és nulla vagy több rejtett rétegben kell.</span><span class="sxs-lookup"><span data-stu-id="b3e05-142">There must be exactly one output layer, at least one input layer, and zero or more hidden layers.</span></span> 
* <span data-ttu-id="b3e05-143">Minden egyes réteg csomópontok, tetszőleges dimenziók téglalap alakú tömbje fogalmilag rendezett rögzített számú rendelkezik.</span><span class="sxs-lookup"><span data-stu-id="b3e05-143">Each layer has a fixed number of nodes, conceptually arranged in a rectangular array of arbitrary dimensions.</span></span> 
* <span data-ttu-id="b3e05-144">Bemeneti rétegek társított képzett paraméter nélküli, és ahol példányadatokat belép a hálózatot képviselő.</span><span class="sxs-lookup"><span data-stu-id="b3e05-144">Input layers have no associated trained parameters and represent the point where instance data enters the network.</span></span> 
* <span data-ttu-id="b3e05-145">Trainable rétegek (rejtett, és a kimeneti rétegek) társított súlyok és elfogultság ismert képzett paraméterek.</span><span class="sxs-lookup"><span data-stu-id="b3e05-145">Trainable layers (the hidden and output layers) have associated trained parameters, known as weights and biases.</span></span> 
* <span data-ttu-id="b3e05-146">A forrás és cél csomópontok külön rétegekben kell lennie.</span><span class="sxs-lookup"><span data-stu-id="b3e05-146">The source and destination nodes must be in separate layers.</span></span> 
* <span data-ttu-id="b3e05-147">Kapcsolatok aciklikus; kell lennie. Ez azt jelenti nem lehet a kezdeti forráshelyen csomópont vezető kapcsolatok láncolata.</span><span class="sxs-lookup"><span data-stu-id="b3e05-147">Connections must be acyclic; in other words, there cannot be a chain of connections leading back to the initial source node.</span></span>
* <span data-ttu-id="b3e05-148">A kimeneti réteg nem lehet kapcsolat köteg forrás réteget.</span><span class="sxs-lookup"><span data-stu-id="b3e05-148">The output layer cannot be a source layer of a connection bundle.</span></span>  

## <a name="structure-specifications"></a><span data-ttu-id="b3e05-149">Struktúra specifikációk</span><span class="sxs-lookup"><span data-stu-id="b3e05-149">Structure specifications</span></span>
<span data-ttu-id="b3e05-150">Három szakaszból tevődik össze a Neurális hálózat struktúra specifikációval: a **konstans deklarációjában**, a **deklaráció réteg**, a **kapcsolat deklaráció**.</span><span class="sxs-lookup"><span data-stu-id="b3e05-150">A neural network structure specification is composed of three sections: the **constant declaration**, the **layer declaration**, the **connection declaration**.</span></span> <span data-ttu-id="b3e05-151">Szerepel továbbá egy nem kötelező **fájlmegosztás a nyilatkozatot** szakasz.</span><span class="sxs-lookup"><span data-stu-id="b3e05-151">There is also an optional **share declaration** section.</span></span> <span data-ttu-id="b3e05-152">A szakaszok bármilyen sorrendben adható meg.</span><span class="sxs-lookup"><span data-stu-id="b3e05-152">The sections can be specified in any order.</span></span>  

## <a name="constant-declaration"></a><span data-ttu-id="b3e05-153">Konstans deklarációjában</span><span class="sxs-lookup"><span data-stu-id="b3e05-153">Constant declaration</span></span>
<span data-ttu-id="b3e05-154">Egy konstans deklarációjában nem kötelező megadni.</span><span class="sxs-lookup"><span data-stu-id="b3e05-154">A constant declaration is optional.</span></span> <span data-ttu-id="b3e05-155">Ez lehetővé teszi a Neurális hálózat definíciójának máshol használt értékek megadhatók.</span><span class="sxs-lookup"><span data-stu-id="b3e05-155">It provides a means to define values used elsewhere in the neural network definition.</span></span> <span data-ttu-id="b3e05-156">A nyilatkozat utasítás áll egy egyenlőségjellel és egy érték kifejezést azonosítója.</span><span class="sxs-lookup"><span data-stu-id="b3e05-156">The declaration statement consists of an identifier followed by an equal sign and a value expression.</span></span>   

<span data-ttu-id="b3e05-157">Például a következő utasítás definiál egy állandó **x**:</span><span class="sxs-lookup"><span data-stu-id="b3e05-157">For example, the following statement defines a constant **x**:</span></span>  

    Const X = 28;  

<span data-ttu-id="b3e05-158">Egyidejűleg két vagy több állandók megadásához tegye a típusú azonosító neveket és értékeket kell használni, és pontosvesszővel válassza el egymástól elválasztani őket.</span><span class="sxs-lookup"><span data-stu-id="b3e05-158">To define two or more constants simultaneously, enclose the identifier names and values in braces, and separate them by using semicolons.</span></span> <span data-ttu-id="b3e05-159">Példa:</span><span class="sxs-lookup"><span data-stu-id="b3e05-159">For example:</span></span>  

    Const { X = 28; Y = 4; }  

<span data-ttu-id="b3e05-160">Minden egyes hozzárendelési kifejezés jobb oldalán lehet egy egész számot, egy valós szám, egy logikai érték (IGAZ vagy hamis) vagy egy kifejezésnek.</span><span class="sxs-lookup"><span data-stu-id="b3e05-160">The right-hand side of each assignment expression can be an integer, a real number, a Boolean value (True or False), or a mathematical expression.</span></span> <span data-ttu-id="b3e05-161">Példa:</span><span class="sxs-lookup"><span data-stu-id="b3e05-161">For example:</span></span>  

    Const { X = 17 * 2; Y = true; }  

## <a name="layer-declaration"></a><span data-ttu-id="b3e05-162">Réteg nyilatkozat</span><span class="sxs-lookup"><span data-stu-id="b3e05-162">Layer declaration</span></span>
<span data-ttu-id="b3e05-163">A réteg szükség esetén.</span><span class="sxs-lookup"><span data-stu-id="b3e05-163">The layer declaration is required.</span></span> <span data-ttu-id="b3e05-164">Azt határozza meg, méretének és a réteg, beleértve a kapcsolat kötegek és attribútumok forrását.</span><span class="sxs-lookup"><span data-stu-id="b3e05-164">It defines the size and source of the layer, including its connection bundles and attributes.</span></span> <span data-ttu-id="b3e05-165">A nyilatkozat utasítás kezdődik-e a neve, a réteg (bemeneti, rejtett vagy kimeneti), a dimenziók a réteg (egy pozitív egész számok rekord) követ.</span><span class="sxs-lookup"><span data-stu-id="b3e05-165">The declaration statement starts with the name of the layer (input, hidden, or output), followed by the dimensions of the layer (a tuple of positive integers).</span></span> <span data-ttu-id="b3e05-166">Példa:</span><span class="sxs-lookup"><span data-stu-id="b3e05-166">For example:</span></span>  

    input Data auto;
    hidden Hidden[5,20] from Data all;
    output Result[2] from Hidden all;  

* <span data-ttu-id="b3e05-167">A termék dimenzió a rétegben található csomópontok számának.</span><span class="sxs-lookup"><span data-stu-id="b3e05-167">The product of the dimensions is the number of nodes in the layer.</span></span> <span data-ttu-id="b3e05-168">Ebben a példában a rendszer két dimenzió [5,20], ami azt jelenti, hogy a réteg 100 csomópontok szerepelnek.</span><span class="sxs-lookup"><span data-stu-id="b3e05-168">In this example, there are two dimensions [5,20], which means there are  100 nodes in the layer.</span></span>
* <span data-ttu-id="b3e05-169">A rétegek deklarálható bármilyen sorrendben, egy kivétellel: Ha egynél több bemeneti réteg van definiálva, deklarálva van a sorrend meg kell egyeznie a szolgáltatások a bemeneti adatok sorrendjét.</span><span class="sxs-lookup"><span data-stu-id="b3e05-169">The layers can be declared in any order, with one exception: If more than one input layer is defined, the order in which they are declared must match the order of features in the input data.</span></span>  

<span data-ttu-id="b3e05-170">Adja meg, hogy egy rétegben található csomópontok számának automatikusan meghatározni a **automatikus** kulcsszó.</span><span class="sxs-lookup"><span data-stu-id="b3e05-170">To specify that the number of nodes in a layer be determined automatically, use the **auto** keyword.</span></span> <span data-ttu-id="b3e05-171">A **automatikus** kulcsszó különböző hatások, attól függően, hogy a réteg van:</span><span class="sxs-lookup"><span data-stu-id="b3e05-171">The **auto** keyword has different effects, depending on the layer:</span></span>  

* <span data-ttu-id="b3e05-172">A bemeneti réteg nyilatkozat, a csomópontok száma a szolgáltatások a bemeneti adatok száma.</span><span class="sxs-lookup"><span data-stu-id="b3e05-172">In an input layer declaration, the number of nodes is the number of features in the input data.</span></span>
* <span data-ttu-id="b3e05-173">A Rejtett réteg nyilatkozatot, a csomópontok száma az a szám, a paraméter értéke meg **rejtett csomópontok száma**.</span><span class="sxs-lookup"><span data-stu-id="b3e05-173">In a hidden layer declaration, the number of nodes is the number that is specified by the parameter value for **Number of hidden nodes**.</span></span> 
* <span data-ttu-id="b3e05-174">A kimeneti réteg nyilatkozat, a csomópontok számát: a két osztályú osztályozási, a regresszióra és a multiclass besorolási kimeneti csomópontok száma egyenlő 1 2.</span><span class="sxs-lookup"><span data-stu-id="b3e05-174">In an output layer declaration, the number of nodes is 2 for two-class classification, 1 for regression, and equal to the number of output nodes for multiclass classification.</span></span>   

<span data-ttu-id="b3e05-175">A következő hálózatdefiníció például lehetővé teszi, hogy az automatikusan meghatározott összes réteg mérete:</span><span class="sxs-lookup"><span data-stu-id="b3e05-175">For example, the following network definition allows the size of all layers to be automatically determined:</span></span>  

    input Data auto;
    hidden Hidden auto from Data all;
    output Result auto from Hidden all;  


<span data-ttu-id="b3e05-176">Egy olyan trainable réteghez (rejtett vagy kimeneti rétegek) réteg nyilatkozatot is választhatóan a kimeneti függvény (más néven az aktiválási függvény), amely alapértelmezés szerint az **sigmoid** a besorolási modell, és  **lineáris** regressziós modell.</span><span class="sxs-lookup"><span data-stu-id="b3e05-176">A layer declaration for a trainable layer (the hidden or output layers) can optionally include the output function (also called an activation function), which defaults to **sigmoid** for classification models, and **linear** for regression models.</span></span> <span data-ttu-id="b3e05-177">(Még akkor is, ha használja az alapértelmezett, akkor is explicit módon állapot aktiválás függvény jobb érthetőség kedvéért bizonyos igény.)</span><span class="sxs-lookup"><span data-stu-id="b3e05-177">(Even if you use the default, you can explicitly state the activation function, if desired for clarity.)</span></span>

<span data-ttu-id="b3e05-178">A következő kimeneti-funkciók támogatottak:</span><span class="sxs-lookup"><span data-stu-id="b3e05-178">The following output functions are supported:</span></span>  

* <span data-ttu-id="b3e05-179">sigmoid</span><span class="sxs-lookup"><span data-stu-id="b3e05-179">sigmoid</span></span>
* <span data-ttu-id="b3e05-180">lineáris</span><span class="sxs-lookup"><span data-stu-id="b3e05-180">linear</span></span>
* <span data-ttu-id="b3e05-181">softmax</span><span class="sxs-lookup"><span data-stu-id="b3e05-181">softmax</span></span>
* <span data-ttu-id="b3e05-182">rlinear</span><span class="sxs-lookup"><span data-stu-id="b3e05-182">rlinear</span></span>
* <span data-ttu-id="b3e05-183">Négyzetes</span><span class="sxs-lookup"><span data-stu-id="b3e05-183">square</span></span>
* <span data-ttu-id="b3e05-184">Sqrt</span><span class="sxs-lookup"><span data-stu-id="b3e05-184">sqrt</span></span>
* <span data-ttu-id="b3e05-185">srlinear</span><span class="sxs-lookup"><span data-stu-id="b3e05-185">srlinear</span></span>
* <span data-ttu-id="b3e05-186">ABS</span><span class="sxs-lookup"><span data-stu-id="b3e05-186">abs</span></span>
* <span data-ttu-id="b3e05-187">TANH</span><span class="sxs-lookup"><span data-stu-id="b3e05-187">tanh</span></span> 
* <span data-ttu-id="b3e05-188">brlinear</span><span class="sxs-lookup"><span data-stu-id="b3e05-188">brlinear</span></span>  

<span data-ttu-id="b3e05-189">Például a következő nyilatkozatot használ a **softmax** függvény:</span><span class="sxs-lookup"><span data-stu-id="b3e05-189">For example, the following declaration uses the **softmax** function:</span></span>  

    output Result [100] softmax from Hidden all;  

## <a name="connection-declaration"></a><span data-ttu-id="b3e05-190">Kapcsolat nyilatkozat</span><span class="sxs-lookup"><span data-stu-id="b3e05-190">Connection declaration</span></span>
<span data-ttu-id="b3e05-191">Határozza meg a trainable réteg, után azonnal meghatározta a rétegek közötti kapcsolatok kell deklarálnia.</span><span class="sxs-lookup"><span data-stu-id="b3e05-191">Immediately after defining the trainable layer, you must declare connections among the layers you have defined.</span></span> <span data-ttu-id="b3e05-192">A kapcsolat köteg deklaráció kezdődik-e a kulcsszó **a**, utána pedig a nevét a csomag forrás réteg és milyen típusú kapcsolat csomag létrehozásához.</span><span class="sxs-lookup"><span data-stu-id="b3e05-192">The connection bundle declaration starts with the keyword **from**, followed by the name of the bundle's source layer and the kind of connection bundle to create.</span></span>   

<span data-ttu-id="b3e05-193">Jelenleg kapcsolat csomagok öt típusú támogatottak:</span><span class="sxs-lookup"><span data-stu-id="b3e05-193">Currently, five kinds of connection bundles are supported:</span></span>  

* <span data-ttu-id="b3e05-194">**Teljes** csomagokat, a kulcsszó által jelzett **összes**</span><span class="sxs-lookup"><span data-stu-id="b3e05-194">**Full** bundles, indicated by the keyword **all**</span></span>
* <span data-ttu-id="b3e05-195">**Szűrt** csomagokat, a kulcsszó által jelzett **ahol**, utána pedig a predikátum kifejezés</span><span class="sxs-lookup"><span data-stu-id="b3e05-195">**Filtered** bundles, indicated by the keyword **where**, followed by a predicate expression</span></span>
* <span data-ttu-id="b3e05-196">**Convolutional** csomagokat, a kulcsszó által jelzett **convolve**, utána pedig a konvolúció attribútumok</span><span class="sxs-lookup"><span data-stu-id="b3e05-196">**Convolutional** bundles, indicated by the keyword **convolve**, followed by the convolution attributes</span></span>
* <span data-ttu-id="b3e05-197">**Készletezését** csomagokat, a kulcsszavak által jelzett **készlet maximális** vagy **készlet témakörök**</span><span class="sxs-lookup"><span data-stu-id="b3e05-197">**Pooling** bundles, indicated by the keywords **max pool** or **mean pool**</span></span>
* <span data-ttu-id="b3e05-198">**Válasz normalizálási** csomagokat, a kulcsszó által jelzett **válasz alapértelmezetté**</span><span class="sxs-lookup"><span data-stu-id="b3e05-198">**Response normalization** bundles, indicated by the keyword **response norm**</span></span>      

## <a name="full-bundles"></a><span data-ttu-id="b3e05-199">Teljes kötegek</span><span class="sxs-lookup"><span data-stu-id="b3e05-199">Full bundles</span></span>
<span data-ttu-id="b3e05-200">Egy teljes kapcsolat csomag minden csomópontjáról kapcsolatot tartalmaz, mindegyik csomópontra a cél rétegben a forrás rétegben.</span><span class="sxs-lookup"><span data-stu-id="b3e05-200">A full connection bundle includes a connection from each node in the source layer to each node in the destination layer.</span></span> <span data-ttu-id="b3e05-201">Ez az az alapértelmezett hálózati kapcsolat típusa.</span><span class="sxs-lookup"><span data-stu-id="b3e05-201">This is the default network connection type.</span></span>  

## <a name="filtered-bundles"></a><span data-ttu-id="b3e05-202">Szűrt kötegek</span><span class="sxs-lookup"><span data-stu-id="b3e05-202">Filtered bundles</span></span>
<span data-ttu-id="b3e05-203">Köteg végrehajtása szűrt kapcsolaton keresztül specifikáció tartalmazza a predikátum, szintaktikailag, kifejezett jelentős, például a C# lambda kifejezésben.</span><span class="sxs-lookup"><span data-stu-id="b3e05-203">A filtered connection bundle specification includes a predicate, expressed syntactically, much like a C# lambda expression.</span></span> <span data-ttu-id="b3e05-204">Az alábbi példa meghatározza, hogy két szűrt csomagokat:</span><span class="sxs-lookup"><span data-stu-id="b3e05-204">The following example defines two filtered bundles:</span></span>  

    input Pixels [10, 20];
    hidden ByRow[10, 12] from Pixels where (s,d) => s[0] == d[0];
    hidden ByCol[5, 20] from Pixels where (s,d) => abs(s[1] - d[1]) <= 1;  

* <span data-ttu-id="b3e05-205">A predikátum a *ByRow*, **s** képviselő index a bemeneti réteg csomópontok a téglalap alakú tömbbe paraméter *képpont*, és **d** indexet a Rejtett réteg csomópontok a tömbbe jelölő paraméter *ByRow*.</span><span class="sxs-lookup"><span data-stu-id="b3e05-205">In the predicate for *ByRow*, **s** is a parameter representing an index into the rectangular array of nodes of the input layer, *Pixels*, and **d** is a parameter representing an index into the array of nodes of the hidden layer, *ByRow*.</span></span> <span data-ttu-id="b3e05-206">Mindkét típusú **s** és **d** hosszúságú két számokból álló rekordot van.</span><span class="sxs-lookup"><span data-stu-id="b3e05-206">The type of both **s** and **d** is a tuple of integers of length two.</span></span> <span data-ttu-id="b3e05-207">Fogalmilag **s** keresztül az egész számok minden pár címtartományok *0 < = [0] s < 10* és *0 < = s[1] < 20*, és **d**  az egész számok, minden pár keresztül címtartományok *0 < = [0] d < 10* és *0 < = d[1] < 12*.</span><span class="sxs-lookup"><span data-stu-id="b3e05-207">Conceptually, **s** ranges over all pairs of integers with *0 <= s[0] < 10* and *0 <= s[1] < 20*, and **d** ranges over all pairs of integers, with *0 <= d[0] < 10* and *0 <= d[1] < 12*.</span></span> 
* <span data-ttu-id="b3e05-208">A jobb oldalon a predikátum kifejezés nincs egy feltételt.</span><span class="sxs-lookup"><span data-stu-id="b3e05-208">On the right-hand side of the predicate expression, there is a condition.</span></span> <span data-ttu-id="b3e05-209">Ebben a példában minden egyes értékéhez **s** és **d** úgy, hogy a feltétel igaz, nincs-e a réteg forráscsomópont él a célcsomópontra réteg.</span><span class="sxs-lookup"><span data-stu-id="b3e05-209">In this example, for every value of **s** and **d** such that the condition is True, there is an edge from the source layer node to the destination layer node.</span></span> <span data-ttu-id="b3e05-210">Ebből kifolyólag a szűrőkifejezés azt jelzi, hogy, hogy a csomag tartalmaz-e a kapcsolat által meghatározott csomópontról **s** a csomópont által meghatározott **d** az összes olyan esetekben, amikor s [0] [0] d egyenlőnek.</span><span class="sxs-lookup"><span data-stu-id="b3e05-210">Thus, this filter expression indicates that the bundle includes a connection from the node defined by **s** to the node defined by **d** in all cases where s[0] is equal to d[0].</span></span>  

<span data-ttu-id="b3e05-211">Másik lehetőségként a szűrt köteg súlyok készlete is megadhat.</span><span class="sxs-lookup"><span data-stu-id="b3e05-211">Optionally, you can specify a set of weights for a filtered bundle.</span></span> <span data-ttu-id="b3e05-212">Az érték a **súlyok** attribútumnak kell lennie egy rekordot a pontértékek határozzák meg a csomag kapcsolatok számának megfelelő hosszúságú lebegőpontos.</span><span class="sxs-lookup"><span data-stu-id="b3e05-212">The value for the **Weights** attribute must be a tuple of floating point values with a length that matches the number of connections defined by the bundle.</span></span> <span data-ttu-id="b3e05-213">Alapértelmezés szerint a súlyok véletlenszerűen generált.</span><span class="sxs-lookup"><span data-stu-id="b3e05-213">By default, weights are randomly generated.</span></span>  

<span data-ttu-id="b3e05-214">Súlyozási értékeket a cél csomópont indexe szerint vannak csoportosítva.</span><span class="sxs-lookup"><span data-stu-id="b3e05-214">Weight values are grouped by the destination node index.</span></span> <span data-ttu-id="b3e05-215">Ez azt jelenti, ha az első célcsomópont csatlakozik K forrás csomópontok, az első *K* elemei a **súlyok** rekordot a súlyok a első célcsomópont index forrássorendben.</span><span class="sxs-lookup"><span data-stu-id="b3e05-215">That is, if the first destination node is connected to K source nodes, the first *K* elements of the **Weights** tuple are the weights for the first destination node, in source index order.</span></span> <span data-ttu-id="b3e05-216">Ugyanez vonatkozik, a fennmaradó cél csomópontok.</span><span class="sxs-lookup"><span data-stu-id="b3e05-216">The same applies for the remaining destination nodes.</span></span>  

<span data-ttu-id="b3e05-217">Akkor adja meg a súlyok közvetlenül konstans érték lehet.</span><span class="sxs-lookup"><span data-stu-id="b3e05-217">It's possible to specify weights directly as constant values.</span></span> <span data-ttu-id="b3e05-218">Például ha korábban már megismerte a súlyok, megadhatja azokat állandók ezen szintaxis használatával:</span><span class="sxs-lookup"><span data-stu-id="b3e05-218">For example, if you learned the weights previously, you can specify them as constants using this syntax:</span></span>

    const Weights_1 = [0.0188045055, 0.130500451, ...]


## <a name="convolutional-bundles"></a><span data-ttu-id="b3e05-219">Convolutional kötegek</span><span class="sxs-lookup"><span data-stu-id="b3e05-219">Convolutional bundles</span></span>
<span data-ttu-id="b3e05-220">Ha a betanítási adatok struktúrája a homogén, convolutional kapcsolatok gyakran használják az adatok magas szintű funkciók további.</span><span class="sxs-lookup"><span data-stu-id="b3e05-220">When the training data has a homogeneous structure, convolutional connections are commonly used to learn high-level features of the data.</span></span> <span data-ttu-id="b3e05-221">Például kép, hang- vagy videó, térbeli vagy időbeli granularitása lehet az adatokat viszonylag egységes.</span><span class="sxs-lookup"><span data-stu-id="b3e05-221">For example, in image, audio, or video data, spatial or temporal dimensionality can be fairly uniform.</span></span>  

<span data-ttu-id="b3e05-222">Convolutional kötegek alkalmaz téglalap alakú **kernelek** , amely a dimenziók keresztül van ütközik.</span><span class="sxs-lookup"><span data-stu-id="b3e05-222">Convolutional bundles employ rectangular **kernels** that are slid through the dimensions.</span></span> <span data-ttu-id="b3e05-223">Tulajdonképpen minden kernel néven a helyi környékeken, alkalmazza a súlyok készletét **kernel-alkalmazásokra**.</span><span class="sxs-lookup"><span data-stu-id="b3e05-223">Essentially, each kernel defines a set of weights applied in local neighborhoods, referred to as **kernel applications**.</span></span> <span data-ttu-id="b3e05-224">A forrás rétegben, amely hivatkozunk a csomópont minden kernel alkalmazás megfelel-e a **központi csomópont**.</span><span class="sxs-lookup"><span data-stu-id="b3e05-224">Each kernel application corresponds to a node in the source layer, which is referred to as the **central node**.</span></span> <span data-ttu-id="b3e05-225">A kernel súlyozását sok kapcsolatok között vannak megosztva.</span><span class="sxs-lookup"><span data-stu-id="b3e05-225">The weights of a kernel are shared among many connections.</span></span> <span data-ttu-id="b3e05-226">Convolutional a köteg minden egyes kernel téglalap alakú pedig minden kernel-alkalmazásokra méretének.</span><span class="sxs-lookup"><span data-stu-id="b3e05-226">In a convolutional bundle, each kernel is rectangular and all kernel applications are the same size.</span></span>  

<span data-ttu-id="b3e05-227">Convolutional csomagokat támogatja a következő attribútumokat:</span><span class="sxs-lookup"><span data-stu-id="b3e05-227">Convolutional bundles support the following attributes:</span></span>

<span data-ttu-id="b3e05-228">**InputShape** határozza meg a forrás réteg dimenzióinak a convolutional köteg céljából.</span><span class="sxs-lookup"><span data-stu-id="b3e05-228">**InputShape** defines the dimensionality of the source layer for the purposes of this convolutional bundle.</span></span> <span data-ttu-id="b3e05-229">Az értéknek pozitív egész számok rekordot kell lennie.</span><span class="sxs-lookup"><span data-stu-id="b3e05-229">The value must be a tuple of positive integers.</span></span> <span data-ttu-id="b3e05-230">Az egész számok szorzatát a forrás rétegben található csomópontok számának egyenlőnek kell lennie, de egyéb, nem kell a forrás réteg deklarált dimenzióinak kereséséhez.</span><span class="sxs-lookup"><span data-stu-id="b3e05-230">The product of the integers must equal the number of nodes in the source layer, but otherwise, it does not need to match the dimensionality declared for the source layer.</span></span> <span data-ttu-id="b3e05-231">Ez a rekord hossza válik a **aritása** értékét a convolutional csomagot.</span><span class="sxs-lookup"><span data-stu-id="b3e05-231">The length of this tuple becomes the **arity** value for the convolutional bundle.</span></span> <span data-ttu-id="b3e05-232">(Általában aritása hivatkozik a számú argumentum vagy operandusok használata történt, amely egy olyan függvényt is igénybe vehet.)</span><span class="sxs-lookup"><span data-stu-id="b3e05-232">(Typically arity refers to the number of arguments or operands that a function can take.)</span></span>  

<span data-ttu-id="b3e05-233">Az alakzat és helyét. a kernelek megadásához használja az attribútumok **KernelShape**, **Stride**, **kitöltési**, **LowerPad**, és  **UpperPad**:</span><span class="sxs-lookup"><span data-stu-id="b3e05-233">To define the shape and locations of the kernels, use the attributes **KernelShape**, **Stride**, **Padding**, **LowerPad**, and **UpperPad**:</span></span>   

* <span data-ttu-id="b3e05-234">**KernelShape**: (kötelező) meghatározza a convolutional köteg minden kernel dimenzióinak.</span><span class="sxs-lookup"><span data-stu-id="b3e05-234">**KernelShape**: (required) Defines the dimensionality of each kernel for the convolutional bundle.</span></span> <span data-ttu-id="b3e05-235">Az értéknek kell lennie, amely a kötegben szereplő argumentumszámmal egyenlő hosszal pozitív egész számok rekordot.</span><span class="sxs-lookup"><span data-stu-id="b3e05-235">The value must be a tuple of positive integers with a length that equals the arity of the bundle.</span></span> <span data-ttu-id="b3e05-236">Lehet, hogy minden összetevő a rekord nem lehet nagyobb a megfelelő összetevője **InputShape**.</span><span class="sxs-lookup"><span data-stu-id="b3e05-236">Each component of this tuple must be no greater than the corresponding component of **InputShape**.</span></span> 
* <span data-ttu-id="b3e05-237">**STRIDE**: (opcionális) határozza meg, amely a központi csomópontok közötti távolság szerint (minden dimenzió egy lépésköz mérete), konvolúció mozgó lépés mérete.</span><span class="sxs-lookup"><span data-stu-id="b3e05-237">**Stride**: (optional) Defines the sliding step sizes of the convolution (one step size for each dimension), that is the distance between the central nodes.</span></span> <span data-ttu-id="b3e05-238">Az értéknek kell lennie, amely a csomag az aritása hosszal pozitív egész számok rekordot.</span><span class="sxs-lookup"><span data-stu-id="b3e05-238">The value must be a tuple of positive integers with a length that is the arity of the bundle.</span></span> <span data-ttu-id="b3e05-239">Lehet, hogy minden összetevő a rekord nem lehet nagyobb a megfelelő összetevője **KernelShape**.</span><span class="sxs-lookup"><span data-stu-id="b3e05-239">Each component of this tuple must be no greater than the corresponding component of **KernelShape**.</span></span> <span data-ttu-id="b3e05-240">Az alapértelmezett értéke egynek összes összetevőkkel rekordot.</span><span class="sxs-lookup"><span data-stu-id="b3e05-240">The default value is a tuple with all components equal to one.</span></span> 
* <span data-ttu-id="b3e05-241">**Megosztás**: (nem kötelező) határozza meg a minden egyes dimenziójának a konvolúció megosztásának súlyt.</span><span class="sxs-lookup"><span data-stu-id="b3e05-241">**Sharing**: (optional) Defines the weight sharing for each dimension of the convolution.</span></span> <span data-ttu-id="b3e05-242">Az érték lehet egy logikai érték vagy egy logikai érték, amely a csomag az aritása hosszúságú rekord.</span><span class="sxs-lookup"><span data-stu-id="b3e05-242">The value can be a single Boolean value or a tuple of Boolean values with a length that is the arity of the bundle.</span></span> <span data-ttu-id="b3e05-243">Egyetlen logikai értéket az időtartam csak a megadott értéknél összes összetevőkkel megfelelő hosszúságú rekord lehet.</span><span class="sxs-lookup"><span data-stu-id="b3e05-243">A single Boolean value is extended to be a tuple of the correct length with all components equal to the specified value.</span></span> <span data-ttu-id="b3e05-244">Az alapértelmezett érték: egy rekord, amely az összes IGAZ érték áll.</span><span class="sxs-lookup"><span data-stu-id="b3e05-244">The default value is a tuple that consists of all True values.</span></span> 
* <span data-ttu-id="b3e05-245">**MapCount**: a convolutional köteg maps szolgáltatás számát (nem kötelező) meghatározza.</span><span class="sxs-lookup"><span data-stu-id="b3e05-245">**MapCount**: (optional) Defines the number of feature maps for the convolutional bundle.</span></span> <span data-ttu-id="b3e05-246">Az érték egy pozitív egész szám vagy egy pozitív egész számok az aritása a kötegben hosszúságú rekord lehet.</span><span class="sxs-lookup"><span data-stu-id="b3e05-246">The value can be a single positive integer or a tuple of positive integers with a length that is the arity of the bundle.</span></span> <span data-ttu-id="b3e05-247">Csak egyetlen egész értéket az időtartam csak az első a megadott értéknél összetevőkkel megfelelő hosszúságú rekord lehet, és a fennmaradó összetevők egy egyenlő.</span><span class="sxs-lookup"><span data-stu-id="b3e05-247">A single integer value is extended to be a tuple of the correct length with the first components equal to the specified value and all the remaining components equal to one.</span></span> <span data-ttu-id="b3e05-248">Az alapértelmezett érték: egyet.</span><span class="sxs-lookup"><span data-stu-id="b3e05-248">The default value is one.</span></span> <span data-ttu-id="b3e05-249">Teljes száma a szolgáltatás a maps a termék a rekord összetevőt.</span><span class="sxs-lookup"><span data-stu-id="b3e05-249">The total number of feature maps is the product of the components of the tuple.</span></span> <span data-ttu-id="b3e05-250">A összetevői között és az összes faktoring meghatározza, hogy a szolgáltatás térkép értékek csoportosításának a cél csomópontok.</span><span class="sxs-lookup"><span data-stu-id="b3e05-250">The factoring of this total number across the components determines how the feature map values are grouped in the destination nodes.</span></span> 
* <span data-ttu-id="b3e05-251">**Súlyozás**: (opcionális) határozza meg a csomag kezdeti súlyok.</span><span class="sxs-lookup"><span data-stu-id="b3e05-251">**Weights**: (optional) Defines the initial weights for the bundle.</span></span> <span data-ttu-id="b3e05-252">Az érték lebegőpontos pontértékek, amely kernelek hányszor hosszal súlyok száma / kernel, a cikk későbbi részében meghatározott rekordot kell lennie.</span><span class="sxs-lookup"><span data-stu-id="b3e05-252">The value must be a tuple of floating point values with a length that is the number of kernels times the number of weights per kernel, as defined later in this article.</span></span> <span data-ttu-id="b3e05-253">Az alapértelmezett súlyozás véletlenszerűen jönnek létre.</span><span class="sxs-lookup"><span data-stu-id="b3e05-253">The default weights are randomly generated.</span></span>  

<span data-ttu-id="b3e05-254">Kitöltési,-folyamatban, egymást kölcsönösen kizáró tulajdonságok szabályozó tulajdonságok két csoportjára van:</span><span class="sxs-lookup"><span data-stu-id="b3e05-254">There are two sets of properties that control padding, the properties being mutually exclusive:</span></span>

* <span data-ttu-id="b3e05-255">**Kitöltési**: (opcionális) megállapítja e bemeneti használatával kell lenniük egy **alapértelmezett kitöltő séma**.</span><span class="sxs-lookup"><span data-stu-id="b3e05-255">**Padding**: (optional) Determines whether the input should be padded by using a **default padding scheme**.</span></span> <span data-ttu-id="b3e05-256">Az érték lehet egy logikai érték, vagy egy logikai érték, amely a csomag az aritása hosszúságú rekord lehet.</span><span class="sxs-lookup"><span data-stu-id="b3e05-256">The value can be a single Boolean value, or it can be a tuple of Boolean values with a length that is the arity of the bundle.</span></span> <span data-ttu-id="b3e05-257">Egyetlen logikai értéket az időtartam csak a megadott értéknél összes összetevőkkel megfelelő hosszúságú rekord lehet.</span><span class="sxs-lookup"><span data-stu-id="b3e05-257">A single Boolean value is extended to be a tuple of the correct length with all components equal to the specified value.</span></span> <span data-ttu-id="b3e05-258">Egy dimenzió értéke igaz, ha a forrás lesz logikailag kiegészítve az adott dimenzióban kiegészítő rendszermag alkalmazásokhoz, nulla értékű cellákkal úgy, hogy az adott dimenzióban első és utolsó kernelek központi csomópontjai legyenek a első és utolsó csomópontokat, amelyek a forrás rétegben dimenzió.</span><span class="sxs-lookup"><span data-stu-id="b3e05-258">If the value for a dimension is True, the source is logically padded in that dimension with zero-valued cells to support additional kernel applications, such that the central nodes of the first and last kernels in that dimension are the first and last nodes in that dimension in the source layer.</span></span> <span data-ttu-id="b3e05-259">Így minden dimenzió "típusú" csomópontok száma határozza meg automatikusan, pontosan megfelelően *(InputShape [d.] - 1) / Stride [d.] + 1* kernelek a tömöttnek forrás rétegbe.</span><span class="sxs-lookup"><span data-stu-id="b3e05-259">Thus, the number of "dummy" nodes in each dimension is determined automatically, to fit exactly *(InputShape[d] - 1) / Stride[d] + 1* kernels into the padded source layer.</span></span> <span data-ttu-id="b3e05-260">Egy dimenzió értéke HAMIS, ha a kernelek határozzák meg, hogy mindkét oldalon kimenő fennmaradó csomópontok száma (legfeljebb 1 különbségek) megegyezik.</span><span class="sxs-lookup"><span data-stu-id="b3e05-260">If the value for a dimension is False, the kernels are defined so that the number of nodes on each side that are left out is the same (up to a difference of 1).</span></span> <span data-ttu-id="b3e05-261">Ez az attribútum alapértelmezett értéke egy rekord összes összetevőkkel értéke FALSE.</span><span class="sxs-lookup"><span data-stu-id="b3e05-261">The default value of this attribute is a tuple with all components equal to False.</span></span>
* <span data-ttu-id="b3e05-262">**UpperPad** és **LowerPad**: (nem kötelező) adja meg nagyobb mértékben vezérelheti a használandó szövegtávolság mértéke.</span><span class="sxs-lookup"><span data-stu-id="b3e05-262">**UpperPad** and **LowerPad**: (optional) Provide greater control over the amount of padding to use.</span></span> <span data-ttu-id="b3e05-263">**Fontos:** lehet, hogy ezek az attribútumok meghatározott if és csak akkor, ha a **kitöltési** fenti tulajdonság ***nem*** definiálva.</span><span class="sxs-lookup"><span data-stu-id="b3e05-263">**Important:** These attributes can be defined if and only if the **Padding** property above is ***not*** defined.</span></span> <span data-ttu-id="b3e05-264">Az értékeket, amelyek a kötegben szereplő argumentumszámmal hosszúságú egész rekordokat kell lennie.</span><span class="sxs-lookup"><span data-stu-id="b3e05-264">The values should be integer-valued tuples with lengths that are the arity of the bundle.</span></span> <span data-ttu-id="b3e05-265">Ha ezek az attribútumok meg van adva, "típusú" csomópontokat ad hozzá a bemeneti réteg minden dimenzió az alsó és felső végén.</span><span class="sxs-lookup"><span data-stu-id="b3e05-265">When these attributes are specified, "dummy" nodes are added to the lower and upper ends of each dimension of the input layer.</span></span> <span data-ttu-id="b3e05-266">Minden dimenzió az alsó és felső végződik hozzáadandó csomópontok száma határozza meg **LowerPad**[i] és **UpperPad**[i] osztályban.</span><span class="sxs-lookup"><span data-stu-id="b3e05-266">The number of nodes added to the lower and upper ends in each dimension is determined by **LowerPad**[i] and **UpperPad**[i] respectively.</span></span> <span data-ttu-id="b3e05-267">Biztosítsa, hogy kernelek csak "tényleges" és "típusú" csomópont nem az, hogy a következő feltételeknek kell teljesülniük:</span><span class="sxs-lookup"><span data-stu-id="b3e05-267">To ensure that kernels correspond only to "real" nodes and not to "dummy" nodes, the following conditions must be met:</span></span>
  * <span data-ttu-id="b3e05-268">Az egyes összetevők **LowerPad** KernelShape [d.] szigorúan kisebbnek kell lennie 2.</span><span class="sxs-lookup"><span data-stu-id="b3e05-268">Each component of **LowerPad** must be strictly less than KernelShape[d]/2.</span></span> 
  * <span data-ttu-id="b3e05-269">Az egyes összetevők **UpperPad** nem nagyobbnak kell lennie [d.] KernelShape / 2.</span><span class="sxs-lookup"><span data-stu-id="b3e05-269">Each component of **UpperPad** must be no greater than KernelShape[d]/2.</span></span> 
  * <span data-ttu-id="b3e05-270">Ezek az attribútumok alapértelmezett értéke egy rekord összes összetevőkkel, mint 0.</span><span class="sxs-lookup"><span data-stu-id="b3e05-270">The default value of these attributes is a tuple with all components equal to 0.</span></span> 

<span data-ttu-id="b3e05-271">A beállítás **kitöltési** = true lehetővé teszi, hogy a legtöbb kitöltési tartani "" a kernel belső "valós" bemeneti szükséges.</span><span class="sxs-lookup"><span data-stu-id="b3e05-271">The setting **Padding** = true allows as much padding as is needed to keep the "center" of the kernel inside the "real" input.</span></span> <span data-ttu-id="b3e05-272">A kimeneti méretének kiszámításához kicsit matematikai értékre változik.</span><span class="sxs-lookup"><span data-stu-id="b3e05-272">This changes the math a bit for computing the output size.</span></span> <span data-ttu-id="b3e05-273">Általában a kimeneti méretének *D* számítja ki, hogy *D = (I - K) / S + 1*, ahol *I* bemeneti mérete *K* kernel mérete *S*  van a stride és  */*  szám (szám nullához) van.</span><span class="sxs-lookup"><span data-stu-id="b3e05-273">Generally, the output size *D* is computed as *D = (I - K) / S + 1*, where *I* is the input size, *K* is the kernel size, *S* is the stride, and */* is integer division (round toward zero).</span></span> <span data-ttu-id="b3e05-274">Ha UpperPad = [1, 1], a bemeneti mérete *I* tulajdonképpen 29, és így *D = (29-5) / 2 + 1 = 13*.</span><span class="sxs-lookup"><span data-stu-id="b3e05-274">If you set UpperPad = [1, 1], the input size *I* is effectively 29, and thus *D = (29 - 5) / 2 + 1 = 13*.</span></span> <span data-ttu-id="b3e05-275">Azonban, amikor **kitöltési** lényegében = true, *I* által kap bumped *K - 1*; ezért *D = ((28 + 4) - 5) / 2 + 1 = 27 / 2 + 1 = 13 + 1 = 14*.</span><span class="sxs-lookup"><span data-stu-id="b3e05-275">However, when **Padding** = true, essentially *I* gets bumped up by *K - 1*; hence *D = ((28 + 4) - 5) / 2 + 1 = 27 / 2 + 1 = 13 + 1 = 14*.</span></span> <span data-ttu-id="b3e05-276">Az értékek megadásával **UpperPad** és **LowerPad** elérhetővé, mint ha csupán be a térközt több ellenőrzést **kitöltési** = true.</span><span class="sxs-lookup"><span data-stu-id="b3e05-276">By specifying values for **UpperPad** and **LowerPad** you get much more control over the padding than if you just set **Padding** = true.</span></span>

<span data-ttu-id="b3e05-277">Convolutional hálózatok és az alkalmazásokkal kapcsolatos további információkért lásd: ezek a cikkek:</span><span class="sxs-lookup"><span data-stu-id="b3e05-277">For more information about convolutional networks and their applications, see these articles:</span></span>  

* [<span data-ttu-id="b3e05-278">http://deeplearning.NET/Tutorial/lenet.HTML</span><span class="sxs-lookup"><span data-stu-id="b3e05-278">http://deeplearning.net/tutorial/lenet.html </span></span>](http://deeplearning.net/tutorial/lenet.html)
* [<span data-ttu-id="b3e05-279">http://Research.microsoft.com/Pubs/68920/icdar03.PDF</span><span class="sxs-lookup"><span data-stu-id="b3e05-279">http://research.microsoft.com/pubs/68920/icdar03.pdf</span></span>](http://research.microsoft.com/pubs/68920/icdar03.pdf) 
* [<span data-ttu-id="b3e05-280">http://People.csail.Mit.edu/jvb/Papers/cnn_tutorial.PDF</span><span class="sxs-lookup"><span data-stu-id="b3e05-280">http://people.csail.mit.edu/jvb/papers/cnn_tutorial.pdf</span></span>](http://people.csail.mit.edu/jvb/papers/cnn_tutorial.pdf)  

## <a name="pooling-bundles"></a><span data-ttu-id="b3e05-281">Csomagok készletezése</span><span class="sxs-lookup"><span data-stu-id="b3e05-281">Pooling bundles</span></span>
<span data-ttu-id="b3e05-282">A **köteg készletezését** vonatkozik geometriai hasonló convolutional kapcsolatot, de forrás csomópont értékek előre meghatározott funkciókat használ kapcsolattípusokból a cél a csomópont-érték.</span><span class="sxs-lookup"><span data-stu-id="b3e05-282">A **pooling bundle** applies geometry similar to convolutional connectivity, but it uses predefined functions to source node values to derive the destination node value.</span></span> <span data-ttu-id="b3e05-283">Emiatt készletezésével kötegek rendelkezik (súlyok vagy elfogultság) trainable állapot nélküli.</span><span class="sxs-lookup"><span data-stu-id="b3e05-283">Hence, pooling bundles have no trainable state (weights or biases).</span></span> <span data-ttu-id="b3e05-284">Egyesítési csomagokat támogatja kivételével minden convolutional attribútumot **megosztás**, **MapCount**, és **súlyok**.</span><span class="sxs-lookup"><span data-stu-id="b3e05-284">Pooling bundles support all the convolutional attributes except **Sharing**, **MapCount**, and **Weights**.</span></span>  

<span data-ttu-id="b3e05-285">Általában a szomszédos készletezésével egységek összesített kernelek nem lehetnek átfedésben.</span><span class="sxs-lookup"><span data-stu-id="b3e05-285">Typically, the kernels summarized by adjacent pooling units do not overlap.</span></span> <span data-ttu-id="b3e05-286">Ha Stride [d] [d] KernelShape minden dimenzió, a kapott réteg a hagyományos helyi készletezésével szintje, amely általában alkalmazottja convolutional Neurális hálózatokat.</span><span class="sxs-lookup"><span data-stu-id="b3e05-286">If Stride[d] is equal to KernelShape[d] in each dimension, the layer obtained is the traditional local pooling layer, which is commonly employed in convolutional neural networks.</span></span> <span data-ttu-id="b3e05-287">Minden célcsomópont kiszámítja a maximális vagy a forrás rétegben a kernel tevékenységeit középértéke.</span><span class="sxs-lookup"><span data-stu-id="b3e05-287">Each destination node computes the maximum or the mean of the activities of its kernel in the source layer.</span></span>  

<span data-ttu-id="b3e05-288">Az alábbi példában látható készletezésével csomagot:</span><span class="sxs-lookup"><span data-stu-id="b3e05-288">The following example illustrates a pooling bundle:</span></span> 

    hidden P1 [5, 12, 12]
      from C1 max pool {
        InputShape  = [ 5, 24, 24];
        KernelShape = [ 1,  2,  2];
        Stride      = [ 1,  2,  2];
      }  

* <span data-ttu-id="b3e05-289">A csomag az aritása a következő: 3 (a rekordokat hosszát **InputShape**, **KernelShape**, és **Stride**).</span><span class="sxs-lookup"><span data-stu-id="b3e05-289">The arity of the bundle is 3 (the length of the tuples **InputShape**, **KernelShape**, and **Stride**).</span></span> 
* <span data-ttu-id="b3e05-290">A forrás rétegben csomópontok száma *5 * 24 * 24 = 2880*.</span><span class="sxs-lookup"><span data-stu-id="b3e05-290">The number of nodes in the source layer is *5 * 24 * 24 = 2880*.</span></span> 
* <span data-ttu-id="b3e05-291">Ennek oka egy hagyományos helyi készletezésével réteg **KernelShape** és **Stride** egyenlő.</span><span class="sxs-lookup"><span data-stu-id="b3e05-291">This is a traditional local pooling layer because **KernelShape** and **Stride** are equal.</span></span> 
* <span data-ttu-id="b3e05-292">A cél rétegben csomópontok száma *5 * 12 * 12 = 1440*.</span><span class="sxs-lookup"><span data-stu-id="b3e05-292">The number of nodes in the destination layer is *5 * 12 * 12 = 1440*.</span></span>  

<span data-ttu-id="b3e05-293">Egyesítési rétegek kapcsolatos további információkért lásd: ezek a cikkek:</span><span class="sxs-lookup"><span data-stu-id="b3e05-293">For more information about pooling layers, see these articles:</span></span>  

* <span data-ttu-id="b3e05-294">[http://www.cs.Toronto.edu/~hinton/absps/imagenet.PDF](http://www.cs.toronto.edu/~hinton/absps/imagenet.pdf) (szakaszban 3.4)</span><span class="sxs-lookup"><span data-stu-id="b3e05-294">[http://www.cs.toronto.edu/~hinton/absps/imagenet.pdf](http://www.cs.toronto.edu/~hinton/absps/imagenet.pdf) (Section 3.4)</span></span>
* [<span data-ttu-id="b3e05-295">http://cs.nyu.edu/~koray/publis/lecun-iscas-10.PDF</span><span class="sxs-lookup"><span data-stu-id="b3e05-295">http://cs.nyu.edu/~koray/publis/lecun-iscas-10.pdf</span></span>](http://cs.nyu.edu/~koray/publis/lecun-iscas-10.pdf) 
* [<span data-ttu-id="b3e05-296">http://cs.nyu.edu/~koray/publis/jarrett-iccv-09.PDF</span><span class="sxs-lookup"><span data-stu-id="b3e05-296">http://cs.nyu.edu/~koray/publis/jarrett-iccv-09.pdf</span></span>](http://cs.nyu.edu/~koray/publis/jarrett-iccv-09.pdf)

## <a name="response-normalization-bundles"></a><span data-ttu-id="b3e05-297">Válasz normalizálási kötegek</span><span class="sxs-lookup"><span data-stu-id="b3e05-297">Response normalization bundles</span></span>
<span data-ttu-id="b3e05-298">**Válasz normalizálási** egy helyi normalizálási rendszer Geoffrey Hinton, először bevezetett és mások, a dokumentum [ImageNet Classiﬁcation Convolutional Neurális hálózatokat a](http://www.cs.toronto.edu/~hinton/absps/imagenet.pdf).</span><span class="sxs-lookup"><span data-stu-id="b3e05-298">**Response normalization** is a local normalization scheme that was first introduced by Geoffrey Hinton, et al, in the paper [ImageNet Classiﬁcation with Deep Convolutional Neural Networks](http://www.cs.toronto.edu/~hinton/absps/imagenet.pdf).</span></span> <span data-ttu-id="b3e05-299">Válasz normalizálási Neurális hálók általánosítása elősegítésére szolgál.</span><span class="sxs-lookup"><span data-stu-id="b3e05-299">Response normalization is used to aid generalization in neural nets.</span></span> <span data-ttu-id="b3e05-300">Amikor egy idegsejt aktiválási nagyon magas szintű folyamatban van, egy helyi válasz normalizálási réteg mellőzi a környező idegsejtek csoportjának viselkedését aktiválási szintjét.</span><span class="sxs-lookup"><span data-stu-id="b3e05-300">When one neuron is firing at a very high activation level, a local response normalization layer suppresses the activation level of the surrounding neurons.</span></span> <span data-ttu-id="b3e05-301">Ehhez három paraméterekkel (***α***, ***β***, és ***k***) és egy convolutional struktúra (vagy hálózatok alakzat).</span><span class="sxs-lookup"><span data-stu-id="b3e05-301">This is done by using three parameters (***α***, ***β***, and ***k***) and a convolutional structure (or neighborhood shape).</span></span> <span data-ttu-id="b3e05-302">A cél rétegben minden idegsejt ***y*** idegsejt megfelel ***x*** a forrás rétegben.</span><span class="sxs-lookup"><span data-stu-id="b3e05-302">Every neuron in the destination layer ***y*** corresponds to a neuron ***x*** in the source layer.</span></span> <span data-ttu-id="b3e05-303">Az aktiválási szintű ***y*** képlettel a következő, ahol ***f*** idegsejt, az aktiválási szintje és ***Nx*** a kernel (vagy a készlet, amely tartalmazza a idegsejtek csoportjának viselkedését a a a helyek ***x***), a következő convolutional struktúra által meghatározott módon:</span><span class="sxs-lookup"><span data-stu-id="b3e05-303">The activation level of ***y*** is given by the following formula, where ***f*** is the activation level of a neuron, and ***Nx*** is the kernel (or the set that contains the neurons in the neighborhood of ***x***), as defined by the following convolutional structure:</span></span>  

![][1]  

<span data-ttu-id="b3e05-304">Válasz normalizálási kötegek támogatja a convolutional attribútumok kivéve **megosztás**, **MapCount**, és **súlyok**.</span><span class="sxs-lookup"><span data-stu-id="b3e05-304">Response normalization bundles support all the convolutional attributes except **Sharing**, **MapCount**, and **Weights**.</span></span>  

* <span data-ttu-id="b3e05-305">Ha a kernel tartalmazza-e, azonos leképezés idegsejtek csoportjának viselkedését ***x***, a rendszer séma nevezzük **normalizálási képezi le azonos**.</span><span class="sxs-lookup"><span data-stu-id="b3e05-305">If the kernel contains neurons in the same map as ***x***, the normalization scheme is referred to as **same map normalization**.</span></span> <span data-ttu-id="b3e05-306">Azonos térkép normalizálási, az első koordináta meghatározásához **InputShape** 1 értéket kell megadni.</span><span class="sxs-lookup"><span data-stu-id="b3e05-306">To define same map normalization, the first coordinate in **InputShape** must have the value 1.</span></span>
* <span data-ttu-id="b3e05-307">Ha a kernel tartalmazza-e az azonos térbeli helyzetben idegsejtek csoportjának viselkedését ***x***, de a idegsejtek csoportjának viselkedését a maps-más, a rendszer séma neve **keresztben leképezi a normalizálási**.</span><span class="sxs-lookup"><span data-stu-id="b3e05-307">If the kernel contains neurons in the same spatial position as ***x***, but the neurons are in other maps, the normalization scheme is called **across maps normalization**.</span></span> <span data-ttu-id="b3e05-308">Az ilyen típusú válasz normalizálási egy formája, amelyet a típus van a valós idegsejtek csoportjának viselkedését, többek között a különböző térképeken számított idegsejt kimenetek nagy aktiválási szintjeinek verseny létrehozása inspirálta oldalirányú gátló valósítja meg.</span><span class="sxs-lookup"><span data-stu-id="b3e05-308">This type of response normalization implements a form of lateral inhibition inspired by the type found in real neurons, creating competition for big activation levels amongst neuron outputs computed on different maps.</span></span> <span data-ttu-id="b3e05-309">Meghatározásához maps normalizálási között, az első koordináta nagyobb, mint egy és a maps száma nem lehet nagyobb egész számnak kell lennie, és a koordináták a többi 1 értéket kell megadni.</span><span class="sxs-lookup"><span data-stu-id="b3e05-309">To define across maps normalization, the first coordinate must be an integer greater than one and no greater than the number of maps, and the rest of the coordinates must have the value 1.</span></span>  

<span data-ttu-id="b3e05-310">Válasz normalizálási csomagok forrás csomópont értékek megadásával határozza meg a cél csomópont érték előre definiált függvényt alkalmazni, mert nincs trainable állapot (súlyok vagy elfogultság) rendelkeznek.</span><span class="sxs-lookup"><span data-stu-id="b3e05-310">Because response normalization bundles apply a predefined function to source node values to determine the destination node value, they have no trainable state (weights or biases).</span></span>   

<span data-ttu-id="b3e05-311">**Riasztási**: A csomópontok a cél rétegben idegsejtek csoportjának viselkedését, amelyek a kernelek központi csomópont felel meg.</span><span class="sxs-lookup"><span data-stu-id="b3e05-311">**Alert**: The nodes in the destination layer correspond to neurons that are the central nodes of the kernels.</span></span> <span data-ttu-id="b3e05-312">Például, ha a [d] KernelShape páratlan, majd *KernelShape [d.] / 2* felel meg a központi kernel csomópont.</span><span class="sxs-lookup"><span data-stu-id="b3e05-312">For example, if KernelShape[d] is odd, then *KernelShape[d]/2* corresponds to the central kernel node.</span></span> <span data-ttu-id="b3e05-313">Ha *KernelShape [d.]* az még akkor is, a központi csomópont *KernelShape [d.] / 2-1*.</span><span class="sxs-lookup"><span data-stu-id="b3e05-313">If *KernelShape[d]* is even, the central node is at *KernelShape[d]/2 - 1*.</span></span> <span data-ttu-id="b3e05-314">Ezért ha **kitöltési**[d.] értéke HAMIS, az első és az utolsó *KernelShape [d.] / 2* csomópontok nem rendelkeznek megfelelő csomópontokat a cél rétegben.</span><span class="sxs-lookup"><span data-stu-id="b3e05-314">Therefore, if **Padding**[d] is False, the first and the last *KernelShape[d]/2* nodes do not have corresponding nodes in the destination layer.</span></span> <span data-ttu-id="b3e05-315">Ez a helyzet elkerülése érdekében adja meg a **kitöltési** mint [értéke true, true,..., igaz].</span><span class="sxs-lookup"><span data-stu-id="b3e05-315">To avoid this situation, define **Padding** as [true, true, …, true].</span></span>  

<span data-ttu-id="b3e05-316">A korábban ismertetett négy attribútumok mellett válasz normalizálási csomagok is támogatja a következő attribútumok:</span><span class="sxs-lookup"><span data-stu-id="b3e05-316">In addition to the four attributes described earlier, response normalization bundles also support the following attributes:</span></span>  

* <span data-ttu-id="b3e05-317">**Alpha**: (kötelező) adja meg egy lebegőpontos érték, amely megfelelne a ***α*** a korábbi képletben.</span><span class="sxs-lookup"><span data-stu-id="b3e05-317">**Alpha**: (required) Specifies a floating-point value that corresponds to ***α*** in the previous formula.</span></span> 
* <span data-ttu-id="b3e05-318">**Beta**: (kötelező) adja meg egy lebegőpontos érték, amely megfelelne a ***β*** a korábbi képletben.</span><span class="sxs-lookup"><span data-stu-id="b3e05-318">**Beta**: (required) Specifies a floating-point value that corresponds to ***β*** in the previous formula.</span></span> 
* <span data-ttu-id="b3e05-319">**Eltolás**: (nem kötelező) adja meg egy lebegőpontos érték, amely megfelelne a ***k*** a korábbi képletben.</span><span class="sxs-lookup"><span data-stu-id="b3e05-319">**Offset**: (optional) Specifies a floating-point value that corresponds to ***k*** in the previous formula.</span></span> <span data-ttu-id="b3e05-320">Alapértelmezés szerint az 1.</span><span class="sxs-lookup"><span data-stu-id="b3e05-320">It defaults to 1.</span></span>  

<span data-ttu-id="b3e05-321">A következő példa egy válasz normalizálási köteg ezek az attribútumok használatával határozza meg:</span><span class="sxs-lookup"><span data-stu-id="b3e05-321">The following example defines a response normalization bundle using these attributes:</span></span>  

    hidden RN1 [5, 10, 10]
      from P1 response norm {
        InputShape  = [ 5, 12, 12];
        KernelShape = [ 1,  3,  3];
        Alpha = 0.001;
        Beta = 0.75;
      }  

* <span data-ttu-id="b3e05-322">A forrás réteg öt 12 x 12 1440 csomópontok összesítés aof léptékű maps tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="b3e05-322">The source layer includes five maps, each with aof dimension of 12x12, totaling in 1440 nodes.</span></span> 
* <span data-ttu-id="b3e05-323">Értékének **KernelShape** jelzi, hogy ez egy azonos normalizálási térképréteg, ahol a pontos 3 x 3 téglalap az.</span><span class="sxs-lookup"><span data-stu-id="b3e05-323">The value of **KernelShape** indicates that this is a same map normalization layer, where the neighborhood is a 3x3 rectangle.</span></span> 
* <span data-ttu-id="b3e05-324">Az alapértelmezett érték **kitöltési** értéke HAMIS, a célfájl layer csak 10 csomópontok be van minden dimenzió.</span><span class="sxs-lookup"><span data-stu-id="b3e05-324">The default value of **Padding** is False, thus the destination layer has only 10 nodes in each dimension.</span></span> <span data-ttu-id="b3e05-325">Egy csomópont a cél rétegben, amely megfelel a forrás-réteg minden csomópontja egészítse kitöltési = [true, true, true]; és RN1 méretének módosítása [5, 12, 12].</span><span class="sxs-lookup"><span data-stu-id="b3e05-325">To include one node in the destination layer that corresponds to every node in the source layer, add Padding = [true, true, true]; and change the size of RN1 to [5, 12, 12].</span></span>  

## <a name="share-declaration"></a><span data-ttu-id="b3e05-326">Fájlmegosztás a nyilatkozatot</span><span class="sxs-lookup"><span data-stu-id="b3e05-326">Share declaration</span></span>
<span data-ttu-id="b3e05-327">NET # opcionálisan is támogatja a megosztott súlyozással több csomagokat.</span><span class="sxs-lookup"><span data-stu-id="b3e05-327">Net# optionally supports defining multiple bundles with shared weights.</span></span> <span data-ttu-id="b3e05-328">A súlyok bármely két kötegek megoszthatók, ha azok struktúrák azonos.</span><span class="sxs-lookup"><span data-stu-id="b3e05-328">The weights of any two bundles can be shared if their structures are the same.</span></span> <span data-ttu-id="b3e05-329">A következő szintaxist a megosztott súlyozással rendelkező csomagok határozza meg:</span><span class="sxs-lookup"><span data-stu-id="b3e05-329">The following syntax defines bundles with shared weights:</span></span>  

    share-declaration:
        share    {    layer-list    }
        share    {    bundle-list    }
       share    {    bias-list    }

    layer-list:
        layer-name    ,    layer-name
        layer-list    ,    layer-name

    bundle-list:
       bundle-spec    ,    bundle-spec
        bundle-list    ,    bundle-spec

    bundle-spec:
       layer-name    =>     layer-name

    bias-list:
        bias-spec    ,    bias-spec
        bias-list    ,    bias-spec

    bias-spec:
        1    =>    layer-name

    layer-name:
        identifier  

<span data-ttu-id="b3e05-330">Például a következő megosztás-adja meg a réteg nevek, amely azt jelzi, hogy a súlyok és a elfogultság megosztott:</span><span class="sxs-lookup"><span data-stu-id="b3e05-330">For example, the following share-declaration specifies the layer names, indicating that both weights and biases should be shared:</span></span>  

    Const {
      InputSize = 37;
      HiddenSize = 50;
    }
    input {
      Data1 [InputSize];
      Data2 [InputSize];
    }
    hidden {
      H1 [HiddenSize] from Data1 all;
      H2 [HiddenSize] from Data2 all;
    }
    output Result [2] {
      from H1 all;
      from H2 all;
    }
    share { H1, H2 } // share both weights and biases  

* <span data-ttu-id="b3e05-331">A bemeneti szolgáltatások particionáltak két egyenlő méretű bemeneti rétegben.</span><span class="sxs-lookup"><span data-stu-id="b3e05-331">The input features are partitioned into two equal sized input layers.</span></span> 
* <span data-ttu-id="b3e05-332">A Rejtett réteg majd számítási a két bemeneti rétegek magasabb szintű funkciók.</span><span class="sxs-lookup"><span data-stu-id="b3e05-332">The hidden layers then compute higher level features on the two input layers.</span></span> 
* <span data-ttu-id="b3e05-333">A megosztás-deklaráció azt jelenti, hogy *H1* és *H2* a a megfelelő bemenetei ugyanúgy kell számolni.</span><span class="sxs-lookup"><span data-stu-id="b3e05-333">The share-declaration specifies that *H1* and *H2* must be computed in the same way from their respective inputs.</span></span>  

<span data-ttu-id="b3e05-334">Azt is megteheti ez sikerült lehet megadni két külön megosztás-deklarációk az alábbiak szerint:</span><span class="sxs-lookup"><span data-stu-id="b3e05-334">Alternatively, this could be specified with two separate share-declarations as follows:</span></span>  

    share { Data1 => H1, Data2 => H2 } // share weights  

<!-- -->

    share { 1 => H1, 1 => H2 } // share biases  

<span data-ttu-id="b3e05-335">A rövid alak: / is használhatja, csak ha a rétegek csomagban szerepel.</span><span class="sxs-lookup"><span data-stu-id="b3e05-335">You can use the short form only when the layers contain a single bundle.</span></span> <span data-ttu-id="b3e05-336">Megosztás általában lehetséges csak akkor, ha a megfelelő struktúra megegyezik, ami azt jelenti, hogy rendelkeznek a azonos méretűnek, azonos convolutional geometriai és így tovább.</span><span class="sxs-lookup"><span data-stu-id="b3e05-336">In general, sharing is possible only when the relevant structure is identical, meaning that they have the same size, same convolutional geometry, and so forth.</span></span>  

## <a name="examples-of-net-usage"></a><span data-ttu-id="b3e05-337">Net # használati példák</span><span class="sxs-lookup"><span data-stu-id="b3e05-337">Examples of Net# usage</span></span>
<span data-ttu-id="b3e05-338">Ez a témakör néhány példa arra, hogyan használhatja a Net # rejtett réteg hozzáadásához meghatározhatja, hogy a Rejtett réteg más rétegeiből kommunikál, és állítsa be convolutional hálózatok.</span><span class="sxs-lookup"><span data-stu-id="b3e05-338">This section provides some examples of how you can use Net# to add hidden layers, define the way that hidden layers interact with other layers, and build convolutional networks.</span></span>   

### <a name="define-a-simple-custom-neural-network-hello-world-example"></a><span data-ttu-id="b3e05-339">Adja meg egy egyszerű egyéni Neurális hálózat: "Hello, World" – példa</span><span class="sxs-lookup"><span data-stu-id="b3e05-339">Define a simple custom neural network: "Hello World" example</span></span>
<span data-ttu-id="b3e05-340">Ez egyszerű példa bemutatja, hogyan, amely rendelkezik egy rejtett rétegben Neurális hálózat modell létrehozásához.</span><span class="sxs-lookup"><span data-stu-id="b3e05-340">This simple example demonstrates how to create a neural network model that has a single hidden layer.</span></span>  

    input Data auto;
    hidden H [200] from Data all;
    output Out [10] sigmoid from H all;  

<span data-ttu-id="b3e05-341">A példa bemutatja, néhány alapvető parancsok az alábbiak szerint:</span><span class="sxs-lookup"><span data-stu-id="b3e05-341">The example illustrates some basic commands as follows:</span></span>  

* <span data-ttu-id="b3e05-342">Az első sor meghatározza a bemeneti réteg (nevű *adatok*).</span><span class="sxs-lookup"><span data-stu-id="b3e05-342">The first line defines the input layer (named *Data*).</span></span> <span data-ttu-id="b3e05-343">Ha a **automatikus** kulcsszóval, a Neurális hálózat automatikusan felveszi a szolgáltatás az összes oszlop a bemeneti példák.</span><span class="sxs-lookup"><span data-stu-id="b3e05-343">When you use the  **auto** keyword, the neural network automatically includes all feature columns in the input examples.</span></span> 
* <span data-ttu-id="b3e05-344">A második sor hoz létre a rejtett rétegben.</span><span class="sxs-lookup"><span data-stu-id="b3e05-344">The second line creates the hidden layer.</span></span> <span data-ttu-id="b3e05-345">A név *H* a rejtett rétegben, amely 200 csomópont van rendelve.</span><span class="sxs-lookup"><span data-stu-id="b3e05-345">The name *H* is assigned to the hidden layer, which has 200 nodes.</span></span> <span data-ttu-id="b3e05-346">Ez a réteg teljesen csatlakozni a bemeneti réteg.</span><span class="sxs-lookup"><span data-stu-id="b3e05-346">This layer is fully connected to the input layer.</span></span>
* <span data-ttu-id="b3e05-347">A harmadik sorban határozza meg a kimeneti réteg (nevű *O*), 10 kimeneti csomópontok, amely tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="b3e05-347">The third line defines the output layer (named *O*), which contains 10 output nodes.</span></span> <span data-ttu-id="b3e05-348">Neurális hálózat besorolást használják, ha van egy kimeneti csomópont / osztály.</span><span class="sxs-lookup"><span data-stu-id="b3e05-348">If the neural network is used for classification, there is one output node per class.</span></span> <span data-ttu-id="b3e05-349">A kulcsszó **sigmoid** azt jelzi, hogy a kimeneti függvénynek a kimeneti réteg van hozzárendelve.</span><span class="sxs-lookup"><span data-stu-id="b3e05-349">The keyword **sigmoid** indicates that the output function is applied to the output layer.</span></span>   

### <a name="define-multiple-hidden-layers-computer-vision-example"></a><span data-ttu-id="b3e05-350">Adja meg a több rejtett réteg: számítógép átfogóan bemutató példa</span><span class="sxs-lookup"><span data-stu-id="b3e05-350">Define multiple hidden layers: computer vision example</span></span>
<span data-ttu-id="b3e05-351">A következő példa bemutatja, hogyan adhat meg egy kicsit bonyolultabb Neurális hálózat, a több egyéni rejtett réteg.</span><span class="sxs-lookup"><span data-stu-id="b3e05-351">The following example demonstrates how to define a slightly more complex neural network, with multiple custom hidden layers.</span></span>  

    // Define the input layers 
    input Pixels [10, 20];
    input MetaData [7];

    // Define the first two hidden layers, using data only from the Pixels input
    hidden ByRow [10, 12] from Pixels where (s,d) => s[0] == d[0];
    hidden ByCol [5, 20] from Pixels where (s,d) => abs(s[1] - d[1]) <= 1;

    // Define the third hidden layer, which uses as source the hidden layers ByRow and ByCol
    hidden Gather [100] 
    {
      from ByRow all;
      from ByCol all;
    }

    // Define the output layer and its sources
    output Result [10]  
    {
      from Gather all;
      from MetaData all;
    }  

<span data-ttu-id="b3e05-352">Ebben a példában a Neurális hálózatokat nyelv több funkcióit mutatja be:</span><span class="sxs-lookup"><span data-stu-id="b3e05-352">This example illustrates several features of the neural networks specification language:</span></span>  

* <span data-ttu-id="b3e05-353">A struktúrának van két bemeneti réteg *képpont* és *metaadatok*.</span><span class="sxs-lookup"><span data-stu-id="b3e05-353">The structure has two input layers, *Pixels* and *MetaData*.</span></span>
* <span data-ttu-id="b3e05-354">A *képpont* réteg rétegeket célfájl, két kapcsolat csomagokat, a forrás-rétege *ByRow* és *ByCol*.</span><span class="sxs-lookup"><span data-stu-id="b3e05-354">The *Pixels* layer is a source layer for two connection bundles, with destination layers, *ByRow* and *ByCol*.</span></span>
* <span data-ttu-id="b3e05-355">A rétegek *összegyűjtése* és *eredmény* cél rétegek több kapcsolat csomagokat a rendszer.</span><span class="sxs-lookup"><span data-stu-id="b3e05-355">The layers *Gather* and *Result* are destination layers in multiple connection bundles.</span></span>
* <span data-ttu-id="b3e05-356">A kimeneti réteg *eredmény*, a cél réteg két kapcsolat kötegek; egyet a második szintű rejtett (összefog) cél rétegként, és egy másik cél rétegként a bemeneti réteggel (MetaData).</span><span class="sxs-lookup"><span data-stu-id="b3e05-356">The output layer, *Result*, is a destination layer in two connection bundles; one with the second level hidden (Gather) as a destination layer, and the other with the input layer (MetaData) as a destination layer.</span></span>
* <span data-ttu-id="b3e05-357">A Rejtett réteg *ByRow* és *ByCol*, adja meg a szűrt kapcsolat predikátum kifejezések használatával.</span><span class="sxs-lookup"><span data-stu-id="b3e05-357">The hidden layers, *ByRow* and *ByCol*, specify filtered connectivity by using predicate expressions.</span></span> <span data-ttu-id="b3e05-358">Pontosabban, a csomópont *ByRow* : [x, y] csatlakozik-e a csomópontok *képpont* , hogy rendelkezik az első index koordinálja a csomópont egyenlőnek csomagazonosítóját az első összehangolják x.</span><span class="sxs-lookup"><span data-stu-id="b3e05-358">More precisely, the node in *ByRow* at [x, y] is connected to the nodes in *Pixels* that have the first index coordinate equal to the node's first coordinate, x.</span></span> <span data-ttu-id="b3e05-359">Hasonlóképpen, a csomópont *ByCol: [x, y] _Pixels csomópontja csatlakozik* második koordinálja, y, hogy rendelkezik a második index koordinálja a csomópont egyik végpontjára.</span><span class="sxs-lookup"><span data-stu-id="b3e05-359">Similarly, the node in *ByCol at [x, y] is connected to the nodes in _Pixels* that have the second index coordinate within one of the node's second coordinate, y.</span></span>  

### <a name="define-a-convolutional-network-for-multiclass-classification-digit-recognition-example"></a><span data-ttu-id="b3e05-360">Adja meg a multiclass besorolási convolutional hálózati: számjegy felismerés – példa</span><span class="sxs-lookup"><span data-stu-id="b3e05-360">Define a convolutional network for multiclass classification: digit recognition example</span></span>
<span data-ttu-id="b3e05-361">A következő hálózati meghatározását arra tervezték, hogy ismeri fel azt a számot, és azt szemlélteti, hogy néhány speciális technikák Neurális hálózat testreszabásához.</span><span class="sxs-lookup"><span data-stu-id="b3e05-361">The definition of the following network is designed to recognize numbers, and it illustrates some advanced techniques for customizing a neural network.</span></span>  

    input Image [29, 29];
    hidden Conv1 [5, 13, 13] from Image convolve 
    {
       InputShape  = [29, 29];
       KernelShape = [ 5,  5];
       Stride      = [ 2,  2];
       MapCount    = 5;
    }
    hidden Conv2 [50, 5, 5]
    from Conv1 convolve 
    {
       InputShape  = [ 5, 13, 13];
       KernelShape = [ 1,  5,  5];
       Stride      = [ 1,  2,  2];
       Sharing     = [false, true, true];
       MapCount    = 10;
    }
    hidden Hid3 [100] from Conv2 all;
    output Digit [10] from Hid3 all;  


* <span data-ttu-id="b3e05-362">A struktúrának van egy bemeneti rétegben *kép*.</span><span class="sxs-lookup"><span data-stu-id="b3e05-362">The structure has a single input layer, *Image*.</span></span>
* <span data-ttu-id="b3e05-363">A kulcsszó **convolve** azt jelzi, hogy a rétegek nevű *Conv1* és *Conv2* convolutional rétegek vannak.</span><span class="sxs-lookup"><span data-stu-id="b3e05-363">The keyword **convolve** indicates that the layers named *Conv1* and *Conv2* are convolutional layers.</span></span> <span data-ttu-id="b3e05-364">Minden, a réteg nyilatkozatok követi a konvolúció attribútumok listáját.</span><span class="sxs-lookup"><span data-stu-id="b3e05-364">Each of these layer declarations is followed by a list of the convolution attributes.</span></span>
* <span data-ttu-id="b3e05-365">A háló harmadik rejtett réteg, *Hid3*, amely teljes mértékben csatlakozik-e a második rejtett réteg *Conv2*.</span><span class="sxs-lookup"><span data-stu-id="b3e05-365">The net has a third hidden layer, *Hid3*, which is fully connected to the second hidden layer, *Conv2*.</span></span>
* <span data-ttu-id="b3e05-366">A kimeneti réteg *számjegy*, csak a harmadik rejtett réteg csatlakozik *Hid3*.</span><span class="sxs-lookup"><span data-stu-id="b3e05-366">The output layer, *Digit*, is connected only to the third hidden layer, *Hid3*.</span></span> <span data-ttu-id="b3e05-367">A kulcsszó **összes** azt jelzi, hogy a kimeneti réteg teljesen csatlakozik *Hid3*.</span><span class="sxs-lookup"><span data-stu-id="b3e05-367">The keyword **all** indicates that the output layer is fully connected to *Hid3*.</span></span>
* <span data-ttu-id="b3e05-368">Az aritása a konvolúció három (a rekordokat hosszát **InputShape**, **KernelShape**, **Stride**, és **megosztás**).</span><span class="sxs-lookup"><span data-stu-id="b3e05-368">The arity of the convolution is three (the length of the tuples **InputShape**, **KernelShape**, **Stride**, and **Sharing**).</span></span> 
* <span data-ttu-id="b3e05-369">A súlyok / kernel száma *1 + **KernelShape**\[0] * **KernelShape**\[1] * **KernelShape** \[ 2] = 1 + 1 * 5 * 5 = 26. Vagy 26 * 50 = 1300*.</span><span class="sxs-lookup"><span data-stu-id="b3e05-369">The number of weights per kernel is *1 + **KernelShape**\[0] * **KernelShape**\[1] * **KernelShape**\[2] = 1 + 1 * 5 * 5 = 26. Or 26 * 50 = 1300*.</span></span>
* <span data-ttu-id="b3e05-370">Kiszámolhatja, minden egyes rejtett rétegben található csomópontok az alábbiak szerint:</span><span class="sxs-lookup"><span data-stu-id="b3e05-370">You can calculate the nodes in each hidden layer as follows:</span></span>
  * <span data-ttu-id="b3e05-371">**NodeCount**\[0] = (5 - 1) vagy 1 + 1 = 5.</span><span class="sxs-lookup"><span data-stu-id="b3e05-371">**NodeCount**\[0] = (5 - 1) / 1 + 1 = 5.</span></span>
  * <span data-ttu-id="b3e05-372">**NodeCount**\[1] = (13-5) / 2 + 1 = 5.</span><span class="sxs-lookup"><span data-stu-id="b3e05-372">**NodeCount**\[1] = (13 - 5) / 2 + 1 = 5.</span></span> 
  * <span data-ttu-id="b3e05-373">**NodeCount**\[2] (13-5) = / 2 + 1 = 5.</span><span class="sxs-lookup"><span data-stu-id="b3e05-373">**NodeCount**\[2] = (13 - 5) / 2 + 1 = 5.</span></span> 
* <span data-ttu-id="b3e05-374">A csomópontok száma kerülhet sor, a réteg deklarált dimenzióinak használatával [50, 5, 5], az alábbiak szerint:  ***MapCount** * **NodeCount**\[0] * **NodeCount**\[1] * **NodeCount**\[2] = 10 * 5 * 5 * 5*</span><span class="sxs-lookup"><span data-stu-id="b3e05-374">The total number of nodes can be calculated by using the declared dimensionality of the layer, [50, 5, 5], as follows: ***MapCount** * **NodeCount**\[0] * **NodeCount**\[1] * **NodeCount**\[2] = 10 * 5 * 5 * 5*</span></span>
* <span data-ttu-id="b3e05-375">Mivel **megosztás**[d.] értéke hamis csak *d == 0*, kernelek száma  ***MapCount** * **NodeCount** \[0] = 10 * 5 = 50*.</span><span class="sxs-lookup"><span data-stu-id="b3e05-375">Because **Sharing**[d] is False only for *d == 0*, the number of kernels is ***MapCount** * **NodeCount**\[0] = 10 * 5 = 50*.</span></span> 

## <a name="acknowledgements"></a><span data-ttu-id="b3e05-376">A nyugtázás</span><span class="sxs-lookup"><span data-stu-id="b3e05-376">Acknowledgements</span></span>
<span data-ttu-id="b3e05-377">A Net # nyelv Neurális hálózatokat architektúrájának testreszabásához fejlesztette ki Microsoft Shon Katzenberger (felelős mérnök, gépi tanulás) és ALEKSZEJ Kamenev (szoftver visszafejtés, a Microsoft Research).</span><span class="sxs-lookup"><span data-stu-id="b3e05-377">The Net# language for customizing the architecture of neural networks was developed at Microsoft by Shon Katzenberger (Architect, Machine Learning) and Alexey Kamenev (Software Engineer, Microsoft Research).</span></span> <span data-ttu-id="b3e05-378">Ez belső használatra készült a gépi tanulási projektek és alkalmazások szövegelemzések kép észlelési kezdve.</span><span class="sxs-lookup"><span data-stu-id="b3e05-378">It is used internally for machine learning projects and applications ranging from image detection to text analytics.</span></span> <span data-ttu-id="b3e05-379">További információkért lásd: [Neurális háló Azure ml - Net # bemutatása](http://blogs.technet.com/b/machinelearning/archive/2015/02/16/neural-nets-in-azure-ml-introduction-to-net.aspx)</span><span class="sxs-lookup"><span data-stu-id="b3e05-379">For more information, see [Neural Nets in Azure ML - Introduction to Net#](http://blogs.technet.com/b/machinelearning/archive/2015/02/16/neural-nets-in-azure-ml-introduction-to-net.aspx)</span></span>

<span data-ttu-id="b3e05-380">[1]:./media/machine-learning-azure-ml-netsharp-reference-guide/formula_large.gif</span><span class="sxs-lookup"><span data-stu-id="b3e05-380">[1]:./media/machine-learning-azure-ml-netsharp-reference-guide/formula_large.gif</span></span>

