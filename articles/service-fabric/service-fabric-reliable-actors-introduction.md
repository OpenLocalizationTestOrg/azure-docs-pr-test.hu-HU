---
title: "Service Fabric Reliable Actors áttekintése |} Microsoft Docs"
description: "A Service Fabric Reliable Actors programozási modell bemutatása."
services: service-fabric
documentationcenter: .net
author: vturecek
manager: timlt
editor: 
ms.assetid: 7fdad07f-f2d6-4c74-804d-e0d56131f060
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/29/2017
ms.author: vturecek
ms.openlocfilehash: e89be04a0d6fe90a89e293e67d42f0204eb7000a
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 07/11/2017
---
# <a name="introduction-to-service-fabric-reliable-actors"></a><span data-ttu-id="79c74-103">A Service Fabric Reliable Actors bemutatása</span><span class="sxs-lookup"><span data-stu-id="79c74-103">Introduction to Service Fabric Reliable Actors</span></span>
<span data-ttu-id="79c74-104">Reliable Actors a Service Fabric alkalmazási keretrendszer alapján a [virtuális szereplő](http://research.microsoft.com/en-us/projects/orleans/) mintát.</span><span class="sxs-lookup"><span data-stu-id="79c74-104">Reliable Actors is a Service Fabric application framework based on the [Virtual Actor](http://research.microsoft.com/en-us/projects/orleans/) pattern.</span></span> <span data-ttu-id="79c74-105">A megbízható Actors API a Service Fabric skálázhatóságát és megbízhatóságát garanciák épülő programozási egyszálas modellt biztosít.</span><span class="sxs-lookup"><span data-stu-id="79c74-105">The Reliable Actors API provides a single-threaded programming model built on the scalability and reliability guarantees provided by Service Fabric.</span></span>

## <a name="what-are-actors"></a><span data-ttu-id="79c74-106">Mik azok a szereplője?</span><span class="sxs-lookup"><span data-stu-id="79c74-106">What are Actors?</span></span>
<span data-ttu-id="79c74-107">Egy szereplő a számítási műveletek és rendelkező egyszálas végrehajtási állapot egy elkülönített, független egység.</span><span class="sxs-lookup"><span data-stu-id="79c74-107">An actor is an isolated, independent unit of compute and state with single-threaded execution.</span></span> <span data-ttu-id="79c74-108">A [szereplő mintát](https://en.wikipedia.org/wiki/Actor_model) olyan számítási modellt egyidejű vagy elosztott rendszerek, amelyek nagyszámú ezek szereplője végrehajtható egyidejűleg, és egymástól függetlenül.</span><span class="sxs-lookup"><span data-stu-id="79c74-108">The [actor pattern](https://en.wikipedia.org/wiki/Actor_model) is a computational model for concurrent or distributed systems in which a large number of these actors can execute simultaneously and independently of each other.</span></span> <span data-ttu-id="79c74-109">Szereplője kommunikálhatnak egymással, és további szereplője hozhatnak létre.</span><span class="sxs-lookup"><span data-stu-id="79c74-109">Actors can communicate with each other and they can create more actors.</span></span>

### <a name="when-to-use-reliable-actors"></a><span data-ttu-id="79c74-110">Mikor érdemes használni a Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="79c74-110">When to use Reliable Actors</span></span>
<span data-ttu-id="79c74-111">Service Fabric Reliable Actors szereplő kialakítási minta megvalósítása.</span><span class="sxs-lookup"><span data-stu-id="79c74-111">Service Fabric Reliable Actors is an implementation of the actor design pattern.</span></span> <span data-ttu-id="79c74-112">Minden szoftver a kialakítási mintában a a döntést, egy adott minta használ-e történik-e a szoftverfrissítések tervezése probléma alapján megfelel a mintának.</span><span class="sxs-lookup"><span data-stu-id="79c74-112">As with any software design pattern, the decision whether to use a specific pattern is made based on whether or not a software design problem fits the pattern.</span></span>

<span data-ttu-id="79c74-113">Bár a szereplő kialakítási minta is jó alkalmasnak elosztott rendszerek problémák és forgatókönyvek, gondosan kell tenni a minta és bevezetné, a keretrendszer korlátozásait figyelembevételével számú.</span><span class="sxs-lookup"><span data-stu-id="79c74-113">Although the actor design pattern can be a good fit to a number of distributed systems problems and scenarios, careful consideration of the constraints of the pattern and the framework implementing it must be made.</span></span> <span data-ttu-id="79c74-114">Általános útmutatásként fontolja meg a probléma vagy forgatókönyv modellezését, ha a szereplő mintát:</span><span class="sxs-lookup"><span data-stu-id="79c74-114">As general guidance, consider the actor pattern to model your problem or scenario if:</span></span>

* <span data-ttu-id="79c74-115">A probléma tárhely magában foglalja a sok (több ezer vagy több) kis, független és elkülönített állapot és a logikai egységek.</span><span class="sxs-lookup"><span data-stu-id="79c74-115">Your problem space involves a large number (thousands or more) of small, independent, and isolated units of state and logic.</span></span>
* <span data-ttu-id="79c74-116">Azt szeretné, külső összetevők, beleértve az állapot lekérdezése szereplője csoportja között jelentős beavatkozást nem igénylő egyszálas objektumok.</span><span class="sxs-lookup"><span data-stu-id="79c74-116">You want to work with single-threaded objects that do not require significant interaction from external components, including querying state across a set of actors.</span></span>
* <span data-ttu-id="79c74-117">A szereplő példányok nem blokkolja a hívók előre nem látható késlelteti az i/o-műveletek kiállításával.</span><span class="sxs-lookup"><span data-stu-id="79c74-117">Your actor instances won't block callers with unpredictable delays by issuing I/O operations.</span></span>

## <a name="actors-in-service-fabric"></a><span data-ttu-id="79c74-118">A Service Fabric actors</span><span class="sxs-lookup"><span data-stu-id="79c74-118">Actors in Service Fabric</span></span>
<span data-ttu-id="79c74-119">A Service Fabric szereplője valósíthatók meg a Reliable Actors keretrendszer: a beépített szereplő minta-alapú alkalmazás-keretrendszer [Service Fabric Reliable Services](service-fabric-reliable-services-introduction.md).</span><span class="sxs-lookup"><span data-stu-id="79c74-119">In Service Fabric, actors are implemented in the Reliable Actors framework: An actor-pattern-based application framework built on top of [Service Fabric Reliable Services](service-fabric-reliable-services-introduction.md).</span></span> <span data-ttu-id="79c74-120">Minden megbízható szereplő szolgáltatás ír egy ténylegesen egy particionált, állapot-nyilvántartó megbízható szolgáltatás.</span><span class="sxs-lookup"><span data-stu-id="79c74-120">Each Reliable Actor service you write is actually a partitioned, stateful Reliable Service.</span></span>

<span data-ttu-id="79c74-121">Minden aktor egy szereplő típusú, a .NET-objektum egy .NET-típus egy példánya nem módosul azonos típusúként van definiálva.</span><span class="sxs-lookup"><span data-stu-id="79c74-121">Every actor is defined as an instance of an actor type, identical to the way a .NET object is an instance of a .NET type.</span></span> <span data-ttu-id="79c74-122">Például előfordulhat, hogy egy olyan Számológép funkcióit megvalósító szereplő típus, és előfordulhat, hogy sok szereplője az adott típusú fürt elosztott különböző csomópontokon.</span><span class="sxs-lookup"><span data-stu-id="79c74-122">For example, there may be an actor type that implements the functionality of a calculator and there could be many actors of that type that are distributed on various nodes across a cluster.</span></span> <span data-ttu-id="79c74-123">Minden ilyen szereplő egyedileg azonosít egy szereplő.</span><span class="sxs-lookup"><span data-stu-id="79c74-123">Each such actor is uniquely identified by an actor ID.</span></span>

### <a name="actor-lifetime"></a><span data-ttu-id="79c74-124">Aktor élettartama</span><span class="sxs-lookup"><span data-stu-id="79c74-124">Actor Lifetime</span></span>
<span data-ttu-id="79c74-125">A Service Fabric szereplője virtuális, ami azt jelenti, hogy az élettartamuk nem kapcsolódna a memórián belüli megjelenítésre.</span><span class="sxs-lookup"><span data-stu-id="79c74-125">Service Fabric actors are virtual, meaning that their lifetime is not tied to their in-memory representation.</span></span> <span data-ttu-id="79c74-126">Ennek eredményeképpen nincs szükségük explicit módon létrehozott vagy megsemmisül.</span><span class="sxs-lookup"><span data-stu-id="79c74-126">As a result, they do not need to be explicitly created or destroyed.</span></span> <span data-ttu-id="79c74-127">A Reliable Actors futásidejű automatikusan aktiválja a szereplő első ideje kap egy adott szereplő azonosítóval.</span><span class="sxs-lookup"><span data-stu-id="79c74-127">The Reliable Actors runtime automatically activates an actor the first time it receives a request for that actor ID.</span></span> <span data-ttu-id="79c74-128">Ha egy szereplő nem használják-e egy adott időn belül, a Reliable Actors futásidejű szemétgyűjtési-gyűjti a memóriában lévő objektum.</span><span class="sxs-lookup"><span data-stu-id="79c74-128">If an actor is not used for a period of time, the Reliable Actors runtime garbage-collects the in-memory object.</span></span> <span data-ttu-id="79c74-129">Is megőrzi a szereplő fenntartása ismerete ki kellene később újra kell aktiválni.</span><span class="sxs-lookup"><span data-stu-id="79c74-129">It will also maintain knowledge of the actor's existence should it need to be reactivated later.</span></span> <span data-ttu-id="79c74-130">További részletekért lásd: [szereplő életciklust és a szemétgyűjtési gyűjtemény](service-fabric-reliable-actors-lifecycle.md).</span><span class="sxs-lookup"><span data-stu-id="79c74-130">For more details, see [Actor lifecycle and garbage collection](service-fabric-reliable-actors-lifecycle.md).</span></span>

<span data-ttu-id="79c74-131">A virtuális szereplő élettartama absztrakciós hordoz magában, ha bizonyos korlátozásokkal miatt a virtuális szereplő modell, és valójában a Reliable Actors megvalósítási néha eltér a modell.</span><span class="sxs-lookup"><span data-stu-id="79c74-131">This virtual actor lifetime abstraction carries some caveats as a result of the virtual actor model, and in fact the Reliable Actors implementation deviates at times from this model.</span></span>

* <span data-ttu-id="79c74-132">Egy szereplő automatikusan aktiválódik (egy szereplő objektumot kell kialakítani, amely) először egy üzenetet küld az aktor azonosítóját.</span><span class="sxs-lookup"><span data-stu-id="79c74-132">An actor is automatically activated (causing an actor object to be constructed) the first time a message is sent to its actor ID.</span></span> <span data-ttu-id="79c74-133">Néhány bizonyos idő eltelte után a szereplő objektum szemétgyűjtő.</span><span class="sxs-lookup"><span data-stu-id="79c74-133">After some period of time, the actor object is garbage collected.</span></span> <span data-ttu-id="79c74-134">A jövőben a azonosítójával szereplő újra, a hozható létre egy új szereplő objektumot.</span><span class="sxs-lookup"><span data-stu-id="79c74-134">In the future, using the actor ID again, causes a new actor object to be constructed.</span></span> <span data-ttu-id="79c74-135">Egy aktorállapot outlives az objektumok az állapotkezelő található.</span><span class="sxs-lookup"><span data-stu-id="79c74-135">An actor's state outlives the object's lifetime when stored in the state manager.</span></span>
* <span data-ttu-id="79c74-136">Adott szereplő bármely aktormetódus hívja a szereplő Azonosítóval aktiválja.</span><span class="sxs-lookup"><span data-stu-id="79c74-136">Calling any actor method for an actor ID activates that actor.</span></span> <span data-ttu-id="79c74-137">Emiatt a szereplő típusokhoz az implicit módon a futtatókörnyezet által meghívott konstruktor.</span><span class="sxs-lookup"><span data-stu-id="79c74-137">For this reason, actor types have their constructor called implicitly by the runtime.</span></span> <span data-ttu-id="79c74-138">Ezért Ügyfélkód nem adhatók át paraméterek az aktor típus konstruktora, bár paraméterek továbbítható a szereplő konstruktor által a szolgáltatás.</span><span class="sxs-lookup"><span data-stu-id="79c74-138">Therefore, client code cannot pass parameters to the actor type's constructor, although parameters may be passed to the actor's constructor by the service itself.</span></span> <span data-ttu-id="79c74-139">Az eredménye, hogy gyakrabban lehet úgy részben inicializált állapotban által a más módszerekkel hívják meg, ha a szereplő inicializálási paramétereket az ügyfél igényel.</span><span class="sxs-lookup"><span data-stu-id="79c74-139">The result is that actors may be constructed in a partially-initialized state by the time other methods are called on it, if the actor requires initialization parameters from the client.</span></span> <span data-ttu-id="79c74-140">Nincs az ügyfél egy szereplő aktiválásának egy belépési pont.</span><span class="sxs-lookup"><span data-stu-id="79c74-140">There is no single entry point for the activation of an actor from the client.</span></span>
* <span data-ttu-id="79c74-141">Bár a Reliable Actors implicit létrehozása szereplő objektumok; lehetősége nyílik explicit módon törli egy szereplő és annak állapotát.</span><span class="sxs-lookup"><span data-stu-id="79c74-141">Although Reliable Actors implicitly create actor objects; you do have the ability to explicitly delete an actor and its state.</span></span>

### <a name="distribution-and-failover"></a><span data-ttu-id="79c74-142">Telepítési és a feladatátvétel</span><span class="sxs-lookup"><span data-stu-id="79c74-142">Distribution and failover</span></span>
<span data-ttu-id="79c74-143">Adja meg a skálázhatóságát és megbízhatóságát, a Service Fabric elosztja a fürt teljes szereplője, majd automatikusan áttelepíti őket a meghibásodott csomópontok szükség szerint kifogástalan meglévők közül.</span><span class="sxs-lookup"><span data-stu-id="79c74-143">To provide scalability and reliability, Service Fabric distributes actors throughout the cluster and automatically migrates them from failed nodes to healthy ones as required.</span></span> <span data-ttu-id="79c74-144">Ez az absztrakciós keresztül egy [particionált, állapot-nyilvántartó megbízható szolgáltatás](service-fabric-concepts-partitioning.md).</span><span class="sxs-lookup"><span data-stu-id="79c74-144">This is an abstraction over a [partitioned, stateful Reliable Service](service-fabric-concepts-partitioning.md).</span></span> <span data-ttu-id="79c74-145">Terjesztési, méretezhetőség, megbízhatóság és automatikus feladatátvételt-e minden megadott a tényen szereplője belül futó állapot-nyilvántartó megbízható szolgáltatás hívása a *szereplő szolgáltatás*.</span><span class="sxs-lookup"><span data-stu-id="79c74-145">Distribution, scalability, reliability, and automatic failover are all provided by virtue of the fact that actors are running inside a stateful Reliable Service called the *Actor Service*.</span></span>

<span data-ttu-id="79c74-146">A partíciók az Aktor szolgáltatás szereplője elosztott, és ezek a partíciók elosztott a Service Fabric-fürt csomópontja.</span><span class="sxs-lookup"><span data-stu-id="79c74-146">Actors are distributed across the partitions of the Actor Service, and those partitions are distributed across the nodes in a Service Fabric cluster.</span></span> <span data-ttu-id="79c74-147">Minden szolgáltatás partíció szereplője tartalmaz.</span><span class="sxs-lookup"><span data-stu-id="79c74-147">Each service partition contains a set of actors.</span></span> <span data-ttu-id="79c74-148">Kezeli a Service Fabric terjesztési és a feladatátvétel szolgáltatás partíciók.</span><span class="sxs-lookup"><span data-stu-id="79c74-148">Service Fabric manages distribution and failover of the service partitions.</span></span>

<span data-ttu-id="79c74-149">Például az alapértelmezett szereplő partíció elhelyezés használatával három csomópontjaira telepített kilenc partíciókkal rendelkező szereplő szolgáltatásnak volna terjeszteni thusly:</span><span class="sxs-lookup"><span data-stu-id="79c74-149">For example, an actor service with nine partitions deployed to three nodes using the default actor partition placement would be distributed thusly:</span></span>

![Megbízható szereplője terjesztési][2]

<span data-ttu-id="79c74-151">Az Aktor keretrendszer partíció protokollt és a kulcs tartomány beállításainak kezelése meg.</span><span class="sxs-lookup"><span data-stu-id="79c74-151">The Actor Framework manages partition scheme and key range settings for you.</span></span> <span data-ttu-id="79c74-152">Ez egyszerűbbé teszi a néhány, de is hordoz magában, ha néhány szempont:</span><span class="sxs-lookup"><span data-stu-id="79c74-152">This simplifies some choices but also carries some consideration:</span></span>

* <span data-ttu-id="79c74-153">Megbízható szolgáltatások lehetővé teszi, hogy a particionálási sémát, a kulcs tartományon (particionálási sémát széles használatakor) kiválasztását, és a partíció száma.</span><span class="sxs-lookup"><span data-stu-id="79c74-153">Reliable Services allows you to choose a partitioning scheme, key range (when using a range partitioning scheme), and partition count.</span></span> <span data-ttu-id="79c74-154">Reliable Actors férhetnek hozzá a particionálási sémát (az egységes Int64 séma) tartomány, és megköveteli, hogy a teljes Int64-tartományt használja.</span><span class="sxs-lookup"><span data-stu-id="79c74-154">Reliable Actors is restricted to the range partitioning scheme (the uniform Int64 scheme) and requires you use the full Int64 key range.</span></span>
* <span data-ttu-id="79c74-155">Alapértelmezés szerint szereplője véletlenszerűen kerülnek, ami egységes terjesztési partíciókra.</span><span class="sxs-lookup"><span data-stu-id="79c74-155">By default, actors are randomly placed into partitions resulting in uniform distribution.</span></span>
* <span data-ttu-id="79c74-156">Szereplője véletlenszerűen kerülnek, mert ez várható szereplő műveletek mindig megkövetelik a hálózati kommunikációt, beleértve a szerializálás és a deszerializálás metódus hívása adatok nélül késleltetés és a terhelést.</span><span class="sxs-lookup"><span data-stu-id="79c74-156">Because actors are randomly placed, it should be expected that actor operations will always require network communication, including serialization and deserialization of method call data, incurring latency and overhead.</span></span>
* <span data-ttu-id="79c74-157">Speciális forgatókönyvekhez is lehet vezérlő szereplő partíció elhelyezési Int64 szereplő, amelyek adott partíciókra azonosítók használatával.</span><span class="sxs-lookup"><span data-stu-id="79c74-157">In advanced scenarios, it is possible to control actor partition placement by using Int64 actor IDs that map to specific partitions.</span></span> <span data-ttu-id="79c74-158">Azonban ezzel úgy eredményezheti egy egyenetlen eloszlását szereplője partíciók között.</span><span class="sxs-lookup"><span data-stu-id="79c74-158">However, doing so can result in an unbalanced distribution of actors across partitions.</span></span>

<span data-ttu-id="79c74-159">A aktorszolgáltatások particionálásáról további információkért tekintse meg [fogalmak particionálás szereplője](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span><span class="sxs-lookup"><span data-stu-id="79c74-159">For more information on how actor services are partitioned, refer to [partitioning concepts for actors](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span></span>

### <a name="actor-communication"></a><span data-ttu-id="79c74-160">Aktor kommunikáció</span><span class="sxs-lookup"><span data-stu-id="79c74-160">Actor communication</span></span>
<span data-ttu-id="79c74-161">Az aktor, amely megvalósítja a felületet, és proxy lekérdezi egy szereplő ugyanazon a felületen keresztül az ügyfél által közösen használt illesztőfelület szereplő kapcsolati vannak definiálva.</span><span class="sxs-lookup"><span data-stu-id="79c74-161">Actor interactions are defined in an interface that is shared by the actor that implements the interface, and the client that gets a proxy to an actor via the same interface.</span></span> <span data-ttu-id="79c74-162">Mivel ez az interfész szereplő módszerek meghívására aszinkron módon van használatban, a felület minden metódusa feladatot visszaadó kell lennie.</span><span class="sxs-lookup"><span data-stu-id="79c74-162">Because this interface is used to invoke actor methods asynchronously, every method on the interface must be Task-returning.</span></span>

<span data-ttu-id="79c74-163">Metódus meghívásához és a válaszok végső soron a hálózati kérelmek a fürtön, így az argumentumok és eredményezi a eredménytípusai feladat, amely akkor adja vissza a platform szerializálhatónak kell lennie.</span><span class="sxs-lookup"><span data-stu-id="79c74-163">Method invocations and their responses ultimately result in network requests across the cluster, so the arguments and the result types of the tasks that they return must be serializable by the platform.</span></span> <span data-ttu-id="79c74-164">Különösen kell [adategyezmény-szerializálható](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="79c74-164">In particular, they must be [data contract serializable](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span></span>

#### <a name="the-actor-proxy"></a><span data-ttu-id="79c74-165">Az aktor proxy</span><span class="sxs-lookup"><span data-stu-id="79c74-165">The actor proxy</span></span>
<span data-ttu-id="79c74-166">A Reliable Actors ügyfél API-ja biztosít szereplő példány és egy szereplő ügyfél közötti kommunikációhoz.</span><span class="sxs-lookup"><span data-stu-id="79c74-166">The Reliable Actors client API provides communication between an actor instance and an actor client.</span></span> <span data-ttu-id="79c74-167">Egy szereplő kommunikálni, egy ügyfél hoz létre, amely megvalósítja az aktor felületet szereplő proxy objektum.</span><span class="sxs-lookup"><span data-stu-id="79c74-167">To communicate with an actor, a client creates an actor proxy object that implements the actor interface.</span></span> <span data-ttu-id="79c74-168">Az aktor módszerek proxy objektumon, hogy az ügyfél kommunikál.</span><span class="sxs-lookup"><span data-stu-id="79c74-168">The client interacts with the actor by invoking methods on the proxy object.</span></span> <span data-ttu-id="79c74-169">Az aktor proxy ügyfél-aktor és aktor szereplő kommunikációhoz használható.</span><span class="sxs-lookup"><span data-stu-id="79c74-169">The actor proxy can be used for client-to-actor and actor-to-actor communication.</span></span>

```csharp
// Create a randomly distributed actor ID
ActorId actorId = ActorId.CreateRandom();

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
IMyActor myActor = ActorProxy.Create<IMyActor>(actorId, new Uri("fabric:/MyApp/MyActorService"));

// This will invoke a method on the actor. If an actor with the given ID does not exist, it will be activated by this method call.
await myActor.DoWorkAsync();
```

```java
// Create actor ID with some name
ActorId actorId = new ActorId("Actor1");

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
MyActor myActor = ActorProxyBase.create(actorId, new URI("fabric:/MyApp/MyActorService"), MyActor.class);

// This will invoke a method on the actor. If an actor with the given ID does not exist, it will be activated by this method call.
myActor.DoWorkAsync().get();
```


<span data-ttu-id="79c74-170">Vegye figyelembe, hogy a két szereplő proxy objektum létrehozásához használt információnak a szereplő azonosító és az alkalmazás nevét.</span><span class="sxs-lookup"><span data-stu-id="79c74-170">Note that the two pieces of information used to create the actor proxy object are the actor ID and the application name.</span></span> <span data-ttu-id="79c74-171">Az aktor azonosító egyedileg azonosítja a szereplő, az alkalmazás neve azonosítja a [Service Fabric-alkalmazás](service-fabric-reliable-actors-platform.md#application-model) a szereplő telepítési helyét.</span><span class="sxs-lookup"><span data-stu-id="79c74-171">The actor ID uniquely identifies the actor, while the application name identifies the [Service Fabric application](service-fabric-reliable-actors-platform.md#application-model) where the actor is deployed.</span></span>

<span data-ttu-id="79c74-172">A `ActorProxy`(C#) / `ActorProxyBase`(Java) osztály ügyféloldali hajtja végre a szükséges névfeloldást keresse meg a szereplő-azonosító szerint, és nyissa meg azt a kommunikációs csatornát.</span><span class="sxs-lookup"><span data-stu-id="79c74-172">The `ActorProxy`(C#) / `ActorProxyBase`(Java) class on the client side performs the necessary resolution to locate the actor by ID and open a communication channel with it.</span></span> <span data-ttu-id="79c74-173">Újra megpróbálja a szereplő keresse meg a kommunikációs hibák és a feladatátvétel.</span><span class="sxs-lookup"><span data-stu-id="79c74-173">It also retries to locate the actor in the cases of communication failures and failovers.</span></span> <span data-ttu-id="79c74-174">Üzenet kézbesítési következtében a következő jellemzőkkel rendelkezik:</span><span class="sxs-lookup"><span data-stu-id="79c74-174">As a result, message delivery has the following characteristics:</span></span>

* <span data-ttu-id="79c74-175">Üzenet kézbesítési a lehető legkedvezőbb módon.</span><span class="sxs-lookup"><span data-stu-id="79c74-175">Message delivery is best effort.</span></span>
* <span data-ttu-id="79c74-176">Szereplője duplikált üzenetek fogadása is ugyanazt az ügyfelet.</span><span class="sxs-lookup"><span data-stu-id="79c74-176">Actors may receive duplicate messages from the same client.</span></span>

### <a name="concurrency"></a><span data-ttu-id="79c74-177">Egyidejűség</span><span class="sxs-lookup"><span data-stu-id="79c74-177">Concurrency</span></span>
<span data-ttu-id="79c74-178">A Reliable Actors futásidejű szereplő módszerek eléréséhez egyszerű kapcsolja-alapú hozzáférés modellt biztosít.</span><span class="sxs-lookup"><span data-stu-id="79c74-178">The Reliable Actors runtime provides a simple turn-based access model for accessing actor methods.</span></span> <span data-ttu-id="79c74-179">Ez azt jelenti, hogy legfeljebb egy szál lehet aktív belső az aktor objektum kódot bármikor.</span><span class="sxs-lookup"><span data-stu-id="79c74-179">This means that no more than one thread can be active inside an actor object's code at any time.</span></span> <span data-ttu-id="79c74-180">Kapcsolja a szerepköralapú hozzáférés egyidejű rendszerek jelentősen egyszerűbb, mivel nincs szükség a szinkronizálási mechanizmus az adatelérési.</span><span class="sxs-lookup"><span data-stu-id="79c74-180">Turn-based access greatly simplifies concurrent systems as there is no need for synchronization mechanisms for data access.</span></span> <span data-ttu-id="79c74-181">Azt is jelenti, rendszerek minden szereplő példány egyszálas hozzáférés jellegét szempontot kell megtervezni.</span><span class="sxs-lookup"><span data-stu-id="79c74-181">It also means systems must be designed with special considerations for the single-threaded access nature of each actor instance.</span></span>

* <span data-ttu-id="79c74-182">A szereplő egyetlen példánya több kérelem nem dolgozható fel egyszerre.</span><span class="sxs-lookup"><span data-stu-id="79c74-182">A single actor instance cannot process more than one request at a time.</span></span> <span data-ttu-id="79c74-183">Aktor példánya a teljesítmény szűk keresztmetszetek okozhat, ha a várható egyidejű kérelmek kezeléséhez.</span><span class="sxs-lookup"><span data-stu-id="79c74-183">An actor instance can cause a throughput bottleneck if it is expected to handle concurrent requests.</span></span>
* <span data-ttu-id="79c74-184">Gyakrabban is kölcsönös kizárás egymástól, ha két szereplője, amíg egy külső kérelem egy a szereplője egyidejűleg között körkörös kérelmet.</span><span class="sxs-lookup"><span data-stu-id="79c74-184">Actors can deadlock on each other if there is a circular request between two actors while an external request is made to one of the actors simultaneously.</span></span> <span data-ttu-id="79c74-185">Az aktor futásidejű automatikusan lévő aktorhívások időtúllépéssel fejeződött be, és kivételt jelez a hívónak feleslegesen zavarni holtpont lehetséges helyzetben.</span><span class="sxs-lookup"><span data-stu-id="79c74-185">The actor runtime will automatically time out on actor calls and throw an exception to the caller to interrupt possible deadlock situations.</span></span>

![Megbízható szereplője kommunikációt][3]

#### <a name="turn-based-access"></a><span data-ttu-id="79c74-187">Kapcsolja a szerepköralapú hozzáférés</span><span class="sxs-lookup"><span data-stu-id="79c74-187">Turn-based access</span></span>
<span data-ttu-id="79c74-188">Egy kapcsolja más szereplője vagy az ügyfelek egy irányuló kérelemre adott válasz egy aktormetódus teljes végrehajtását, vagy a teljes végrehajtását tartalmaz egy [időzítő/emlékeztető](service-fabric-reliable-actors-timers-reminders.md) visszahívás.</span><span class="sxs-lookup"><span data-stu-id="79c74-188">A turn consists of the complete execution of an actor method in response to a request from other actors or clients, or the complete execution of a [timer/reminder](service-fabric-reliable-actors-timers-reminders.md) callback.</span></span> <span data-ttu-id="79c74-189">Annak ellenére, hogy ezen metódusok és a visszahívások aszinkron, a gyakrabban futásidejű nem interleave őket.</span><span class="sxs-lookup"><span data-stu-id="79c74-189">Even though these methods and callbacks are asynchronous, the Actors runtime does not interleave them.</span></span> <span data-ttu-id="79c74-190">Egy teljesen kész kell, mielőtt új kapcsolja engedélyezett.</span><span class="sxs-lookup"><span data-stu-id="79c74-190">A turn must be fully finished before a new turn is allowed.</span></span> <span data-ttu-id="79c74-191">Ez azt jelenti jelenleg feldolgozás alatt álló egy szereplő metódus vagy időzítő/emlékeztető visszahívás teljesen befejeződött egy új metódus hívása előtt kell lennie, vagy visszahívási engedélyezett.</span><span class="sxs-lookup"><span data-stu-id="79c74-191">In other words, an actor method or timer/reminder callback that is currently executing must be fully finished before a new call to a method or callback is allowed.</span></span> <span data-ttu-id="79c74-192">A metódus vagy a visszahívási tekinthető végzett, ha a végrehajtás tért vissza a metódusból vagy visszahívási és a feladat a metódust vagy a visszahívási által visszaadott befejeződött.</span><span class="sxs-lookup"><span data-stu-id="79c74-192">A method or callback is considered to have finished if the execution has returned from the method or callback and the task returned by the method or callback has finished.</span></span> <span data-ttu-id="79c74-193">Érdemes fogalmazás, hogy kapcsolja-alapú feldolgozási tiszteletben tartják még különböző módszereket, időzítők és visszahívások között.</span><span class="sxs-lookup"><span data-stu-id="79c74-193">It is worth emphasizing that turn-based concurrency is respected even across different methods, timers, and callbacks.</span></span>

<span data-ttu-id="79c74-194">A szereplője futásidejű kapcsolja-alapú feldolgozási által az beszerzése egy aktoronkénti zárolásra egy kapcsolja elején és végén található a kapcsolja a zárolás feloldása érvénybe lépteti.</span><span class="sxs-lookup"><span data-stu-id="79c74-194">The Actors runtime enforces turn-based concurrency by acquiring a per-actor lock at the beginning of a turn and releasing the lock at the end of the turn.</span></span> <span data-ttu-id="79c74-195">Ebből kifolyólag kapcsolja-alapú feldolgozási aktoronkénti alapon és szereplője között nem érvényes.</span><span class="sxs-lookup"><span data-stu-id="79c74-195">Thus, turn-based concurrency is enforced on a per-actor basis and not across actors.</span></span> <span data-ttu-id="79c74-196">Aktor módszerek egyidejűleg végrehajtható időzítő/emlékeztető visszahívások, különböző szereplője nevében.</span><span class="sxs-lookup"><span data-stu-id="79c74-196">Actor methods and timer/reminder callbacks can execute simultaneously on behalf of different actors.</span></span>

<span data-ttu-id="79c74-197">Az alábbi példában látható a fenti fogalmakat.</span><span class="sxs-lookup"><span data-stu-id="79c74-197">The following example illustrates the above concepts.</span></span> <span data-ttu-id="79c74-198">Vegye figyelembe az aktor típusa, amely megvalósítja az két aszinkron metódusok (tegyük fel például, *Method1* és *Method2*), időzítő, valamint egy emlékeztető.</span><span class="sxs-lookup"><span data-stu-id="79c74-198">Consider an actor type that implements two asynchronous methods (say, *Method1* and *Method2*), a timer, and a reminder.</span></span> <span data-ttu-id="79c74-199">Az alábbi ábra szemlélteti, két szereplője nevében ezen módszerek és a visszahívások végrehajtásának ütemterv (*ActorId1* és *ActorId2*), amely a szereplő típus tartozik.</span><span class="sxs-lookup"><span data-stu-id="79c74-199">The diagram below shows an example of a timeline for the execution of these methods and callbacks on behalf of two actors (*ActorId1* and *ActorId2*) that belong to this actor type.</span></span>

![Megbízható szereplője futásidejű kapcsolja-alapú feldolgozási és a hozzáférés][1]

<span data-ttu-id="79c74-201">Ez az ábra ezeket a szabályokat követi:</span><span class="sxs-lookup"><span data-stu-id="79c74-201">This diagram follows these conventions:</span></span>

* <span data-ttu-id="79c74-202">Minden egyes függőleges vonal szemlélteti a logikai metódust, illetve egy visszahívás végrehajtása egy adott szereplő nevében.</span><span class="sxs-lookup"><span data-stu-id="79c74-202">Each vertical line shows the logical flow of execution of a method or a callback on behalf of a particular actor.</span></span>
* <span data-ttu-id="79c74-203">A függőleges soronként jelölésű esemény újabb régieket alatt bekövetkező események időrendi sorrendben következik be.</span><span class="sxs-lookup"><span data-stu-id="79c74-203">The events marked on each vertical line occur in chronological order, with newer events occurring below older ones.</span></span>
* <span data-ttu-id="79c74-204">Különböző színek különböző szereplője megfelelő ütemtervek használ.</span><span class="sxs-lookup"><span data-stu-id="79c74-204">Different colors are used for timelines corresponding to different actors.</span></span>
* <span data-ttu-id="79c74-205">Jelzi az időtartam, amelynek az aktoronkénti zárolásra nevében metódust vagy visszahívási tárolt kiemelés szolgál.</span><span class="sxs-lookup"><span data-stu-id="79c74-205">Highlighting is used to indicate the duration for which the per-actor lock is held on behalf of a method or callback.</span></span>

<span data-ttu-id="79c74-206">Néhány fontos tényezőt kell figyelembe venni:</span><span class="sxs-lookup"><span data-stu-id="79c74-206">Some important points to consider:</span></span>

* <span data-ttu-id="79c74-207">Amíg *Method1* metódus végrehajtása a következő nevében: *ActorId2* ügyfél irányuló kérelemre adott válasz *xyz789*, egy másik ügyfélkérés (*abc123*) érkezik, amely megköveteli azt is, *Method1* hajtja végre *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="79c74-207">While *Method1* is executing on behalf of *ActorId2* in response to client request *xyz789*, another client request (*abc123*) arrives that also requires *Method1* to be executed by *ActorId2*.</span></span> <span data-ttu-id="79c74-208">Azonban a második végrehajtása *Method1* nem kezdődik, amíg a korábbi végrehajtása nem fejeződött be.</span><span class="sxs-lookup"><span data-stu-id="79c74-208">However, the second execution of *Method1* does not begin until the prior execution has finished.</span></span> <span data-ttu-id="79c74-209">Hasonlóképpen, a emlékeztető által regisztrált *ActorId2* következik be, amikor *Method1* ügyfél irányuló kérelemre adott válasz végrehajtott *xyz789*.</span><span class="sxs-lookup"><span data-stu-id="79c74-209">Similarly, a reminder registered by *ActorId2* fires while *Method1* is being executed in response to client request *xyz789*.</span></span> <span data-ttu-id="79c74-210">A felszólítás visszahívás végrehajtása mindkét végrehajtások, miután *Method1* befejeződött.</span><span class="sxs-lookup"><span data-stu-id="79c74-210">The reminder callback is executed only after both executions of *Method1* are complete.</span></span> <span data-ttu-id="79c74-211">Mindez okozza-e a kényszerítést kapcsolja-alapú feldolgozási *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="79c74-211">All of this is due to turn-based concurrency being enforced for *ActorId2*.</span></span>
* <span data-ttu-id="79c74-212">Hasonlóképpen, kapcsolja-alapú feldolgozási is az érvényes *ActorId1*, amint azt a végrehajtása *Method1*, *Method2*, és a időzítő visszahívás nevében *ActorId1* soros módon történik.</span><span class="sxs-lookup"><span data-stu-id="79c74-212">Similarly, turn-based concurrency is also enforced for *ActorId1*, as demonstrated by the execution of *Method1*, *Method2*, and the timer callback on behalf of *ActorId1* happening in a serial fashion.</span></span>
* <span data-ttu-id="79c74-213">Végrehajtásának *Method1* nevében *ActorId1* átfedésben van a végrehajtása a következő nevében: *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="79c74-213">Execution of *Method1* on behalf of *ActorId1* overlaps with its execution on behalf of *ActorId2*.</span></span> <span data-ttu-id="79c74-214">Ennek az az oka kapcsolja-alapú feldolgozási csak egy szereplő belül és szereplője között nem kényszeríti ki.</span><span class="sxs-lookup"><span data-stu-id="79c74-214">This is because turn-based concurrency is enforced only within an actor and not across actors.</span></span>
* <span data-ttu-id="79c74-215">Egyes metódus/visszahívási végrehajtások a `Task`(C#) / `CompletableFuture`(Java) a módszer/visszahívási befejeződik által visszaadott, miután a metódus visszaadja.</span><span class="sxs-lookup"><span data-stu-id="79c74-215">In some of the method/callback executions, the `Task`(C#) / `CompletableFuture`(Java) returned by the method/callback finishes after the method returns.</span></span> <span data-ttu-id="79c74-216">A más az aszinkron művelet már befejeződött a időpontjára, a módszer/visszahívási adja vissza.</span><span class="sxs-lookup"><span data-stu-id="79c74-216">In some others, the asynchronous operation has already finished by the time the method/callback returns.</span></span> <span data-ttu-id="79c74-217">Mindkét esetben az aktoronkénti zárolásra felszabadul csak mind a módszer/visszahívási adja vissza, és az aszinkron művelet befejeződése után.</span><span class="sxs-lookup"><span data-stu-id="79c74-217">In both cases, the per-actor lock is released only after both the method/callback returns and the asynchronous operation finishes.</span></span>

#### <a name="reentrancy"></a><span data-ttu-id="79c74-218">Rögzítve</span><span class="sxs-lookup"><span data-stu-id="79c74-218">Reentrancy</span></span>
<span data-ttu-id="79c74-219">A szereplője futásidejű rögzítve alapértelmezés szerint lehetővé teszi.</span><span class="sxs-lookup"><span data-stu-id="79c74-219">The Actors runtime allows reentrancy by default.</span></span> <span data-ttu-id="79c74-220">Ez azt jelenti, hogy ha egy aktormetódus a *Aktor A* metódus meghívja *Aktor B*, amely meghívja a másik módszer a *Aktor A*, hogy engedélyezi-e módszer futtatásához.</span><span class="sxs-lookup"><span data-stu-id="79c74-220">This means that if an actor method of *Actor A* calls a method on *Actor B*, which in turn calls another method on *Actor A*, that method is allowed to run.</span></span> <span data-ttu-id="79c74-221">Ennek az az oka az azonos logikai hívás-lánc-környezet részét képezi.</span><span class="sxs-lookup"><span data-stu-id="79c74-221">This is because it is part of the same logical call-chain context.</span></span> <span data-ttu-id="79c74-222">Az összes időzítő és felszólítás hívás az új logikai hívás környezetben kezdődik.</span><span class="sxs-lookup"><span data-stu-id="79c74-222">All timer and reminder calls start with the new logical call context.</span></span> <span data-ttu-id="79c74-223">Tekintse meg a [Reliable Actors rögzítve](service-fabric-reliable-actors-reentrancy.md) további részleteket.</span><span class="sxs-lookup"><span data-stu-id="79c74-223">See the [Reliable Actors reentrancy](service-fabric-reliable-actors-reentrancy.md) for more details.</span></span>

#### <a name="scope-of-concurrency-guarantees"></a><span data-ttu-id="79c74-224">Párhuzamossági garanciák hatókör</span><span class="sxs-lookup"><span data-stu-id="79c74-224">Scope of concurrency guarantees</span></span>
<span data-ttu-id="79c74-225">A szereplője futásidejű ezek párhuzamossági garanciákat olyan esetekben, ahol azt szabályozza, hogy ezek a metódusok meghívását nyújt.</span><span class="sxs-lookup"><span data-stu-id="79c74-225">The Actors runtime provides these concurrency guarantees in situations where it controls the invocation of these methods.</span></span> <span data-ttu-id="79c74-226">Például azzal a garanciákat nyújt, amely egy ügyfél irányuló kérelemre adott válasz végzett a metódus meghívásához, valamint időzítő és felszólítás visszahívások.</span><span class="sxs-lookup"><span data-stu-id="79c74-226">For example, it provides these guarantees for the method invocations that are done in response to a client request, as well as for timer and reminder callbacks.</span></span> <span data-ttu-id="79c74-227">Azonban a szereplő kódot közvetlenül hív meg, ezek a módszerek a szereplője futtatókörnyezet által megadott mechanizmusok kívül, ha a futtatókörnyezet nem adja meg minden párhuzamossági garanciák.</span><span class="sxs-lookup"><span data-stu-id="79c74-227">However, if the actor code directly invokes these methods outside of the mechanisms provided by the Actors runtime, then the runtime cannot provide any concurrency guarantees.</span></span> <span data-ttu-id="79c74-228">Például ha a metódus hivatkoznak, néhány feladatot, amely nincs társítva a tevékenység aktor módszerek által visszaadott a környezetében, a futtatókörnyezet nem adja meg párhuzamossági garanciát.</span><span class="sxs-lookup"><span data-stu-id="79c74-228">For example, if the method is invoked in the context of some task that is not associated with the task returned by the actor methods, then the runtime cannot provide concurrency guarantees.</span></span> <span data-ttu-id="79c74-229">Ha a metódus egy olyan szálból, amely a szereplő hoz létre a saját hivatkoznak, a futtatókörnyezet is nem adja meg párhuzamossági garanciát.</span><span class="sxs-lookup"><span data-stu-id="79c74-229">If the method is invoked from a thread that the actor creates on its own, then the runtime also cannot provide concurrency guarantees.</span></span> <span data-ttu-id="79c74-230">Ezért háttérbeli műveletek végrehajtásához szereplője használandó [szereplő időzítők és szereplő emlékeztetők](service-fabric-reliable-actors-timers-reminders.md) , figyelembe vegyék kapcsolja-alapú feldolgozási.</span><span class="sxs-lookup"><span data-stu-id="79c74-230">Therefore, to perform background operations, actors should use [actor timers and actor reminders](service-fabric-reliable-actors-timers-reminders.md) that respect turn-based concurrency.</span></span>

## <a name="next-steps"></a><span data-ttu-id="79c74-231">Következő lépések</span><span class="sxs-lookup"><span data-stu-id="79c74-231">Next steps</span></span>
* <span data-ttu-id="79c74-232">Ismerkedés az első Reliable Actors szolgáltatás épület:</span><span class="sxs-lookup"><span data-stu-id="79c74-232">Get started by building your first Reliable Actors service:</span></span>
   * [<span data-ttu-id="79c74-233">Bevezetés a Reliable Actors a .NET használatába</span><span class="sxs-lookup"><span data-stu-id="79c74-233">Getting started with Reliable Actors on .NET</span></span>](service-fabric-reliable-actors-get-started.md)
   * [<span data-ttu-id="79c74-234">Ismerkedés a Java a Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="79c74-234">Getting started with Reliable Actors on Java</span></span>](service-fabric-reliable-actors-get-started-java.md)

<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-introduction/concurrency.png
[2]: ./media/service-fabric-reliable-actors-introduction/distribution.png
[3]: ./media/service-fabric-reliable-actors-introduction/actor-communication.png
