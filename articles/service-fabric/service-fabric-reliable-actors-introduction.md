---
title: "aaaService háló megbízható szereplője áttekintése |} Microsoft Docs"
description: "Bevezetés toohello Service Fabric Reliable Actors programozási modell."
services: service-fabric
documentationcenter: .net
author: vturecek
manager: timlt
editor: 
ms.assetid: 7fdad07f-f2d6-4c74-804d-e0d56131f060
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/29/2017
ms.author: vturecek
ms.openlocfilehash: ab010cbf936c6cf723b3d453ef95a9bf51f76c95
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 10/06/2017
---
# <a name="introduction-tooservice-fabric-reliable-actors"></a><span data-ttu-id="f7c90-103">Bevezetés tooService háló Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="f7c90-103">Introduction tooService Fabric Reliable Actors</span></span>
<span data-ttu-id="f7c90-104">Reliable Actors a Service Fabric alkalmazási keretrendszer hello alapján [virtuális szereplő](http://research.microsoft.com/en-us/projects/orleans/) mintát.</span><span class="sxs-lookup"><span data-stu-id="f7c90-104">Reliable Actors is a Service Fabric application framework based on hello [Virtual Actor](http://research.microsoft.com/en-us/projects/orleans/) pattern.</span></span> <span data-ttu-id="f7c90-105">hello megbízható Actors API skálázhatóságát és megbízhatóságát Service Fabric által nyújtott garanciák hello épülő programozási egyszálas modellt biztosít.</span><span class="sxs-lookup"><span data-stu-id="f7c90-105">hello Reliable Actors API provides a single-threaded programming model built on hello scalability and reliability guarantees provided by Service Fabric.</span></span>

## <a name="what-are-actors"></a><span data-ttu-id="f7c90-106">Mik azok a szereplője?</span><span class="sxs-lookup"><span data-stu-id="f7c90-106">What are Actors?</span></span>
<span data-ttu-id="f7c90-107">Egy szereplő a számítási műveletek és rendelkező egyszálas végrehajtási állapot egy elkülönített, független egység.</span><span class="sxs-lookup"><span data-stu-id="f7c90-107">An actor is an isolated, independent unit of compute and state with single-threaded execution.</span></span> <span data-ttu-id="f7c90-108">Hello [szereplő mintát](https://en.wikipedia.org/wiki/Actor_model) olyan számítási modellt egyidejű vagy elosztott rendszerek, amelyek nagyszámú ezek szereplője végrehajtható egyidejűleg, és egymástól függetlenül.</span><span class="sxs-lookup"><span data-stu-id="f7c90-108">hello [actor pattern](https://en.wikipedia.org/wiki/Actor_model) is a computational model for concurrent or distributed systems in which a large number of these actors can execute simultaneously and independently of each other.</span></span> <span data-ttu-id="f7c90-109">Szereplője kommunikálhatnak egymással, és további szereplője hozhatnak létre.</span><span class="sxs-lookup"><span data-stu-id="f7c90-109">Actors can communicate with each other and they can create more actors.</span></span>

### <a name="when-toouse-reliable-actors"></a><span data-ttu-id="f7c90-110">Amikor toouse Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="f7c90-110">When toouse Reliable Actors</span></span>
<span data-ttu-id="f7c90-111">Service Fabric Reliable Actors hello szereplő kialakítási mintája megvalósítása.</span><span class="sxs-lookup"><span data-stu-id="f7c90-111">Service Fabric Reliable Actors is an implementation of hello actor design pattern.</span></span> <span data-ttu-id="f7c90-112">A szoftver a kialakítási mintában a hello döntés, hogy toouse egy adott minta történik-e a szoftverfrissítések tervezése probléma alapján megfelelő hello mintát.</span><span class="sxs-lookup"><span data-stu-id="f7c90-112">As with any software design pattern, hello decision whether toouse a specific pattern is made based on whether or not a software design problem fits hello pattern.</span></span>

<span data-ttu-id="f7c90-113">Bár hello szereplő kialakítási mintában a helyes illeszkedő tooa, számát, elosztott rendszerek problémák és forgatókönyvek alapos megfontolás hello megkötéseket hello mintát és hello keretrendszer végrehajtási készült.</span><span class="sxs-lookup"><span data-stu-id="f7c90-113">Although hello actor design pattern can be a good fit tooa number of distributed systems problems and scenarios, careful consideration of hello constraints of hello pattern and hello framework implementing it must be made.</span></span> <span data-ttu-id="f7c90-114">Általános útmutatást fontolja meg a hello szereplő mintát toomodel a probléma vagy forgatókönyv ha:</span><span class="sxs-lookup"><span data-stu-id="f7c90-114">As general guidance, consider hello actor pattern toomodel your problem or scenario if:</span></span>

* <span data-ttu-id="f7c90-115">A probléma tárhely magában foglalja a sok (több ezer vagy több) kis, független és elkülönített állapot és a logikai egységek.</span><span class="sxs-lookup"><span data-stu-id="f7c90-115">Your problem space involves a large number (thousands or more) of small, independent, and isolated units of state and logic.</span></span>
* <span data-ttu-id="f7c90-116">Azt szeretné, hogy a külső összetevők, beleértve az állapot lekérdezése szereplője csoportja között jelentős beavatkozást nem igénylő egyszálas objektummal toowork.</span><span class="sxs-lookup"><span data-stu-id="f7c90-116">You want toowork with single-threaded objects that do not require significant interaction from external components, including querying state across a set of actors.</span></span>
* <span data-ttu-id="f7c90-117">A szereplő példányok nem blokkolja a hívók előre nem látható késlelteti az i/o-műveletek kiállításával.</span><span class="sxs-lookup"><span data-stu-id="f7c90-117">Your actor instances won't block callers with unpredictable delays by issuing I/O operations.</span></span>

## <a name="actors-in-service-fabric"></a><span data-ttu-id="f7c90-118">A Service Fabric actors</span><span class="sxs-lookup"><span data-stu-id="f7c90-118">Actors in Service Fabric</span></span>
<span data-ttu-id="f7c90-119">A Service Fabric szereplője valósíthatók meg hello Reliable Actors keretrendszer: a beépített szereplő minta-alapú alkalmazás-keretrendszer [Service Fabric Reliable Services](service-fabric-reliable-services-introduction.md).</span><span class="sxs-lookup"><span data-stu-id="f7c90-119">In Service Fabric, actors are implemented in hello Reliable Actors framework: An actor-pattern-based application framework built on top of [Service Fabric Reliable Services](service-fabric-reliable-services-introduction.md).</span></span> <span data-ttu-id="f7c90-120">Minden megbízható szereplő szolgáltatás ír egy ténylegesen egy particionált, állapot-nyilvántartó megbízható szolgáltatás.</span><span class="sxs-lookup"><span data-stu-id="f7c90-120">Each Reliable Actor service you write is actually a partitioned, stateful Reliable Service.</span></span>

<span data-ttu-id="f7c90-121">Minden aktor egy szereplő típusú típusúként van definiálva, azonos toohello egy .NET-objektum módja a .NET-típus példánya.</span><span class="sxs-lookup"><span data-stu-id="f7c90-121">Every actor is defined as an instance of an actor type, identical toohello way a .NET object is an instance of a .NET type.</span></span> <span data-ttu-id="f7c90-122">Például előfordulhat, hogy egy szereplő típus, amely megvalósítja a Számológép hello funkcióit, és előfordulhat, hogy sok szereplője az adott típusú fürt különböző csomópontokon elosztott.</span><span class="sxs-lookup"><span data-stu-id="f7c90-122">For example, there may be an actor type that implements hello functionality of a calculator and there could be many actors of that type that are distributed on various nodes across a cluster.</span></span> <span data-ttu-id="f7c90-123">Minden ilyen szereplő egyedileg azonosít egy szereplő.</span><span class="sxs-lookup"><span data-stu-id="f7c90-123">Each such actor is uniquely identified by an actor ID.</span></span>

### <a name="actor-lifetime"></a><span data-ttu-id="f7c90-124">Aktor élettartama</span><span class="sxs-lookup"><span data-stu-id="f7c90-124">Actor Lifetime</span></span>
<span data-ttu-id="f7c90-125">A Service Fabric szereplője virtuális, ami azt jelenti, hogy az élettartamuk nem kapcsolt tootheir memórián belüli ábrázolását.</span><span class="sxs-lookup"><span data-stu-id="f7c90-125">Service Fabric actors are virtual, meaning that their lifetime is not tied tootheir in-memory representation.</span></span> <span data-ttu-id="f7c90-126">Ennek eredményeképpen nincs szükségük toobe explicit módon létrehozott vagy megsemmisül.</span><span class="sxs-lookup"><span data-stu-id="f7c90-126">As a result, they do not need toobe explicitly created or destroyed.</span></span> <span data-ttu-id="f7c90-127">hello Reliable Actors futásidejű automatikusan aktiválja az aktor hello először kap egy adott szereplő azonosítóval.</span><span class="sxs-lookup"><span data-stu-id="f7c90-127">hello Reliable Actors runtime automatically activates an actor hello first time it receives a request for that actor ID.</span></span> <span data-ttu-id="f7c90-128">Ha egy szereplő nem használják-e egy adott időn belül, hello Reliable Actors futásidejű szemétgyűjtési-gyűjti hello memórián belüli objektum.</span><span class="sxs-lookup"><span data-stu-id="f7c90-128">If an actor is not used for a period of time, hello Reliable Actors runtime garbage-collects hello in-memory object.</span></span> <span data-ttu-id="f7c90-129">Is megőrzi a hello szereplő fenntartása ismerete kell azt toobe később újra aktiválni kell.</span><span class="sxs-lookup"><span data-stu-id="f7c90-129">It will also maintain knowledge of hello actor's existence should it need toobe reactivated later.</span></span> <span data-ttu-id="f7c90-130">További részletekért lásd: [szereplő életciklust és a szemétgyűjtési gyűjtemény](service-fabric-reliable-actors-lifecycle.md).</span><span class="sxs-lookup"><span data-stu-id="f7c90-130">For more details, see [Actor lifecycle and garbage collection](service-fabric-reliable-actors-lifecycle.md).</span></span>

<span data-ttu-id="f7c90-131">A virtuális szereplő élettartama absztrakciós hello virtuális szereplő modell eredményeképpen bizonyos korlátozásokkal tartozik, és ténylegesen hello Reliable Actors megvalósítási néha eltér a modell.</span><span class="sxs-lookup"><span data-stu-id="f7c90-131">This virtual actor lifetime abstraction carries some caveats as a result of hello virtual actor model, and in fact hello Reliable Actors implementation deviates at times from this model.</span></span>

* <span data-ttu-id="f7c90-132">Egy szereplő automatikusan aktiválódik (ami egy szereplő objektum toobe összeállított) hello először egy üzenetet kap tooits szereplő azonosítóját.</span><span class="sxs-lookup"><span data-stu-id="f7c90-132">An actor is automatically activated (causing an actor object toobe constructed) hello first time a message is sent tooits actor ID.</span></span> <span data-ttu-id="f7c90-133">Néhány bizonyos idő eltelte után hello szereplő objektum szemétgyűjtő.</span><span class="sxs-lookup"><span data-stu-id="f7c90-133">After some period of time, hello actor object is garbage collected.</span></span> <span data-ttu-id="f7c90-134">Hello a jövőben azonosítójával hello szereplő újra, összeállított objektum toobe eredményezi egy új aktor.</span><span class="sxs-lookup"><span data-stu-id="f7c90-134">In hello future, using hello actor ID again, causes a new actor object toobe constructed.</span></span> <span data-ttu-id="f7c90-135">Egy aktorállapot outlives hello objektum élettartama az állapotkezelő hello található.</span><span class="sxs-lookup"><span data-stu-id="f7c90-135">An actor's state outlives hello object's lifetime when stored in hello state manager.</span></span>
* <span data-ttu-id="f7c90-136">Adott szereplő bármely aktormetódus hívja a szereplő Azonosítóval aktiválja.</span><span class="sxs-lookup"><span data-stu-id="f7c90-136">Calling any actor method for an actor ID activates that actor.</span></span> <span data-ttu-id="f7c90-137">Emiatt a szereplő típusokhoz hello futásidejű implicit módon hívja az konstruktor.</span><span class="sxs-lookup"><span data-stu-id="f7c90-137">For this reason, actor types have their constructor called implicitly by hello runtime.</span></span> <span data-ttu-id="f7c90-138">Ezért Ügyfélkód nem adható át paraméterek toohello szereplő típus konstruktora, bár paraméterek teljesíthetők toohello szereplő konstruktor hello szolgáltatás magát.</span><span class="sxs-lookup"><span data-stu-id="f7c90-138">Therefore, client code cannot pass parameters toohello actor type's constructor, although parameters may be passed toohello actor's constructor by hello service itself.</span></span> <span data-ttu-id="f7c90-139">hello eredménye, hogy gyakrabban lehet úgy részben inicializált állapotban hello időpontjára más módszerekkel hívják meg, ha hello szereplő hello ügyfélről inicializálási paramétereket igényel.</span><span class="sxs-lookup"><span data-stu-id="f7c90-139">hello result is that actors may be constructed in a partially-initialized state by hello time other methods are called on it, if hello actor requires initialization parameters from hello client.</span></span> <span data-ttu-id="f7c90-140">Nincs egyetlen belépési pont egy szereplő hello ügyfélről hello aktiválásához.</span><span class="sxs-lookup"><span data-stu-id="f7c90-140">There is no single entry point for hello activation of an actor from hello client.</span></span>
* <span data-ttu-id="f7c90-141">Bár a Reliable Actors implicit létrehozása szereplő objektumok; hello képességét tooexplicitly szereplő és állapotában törlése rendelkeznek.</span><span class="sxs-lookup"><span data-stu-id="f7c90-141">Although Reliable Actors implicitly create actor objects; you do have hello ability tooexplicitly delete an actor and its state.</span></span>

### <a name="distribution-and-failover"></a><span data-ttu-id="f7c90-142">Telepítési és a feladatátvétel</span><span class="sxs-lookup"><span data-stu-id="f7c90-142">Distribution and failover</span></span>
<span data-ttu-id="f7c90-143">tooprovide skálázhatóságát és megbízhatóságát, a Service Fabric szereplője hello fürt alatt, és automatikusan továbbítja őket a meghibásodott csomópontok toohealthy megfelelően szükség szerint áttelepíti.</span><span class="sxs-lookup"><span data-stu-id="f7c90-143">tooprovide scalability and reliability, Service Fabric distributes actors throughout hello cluster and automatically migrates them from failed nodes toohealthy ones as required.</span></span> <span data-ttu-id="f7c90-144">Ez az absztrakciós keresztül egy [particionált, állapot-nyilvántartó megbízható szolgáltatás](service-fabric-concepts-partitioning.md).</span><span class="sxs-lookup"><span data-stu-id="f7c90-144">This is an abstraction over a [partitioned, stateful Reliable Service](service-fabric-concepts-partitioning.md).</span></span> <span data-ttu-id="f7c90-145">Terjesztési, méretezhetőség, megbízhatóság és automatikus feladatátvételt összes biztosított hello tény szereplője belül futó hello nevű állapot-nyilvántartó megbízható szolgáltatás alapján *szereplő szolgáltatás*.</span><span class="sxs-lookup"><span data-stu-id="f7c90-145">Distribution, scalability, reliability, and automatic failover are all provided by virtue of hello fact that actors are running inside a stateful Reliable Service called hello *Actor Service*.</span></span>

<span data-ttu-id="f7c90-146">Szereplője hello partíciója hello szereplő szolgáltatás különböző pontjain, és ezek a partíciók elosztott hello a Service Fabric-fürt csomópontja.</span><span class="sxs-lookup"><span data-stu-id="f7c90-146">Actors are distributed across hello partitions of hello Actor Service, and those partitions are distributed across hello nodes in a Service Fabric cluster.</span></span> <span data-ttu-id="f7c90-147">Minden szolgáltatás partíció szereplője tartalmaz.</span><span class="sxs-lookup"><span data-stu-id="f7c90-147">Each service partition contains a set of actors.</span></span> <span data-ttu-id="f7c90-148">Kezeli a Service Fabric terjesztési és feladatátvételi hello szolgáltatást a partíciók száma.</span><span class="sxs-lookup"><span data-stu-id="f7c90-148">Service Fabric manages distribution and failover of hello service partitions.</span></span>

<span data-ttu-id="f7c90-149">Például egy szereplő szolgáltatás kilenc partíciókkal rendelkező telepített toothree hello alapértelmezett szereplő partíció elhelyezési használt csomópontok thusly volna terjeszteni:</span><span class="sxs-lookup"><span data-stu-id="f7c90-149">For example, an actor service with nine partitions deployed toothree nodes using hello default actor partition placement would be distributed thusly:</span></span>

![Megbízható szereplője terjesztési][2]

<span data-ttu-id="f7c90-151">hello szereplő keretrendszer partíciós séma és a kulcs tartomány beállításainak kezelése meg.</span><span class="sxs-lookup"><span data-stu-id="f7c90-151">hello Actor Framework manages partition scheme and key range settings for you.</span></span> <span data-ttu-id="f7c90-152">Ez egyszerűbbé teszi a néhány, de is hordoz magában, ha néhány szempont:</span><span class="sxs-lookup"><span data-stu-id="f7c90-152">This simplifies some choices but also carries some consideration:</span></span>

* <span data-ttu-id="f7c90-153">Megbízható szolgáltatások lehetővé teszi toochoose particionálási séma, kulcs tartományon (particionálási sémát széles használatakor), és a partíció száma.</span><span class="sxs-lookup"><span data-stu-id="f7c90-153">Reliable Services allows you toochoose a partitioning scheme, key range (when using a range partitioning scheme), and partition count.</span></span> <span data-ttu-id="f7c90-154">Reliable Actors korlátozott toohello tartomány particionálási sémát (hello egységes Int64 sémával), és igényel a hello teljes Int64 kulcs címtartományt használhat.</span><span class="sxs-lookup"><span data-stu-id="f7c90-154">Reliable Actors is restricted toohello range partitioning scheme (hello uniform Int64 scheme) and requires you use hello full Int64 key range.</span></span>
* <span data-ttu-id="f7c90-155">Alapértelmezés szerint szereplője véletlenszerűen kerülnek, ami egységes terjesztési partíciókra.</span><span class="sxs-lookup"><span data-stu-id="f7c90-155">By default, actors are randomly placed into partitions resulting in uniform distribution.</span></span>
* <span data-ttu-id="f7c90-156">Szereplője véletlenszerűen kerülnek, mert ez várható szereplő műveletek mindig megkövetelik a hálózati kommunikációt, beleértve a szerializálás és a deszerializálás metódus hívása adatok nélül késleltetés és a terhelést.</span><span class="sxs-lookup"><span data-stu-id="f7c90-156">Because actors are randomly placed, it should be expected that actor operations will always require network communication, including serialization and deserialization of method call data, incurring latency and overhead.</span></span>
* <span data-ttu-id="f7c90-157">Speciális forgatókönyvek, az lehetséges toocontrol szereplő partíció elhelyezési Int64 szereplő, amelyek kapcsolódnak toospecific partíciókat azonosítók használatával is.</span><span class="sxs-lookup"><span data-stu-id="f7c90-157">In advanced scenarios, it is possible toocontrol actor partition placement by using Int64 actor IDs that map toospecific partitions.</span></span> <span data-ttu-id="f7c90-158">Azonban ezzel úgy eredményezheti egy egyenetlen eloszlását szereplője partíciók között.</span><span class="sxs-lookup"><span data-stu-id="f7c90-158">However, doing so can result in an unbalanced distribution of actors across partitions.</span></span>

<span data-ttu-id="f7c90-159">Aktorszolgáltatások particionálásáról további információkért tekintse meg túl[fogalmak particionálás szereplője](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span><span class="sxs-lookup"><span data-stu-id="f7c90-159">For more information on how actor services are partitioned, refer too[partitioning concepts for actors](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span></span>

### <a name="actor-communication"></a><span data-ttu-id="f7c90-160">Aktor kommunikáció</span><span class="sxs-lookup"><span data-stu-id="f7c90-160">Actor communication</span></span>
<span data-ttu-id="f7c90-161">Aktor kapcsolati definiált hello szereplő hello felületet megvalósító, és lekérdezi a proxy tooan szereplő keresztül hello hello ügyfél által közösen használt illesztőfelület ugyanazon a felületen.</span><span class="sxs-lookup"><span data-stu-id="f7c90-161">Actor interactions are defined in an interface that is shared by hello actor that implements hello interface, and hello client that gets a proxy tooan actor via hello same interface.</span></span> <span data-ttu-id="f7c90-162">Mivel ez az interfész használt tooinvoke szereplő módszerek aszinkron módon történik, hello felület minden metódusa feladatot visszaadó kell lennie.</span><span class="sxs-lookup"><span data-stu-id="f7c90-162">Because this interface is used tooinvoke actor methods asynchronously, every method on hello interface must be Task-returning.</span></span>

<span data-ttu-id="f7c90-163">Metódus meghívásához és a válaszok végső soron eredményez hálózati kérelmek hello fürt, Igen hello argumentumok és visszatérési lenniük szerializálható hello platform hello feladatok hello eredménytípusai között.</span><span class="sxs-lookup"><span data-stu-id="f7c90-163">Method invocations and their responses ultimately result in network requests across hello cluster, so hello arguments and hello result types of hello tasks that they return must be serializable by hello platform.</span></span> <span data-ttu-id="f7c90-164">Különösen kell [adategyezmény-szerializálható](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="f7c90-164">In particular, they must be [data contract serializable](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span></span>

#### <a name="hello-actor-proxy"></a><span data-ttu-id="f7c90-165">hello szereplő proxy</span><span class="sxs-lookup"><span data-stu-id="f7c90-165">hello actor proxy</span></span>
<span data-ttu-id="f7c90-166">hello Reliable Actors ügyfél API-ja biztosít szereplő példány és egy szereplő ügyfél közötti kommunikációhoz.</span><span class="sxs-lookup"><span data-stu-id="f7c90-166">hello Reliable Actors client API provides communication between an actor instance and an actor client.</span></span> <span data-ttu-id="f7c90-167">egy résztvevővel toocommunicate, egy ügyfél szereplő proxy hello szereplő felületet megvalósító objektum hoz létre.</span><span class="sxs-lookup"><span data-stu-id="f7c90-167">toocommunicate with an actor, a client creates an actor proxy object that implements hello actor interface.</span></span> <span data-ttu-id="f7c90-168">hello szereplő hello proxy objektumon hívása módszerekkel hello ügyfél kommunikál.</span><span class="sxs-lookup"><span data-stu-id="f7c90-168">hello client interacts with hello actor by invoking methods on hello proxy object.</span></span> <span data-ttu-id="f7c90-169">hello szereplő proxy ügyfél-aktor és aktor szereplő kommunikációhoz használható.</span><span class="sxs-lookup"><span data-stu-id="f7c90-169">hello actor proxy can be used for client-to-actor and actor-to-actor communication.</span></span>

```csharp
// Create a randomly distributed actor ID
ActorId actorId = ActorId.CreateRandom();

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
IMyActor myActor = ActorProxy.Create<IMyActor>(actorId, new Uri("fabric:/MyApp/MyActorService"));

// This will invoke a method on hello actor. If an actor with hello given ID does not exist, it will be activated by this method call.
await myActor.DoWorkAsync();
```

```java
// Create actor ID with some name
ActorId actorId = new ActorId("Actor1");

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
MyActor myActor = ActorProxyBase.create(actorId, new URI("fabric:/MyApp/MyActorService"), MyActor.class);

// This will invoke a method on hello actor. If an actor with hello given ID does not exist, it will be activated by this method call.
myActor.DoWorkAsync().get();
```


<span data-ttu-id="f7c90-170">Vegye figyelembe, hogy a két hello adatra toocreate hello szereplő proxy objektum használja a következők: hello szereplő azonosító és hello alkalmazás neve.</span><span class="sxs-lookup"><span data-stu-id="f7c90-170">Note that hello two pieces of information used toocreate hello actor proxy object are hello actor ID and hello application name.</span></span> <span data-ttu-id="f7c90-171">hello szereplő azonosító egyedileg azonosítja hello szereplő hello alkalmazás neve azonosítja a hello [Service Fabric-alkalmazás](service-fabric-reliable-actors-platform.md#application-model) hello szereplő telepítési helyét.</span><span class="sxs-lookup"><span data-stu-id="f7c90-171">hello actor ID uniquely identifies hello actor, while hello application name identifies hello [Service Fabric application](service-fabric-reliable-actors-platform.md#application-model) where hello actor is deployed.</span></span>

<span data-ttu-id="f7c90-172">Hello `ActorProxy`(C#) / `ActorProxyBase`(Java) osztály hello ügyféloldalon hello szükséges feloldási toolocate hello szereplő azonosító alapján hajtja végre, és nyissa meg azt a kommunikációs csatornát.</span><span class="sxs-lookup"><span data-stu-id="f7c90-172">hello `ActorProxy`(C#) / `ActorProxyBase`(Java) class on hello client side performs hello necessary resolution toolocate hello actor by ID and open a communication channel with it.</span></span> <span data-ttu-id="f7c90-173">Kommunikációs hibák és a feladatátvétel hello esetekben toolocate hello szereplő is újrapróbálkozik.</span><span class="sxs-lookup"><span data-stu-id="f7c90-173">It also retries toolocate hello actor in hello cases of communication failures and failovers.</span></span> <span data-ttu-id="f7c90-174">Ennek eredményeképpen a üzenetkézbesítést hello a következő jellemzőkkel rendelkezik:</span><span class="sxs-lookup"><span data-stu-id="f7c90-174">As a result, message delivery has hello following characteristics:</span></span>

* <span data-ttu-id="f7c90-175">Üzenet kézbesítési a lehető legkedvezőbb módon.</span><span class="sxs-lookup"><span data-stu-id="f7c90-175">Message delivery is best effort.</span></span>
* <span data-ttu-id="f7c90-176">Gyakrabban is duplikált üzenetek fogadása hello ugyanazt az ügyfelet.</span><span class="sxs-lookup"><span data-stu-id="f7c90-176">Actors may receive duplicate messages from hello same client.</span></span>

### <a name="concurrency"></a><span data-ttu-id="f7c90-177">Egyidejűség</span><span class="sxs-lookup"><span data-stu-id="f7c90-177">Concurrency</span></span>
<span data-ttu-id="f7c90-178">hello Reliable Actors futásidejű szereplő módszerek eléréséhez egyszerű kapcsolja-alapú hozzáférés modellt biztosít.</span><span class="sxs-lookup"><span data-stu-id="f7c90-178">hello Reliable Actors runtime provides a simple turn-based access model for accessing actor methods.</span></span> <span data-ttu-id="f7c90-179">Ez azt jelenti, hogy legfeljebb egy szál lehet aktív belső az aktor objektum kódot bármikor.</span><span class="sxs-lookup"><span data-stu-id="f7c90-179">This means that no more than one thread can be active inside an actor object's code at any time.</span></span> <span data-ttu-id="f7c90-180">Kapcsolja a szerepköralapú hozzáférés egyidejű rendszerek jelentősen egyszerűbb, mivel nincs szükség a szinkronizálási mechanizmus az adatelérési.</span><span class="sxs-lookup"><span data-stu-id="f7c90-180">Turn-based access greatly simplifies concurrent systems as there is no need for synchronization mechanisms for data access.</span></span> <span data-ttu-id="f7c90-181">Azt is jelenti, rendszerek minden szereplő példány hello egyszálas hozzáférés jellegű szempontot kell megtervezni.</span><span class="sxs-lookup"><span data-stu-id="f7c90-181">It also means systems must be designed with special considerations for hello single-threaded access nature of each actor instance.</span></span>

* <span data-ttu-id="f7c90-182">A szereplő egyetlen példánya több kérelem nem dolgozható fel egyszerre.</span><span class="sxs-lookup"><span data-stu-id="f7c90-182">A single actor instance cannot process more than one request at a time.</span></span> <span data-ttu-id="f7c90-183">Aktor példánya okozhat a teljesítmény szűk keresztmetszetek várt toohandle egyidejű kérelmek esetén.</span><span class="sxs-lookup"><span data-stu-id="f7c90-183">An actor instance can cause a throughput bottleneck if it is expected toohandle concurrent requests.</span></span>
* <span data-ttu-id="f7c90-184">Gyakrabban is kölcsönös kizárás egymástól, ha két szereplője, amíg egy külső kérelem tooone hello szereplője az egyidejűleg között körkörös kérelmet.</span><span class="sxs-lookup"><span data-stu-id="f7c90-184">Actors can deadlock on each other if there is a circular request between two actors while an external request is made tooone of hello actors simultaneously.</span></span> <span data-ttu-id="f7c90-185">hello szereplő futásidejű lesz automatikusan idő ki szereplő hívja, és egy kivétel toohello hívó toointerrupt holtpont lehetséges helyzetben kivételt.</span><span class="sxs-lookup"><span data-stu-id="f7c90-185">hello actor runtime will automatically time out on actor calls and throw an exception toohello caller toointerrupt possible deadlock situations.</span></span>

![Megbízható szereplője kommunikációt][3]

#### <a name="turn-based-access"></a><span data-ttu-id="f7c90-187">Kapcsolja a szerepköralapú hozzáférés</span><span class="sxs-lookup"><span data-stu-id="f7c90-187">Turn-based access</span></span>
<span data-ttu-id="f7c90-188">Egy teljes végrehajtási hello más szereplője vagy az ügyfelek a válasz tooa kérelemben szereplő metódus, vagy hello teljes végrehajtását tartalmaz egy [időzítő/emlékeztető](service-fabric-reliable-actors-timers-reminders.md) visszahívás.</span><span class="sxs-lookup"><span data-stu-id="f7c90-188">A turn consists of hello complete execution of an actor method in response tooa request from other actors or clients, or hello complete execution of a [timer/reminder](service-fabric-reliable-actors-timers-reminders.md) callback.</span></span> <span data-ttu-id="f7c90-189">Annak ellenére, hogy ezen metódusok és a visszahívások aszinkron, hello szereplője futásidejű nem interleave őket.</span><span class="sxs-lookup"><span data-stu-id="f7c90-189">Even though these methods and callbacks are asynchronous, hello Actors runtime does not interleave them.</span></span> <span data-ttu-id="f7c90-190">Egy teljesen kész kell, mielőtt új kapcsolja engedélyezett.</span><span class="sxs-lookup"><span data-stu-id="f7c90-190">A turn must be fully finished before a new turn is allowed.</span></span> <span data-ttu-id="f7c90-191">Más szóval egy szereplő metódus vagy időzítő/emlékeztető visszahívást, amelyet éppen végrehajtás alatt teljesen befejezése előtt egy új tooa telefonhívás vagy visszahívási engedélyezett.</span><span class="sxs-lookup"><span data-stu-id="f7c90-191">In other words, an actor method or timer/reminder callback that is currently executing must be fully finished before a new call tooa method or callback is allowed.</span></span> <span data-ttu-id="f7c90-192">A metódus vagy a visszahívási tekinteni toohave befejeződött, ha hello rendelkezik adott eredményül hello metódusból vagy hello metódust vagy a visszahívási által visszaadott visszahívási és hello feladat befejezése után.</span><span class="sxs-lookup"><span data-stu-id="f7c90-192">A method or callback is considered toohave finished if hello execution has returned from hello method or callback and hello task returned by hello method or callback has finished.</span></span> <span data-ttu-id="f7c90-193">Érdemes fogalmazás, hogy kapcsolja-alapú feldolgozási tiszteletben tartják még különböző módszereket, időzítők és visszahívások között.</span><span class="sxs-lookup"><span data-stu-id="f7c90-193">It is worth emphasizing that turn-based concurrency is respected even across different methods, timers, and callbacks.</span></span>

<span data-ttu-id="f7c90-194">hello szereplője futásidejű kapcsolja-alapú feldolgozási kikényszeríti által az beszerzése egy aktoronkénti zárolásra egy kapcsolja a hello elején, és kapcsolja hello hello végén hello zárolás feloldása.</span><span class="sxs-lookup"><span data-stu-id="f7c90-194">hello Actors runtime enforces turn-based concurrency by acquiring a per-actor lock at hello beginning of a turn and releasing hello lock at hello end of hello turn.</span></span> <span data-ttu-id="f7c90-195">Ebből kifolyólag kapcsolja-alapú feldolgozási aktoronkénti alapon és szereplője között nem érvényes.</span><span class="sxs-lookup"><span data-stu-id="f7c90-195">Thus, turn-based concurrency is enforced on a per-actor basis and not across actors.</span></span> <span data-ttu-id="f7c90-196">Aktor módszerek egyidejűleg végrehajtható időzítő/emlékeztető visszahívások, különböző szereplője nevében.</span><span class="sxs-lookup"><span data-stu-id="f7c90-196">Actor methods and timer/reminder callbacks can execute simultaneously on behalf of different actors.</span></span>

<span data-ttu-id="f7c90-197">a következő példa hello fent fogalmak hello mutatja be.</span><span class="sxs-lookup"><span data-stu-id="f7c90-197">hello following example illustrates hello above concepts.</span></span> <span data-ttu-id="f7c90-198">Vegye figyelembe az aktor típusa, amely megvalósítja az két aszinkron metódusok (tegyük fel például, *Method1* és *Method2*), időzítő, valamint egy emlékeztető.</span><span class="sxs-lookup"><span data-stu-id="f7c90-198">Consider an actor type that implements two asynchronous methods (say, *Method1* and *Method2*), a timer, and a reminder.</span></span> <span data-ttu-id="f7c90-199">az alábbi ábrán hello hello végrehajtásra ezen módszerek és a visszahívások két szereplője nevében ütemterv példáját mutatja be (*ActorId1* és *ActorId2*), amely toothis szereplő típus tartozik.</span><span class="sxs-lookup"><span data-stu-id="f7c90-199">hello diagram below shows an example of a timeline for hello execution of these methods and callbacks on behalf of two actors (*ActorId1* and *ActorId2*) that belong toothis actor type.</span></span>

![Megbízható szereplője futásidejű kapcsolja-alapú feldolgozási és a hozzáférés][1]

<span data-ttu-id="f7c90-201">Ez az ábra ezeket a szabályokat követi:</span><span class="sxs-lookup"><span data-stu-id="f7c90-201">This diagram follows these conventions:</span></span>

* <span data-ttu-id="f7c90-202">Minden egyes függőleges vonal szemlélteti hello logikai metódust, illetve egy visszahívás végrehajtása egy adott szereplő nevében.</span><span class="sxs-lookup"><span data-stu-id="f7c90-202">Each vertical line shows hello logical flow of execution of a method or a callback on behalf of a particular actor.</span></span>
* <span data-ttu-id="f7c90-203">minden egyes függőleges vonal tüntetve hello esemény újabb régieket alatt bekövetkező események időrendi sorrendben következik be.</span><span class="sxs-lookup"><span data-stu-id="f7c90-203">hello events marked on each vertical line occur in chronological order, with newer events occurring below older ones.</span></span>
* <span data-ttu-id="f7c90-204">Különböző színek ütemtervek megfelelő toodifferent gyakrabban használ.</span><span class="sxs-lookup"><span data-stu-id="f7c90-204">Different colors are used for timelines corresponding toodifferent actors.</span></span>
* <span data-ttu-id="f7c90-205">Használt tooindicate hello időtartam, mely hello az aktoronkénti zárolásra nevében metódust vagy visszahívási tárolt kiemelés.</span><span class="sxs-lookup"><span data-stu-id="f7c90-205">Highlighting is used tooindicate hello duration for which hello per-actor lock is held on behalf of a method or callback.</span></span>

<span data-ttu-id="f7c90-206">Néhány fontos tényezőt tooconsider:</span><span class="sxs-lookup"><span data-stu-id="f7c90-206">Some important points tooconsider:</span></span>

* <span data-ttu-id="f7c90-207">Amíg *Method1* metódus végrehajtása a következő nevében: *ActorId2* válasz tooclient kérelem *xyz789*, egy másik ügyfélkérés (*abc123*) érkezik, amely megköveteli azt is, *Method1* hajtja végre a toobe *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="f7c90-207">While *Method1* is executing on behalf of *ActorId2* in response tooclient request *xyz789*, another client request (*abc123*) arrives that also requires *Method1* toobe executed by *ActorId2*.</span></span> <span data-ttu-id="f7c90-208">Azonban a második végrehajtásának hello *Method1* nem kezdődik, amíg hello előzetes végrehajtása nem fejeződött be.</span><span class="sxs-lookup"><span data-stu-id="f7c90-208">However, hello second execution of *Method1* does not begin until hello prior execution has finished.</span></span> <span data-ttu-id="f7c90-209">Ehhez hasonlóan emlékeztető által regisztrált *ActorId2* következik be, amikor *Method1* válasz tooclient kérelem végrehajtott *xyz789*.</span><span class="sxs-lookup"><span data-stu-id="f7c90-209">Similarly, a reminder registered by *ActorId2* fires while *Method1* is being executed in response tooclient request *xyz789*.</span></span> <span data-ttu-id="f7c90-210">hello emlékeztető visszahívás végrehajtása mindkét végrehajtások, miután *Method1* befejeződött.</span><span class="sxs-lookup"><span data-stu-id="f7c90-210">hello reminder callback is executed only after both executions of *Method1* are complete.</span></span> <span data-ttu-id="f7c90-211">Mindezt a kényszerítést tooturn alapú párhuzamosság miatt van *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="f7c90-211">All of this is due tooturn-based concurrency being enforced for *ActorId2*.</span></span>
* <span data-ttu-id="f7c90-212">Hasonlóképpen, kapcsolja-alapú feldolgozási is az érvényes *ActorId1*, amint azt a hello végrehajtásának *Method1*, *Method2*, és hello időzítő visszahívási nevében *ActorId1* soros módon történik.</span><span class="sxs-lookup"><span data-stu-id="f7c90-212">Similarly, turn-based concurrency is also enforced for *ActorId1*, as demonstrated by hello execution of *Method1*, *Method2*, and hello timer callback on behalf of *ActorId1* happening in a serial fashion.</span></span>
* <span data-ttu-id="f7c90-213">Végrehajtásának *Method1* nevében *ActorId1* átfedésben van a végrehajtása a következő nevében: *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="f7c90-213">Execution of *Method1* on behalf of *ActorId1* overlaps with its execution on behalf of *ActorId2*.</span></span> <span data-ttu-id="f7c90-214">Ennek az az oka kapcsolja-alapú feldolgozási csak egy szereplő belül és szereplője között nem kényszeríti ki.</span><span class="sxs-lookup"><span data-stu-id="f7c90-214">This is because turn-based concurrency is enforced only within an actor and not across actors.</span></span>
* <span data-ttu-id="f7c90-215">Egyes hello metódus/visszahívási végrehajtások hello `Task`(C#) / `CompletableFuture`(Java) hello metódus/visszahívási befejeződik által visszaadott, miután hello metódus ad vissza.</span><span class="sxs-lookup"><span data-stu-id="f7c90-215">In some of hello method/callback executions, hello `Task`(C#) / `CompletableFuture`(Java) returned by hello method/callback finishes after hello method returns.</span></span> <span data-ttu-id="f7c90-216">Más, a hello aszinkron művelet már befejeződött hello időpontjára hello metódus/visszahívási adja vissza.</span><span class="sxs-lookup"><span data-stu-id="f7c90-216">In some others, hello asynchronous operation has already finished by hello time hello method/callback returns.</span></span> <span data-ttu-id="f7c90-217">Mindkét esetben a hello aktoronkénti zárolásra csak mindkét hello metódus/visszahívási adja vissza, és hello aszinkron művelet befejeződése után felszabadul.</span><span class="sxs-lookup"><span data-stu-id="f7c90-217">In both cases, hello per-actor lock is released only after both hello method/callback returns and hello asynchronous operation finishes.</span></span>

#### <a name="reentrancy"></a><span data-ttu-id="f7c90-218">Rögzítve</span><span class="sxs-lookup"><span data-stu-id="f7c90-218">Reentrancy</span></span>
<span data-ttu-id="f7c90-219">hello szereplője futásidejű rögzítve alapértelmezés szerint lehetővé teszi.</span><span class="sxs-lookup"><span data-stu-id="f7c90-219">hello Actors runtime allows reentrancy by default.</span></span> <span data-ttu-id="f7c90-220">Ez azt jelenti, hogy ha egy aktormetódus a *Aktor A* metódus meghívja *szereplő B*, amely meghívja a másik módszer a *Aktor A*, hogy metódus toorun engedélyezett.</span><span class="sxs-lookup"><span data-stu-id="f7c90-220">This means that if an actor method of *Actor A* calls a method on *Actor B*, which in turn calls another method on *Actor A*, that method is allowed toorun.</span></span> <span data-ttu-id="f7c90-221">Ennek az az oka hello része azonos logikai hívás-lánc környezetben.</span><span class="sxs-lookup"><span data-stu-id="f7c90-221">This is because it is part of hello same logical call-chain context.</span></span> <span data-ttu-id="f7c90-222">Az összes időzítő és felszólítás hívás hello új logikai hívás környezetben kezdődik.</span><span class="sxs-lookup"><span data-stu-id="f7c90-222">All timer and reminder calls start with hello new logical call context.</span></span> <span data-ttu-id="f7c90-223">Lásd: hello [Reliable Actors rögzítve](service-fabric-reliable-actors-reentrancy.md) további részleteket.</span><span class="sxs-lookup"><span data-stu-id="f7c90-223">See hello [Reliable Actors reentrancy](service-fabric-reliable-actors-reentrancy.md) for more details.</span></span>

#### <a name="scope-of-concurrency-guarantees"></a><span data-ttu-id="f7c90-224">Párhuzamossági garanciák hatókör</span><span class="sxs-lookup"><span data-stu-id="f7c90-224">Scope of concurrency guarantees</span></span>
<span data-ttu-id="f7c90-225">hello szereplője futásidejű ezek párhuzamossági garanciákat olyan esetekben, ahol az általa szabályozott hello meghívása az alábbi módszerek nyújt.</span><span class="sxs-lookup"><span data-stu-id="f7c90-225">hello Actors runtime provides these concurrency guarantees in situations where it controls hello invocation of these methods.</span></span> <span data-ttu-id="f7c90-226">Például azzal a garanciákat nyújt, amely választ tooa ügyfélkérelemben végzett hello metódus meghívásához, valamint időzítő és felszólítás visszahívások.</span><span class="sxs-lookup"><span data-stu-id="f7c90-226">For example, it provides these guarantees for hello method invocations that are done in response tooa client request, as well as for timer and reminder callbacks.</span></span> <span data-ttu-id="f7c90-227">Azonban hello szereplő kód közvetlenül ezen módszerek kívül hello mechanizmusok hello szereplője futtatókörnyezet által biztosított hív, ha majd hello futásidejű nem adhatók meg bármely párhuzamossági garanciát.</span><span class="sxs-lookup"><span data-stu-id="f7c90-227">However, if hello actor code directly invokes these methods outside of hello mechanisms provided by hello Actors runtime, then hello runtime cannot provide any concurrency guarantees.</span></span> <span data-ttu-id="f7c90-228">Például ha hello metódus hivatkoznak, néhány feladatot, amely nincs társítva a hello tevékenység aktor módszerek hello által visszaadott hello környezetében, majd hello futásidejű nem tud párhuzamossági garanciát.</span><span class="sxs-lookup"><span data-stu-id="f7c90-228">For example, if hello method is invoked in hello context of some task that is not associated with hello task returned by hello actor methods, then hello runtime cannot provide concurrency guarantees.</span></span> <span data-ttu-id="f7c90-229">Ha hello metódust egy olyan szálból hívják adott hello szereplő hoz létre a saját, majd hello futásidejű is nem adhatók meg a feldolgozási garanciát.</span><span class="sxs-lookup"><span data-stu-id="f7c90-229">If hello method is invoked from a thread that hello actor creates on its own, then hello runtime also cannot provide concurrency guarantees.</span></span> <span data-ttu-id="f7c90-230">Ezért tooperform háttérbeli műveletek végrehajtását, szereplője használandó [szereplő időzítők és szereplő emlékeztetők](service-fabric-reliable-actors-timers-reminders.md) , figyelembe vegyék kapcsolja-alapú feldolgozási.</span><span class="sxs-lookup"><span data-stu-id="f7c90-230">Therefore, tooperform background operations, actors should use [actor timers and actor reminders](service-fabric-reliable-actors-timers-reminders.md) that respect turn-based concurrency.</span></span>

## <a name="next-steps"></a><span data-ttu-id="f7c90-231">Következő lépések</span><span class="sxs-lookup"><span data-stu-id="f7c90-231">Next steps</span></span>
* <span data-ttu-id="f7c90-232">Ismerkedés az első Reliable Actors szolgáltatás épület:</span><span class="sxs-lookup"><span data-stu-id="f7c90-232">Get started by building your first Reliable Actors service:</span></span>
   * [<span data-ttu-id="f7c90-233">Bevezetés a Reliable Actors a .NET használatába</span><span class="sxs-lookup"><span data-stu-id="f7c90-233">Getting started with Reliable Actors on .NET</span></span>](service-fabric-reliable-actors-get-started.md)
   * [<span data-ttu-id="f7c90-234">Ismerkedés a Java a Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="f7c90-234">Getting started with Reliable Actors on Java</span></span>](service-fabric-reliable-actors-get-started-java.md)

<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-introduction/concurrency.png
[2]: ./media/service-fabric-reliable-actors-introduction/distribution.png
[3]: ./media/service-fabric-reliable-actors-introduction/actor-communication.png
