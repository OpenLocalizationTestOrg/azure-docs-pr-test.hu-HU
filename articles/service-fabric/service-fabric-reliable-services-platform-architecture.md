---
title: "Megbízható service-architektúra |} Microsoft Docs"
description: "Az állapot nélküli és állapotalapú alkalmazások és szolgáltatások megbízható Service-architektúra áttekintése"
services: service-fabric
documentationcenter: .net
author: AlanWarwick
manager: timlt
editor: vturecek
ms.assetid: af002ae6-7f6d-4769-b049-82aa1ba0891b
ms.service: Service-Fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 03/30/2016
ms.author: alanwar
redirect_url: /azure/service-fabric/service-fabric-reliable-services-introduction
ms.openlocfilehash: a00a16945356b9731485554e06df46528b5c7bb2
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 07/11/2017
---
# <a name="architecture-for-stateful-and-stateless-reliable-services"></a><span data-ttu-id="289be-103">Állapot nélküli és állapotalapú Reliable Services architektúrája</span><span class="sxs-lookup"><span data-stu-id="289be-103">Architecture for stateful and stateless Reliable Services</span></span>
<span data-ttu-id="289be-104">Az Azure Service Fabric-megbízható szolgáltatás állapot-nyilvántartó vagy állapotmentes lehet.</span><span class="sxs-lookup"><span data-stu-id="289be-104">An Azure Service Fabric Reliable Service may be stateful or stateless.</span></span> <span data-ttu-id="289be-105">Minden szolgáltatás típusának belül egy adott architektúra fut.</span><span class="sxs-lookup"><span data-stu-id="289be-105">Each type of service runs within a specific architecture.</span></span> <span data-ttu-id="289be-106">Ez a cikk ismerteti ezek architektúrák.</span><span class="sxs-lookup"><span data-stu-id="289be-106">These architectures are described in this article.</span></span>
<span data-ttu-id="289be-107">Tekintse meg a [megbízható szolgáltatás áttekintése](service-fabric-reliable-services-introduction.md) állapot nélküli és állapotalapú alkalmazások és szolgáltatások közötti különbségekről további információt.</span><span class="sxs-lookup"><span data-stu-id="289be-107">See the [Reliable Service overview](service-fabric-reliable-services-introduction.md) for more information about the differences between stateful and stateless services.</span></span>

## <a name="stateful-reliable-services"></a><span data-ttu-id="289be-108">Állapotalapú Reliable Services</span><span class="sxs-lookup"><span data-stu-id="289be-108">Stateful Reliable Services</span></span>
### <a name="architecture-of-a-stateful-service"></a><span data-ttu-id="289be-109">Az állapotalapú szolgáltatás architektúrája</span><span class="sxs-lookup"><span data-stu-id="289be-109">Architecture of a stateful service</span></span>
![Az állapotalapú szolgáltatás architektúra ábrája](./media/service-fabric-reliable-services-platform-architecture/reliable-stateful-service-architecture.png)

### <a name="stateful-reliable-service"></a><span data-ttu-id="289be-111">Az állapotalapú szolgáltatás</span><span class="sxs-lookup"><span data-stu-id="289be-111">Stateful Reliable Service</span></span>
<span data-ttu-id="289be-112">Állapot-nyilvántartó működnie StatefulService vagy StatefulServiceBase osztályból származtathatók.</span><span class="sxs-lookup"><span data-stu-id="289be-112">A stateful Reliable Service can derive from either the StatefulService or StatefulServiceBase class.</span></span> <span data-ttu-id="289be-113">Mindkét ezek alaposztályok Service Fabric által biztosított.</span><span class="sxs-lookup"><span data-stu-id="289be-113">Both of these base classes are provided by Service Fabric.</span></span> <span data-ttu-id="289be-114">Különböző szintű támogatást és az állapotalapú szolgáltatás kommunikáljon a Service Fabric--és részt venni a Service Fabric-fürt belül szolgáltatásként absztrakciós kínálnak.</span><span class="sxs-lookup"><span data-stu-id="289be-114">They offer various levels of support and abstraction for the stateful service to interface with Service Fabric--and to participate as a service within the Service Fabric cluster.</span></span>

<span data-ttu-id="289be-115">StatefulService StatefulServiceBase származik.</span><span class="sxs-lookup"><span data-stu-id="289be-115">StatefulService derives from StatefulServiceBase.</span></span> <span data-ttu-id="289be-116">StatefulServiceBase nagyobb rugalmasságot biztosít, szolgáltatásokat, de a Service Fabric rendszerarchitektúra további ismerete szükséges.</span><span class="sxs-lookup"><span data-stu-id="289be-116">StatefulServiceBase offers services more flexibility, but requires more understanding of the internals of Service Fabric.</span></span>
<span data-ttu-id="289be-117">Tekintse meg a [megbízható szolgáltatás áttekintése](service-fabric-reliable-services-introduction.md) és [megbízható szolgáltatás használati speciális](service-fabric-reliable-services-advanced-usage.md) szolgáltatások rendszerekben a StatefulService és StatefulServiceBase osztályok használatával a részletekről további információt.</span><span class="sxs-lookup"><span data-stu-id="289be-117">See the [Reliable Service overview](service-fabric-reliable-services-introduction.md) and [Reliable Service advanced usage](service-fabric-reliable-services-advanced-usage.md) for more information on the specifics of writing services by using the StatefulService and StatefulServiceBase classes.</span></span>

<span data-ttu-id="289be-118">Mindkét alaposztályok élettartamát és a szolgáltatás megvalósítási szerepe kezelheti.</span><span class="sxs-lookup"><span data-stu-id="289be-118">Both base classes manage the lifetime and role of the service implementation.</span></span> <span data-ttu-id="289be-119">A szolgáltatás megvalósítási virtuális metódusok vagy alaposztály bírálhatja felül adott időpontokban, a szolgáltatás megvalósítási életciklusának--tennivalója a szolgáltatásimplementáció-e, vagy ha azt szeretné, hogy a kommunikációs figyelő objektum létrehozásához.</span><span class="sxs-lookup"><span data-stu-id="289be-119">The service implementation may override virtual methods of either base class if the service implementation has work to do at those points in the service implementation lifecycle--or if it wants to create a communication listener object.</span></span> <span data-ttu-id="289be-120">Megjegyzés:, hogy a szolgáltatás megvalósítása nehéznek saját kommunikációs figyelő objektum, a fenti ábrán az ilyen ICommunicationListener, bár a kommunikációs figyelő megvalósítja a Service Fabric – a szolgáltatás a Service Fabric által megvalósított kommunikációs figyelő használ.</span><span class="sxs-lookup"><span data-stu-id="289be-120">Note that although a service implementation may implement its own communication listener object exposing ICommunicationListener, in the diagram above, the communication listener is implemented by Service Fabric--as the service implementation uses a communication listener that is implemented by Service Fabric.</span></span>

<span data-ttu-id="289be-121">Egy állapot-nyilvántartó megbízható szolgáltatás megbízható állapotkezelő használja a megbízható gyűjtemények előnyeit.</span><span class="sxs-lookup"><span data-stu-id="289be-121">A stateful Reliable Service uses the reliable state manager to take advantage of reliable collections.</span></span> <span data-ttu-id="289be-122">Megbízható gyűjtemények helyi adatstruktúrák, amelyek a szolgáltatás –, amely a magas rendelkezésre állású, olyan mindig elérhető, függetlenül a feladatátvétel szolgáltatás.</span><span class="sxs-lookup"><span data-stu-id="289be-122">Reliable collections are local data structures that are highly available to the service--that is, they are always available, regardless of service failovers.</span></span> <span data-ttu-id="289be-123">A megbízható gyűjtemény típusonkénti megbízható állapotszolgáltató valósítják meg.</span><span class="sxs-lookup"><span data-stu-id="289be-123">Each type of reliable collection is implemented by a reliable state provider.</span></span>
<span data-ttu-id="289be-124">A megbízható gyűjtemények további információkért lásd: a [megbízható gyűjtemények áttekintése](service-fabric-reliable-services-reliable-collections.md).</span><span class="sxs-lookup"><span data-stu-id="289be-124">For more information on reliable collections, see the [reliable collections overview](service-fabric-reliable-services-reliable-collections.md).</span></span>

### <a name="reliable-state-manager-and-state-providers"></a><span data-ttu-id="289be-125">Megbízható állapotkezelője és állapotszolgáltatója</span><span class="sxs-lookup"><span data-stu-id="289be-125">Reliable state manager and state providers</span></span>
<span data-ttu-id="289be-126">A megbízható állapotkezelője egy olyan objektum, amely megbízható állapotszolgáltatója kezeli.</span><span class="sxs-lookup"><span data-stu-id="289be-126">The reliable state manager is the object that manages reliable state providers.</span></span> <span data-ttu-id="289be-127">A funkció létrehozása, törlése, enumerálása, és győződjön meg arról, hogy a megbízható állapotszolgáltatója megőrzött és magas rendelkezésre állású rendelkezik.</span><span class="sxs-lookup"><span data-stu-id="289be-127">It has the functionality to create, delete, enumerate, and ensure that the reliable state providers are persisted and highly available.</span></span> <span data-ttu-id="289be-128">Egy megbízható állapota szolgáltató példányt megőrzött és magas rendelkezésre állású adatszerkezet, például egy könyvtár, illetve a várólista egyik példányát képviseli.</span><span class="sxs-lookup"><span data-stu-id="289be-128">A reliable state provider instance represents an instance of a persisted and highly available data structure, such as a dictionary or a queue.</span></span>

<span data-ttu-id="289be-129">Minden megbízható állapotszolgáltató mutatja meg a megbízható állapotszolgáltató együttműködhet egy állapotalapú szolgáltatás által használt felületet.</span><span class="sxs-lookup"><span data-stu-id="289be-129">Each reliable state provider exposes an interface that is used by a stateful service to interact with the reliable state provider.</span></span> <span data-ttu-id="289be-130">Például IReliableDictionary szolgál a megbízható adatkönyvtárhoz, míg az IReliableQueue felületre a megbízható sor felületre.</span><span class="sxs-lookup"><span data-stu-id="289be-130">For example, IReliableDictionary is used to interface with the reliable dictionary, while IReliableQueue is used to interface with the reliable queue.</span></span> <span data-ttu-id="289be-131">Minden megbízható állapotszolgáltatója valósítja meg az IReliableState illesztőfelületet.</span><span class="sxs-lookup"><span data-stu-id="289be-131">All reliable state providers implement the IReliableState interface.</span></span>

<span data-ttu-id="289be-132">A megbízható állapotkezelője egy IReliableStateManager, amely lehetővé teszi a hozzáférést, az állapotalapú szolgáltatásból nevű felülettel rendelkezik.</span><span class="sxs-lookup"><span data-stu-id="289be-132">The reliable state manager has an interface named IReliableStateManager, which allows access to it from a stateful service.</span></span> <span data-ttu-id="289be-133">Megbízható állapotszolgáltatója felületet IReliableStateManager keresztül adja vissza.</span><span class="sxs-lookup"><span data-stu-id="289be-133">Interfaces to reliable state providers are returned through IReliableStateManager.</span></span>

<span data-ttu-id="289be-134">A megbízható állapotkezelője beépülő modul architektúrát használ, így az új típusú megbízható gyűjteményeket is csatlakoztatható dinamikusan.</span><span class="sxs-lookup"><span data-stu-id="289be-134">The reliable state manager uses a plug-in architecture so that new types of reliable collections can be plugged in dynamically.</span></span>

<span data-ttu-id="289be-135">A megbízható szótár és megbízható várólista beépített egy nagy teljesítményű, verzióval ellátott különbözeti tároló végrehajtásakor.</span><span class="sxs-lookup"><span data-stu-id="289be-135">The reliable dictionary and reliable queue are built upon the implementation of a high-performance, versioned differential store.</span></span>

### <a name="transactional-replicator"></a><span data-ttu-id="289be-136">Tranzakciós replikátor</span><span class="sxs-lookup"><span data-stu-id="289be-136">Transactional replicator</span></span>
<span data-ttu-id="289be-137">A tranzakciós replikátor összetevője biztosításáért, hogy egy szolgáltatást (Ez azt jelenti, hogy a megbízható állapotkezelője és a megbízható gyűjtemények állapot) állapota konzisztens szolgáltatást futtató összes replika között.</span><span class="sxs-lookup"><span data-stu-id="289be-137">The transactional replicator component is responsible for ensuring that the state of a service (that is, the state within the reliable state manager and the reliable collections) is consistent across all replicas running the service.</span></span> <span data-ttu-id="289be-138">Emellett biztosítja, hogy az állapot a naplóban megőrződjenek.</span><span class="sxs-lookup"><span data-stu-id="289be-138">It also ensures that the state is persisted in the log.</span></span> <span data-ttu-id="289be-139">A megbízható állapotát kezelő kapcsolódási pontok a tranzakciós replikátor titkos mechanizmus révén.</span><span class="sxs-lookup"><span data-stu-id="289be-139">The reliable state manager interfaces with the transactional replicator via a private mechanism.</span></span>

<span data-ttu-id="289be-140">A tranzakciós replikátor egy hálózati protokoll segítségével kommunikálnak a szolgáltatáspéldány más replikával állapotát, hogy minden replikának naprakész állapotadatokat.</span><span class="sxs-lookup"><span data-stu-id="289be-140">The transactional replicator uses a network protocol to communicate state with other replicas of the service instance so that all replicas have up-to-date state information.</span></span>

<span data-ttu-id="289be-141">A tranzakciós replikátor napló használatával állapotadatokat továbbra is fennáll, így az állapotinformációkat survives folyamat vagy csomópont összeomlik.</span><span class="sxs-lookup"><span data-stu-id="289be-141">The transactional replicator uses a log to persist state information so that the state information survives process or node crashes.</span></span> <span data-ttu-id="289be-142">A naplózandó felülete, titkos mechanizmus révén.</span><span class="sxs-lookup"><span data-stu-id="289be-142">The interface to the log is via a private mechanism.</span></span>

### <a name="log"></a><span data-ttu-id="289be-143">Napló</span><span class="sxs-lookup"><span data-stu-id="289be-143">Log</span></span>
<span data-ttu-id="289be-144">A napló az összetevő biztosítja egy nagy teljesítményű állandó tároló írásra is lehet optimalizálni a forgó vagy tartós állapotú lemezeket.</span><span class="sxs-lookup"><span data-stu-id="289be-144">The log component provides a high-performance persistent store that can be optimized for writing to spinning or solid-state disks.</span></span>  <span data-ttu-id="289be-145">Az állandó tároló (azaz merevlemezek) kell lennie a csomópontok az állapot-nyilvántartó szolgáltatást futtató helyi napló tervezési szolgál.</span><span class="sxs-lookup"><span data-stu-id="289be-145">The design of the log is for the persistent storage (i.e., hard disks) to be local to the nodes that are running the stateful service.</span></span> <span data-ttu-id="289be-146">Ez lehetővé teszi a kis késleltetésű és a magas teljesítmény távoli állandó tároló, amely nem a csomópont helyi képest.</span><span class="sxs-lookup"><span data-stu-id="289be-146">This allows for low latencies and high throughput, as compared to remote persistent storage, which is not local to the node.</span></span>

<span data-ttu-id="289be-147">A napló összetevő több naplófájlt használ.</span><span class="sxs-lookup"><span data-stu-id="289be-147">The log component uses multiple log files.</span></span> <span data-ttu-id="289be-148">Hogy egy csomópont kiterjedő megosztott naplófájl van, amely az összes replika használhatja azt is adja meg a legkisebb mértékű késleltetést és legnagyobb átviteli sebességet-állapot adatainak tárolásához.</span><span class="sxs-lookup"><span data-stu-id="289be-148">There is a node-wide shared log file that all replicas use as it can provide the lowest latency and highest throughput for storing state data.</span></span> <span data-ttu-id="289be-149">Alapértelmezés szerint a megosztott napló a Service Fabric-csomópont munkakönyvtár kerül, de azt is el kell helyezni egy lemezen csak a megosztott napló számára fenntartott ideális esetben egy másik helyen konfigurálhatók.</span><span class="sxs-lookup"><span data-stu-id="289be-149">By default the shared log is placed in the Service Fabric node work directory but it may also be configured to be placed at another location, ideally on a disk reserved for only the shared log.</span></span> <span data-ttu-id="289be-150">A szolgáltatás összes replikát is rendelkezik egy dedikált naplófájlt, és a dedikált napló helyezkedik el, a szolgáltatás munkakönyvtár belül.</span><span class="sxs-lookup"><span data-stu-id="289be-150">Each replica for the service also has a dedicated log file and the dedicated log is placed within the service's work directory.</span></span> <span data-ttu-id="289be-151">Nincs olyan mechanizmus konfigurálása a dedikált napló más helyen kell elhelyezni.</span><span class="sxs-lookup"><span data-stu-id="289be-151">There is no mechanism to configure the dedicated log to be placed at a different location.</span></span>

<span data-ttu-id="289be-152">A megosztott napló egy átmeneti területre, a replika állapota információ addig, amíg a dedikált naplófájl, tároló végső célja.</span><span class="sxs-lookup"><span data-stu-id="289be-152">The shared log is a transitional area for the replica's state information, while the dedicated log file is the final destination where it is persisted.</span></span> <span data-ttu-id="289be-153">Ez a kialakítás az állapotinformációkat először írni a megosztott naplófájlt, és majd lazily át lett helyezve a dedikált naplófájl a háttérben.</span><span class="sxs-lookup"><span data-stu-id="289be-153">In this design, the state information is first written to the shared log file and then lazily moved to the dedicated log file in the background.</span></span> <span data-ttu-id="289be-154">Ezzel a módszerrel a megosztott naplóba írás kellene a legkisebb mértékű késleltetést és legmagasabb átviteli sebességet, amely lehetővé teszi a szolgáltatás gyorsabb halad.</span><span class="sxs-lookup"><span data-stu-id="289be-154">In this way, the write to the shared log would have the lowest latency and highest throughput which allows the service to make progress faster.</span></span>

<span data-ttu-id="289be-155">Beolvassa és a megosztott naplóba írás előzetesen lefoglalt terület a lemezen, a megosztott naplófájl közvetlen I/O keresztül történik.</span><span class="sxs-lookup"><span data-stu-id="289be-155">Reads and writes to the shared log are done via direct IO to preallocated space on the disk for the shared log file.</span></span> <span data-ttu-id="289be-156">Ahhoz, hogy a szabad lemezterület a meghajtón, dedikált naplók optimális használatát, a dedikált naplófájl NTFS újraelemzési fájl jön létre.</span><span class="sxs-lookup"><span data-stu-id="289be-156">To allow optimal use of disk space on the drive with dedicated logs, the dedicated log file is created as a NTFS sparse file.</span></span> <span data-ttu-id="289be-157">Ne feledje, hogy ez lehetővé teszi a elhelyezésétől lemezterület az operációs rendszer megjeleníti a dedikált naplófájlokat sokkal nagyobb területet a lemezen, mint a ténylegesen használt.</span><span class="sxs-lookup"><span data-stu-id="289be-157">Note that this will allow overprovisioning of disk space and the OS will show the dedicated log files using much more disk space than is actually used.</span></span>

<span data-ttu-id="289be-158">Kernelmódú illesztőprogram vezérelt egy minimális felhasználói módú felületet a napló, a napló van megírva.</span><span class="sxs-lookup"><span data-stu-id="289be-158">Aside from a minimal user-mode interface to the log, the log is written as a kernel-mode driver.</span></span> <span data-ttu-id="289be-159">Kernelmódú illesztőprogram működjön, a napló biztosíthat a lehető legjobb teljesítmény az azt használó összes szolgáltatáshoz.</span><span class="sxs-lookup"><span data-stu-id="289be-159">By running as a kernel-mode driver, the log can provide the highest performance to all services that use it.</span></span>

<span data-ttu-id="289be-160">A napló konfigurálásával kapcsolatos további információkért lásd: [állapotalapú Reliable Services konfigurálása](service-fabric-reliable-services-configuration.md).</span><span class="sxs-lookup"><span data-stu-id="289be-160">For more information about configuring the log, see [Configuring stateful Reliable Services](service-fabric-reliable-services-configuration.md).</span></span>

## <a name="stateless-reliable-service"></a><span data-ttu-id="289be-161">Állapot nélküli megbízható szolgáltatás</span><span class="sxs-lookup"><span data-stu-id="289be-161">Stateless Reliable Service</span></span>
### <a name="architecture-of-a-stateless-service"></a><span data-ttu-id="289be-162">Az állapotmentes szolgáltatások architektúrája</span><span class="sxs-lookup"><span data-stu-id="289be-162">Architecture of a stateless service</span></span>
![Az állapotmentes szolgáltatások architektúrája](./media/service-fabric-reliable-services-platform-architecture/reliable-stateless-service-architecture.png)

### <a name="stateless-reliable-service"></a><span data-ttu-id="289be-164">Állapot nélküli megbízható szolgáltatás</span><span class="sxs-lookup"><span data-stu-id="289be-164">Stateless Reliable Service</span></span>
<span data-ttu-id="289be-165">Állapotmentes szolgáltatások megvalósítások StatelessService vagy StatelessServiceBase osztályból származik.</span><span class="sxs-lookup"><span data-stu-id="289be-165">Stateless service implementations derive from the StatelessService or StatelessServiceBase class.</span></span> <span data-ttu-id="289be-166">A StatelessServiceBase osztály lehetővé teszi a StatelessService osztály-nál nagyobb rugalmasságot.</span><span class="sxs-lookup"><span data-stu-id="289be-166">The StatelessServiceBase class allows more flexibility than the StatelessService class.</span></span>
<span data-ttu-id="289be-167">Mindkét alaposztályok kezelése az élettartama és szerepkör-szolgáltatás.</span><span class="sxs-lookup"><span data-stu-id="289be-167">Both base classes manage the lifetime and role of a service.</span></span>

<span data-ttu-id="289be-168">A szolgáltatás megvalósítási virtuális metódusok vagy alaposztály bírálhatja felül a szolgáltatási életciklus – ezek időpontokban tennivalója a szolgáltatás-e, vagy ha azt szeretné, hogy a kommunikációs figyelő objektum létrehozásához.</span><span class="sxs-lookup"><span data-stu-id="289be-168">The service implementation may override virtual methods of either base class if the service has work to do at those points in the service lifecycle--or if it wants to create a communication listener object.</span></span> <span data-ttu-id="289be-169">Megjegyzés:, hogy a szolgáltatás nehéznek saját kommunikációs figyelő objektum, a fenti ábrán az ilyen ICommunicationListener, bár a kommunikációs figyelő megvalósítja a Service Fabric, a szolgáltatás a Service Fabric által megvalósított kommunikációs figyelő használ.</span><span class="sxs-lookup"><span data-stu-id="289be-169">Note that although the service may implement its own communication listener object exposing ICommunicationListener, in the diagram above, the communication listener is implemented by Service Fabric, as that service implementation uses a communication listener that is implemented by Service Fabric.</span></span>

<span data-ttu-id="289be-170">Tekintse meg a [megbízható szolgáltatás áttekintése](service-fabric-reliable-services-introduction.md) és [megbízható szolgáltatás használati speciális](service-fabric-reliable-services-advanced-usage.md) a StatelessService és StatelessServiceBase osztályokat szolgáltatások rendszerekben a részletekről további információt.</span><span class="sxs-lookup"><span data-stu-id="289be-170">See the [Reliable Service overview](service-fabric-reliable-services-introduction.md) and [Reliable Service advanced usage](service-fabric-reliable-services-advanced-usage.md) for more information on the specifics of writing services using the StatelessService and StatelessServiceBase classes.</span></span>

<!--Every topic should have next steps and links to the next logical set of content to keep the customer engaged-->
## <a name="next-steps"></a><span data-ttu-id="289be-171">Következő lépések</span><span class="sxs-lookup"><span data-stu-id="289be-171">Next steps</span></span>
<span data-ttu-id="289be-172">A Service Fabric kapcsolatos további információkért lásd:</span><span class="sxs-lookup"><span data-stu-id="289be-172">For more information about Service Fabric, see:</span></span>

[<span data-ttu-id="289be-173">Megbízható szolgáltatás áttekintése</span><span class="sxs-lookup"><span data-stu-id="289be-173">Reliable service overview</span></span>](service-fabric-reliable-services-introduction.md)

[<span data-ttu-id="289be-174">Első lépések</span><span class="sxs-lookup"><span data-stu-id="289be-174">Quick start</span></span>](service-fabric-reliable-services-quick-start.md)

[<span data-ttu-id="289be-175">Megbízható gyűjtemények áttekintése</span><span class="sxs-lookup"><span data-stu-id="289be-175">Reliable collections overview</span></span>](service-fabric-reliable-services-reliable-collections.md)

[<span data-ttu-id="289be-176">Speciális használati szolgáltatás</span><span class="sxs-lookup"><span data-stu-id="289be-176">Reliable service advanced usage</span></span>](service-fabric-reliable-services-advanced-usage.md)

[<span data-ttu-id="289be-177">Megbízható szolgáltatás konfigurációja</span><span class="sxs-lookup"><span data-stu-id="289be-177">Reliable service configuration</span></span>](service-fabric-reliable-services-configuration.md)  

