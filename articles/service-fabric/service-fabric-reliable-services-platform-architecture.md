---
title: "aaaReliable service-architektúra |} Microsoft Docs"
description: "Az állapot nélküli és állapotalapú alkalmazások és szolgáltatások hello megbízható Service-architektúra áttekintése"
services: service-fabric
documentationcenter: .net
author: AlanWarwick
manager: timlt
editor: vturecek
ms.assetid: af002ae6-7f6d-4769-b049-82aa1ba0891b
ms.service: Service-Fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 03/30/2016
ms.author: alanwar
redirect_url: /azure/service-fabric/service-fabric-reliable-services-introduction
ms.openlocfilehash: d2d0ec9600275ae248ab7717be269cc7204a1e4d
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 10/06/2017
---
# <a name="architecture-for-stateful-and-stateless-reliable-services"></a><span data-ttu-id="e16e9-103">Állapot nélküli és állapotalapú Reliable Services architektúrája</span><span class="sxs-lookup"><span data-stu-id="e16e9-103">Architecture for stateful and stateless Reliable Services</span></span>
<span data-ttu-id="e16e9-104">Az Azure Service Fabric-megbízható szolgáltatás állapot-nyilvántartó vagy állapotmentes lehet.</span><span class="sxs-lookup"><span data-stu-id="e16e9-104">An Azure Service Fabric Reliable Service may be stateful or stateless.</span></span> <span data-ttu-id="e16e9-105">Minden szolgáltatás típusának belül egy adott architektúra fut.</span><span class="sxs-lookup"><span data-stu-id="e16e9-105">Each type of service runs within a specific architecture.</span></span> <span data-ttu-id="e16e9-106">Ez a cikk ismerteti ezek architektúrák.</span><span class="sxs-lookup"><span data-stu-id="e16e9-106">These architectures are described in this article.</span></span>
<span data-ttu-id="e16e9-107">Lásd: hello [megbízható szolgáltatás áttekintése](service-fabric-reliable-services-introduction.md) hello különbségei állapot nélküli és állapotalapú alkalmazások és szolgáltatások további információt.</span><span class="sxs-lookup"><span data-stu-id="e16e9-107">See hello [Reliable Service overview](service-fabric-reliable-services-introduction.md) for more information about hello differences between stateful and stateless services.</span></span>

## <a name="stateful-reliable-services"></a><span data-ttu-id="e16e9-108">Állapotalapú Reliable Services</span><span class="sxs-lookup"><span data-stu-id="e16e9-108">Stateful Reliable Services</span></span>
### <a name="architecture-of-a-stateful-service"></a><span data-ttu-id="e16e9-109">Az állapotalapú szolgáltatás architektúrája</span><span class="sxs-lookup"><span data-stu-id="e16e9-109">Architecture of a stateful service</span></span>
![Az állapotalapú szolgáltatás architektúra ábrája](./media/service-fabric-reliable-services-platform-architecture/reliable-stateful-service-architecture.png)

### <a name="stateful-reliable-service"></a><span data-ttu-id="e16e9-111">Az állapotalapú szolgáltatás</span><span class="sxs-lookup"><span data-stu-id="e16e9-111">Stateful Reliable Service</span></span>
<span data-ttu-id="e16e9-112">Állapot-nyilvántartó működnie hello StatefulService vagy StatefulServiceBase osztály is származik.</span><span class="sxs-lookup"><span data-stu-id="e16e9-112">A stateful Reliable Service can derive from either hello StatefulService or StatefulServiceBase class.</span></span> <span data-ttu-id="e16e9-113">Mindkét ezek alaposztályok Service Fabric által biztosított.</span><span class="sxs-lookup"><span data-stu-id="e16e9-113">Both of these base classes are provided by Service Fabric.</span></span> <span data-ttu-id="e16e9-114">Különböző szintű támogatást és a Service Fabric--és tooparticipate hello állapotalapú szolgáltatási toointerface absztrakciós belül hello Service Fabric-fürt szolgáltatásként kínálnak.</span><span class="sxs-lookup"><span data-stu-id="e16e9-114">They offer various levels of support and abstraction for hello stateful service toointerface with Service Fabric--and tooparticipate as a service within hello Service Fabric cluster.</span></span>

<span data-ttu-id="e16e9-115">StatefulService StatefulServiceBase származik.</span><span class="sxs-lookup"><span data-stu-id="e16e9-115">StatefulService derives from StatefulServiceBase.</span></span> <span data-ttu-id="e16e9-116">StatefulServiceBase nagyobb rugalmasságot biztosít, szolgáltatásokat, de a Service Fabric hello rendszerarchitektúra további megértése szükséges.</span><span class="sxs-lookup"><span data-stu-id="e16e9-116">StatefulServiceBase offers services more flexibility, but requires more understanding of hello internals of Service Fabric.</span></span>
<span data-ttu-id="e16e9-117">Lásd: hello [megbízható szolgáltatás áttekintése](service-fabric-reliable-services-introduction.md) és [használati speciális szolgáltatás](service-fabric-reliable-services-advanced-usage.md) hello részletekről további információt a szolgáltatások leírás hello StatefulService és StatefulServiceBase osztályok használatával .</span><span class="sxs-lookup"><span data-stu-id="e16e9-117">See hello [Reliable Service overview](service-fabric-reliable-services-introduction.md) and [Reliable Service advanced usage](service-fabric-reliable-services-advanced-usage.md) for more information on hello specifics of writing services by using hello StatefulService and StatefulServiceBase classes.</span></span>

<span data-ttu-id="e16e9-118">Mindkét alaposztályok hello élettartamát és hello szolgáltatás végrehajtásának szerepkör kezelése.</span><span class="sxs-lookup"><span data-stu-id="e16e9-118">Both base classes manage hello lifetime and role of hello service implementation.</span></span> <span data-ttu-id="e16e9-119">hello szolgáltatás megvalósítási bírálhatják felül virtuális metódusok vagy alaposztály, ha hello szolgáltatás megvalósítási munkahelyi toodo hello szolgáltatás megvalósítási életciklusa – adott időpontokban vagy ha azt szeretné, hogy a kommunikációs figyelő objektum toocreate.</span><span class="sxs-lookup"><span data-stu-id="e16e9-119">hello service implementation may override virtual methods of either base class if hello service implementation has work toodo at those points in hello service implementation lifecycle--or if it wants toocreate a communication listener object.</span></span> <span data-ttu-id="e16e9-120">Vegye figyelembe, hogy bár a szolgáltatás megvalósítása nehéznek saját kommunikációs figyelő objektum kitettségének ICommunicationListener, a fenti diagramon hello hello kommunikációs figyelő megvalósítja a Service Fabric – hello megvalósított módon használja a a Service Fabric által megvalósított kommunikációs figyelő.</span><span class="sxs-lookup"><span data-stu-id="e16e9-120">Note that although a service implementation may implement its own communication listener object exposing ICommunicationListener, in hello diagram above, hello communication listener is implemented by Service Fabric--as hello service implementation uses a communication listener that is implemented by Service Fabric.</span></span>

<span data-ttu-id="e16e9-121">Állapot-nyilvántartó működnie hello megbízható állapotát kezelő tootake előnyeit megbízható gyűjteményeket használ.</span><span class="sxs-lookup"><span data-stu-id="e16e9-121">A stateful Reliable Service uses hello reliable state manager tootake advantage of reliable collections.</span></span> <span data-ttu-id="e16e9-122">Megbízható gyűjtemények helyi adatstruktúrák, amelyek magas rendelkezésre állású toohello szolgáltatás--, olyan mindig elérhető, függetlenül a feladatátvétel szolgáltatás.</span><span class="sxs-lookup"><span data-stu-id="e16e9-122">Reliable collections are local data structures that are highly available toohello service--that is, they are always available, regardless of service failovers.</span></span> <span data-ttu-id="e16e9-123">A megbízható gyűjtemény típusonkénti megbízható állapotszolgáltató valósítják meg.</span><span class="sxs-lookup"><span data-stu-id="e16e9-123">Each type of reliable collection is implemented by a reliable state provider.</span></span>
<span data-ttu-id="e16e9-124">A megbízható gyűjtemények további információkért lásd: hello [megbízható gyűjtemények áttekintése](service-fabric-reliable-services-reliable-collections.md).</span><span class="sxs-lookup"><span data-stu-id="e16e9-124">For more information on reliable collections, see hello [reliable collections overview](service-fabric-reliable-services-reliable-collections.md).</span></span>

### <a name="reliable-state-manager-and-state-providers"></a><span data-ttu-id="e16e9-125">Megbízható állapotkezelője és állapotszolgáltatója</span><span class="sxs-lookup"><span data-stu-id="e16e9-125">Reliable state manager and state providers</span></span>
<span data-ttu-id="e16e9-126">hello megbízható állapotkezelője hello objektum, amely megbízható állapotszolgáltatója kezeli.</span><span class="sxs-lookup"><span data-stu-id="e16e9-126">hello reliable state manager is hello object that manages reliable state providers.</span></span> <span data-ttu-id="e16e9-127">Hello funkció toocreate, törlése, enumerálásához és győződjön meg arról, hogy megbízható állapotszolgáltatója hello megőrzött és magas rendelkezésre állású rendelkezik.</span><span class="sxs-lookup"><span data-stu-id="e16e9-127">It has hello functionality toocreate, delete, enumerate, and ensure that hello reliable state providers are persisted and highly available.</span></span> <span data-ttu-id="e16e9-128">Egy megbízható állapota szolgáltató példányt megőrzött és magas rendelkezésre állású adatszerkezet, például egy könyvtár, illetve a várólista egyik példányát képviseli.</span><span class="sxs-lookup"><span data-stu-id="e16e9-128">A reliable state provider instance represents an instance of a persisted and highly available data structure, such as a dictionary or a queue.</span></span>

<span data-ttu-id="e16e9-129">Minden megbízható állapotszolgáltató közzétesz egy állapotalapú szolgáltatási toointeract hello megbízható állapota szolgáltató által használt illesztőfelület.</span><span class="sxs-lookup"><span data-stu-id="e16e9-129">Each reliable state provider exposes an interface that is used by a stateful service toointeract with hello reliable state provider.</span></span> <span data-ttu-id="e16e9-130">Például az IReliableDictionary használt toointerface hello megbízható adatkönyvtárhoz, addig, amíg IReliableQueue használt toointerface hello megbízható várólistához.</span><span class="sxs-lookup"><span data-stu-id="e16e9-130">For example, IReliableDictionary is used toointerface with hello reliable dictionary, while IReliableQueue is used toointerface with hello reliable queue.</span></span> <span data-ttu-id="e16e9-131">Minden megbízható állapotszolgáltatója hello IReliableState felületet valósítja meg.</span><span class="sxs-lookup"><span data-stu-id="e16e9-131">All reliable state providers implement hello IReliableState interface.</span></span>

<span data-ttu-id="e16e9-132">hello megbízható állapotkezelője egy IReliableStateManager, amely lehetővé teszi az állapotalapú szolgáltatásból hozzáférés tooit nevű felülettel rendelkezik.</span><span class="sxs-lookup"><span data-stu-id="e16e9-132">hello reliable state manager has an interface named IReliableStateManager, which allows access tooit from a stateful service.</span></span> <span data-ttu-id="e16e9-133">Felületek tooreliable állapotszolgáltatója IReliableStateManager keresztül adja vissza.</span><span class="sxs-lookup"><span data-stu-id="e16e9-133">Interfaces tooreliable state providers are returned through IReliableStateManager.</span></span>

<span data-ttu-id="e16e9-134">hello megbízható állapotkezelője beépülő modul architektúrát használ, így az új típusú megbízható gyűjteményeket is csatlakoztatható dinamikusan.</span><span class="sxs-lookup"><span data-stu-id="e16e9-134">hello reliable state manager uses a plug-in architecture so that new types of reliable collections can be plugged in dynamically.</span></span>

<span data-ttu-id="e16e9-135">hello megbízható szótár és megbízható várólista beépített egy nagy teljesítményű, verzióval ellátott különbözeti tároló hello végrehajtásakor.</span><span class="sxs-lookup"><span data-stu-id="e16e9-135">hello reliable dictionary and reliable queue are built upon hello implementation of a high-performance, versioned differential store.</span></span>

### <a name="transactional-replicator"></a><span data-ttu-id="e16e9-136">Tranzakciós replikátor</span><span class="sxs-lookup"><span data-stu-id="e16e9-136">Transactional replicator</span></span>
<span data-ttu-id="e16e9-137">hello tranzakciós replikátor összetevő felelős annak biztosítása, hogy a szolgáltatás (Ez azt jelenti, hogy hello állapot hello megbízható állapotkezelője és hello megbízható gyűjtemények belül) hello állapotát konzisztens hello szolgáltatást futtató összes replika között.</span><span class="sxs-lookup"><span data-stu-id="e16e9-137">hello transactional replicator component is responsible for ensuring that hello state of a service (that is, hello state within hello reliable state manager and hello reliable collections) is consistent across all replicas running hello service.</span></span> <span data-ttu-id="e16e9-138">Emellett biztosítja, hogy hello állapot hello naplóban megőrződjenek.</span><span class="sxs-lookup"><span data-stu-id="e16e9-138">It also ensures that hello state is persisted in hello log.</span></span> <span data-ttu-id="e16e9-139">hello megbízható állapotát kezelő kapcsolódási pontok hello tranzakciós replikátor titkos mechanizmus révén.</span><span class="sxs-lookup"><span data-stu-id="e16e9-139">hello reliable state manager interfaces with hello transactional replicator via a private mechanism.</span></span>

<span data-ttu-id="e16e9-140">hello tranzakciós replikátor, hogy minden replikának naprakész állapotadatokat hello szolgáltatáspéldány más replikáinak használ a hálózati protokoll toocommunicate állapota.</span><span class="sxs-lookup"><span data-stu-id="e16e9-140">hello transactional replicator uses a network protocol toocommunicate state with other replicas of hello service instance so that all replicas have up-to-date state information.</span></span>

<span data-ttu-id="e16e9-141">hello tranzakciós replikátor használja a napló toopersist állapotadatokat, így hello állapotadatokat survives folyamat vagy csomópont összeomlik.</span><span class="sxs-lookup"><span data-stu-id="e16e9-141">hello transactional replicator uses a log toopersist state information so that hello state information survives process or node crashes.</span></span> <span data-ttu-id="e16e9-142">hello felület toohello log utasítás titkos mechanizmus révén.</span><span class="sxs-lookup"><span data-stu-id="e16e9-142">hello interface toohello log is via a private mechanism.</span></span>

### <a name="log"></a><span data-ttu-id="e16e9-143">Napló</span><span class="sxs-lookup"><span data-stu-id="e16e9-143">Log</span></span>
<span data-ttu-id="e16e9-144">hello napló összetevője egy nagy teljesítményű állandó tároló is lehet optimalizálni toospinning vagy SSD lemezek írásra biztosítja.</span><span class="sxs-lookup"><span data-stu-id="e16e9-144">hello log component provides a high-performance persistent store that can be optimized for writing toospinning or solid-state disks.</span></span>  <span data-ttu-id="e16e9-145">hello kialakítása hello napló hello állandó tárolás (azaz merevlemezek) esetén a toobe helyi toohello csomópontokon hello állapotalapú szolgáltatásból.</span><span class="sxs-lookup"><span data-stu-id="e16e9-145">hello design of hello log is for hello persistent storage (i.e., hard disks) toobe local toohello nodes that are running hello stateful service.</span></span> <span data-ttu-id="e16e9-146">Ez lehetővé teszi a kis késleltetésű és magas teljesítmény tárolóként összehasonlított tooremote állandó, amely nem helyi toohello csomópont.</span><span class="sxs-lookup"><span data-stu-id="e16e9-146">This allows for low latencies and high throughput, as compared tooremote persistent storage, which is not local toohello node.</span></span>

<span data-ttu-id="e16e9-147">hello napló összetevő több naplófájlt használ.</span><span class="sxs-lookup"><span data-stu-id="e16e9-147">hello log component uses multiple log files.</span></span> <span data-ttu-id="e16e9-148">Hogy egy csomópont kiterjedő megosztott naplófájl van, amely az összes replika használható nyújthat hello legkisebb mértékű késleltetést és legnagyobb átviteli sebességet állapot adatainak tárolásához.</span><span class="sxs-lookup"><span data-stu-id="e16e9-148">There is a node-wide shared log file that all replicas use as it can provide hello lowest latency and highest throughput for storing state data.</span></span> <span data-ttu-id="e16e9-149">Alapértelmezés szerint a Service Fabric-csomópont munkakönyvtár hello hello megosztott napló kerül, de a lemezen csak hello megosztott napló számára fenntartott ideális esetben egy másik helyen elhelyezett konfigurált toobe is lehet.</span><span class="sxs-lookup"><span data-stu-id="e16e9-149">By default hello shared log is placed in hello Service Fabric node work directory but it may also be configured toobe placed at another location, ideally on a disk reserved for only hello shared log.</span></span> <span data-ttu-id="e16e9-150">Minden egyes replikának hello szolgáltatás is rendelkezik egy dedikált naplófájlt, és hello dedikált napló hello szolgáltatás munkakönyvtár belül helyezkedik el.</span><span class="sxs-lookup"><span data-stu-id="e16e9-150">Each replica for hello service also has a dedicated log file and hello dedicated log is placed within hello service's work directory.</span></span> <span data-ttu-id="e16e9-151">Nincs nincs mechanizmus tooconfigure dedikált hello napló toobe elhelyezni egy másik helyen.</span><span class="sxs-lookup"><span data-stu-id="e16e9-151">There is no mechanism tooconfigure hello dedicated log toobe placed at a different location.</span></span>

<span data-ttu-id="e16e9-152">hello megosztott napló hello replika állapota információt egy átmeneti területre, a hello közben dedikált naplófájl hello végső rendeltetési azt tároló.</span><span class="sxs-lookup"><span data-stu-id="e16e9-152">hello shared log is a transitional area for hello replica's state information, while hello dedicated log file is hello final destination where it is persisted.</span></span> <span data-ttu-id="e16e9-153">Ez a kialakítás hello állapotadatokat első írásbeli toohello megosztott naplófájl, és lazily áthelyezése toohello hello háttérben dedikált naplófájl.</span><span class="sxs-lookup"><span data-stu-id="e16e9-153">In this design, hello state information is first written toohello shared log file and then lazily moved toohello dedicated log file in hello background.</span></span> <span data-ttu-id="e16e9-154">Ezzel a módszerrel hello toohello megosztott napló írása kellene hello legkisebb mértékű késleltetést és legnagyobb átviteli sebességet, amely lehetővé teszi gyorsabban hello szolgáltatás toomake folyamatban van.</span><span class="sxs-lookup"><span data-stu-id="e16e9-154">In this way, hello write toohello shared log would have hello lowest latency and highest throughput which allows hello service toomake progress faster.</span></span>

<span data-ttu-id="e16e9-155">Beolvassa és toohello megosztott napló közvetlen I/O toopreallocated lemezterület hello hello megosztott naplófájl keresztül történik.</span><span class="sxs-lookup"><span data-stu-id="e16e9-155">Reads and writes toohello shared log are done via direct IO toopreallocated space on hello disk for hello shared log file.</span></span> <span data-ttu-id="e16e9-156">tooallow és dedikált naplófájlokat hello meghajtón rendelkezésre álló lemezterületet optimális használatát, a hello dedikált naplófájl NTFS ritka fájlként jön létre.</span><span class="sxs-lookup"><span data-stu-id="e16e9-156">tooallow optimal use of disk space on hello drive with dedicated logs, hello dedicated log file is created as a NTFS sparse file.</span></span> <span data-ttu-id="e16e9-157">Ne feledje, hogy ez lehetővé teszi a elhelyezésétől lemezterület az operációs rendszer hello dedikált hello naplófájlokat sokkal nagyobb területet a lemezen, mint a ténylegesen használt megjeleníti.</span><span class="sxs-lookup"><span data-stu-id="e16e9-157">Note that this will allow overprovisioning of disk space and hello OS will show hello dedicated log files using much more disk space than is actually used.</span></span>

<span data-ttu-id="e16e9-158">A minimális felhasználói módú felület toohello napló vezérelt hello napló kernelmódú illesztőprogram van megírva.</span><span class="sxs-lookup"><span data-stu-id="e16e9-158">Aside from a minimal user-mode interface toohello log, hello log is written as a kernel-mode driver.</span></span> <span data-ttu-id="e16e9-159">Kernelmódú illesztőprogram működjön, hello napló biztosíthat hello lehető legjobb teljesítmény tooall szolgáltatások, amelyek használják azt.</span><span class="sxs-lookup"><span data-stu-id="e16e9-159">By running as a kernel-mode driver, hello log can provide hello highest performance tooall services that use it.</span></span>

<span data-ttu-id="e16e9-160">Hello napló konfigurálásával kapcsolatos további információkért lásd: [állapotalapú Reliable Services konfigurálása](service-fabric-reliable-services-configuration.md).</span><span class="sxs-lookup"><span data-stu-id="e16e9-160">For more information about configuring hello log, see [Configuring stateful Reliable Services](service-fabric-reliable-services-configuration.md).</span></span>

## <a name="stateless-reliable-service"></a><span data-ttu-id="e16e9-161">Állapot nélküli megbízható szolgáltatás</span><span class="sxs-lookup"><span data-stu-id="e16e9-161">Stateless Reliable Service</span></span>
### <a name="architecture-of-a-stateless-service"></a><span data-ttu-id="e16e9-162">Az állapotmentes szolgáltatások architektúrája</span><span class="sxs-lookup"><span data-stu-id="e16e9-162">Architecture of a stateless service</span></span>
![Az állapotmentes szolgáltatások architektúrája](./media/service-fabric-reliable-services-platform-architecture/reliable-stateless-service-architecture.png)

### <a name="stateless-reliable-service"></a><span data-ttu-id="e16e9-164">Állapot nélküli megbízható szolgáltatás</span><span class="sxs-lookup"><span data-stu-id="e16e9-164">Stateless Reliable Service</span></span>
<span data-ttu-id="e16e9-165">Állapotmentes szolgáltatások megvalósítások hello StatelessService vagy StatelessServiceBase osztály származik.</span><span class="sxs-lookup"><span data-stu-id="e16e9-165">Stateless service implementations derive from hello StatelessService or StatelessServiceBase class.</span></span> <span data-ttu-id="e16e9-166">hello StatelessServiceBase osztály lehetővé teszi, hogy a rugalmasabb sablontelepítést hello StatelessService osztály.</span><span class="sxs-lookup"><span data-stu-id="e16e9-166">hello StatelessServiceBase class allows more flexibility than hello StatelessService class.</span></span>
<span data-ttu-id="e16e9-167">Mindkét alaposztályok hello élettartamát és szerepkör-szolgáltatás kezelése.</span><span class="sxs-lookup"><span data-stu-id="e16e9-167">Both base classes manage hello lifetime and role of a service.</span></span>

<span data-ttu-id="e16e9-168">hello szolgáltatás megvalósítási bírálhatják felül virtuális metódusok vagy alaposztály, ha hello szolgáltatás munkahelyi toodo hello szolgáltatás életciklusa – adott időpontokban vagy ha azt szeretné, hogy a kommunikációs figyelő objektum toocreate.</span><span class="sxs-lookup"><span data-stu-id="e16e9-168">hello service implementation may override virtual methods of either base class if hello service has work toodo at those points in hello service lifecycle--or if it wants toocreate a communication listener object.</span></span> <span data-ttu-id="e16e9-169">Vegye figyelembe, hogy bár hello szolgáltatás nehéznek saját kommunikációs figyelő objektum kitettségének ICommunicationListener, a fenti diagramon hello hello kommunikációs figyelő megvalósítja a Service Fabric szerint kommunikál a szolgáltatás megvalósítása a Service Fabric által megvalósított figyelő.</span><span class="sxs-lookup"><span data-stu-id="e16e9-169">Note that although hello service may implement its own communication listener object exposing ICommunicationListener, in hello diagram above, hello communication listener is implemented by Service Fabric, as that service implementation uses a communication listener that is implemented by Service Fabric.</span></span>

<span data-ttu-id="e16e9-170">Lásd: hello [megbízható szolgáltatás áttekintése](service-fabric-reliable-services-introduction.md) és [megbízható szolgáltatás használati speciális](service-fabric-reliable-services-advanced-usage.md) hello StatelessService és StatelessServiceBase osztályokat szolgáltatások rendszerekben hello részletekről további információt .</span><span class="sxs-lookup"><span data-stu-id="e16e9-170">See hello [Reliable Service overview](service-fabric-reliable-services-introduction.md) and [Reliable Service advanced usage](service-fabric-reliable-services-advanced-usage.md) for more information on hello specifics of writing services using hello StatelessService and StatelessServiceBase classes.</span></span>

<!--Every topic should have next steps and links toohello next logical set of content tookeep hello customer engaged-->
## <a name="next-steps"></a><span data-ttu-id="e16e9-171">Következő lépések</span><span class="sxs-lookup"><span data-stu-id="e16e9-171">Next steps</span></span>
<span data-ttu-id="e16e9-172">A Service Fabric kapcsolatos további információkért lásd:</span><span class="sxs-lookup"><span data-stu-id="e16e9-172">For more information about Service Fabric, see:</span></span>

[<span data-ttu-id="e16e9-173">Megbízható szolgáltatás áttekintése</span><span class="sxs-lookup"><span data-stu-id="e16e9-173">Reliable service overview</span></span>](service-fabric-reliable-services-introduction.md)

[<span data-ttu-id="e16e9-174">Első lépések</span><span class="sxs-lookup"><span data-stu-id="e16e9-174">Quick start</span></span>](service-fabric-reliable-services-quick-start.md)

[<span data-ttu-id="e16e9-175">Megbízható gyűjtemények áttekintése</span><span class="sxs-lookup"><span data-stu-id="e16e9-175">Reliable collections overview</span></span>](service-fabric-reliable-services-reliable-collections.md)

[<span data-ttu-id="e16e9-176">Speciális használati szolgáltatás</span><span class="sxs-lookup"><span data-stu-id="e16e9-176">Reliable service advanced usage</span></span>](service-fabric-reliable-services-advanced-usage.md)

[<span data-ttu-id="e16e9-177">Megbízható szolgáltatás konfigurációja</span><span class="sxs-lookup"><span data-stu-id="e16e9-177">Reliable service configuration</span></span>](service-fabric-reliable-services-configuration.md)  

