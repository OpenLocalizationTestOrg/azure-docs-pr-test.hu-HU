---
title: "az Azure Service Fabric Reliable Services hello életciklus aaaOverview |} Microsoft Docs"
description: "A Service Fabric megbízható szolgáltatások hello különböző életciklus események"
services: Service-Fabric
documentationcenter: java
author: PavanKunapareddyMSFT
manager: timlt
ms.assetid: 
ms.service: Service-Fabric
ms.devlang: java
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/30/2017
ms.author: pakunapa;
ms.openlocfilehash: 6d48c217d12bc5248c2da57b544aac747cecd872
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 10/06/2017
---
# <a name="reliable-services-lifecycle-overview"></a><span data-ttu-id="ee21e-103">Megbízható életciklusának áttekintése</span><span class="sxs-lookup"><span data-stu-id="ee21e-103">Reliable services lifecycle overview</span></span>
> [!div class="op_single_selector"]
> * [<span data-ttu-id="ee21e-104">C# Windowson</span><span class="sxs-lookup"><span data-stu-id="ee21e-104">C# on Windows</span></span>](service-fabric-reliable-services-lifecycle.md)
> * [<span data-ttu-id="ee21e-105">Java Linuxon</span><span class="sxs-lookup"><span data-stu-id="ee21e-105">Java on Linux</span></span>](service-fabric-reliable-services-lifecycle-java.md)
>
>

<span data-ttu-id="ee21e-106">Végezni hello megbízható szolgáltatásokat nyújt, a hello életciklus hello alapjait legfontosabb hello.</span><span class="sxs-lookup"><span data-stu-id="ee21e-106">When thinking about hello lifecycles of Reliable Services, hello basics of hello lifecycle are hello most important.</span></span> <span data-ttu-id="ee21e-107">Általában:</span><span class="sxs-lookup"><span data-stu-id="ee21e-107">In general:</span></span>

* <span data-ttu-id="ee21e-108">Indítás közben</span><span class="sxs-lookup"><span data-stu-id="ee21e-108">During Startup</span></span>
  * <span data-ttu-id="ee21e-109">Szolgáltatások össze</span><span class="sxs-lookup"><span data-stu-id="ee21e-109">Services are constructed</span></span>
  * <span data-ttu-id="ee21e-110">Egy lehetőség tooconstruct rendelkezik, és térjen vissza a nulla vagy több figyelői</span><span class="sxs-lookup"><span data-stu-id="ee21e-110">They have an opportunity tooconstruct and return zero or more listeners</span></span>
  * <span data-ttu-id="ee21e-111">A visszaadott figyelői nyitva vannak, hello szolgáltatással való kommunikáció engedélyezése</span><span class="sxs-lookup"><span data-stu-id="ee21e-111">Any returned listeners are opened, allowing communication with hello service</span></span>
  * <span data-ttu-id="ee21e-112">hello szolgáltatás runAsync metódusában nevezik, hosszú ideig futniuk szolgáltatás toodo hello vagy munka háttérben</span><span class="sxs-lookup"><span data-stu-id="ee21e-112">hello Service's runAsync method is called, allowing hello service toodo long running or background work</span></span>
* <span data-ttu-id="ee21e-113">Leállítás közben</span><span class="sxs-lookup"><span data-stu-id="ee21e-113">During shutdown</span></span>
  * <span data-ttu-id="ee21e-114">hello cancellation token átadott toorunAsync meg lett szakítva, és hello figyelők be van zárva</span><span class="sxs-lookup"><span data-stu-id="ee21e-114">hello cancellation token passed toorunAsync is canceled, and hello listeners are closed</span></span>
  * <span data-ttu-id="ee21e-115">Vagyis egyszer teljes van destructed hello szolgáltatás objektum</span><span class="sxs-lookup"><span data-stu-id="ee21e-115">Once that is complete, hello service object itself is destructed</span></span>

<span data-ttu-id="ee21e-116">Nincsenek pontos az ezen események részletek hello körül.</span><span class="sxs-lookup"><span data-stu-id="ee21e-116">There are details around hello exact ordering of these events.</span></span> <span data-ttu-id="ee21e-117">Azt jelzi, hogy attól függően, hogy a megbízható szolgáltatás hello Stateless vagy állapotalapú alkalmazások és szolgáltatások kis mértékben változhat-különösen hello események sorrendje.</span><span class="sxs-lookup"><span data-stu-id="ee21e-117">In particular, hello order of events may change slightly depending on whether hello Reliable Service is Stateless or Stateful.</span></span> <span data-ttu-id="ee21e-118">Emellett az állapotalapú szolgáltatások esetén tudunk toodeal hello elsődleges swap forgatókönyv.</span><span class="sxs-lookup"><span data-stu-id="ee21e-118">In addition, for stateful services, we have toodeal with hello Primary swap scenario.</span></span> <span data-ttu-id="ee21e-119">Ez a folyamat során hello szerepkör elsődleges átvitt tooanother másodpéldány (vagy ismét elérhető lesz) hello szolgáltatás leállítása nélkül.</span><span class="sxs-lookup"><span data-stu-id="ee21e-119">During this sequence, hello role of Primary is transferred tooanother replica (or comes back) without hello service shutting down.</span></span> <span data-ttu-id="ee21e-120">Végezetül toothink vonatkozó hiba vagy probléma van.</span><span class="sxs-lookup"><span data-stu-id="ee21e-120">Finally, we have toothink about error or failure conditions.</span></span>

## <a name="stateless-service-startup"></a><span data-ttu-id="ee21e-121">Állapot nélküli a szolgáltatás indítása</span><span class="sxs-lookup"><span data-stu-id="ee21e-121">Stateless service startup</span></span>
<span data-ttu-id="ee21e-122">az állapotmentes szolgáltatások hello élettartama meglehetősen egyszerű.</span><span class="sxs-lookup"><span data-stu-id="ee21e-122">hello lifecycle of a stateless service is fairly straightforward.</span></span> <span data-ttu-id="ee21e-123">Események hello sorrendje a következő:</span><span class="sxs-lookup"><span data-stu-id="ee21e-123">Here's hello order of events:</span></span>

1. <span data-ttu-id="ee21e-124">hello szolgáltatás összeállított</span><span class="sxs-lookup"><span data-stu-id="ee21e-124">hello Service is constructed</span></span>
2. <span data-ttu-id="ee21e-125">Ezt követően a párhuzamos két dolgot fordulhat elő:</span><span class="sxs-lookup"><span data-stu-id="ee21e-125">Then, in parallel two things happen:</span></span>
    - <span data-ttu-id="ee21e-126">`StatelessService.createServiceInstanceListeners()`meghívták és bármely visszaadott figyelői megnyitása (`CommunicationListener.openAsync()` meghívta az egyes figyelő)</span><span class="sxs-lookup"><span data-stu-id="ee21e-126">`StatelessService.createServiceInstanceListeners()` is invoked and any returned listeners are Opened (`CommunicationListener.openAsync()` is called on each listener)</span></span>
    - <span data-ttu-id="ee21e-127">hello szolgáltatás runAsync metódusában (`StatelessService.runAsync()`) neve</span><span class="sxs-lookup"><span data-stu-id="ee21e-127">hello service's runAsync method (`StatelessService.runAsync()`) is called</span></span>
3. <span data-ttu-id="ee21e-128">Ha van ilyen, hello szolgáltatás saját onOpenAsync módszer neve (pontosabban `StatelessService.onOpenAsync()` nevezik.</span><span class="sxs-lookup"><span data-stu-id="ee21e-128">If present, hello service's own onOpenAsync method is called (Specifically, `StatelessService.onOpenAsync()` is called.</span></span> <span data-ttu-id="ee21e-129">Ez egy ritka felülbírálást de érhető el).</span><span class="sxs-lookup"><span data-stu-id="ee21e-129">This is an uncommon override but it is available).</span></span>

<span data-ttu-id="ee21e-130">Fontos, hogy nincs nincs hello hívások toocreate és nyitott hello figyelők és runAsync közötti rendezés toonote.</span><span class="sxs-lookup"><span data-stu-id="ee21e-130">It is important toonote that there is no ordering between hello calls toocreate and open hello listeners and runAsync.</span></span> <span data-ttu-id="ee21e-131">hello figyelői előfordulhat, hogy nyissa meg a runAsync megkezdése előtt.</span><span class="sxs-lookup"><span data-stu-id="ee21e-131">hello listeners may open before runAsync is started.</span></span> <span data-ttu-id="ee21e-132">Ehhez hasonlóan runAsync is szükségessé tehet meghívása előtt hello kommunikációs figyelőket is nyitva, vagy még össze.</span><span class="sxs-lookup"><span data-stu-id="ee21e-132">Similarly, runAsync may end up invoked before hello communication listeners are open or have even been constructed.</span></span> <span data-ttu-id="ee21e-133">Bármely szinkronizálásra szükség, ha azt egy a gyakorlatban toohello végrehajtó állapotban maradt.</span><span class="sxs-lookup"><span data-stu-id="ee21e-133">If any synchronization is required, it is left as an exercise toohello implementer.</span></span> <span data-ttu-id="ee21e-134">Közös megoldások:</span><span class="sxs-lookup"><span data-stu-id="ee21e-134">Common solutions:</span></span>

* <span data-ttu-id="ee21e-135">Egyes esetekben a figyelői nem működőképes, amíg az egyéb információk jön létre, vagy végzett munkát.</span><span class="sxs-lookup"><span data-stu-id="ee21e-135">Sometimes listeners can't function until some other information is created or work done.</span></span> <span data-ttu-id="ee21e-136">Munkaelem általában teheti hello szolgáltatás konstruktor során hello állapotmentes szolgáltatások `createServiceInstanceListeners()` hívja, vagy maga hello figyelő hello építése részeként.</span><span class="sxs-lookup"><span data-stu-id="ee21e-136">For stateless services that work can usually be done in hello service's constructor, during hello `createServiceInstanceListeners()` call, or as a part of hello construction of hello listener itself.</span></span>
* <span data-ttu-id="ee21e-137">Néha hello runAsync kód nem szeretné, hogy toostart amíg hello figyelői nyitva.</span><span class="sxs-lookup"><span data-stu-id="ee21e-137">Sometimes hello code in runAsync does not want toostart until hello listeners are open.</span></span> <span data-ttu-id="ee21e-138">Ebben az esetben a további koordinációs szükség.</span><span class="sxs-lookup"><span data-stu-id="ee21e-138">In this case additional coordination is necessary.</span></span> <span data-ttu-id="ee21e-139">Egy gyakori megoldás, néhány jelző belül hello figyelők, amely azt jelzi, ha végzi, amely beadása runAsync tooactual munka folytatásához.</span><span class="sxs-lookup"><span data-stu-id="ee21e-139">One common solution is some flag within hello listeners indicating when they have completed, which is checked in runAsync before continuing tooactual work.</span></span>

## <a name="stateless-service-shutdown"></a><span data-ttu-id="ee21e-140">Állapot nélküli szolgáltatás leállítása</span><span class="sxs-lookup"><span data-stu-id="ee21e-140">Stateless service shutdown</span></span>
<span data-ttu-id="ee21e-141">Ha egy állapotmentes szolgáltatások azonos mintát követi, csak a névkeresési hello leállítása:</span><span class="sxs-lookup"><span data-stu-id="ee21e-141">When shutting down a stateless service, hello same pattern is followed, just in reverse:</span></span>

1. <span data-ttu-id="ee21e-142">Párhuzamos</span><span class="sxs-lookup"><span data-stu-id="ee21e-142">In parallel</span></span>
    - <span data-ttu-id="ee21e-143">Bármely nyitott figyelők be legyen zárva (`CommunicationListener.closeAsync()` meghívta az egyes figyelő)</span><span class="sxs-lookup"><span data-stu-id="ee21e-143">Any open listeners are Closed (`CommunicationListener.closeAsync()` is called on each listener)</span></span>
    - <span data-ttu-id="ee21e-144">hello cancellation token átadott túl`runAsync()` megszakadt (hello cancellation token ellenőrzése `isCancelled` tulajdonság igaz értéket ad vissza, és hello token hívása `throwIfCancellationRequested` metódus jelez egy `CancellationException`)</span><span class="sxs-lookup"><span data-stu-id="ee21e-144">hello cancellation token passed too`runAsync()` is canceled (checking hello cancellation token's `isCancelled` property returns true, and if called hello token's `throwIfCancellationRequested` method throws a `CancellationException`)</span></span>
2. <span data-ttu-id="ee21e-145">Egyszer `closeAsync()` minden egyes figyelő működése befejeződött és `runAsync()` is befejeződött, hello szolgáltatás `StatelessService.onCloseAsync()` metódus lehívásra kerül, ha van ilyen (újra ez egy ritka felülbírálás).</span><span class="sxs-lookup"><span data-stu-id="ee21e-145">Once `closeAsync()` completes on each listener and `runAsync()` also completes, hello service's `StatelessService.onCloseAsync()` method is called, if present (again this is an uncommon override).</span></span>
3. <span data-ttu-id="ee21e-146">Miután `StatelessService.onCloseAsync()` befejezése hello szolgáltatás objektum destructed van</span><span class="sxs-lookup"><span data-stu-id="ee21e-146">After `StatelessService.onCloseAsync()` completes, hello service object is destructed</span></span>

## <a name="notes-on-service-lifecycle"></a><span data-ttu-id="ee21e-147">Tudnivalók a szolgáltatási életciklus</span><span class="sxs-lookup"><span data-stu-id="ee21e-147">Notes on service lifecycle</span></span>
* <span data-ttu-id="ee21e-148">Mindkét hello `runAsync()` metódus és hello `createServiceInstanceListeners` hívások nem kötelező.</span><span class="sxs-lookup"><span data-stu-id="ee21e-148">Both hello `runAsync()` method and hello `createServiceInstanceListeners` calls are optional.</span></span> <span data-ttu-id="ee21e-149">Szolgáltatásként lehet őket, egyaránt, vagy egyiket sem.</span><span class="sxs-lookup"><span data-stu-id="ee21e-149">A service may have one of them, both, or neither.</span></span> <span data-ttu-id="ee21e-150">Például ha hello szolgáltatásnak nincs válasz toouser hívások a munkáját, nincs szükség az tooimplement `runAsync()`.</span><span class="sxs-lookup"><span data-stu-id="ee21e-150">For example, if hello service does all its work in response toouser calls, there is no need for it tooimplement `runAsync()`.</span></span> <span data-ttu-id="ee21e-151">Csak a hello kommunikációs figyelőket és a kapcsolódó kódra szükség.</span><span class="sxs-lookup"><span data-stu-id="ee21e-151">Only hello communication listeners and their associated code are necessary.</span></span> <span data-ttu-id="ee21e-152">Hasonlóképpen létrehozása és a kommunikációs figyelőket visszaadó nem kötelező, hello szolgáltatás esetleg csak a háttér toodo működik, és tooimplement csak úgy kell`runAsync()`</span><span class="sxs-lookup"><span data-stu-id="ee21e-152">Similarly, creating and returning communication listeners is optional, as hello service may have only background work toodo, and so only needs tooimplement `runAsync()`</span></span>
* <span data-ttu-id="ee21e-153">A szolgáltatás toocomplete érvényes `runAsync()` sikeresen és visszatérési belőle.</span><span class="sxs-lookup"><span data-stu-id="ee21e-153">It is valid for a service toocomplete `runAsync()` successfully and return from it.</span></span> <span data-ttu-id="ee21e-154">Ez nem tekinthető hiba feltételt, és hello háttérműveletek hello szolgáltatás befejezését jelenti.</span><span class="sxs-lookup"><span data-stu-id="ee21e-154">This is not considered a failure condition and would represent hello background work of hello service completing.</span></span> <span data-ttu-id="ee21e-155">Az állapot-nyilvántartó megbízható szolgáltatások `runAsync()` volna lehet újra hívni Ha hello szolgáltatás elsődleges lefokozása volt, és majd a hátsó tooprimary elő.</span><span class="sxs-lookup"><span data-stu-id="ee21e-155">For stateful reliable services `runAsync()` would be called again if hello service were demoted from primary and then promoted back tooprimary.</span></span>
* <span data-ttu-id="ee21e-156">Ha egy szolgáltatás kilép a `runAsync()` egy váratlan kivétel kiváltása, ez a hiba és hello szolgáltatás objektum le van állítva, és a health hibát jelzett.</span><span class="sxs-lookup"><span data-stu-id="ee21e-156">If a service exits from `runAsync()` by throwing some unexpected exception, this is a failure and hello service object is shut down and a health error reported.</span></span>
* <span data-ttu-id="ee21e-157">Bár a visszatérésre ezek a módszerek nem korlátozott, azonnal elveszti a hello képességét toowrite, és ezért nem tudja végrehajtani a valódi munkát.</span><span class="sxs-lookup"><span data-stu-id="ee21e-157">While there is no time limit on returning from these methods, you immediately lose hello ability toowrite and therefore cannot complete any real work.</span></span> <span data-ttu-id="ee21e-158">Ajánlott, hogy ismét lehető leggyorsabban hello visszavonási kérelem fogadásakor.</span><span class="sxs-lookup"><span data-stu-id="ee21e-158">It is recommended that you return as quickly as possible upon receiving hello cancellation request.</span></span> <span data-ttu-id="ee21e-159">Ha a szolgáltatás nem válaszol a Service Fabric előfordulhat, hogy kényszerített elfogadható időn belül toothese API-hívások leáll a szolgáltatás.</span><span class="sxs-lookup"><span data-stu-id="ee21e-159">If your service does not respond toothese API calls in a reasonable amount of time Service Fabric may forcibly terminate your service.</span></span> <span data-ttu-id="ee21e-160">Általában ez csak akkor fordul elő alkalmazásfrissítések vagy egy szolgáltatás törlésekor során.</span><span class="sxs-lookup"><span data-stu-id="ee21e-160">Usually this only happens during application upgrades or when a service is being deleted.</span></span> <span data-ttu-id="ee21e-161">Ez az időkorlát értéke alapértelmezés szerint 15 percenként.</span><span class="sxs-lookup"><span data-stu-id="ee21e-161">This timeout is 15 minutes by default.</span></span>
* <span data-ttu-id="ee21e-162">Hello hibáinak `onCloseAsync()` elérési eredményez `onAbort()` Ez az egy utolsó-alkalommal legjobb lehetőség hello meghívott tooclean szolgáltatás fel, és felszabadíthatja a minden olyan erőforrásnál, amely azt állítják.</span><span class="sxs-lookup"><span data-stu-id="ee21e-162">Failures in hello `onCloseAsync()` path result in `onAbort()` being called which is a last-chance best-effort opportunity for hello service tooclean up and release any resources that they have claimed.</span></span>

> [!NOTE]
> <span data-ttu-id="ee21e-163">Állapot-nyilvántartó megbízható szolgáltatások nem támogatottak a java még.</span><span class="sxs-lookup"><span data-stu-id="ee21e-163">Stateful reliable services are not supported in java yet.</span></span>
>
>

## <a name="next-steps"></a><span data-ttu-id="ee21e-164">Következő lépések</span><span class="sxs-lookup"><span data-stu-id="ee21e-164">Next steps</span></span>
* [<span data-ttu-id="ee21e-165">TooReliable szolgáltatások bemutatása</span><span class="sxs-lookup"><span data-stu-id="ee21e-165">Introduction tooReliable Services</span></span>](service-fabric-reliable-services-introduction.md)
* [<span data-ttu-id="ee21e-166">Megbízható szolgáltatások – első lépések</span><span class="sxs-lookup"><span data-stu-id="ee21e-166">Reliable Services quick start</span></span>](service-fabric-reliable-services-quick-start.md)
* [<span data-ttu-id="ee21e-167">Megbízható szolgáltatás használati speciális</span><span class="sxs-lookup"><span data-stu-id="ee21e-167">Reliable Services advanced usage</span></span>](service-fabric-reliable-services-advanced-usage.md)
