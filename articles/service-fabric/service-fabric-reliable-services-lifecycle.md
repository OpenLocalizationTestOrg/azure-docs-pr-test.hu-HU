---
title: "az Azure Service Fabric Reliable Services hello életciklus aaaOverview |} Microsoft Docs"
description: "A Service Fabric megbízható szolgáltatások hello különböző életciklus események"
services: Service-Fabric
documentationcenter: .net
author: masnider
manager: timlt
editor: vturecek;
ms.assetid: 
ms.service: Service-Fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 08/18/2017
ms.author: masnider
ms.openlocfilehash: 0d75ed5ee7cda85ac9af6a02e160727277804a2b
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 10/06/2017
---
# <a name="reliable-services-lifecycle-overview"></a><span data-ttu-id="21340-103">Megbízható életciklusának áttekintése</span><span class="sxs-lookup"><span data-stu-id="21340-103">Reliable services lifecycle overview</span></span>
> [!div class="op_single_selector"]
> * [<span data-ttu-id="21340-104">C# Windowson</span><span class="sxs-lookup"><span data-stu-id="21340-104">C# on Windows</span></span>](service-fabric-reliable-services-lifecycle.md)
> * [<span data-ttu-id="21340-105">Java Linuxon</span><span class="sxs-lookup"><span data-stu-id="21340-105">Java on Linux</span></span>](service-fabric-reliable-services-lifecycle-java.md)
>
>

<span data-ttu-id="21340-106">Végezni hello megbízható szolgáltatásokat nyújt, a hello életciklus hello alapjait legfontosabb hello.</span><span class="sxs-lookup"><span data-stu-id="21340-106">When thinking about hello lifecycles of Reliable Services, hello basics of hello lifecycle are hello most important.</span></span> <span data-ttu-id="21340-107">Általában:</span><span class="sxs-lookup"><span data-stu-id="21340-107">In general:</span></span>

- <span data-ttu-id="21340-108">Indítás közben</span><span class="sxs-lookup"><span data-stu-id="21340-108">During Startup</span></span>
  - <span data-ttu-id="21340-109">Szolgáltatások össze</span><span class="sxs-lookup"><span data-stu-id="21340-109">Services are constructed</span></span>
  - <span data-ttu-id="21340-110">Egy lehetőség tooconstruct rendelkezik, és térjen vissza a nulla vagy több figyelői</span><span class="sxs-lookup"><span data-stu-id="21340-110">They have an opportunity tooconstruct and return zero or more listeners</span></span>
  - <span data-ttu-id="21340-111">A visszaadott figyelői nyitva vannak, hello szolgáltatással való kommunikáció engedélyezése</span><span class="sxs-lookup"><span data-stu-id="21340-111">Any returned listeners are opened, allowing communication with hello service</span></span>
  - <span data-ttu-id="21340-112">hello szolgáltatás RunAsync metódus lehívásra kerül, így hello hosszú ideig futniuk toodo szolgáltatás, vagy a háttérben munka</span><span class="sxs-lookup"><span data-stu-id="21340-112">hello Service's RunAsync method is called, allowing hello service toodo long running or background work</span></span>
- <span data-ttu-id="21340-113">Leállítás közben</span><span class="sxs-lookup"><span data-stu-id="21340-113">During shutdown</span></span>
  - <span data-ttu-id="21340-114">hello cancellation token átadott tooRunAsync meg lett szakítva, és hello figyelők be van zárva</span><span class="sxs-lookup"><span data-stu-id="21340-114">hello cancellation token passed tooRunAsync is canceled, and hello listeners are closed</span></span>
  - <span data-ttu-id="21340-115">Vagyis egyszer teljes van destructed hello szolgáltatás objektum</span><span class="sxs-lookup"><span data-stu-id="21340-115">Once that is complete, hello service object itself is destructed</span></span>

<span data-ttu-id="21340-116">Nincsenek pontos az ezen események részletek hello körül.</span><span class="sxs-lookup"><span data-stu-id="21340-116">There are details around hello exact ordering of these events.</span></span> <span data-ttu-id="21340-117">Azt jelzi, hogy attól függően, hogy a megbízható szolgáltatás hello Stateless vagy állapotalapú alkalmazások és szolgáltatások kis mértékben változhat-különösen hello események sorrendje.</span><span class="sxs-lookup"><span data-stu-id="21340-117">In particular, hello order of events may change slightly depending on whether hello Reliable Service is Stateless or Stateful.</span></span> <span data-ttu-id="21340-118">Emellett az állapotalapú szolgáltatások esetén tudunk toodeal hello elsődleges swap forgatókönyv.</span><span class="sxs-lookup"><span data-stu-id="21340-118">In addition, for stateful services, we have toodeal with hello Primary swap scenario.</span></span> <span data-ttu-id="21340-119">Ez a folyamat során hello szerepkör elsődleges átvitt tooanother másodpéldány (vagy ismét elérhető lesz) hello szolgáltatás leállítása nélkül.</span><span class="sxs-lookup"><span data-stu-id="21340-119">During this sequence, hello role of Primary is transferred tooanother replica (or comes back) without hello service shutting down.</span></span> <span data-ttu-id="21340-120">Végezetül toothink vonatkozó hiba vagy probléma van.</span><span class="sxs-lookup"><span data-stu-id="21340-120">Finally, we have toothink about error or failure conditions.</span></span>

## <a name="stateless-service-startup"></a><span data-ttu-id="21340-121">Állapot nélküli a szolgáltatás indítása</span><span class="sxs-lookup"><span data-stu-id="21340-121">Stateless service startup</span></span>
<span data-ttu-id="21340-122">az állapotmentes szolgáltatások hello élettartama meglehetősen egyszerű.</span><span class="sxs-lookup"><span data-stu-id="21340-122">hello lifecycle of a stateless service is fairly straightforward.</span></span> <span data-ttu-id="21340-123">Események hello sorrendje a következő:</span><span class="sxs-lookup"><span data-stu-id="21340-123">Here's hello order of events:</span></span>

1. <span data-ttu-id="21340-124">hello szolgáltatás összeállított</span><span class="sxs-lookup"><span data-stu-id="21340-124">hello Service is constructed</span></span>
2. <span data-ttu-id="21340-125">Ezt követően a párhuzamos két dolgot fordulhat elő:</span><span class="sxs-lookup"><span data-stu-id="21340-125">Then, in parallel two things happen:</span></span>
    - <span data-ttu-id="21340-126">`StatelessService.CreateServiceInstanceListeners()`meghívták és bármely visszaadott figyelői megnyitása.</span><span class="sxs-lookup"><span data-stu-id="21340-126">`StatelessService.CreateServiceInstanceListeners()` is invoked and any returned listeners are Opened.</span></span> <span data-ttu-id="21340-127">`ICommunicationListener.OpenAsync()`a minden egyes figyelő neve</span><span class="sxs-lookup"><span data-stu-id="21340-127">`ICommunicationListener.OpenAsync()` is called on each listener</span></span>
    - <span data-ttu-id="21340-128">hello szolgáltatás `StatelessService.RunAsync()` módszer neve</span><span class="sxs-lookup"><span data-stu-id="21340-128">hello service's `StatelessService.RunAsync()` method is called</span></span>
3. <span data-ttu-id="21340-129">Ha van ilyen, hello szolgáltatás `StatelessService.OnOpenAsync()` metódust.</span><span class="sxs-lookup"><span data-stu-id="21340-129">If present, hello service's `StatelessService.OnOpenAsync()` method is called.</span></span> <span data-ttu-id="21340-130">Ez egy ritka felülbírálást, de érhető el.</span><span class="sxs-lookup"><span data-stu-id="21340-130">This is an uncommon override, but it is available.</span></span>

<span data-ttu-id="21340-131">Fontos, hogy nincs nincs hello hívások toocreate és nyitott hello figyelők és RunAsync közötti rendezés toonote.</span><span class="sxs-lookup"><span data-stu-id="21340-131">It is important toonote that there is no ordering between hello calls toocreate and open hello listeners and RunAsync.</span></span> <span data-ttu-id="21340-132">hello figyelői előfordulhat, hogy nyissa meg a RunAsync megkezdése előtt.</span><span class="sxs-lookup"><span data-stu-id="21340-132">hello listeners may open before RunAsync is started.</span></span> <span data-ttu-id="21340-133">Ehhez hasonlóan RunAsync is szükségessé tehet meghívása előtt hello kommunikációs figyelőket is nyitva, vagy még össze.</span><span class="sxs-lookup"><span data-stu-id="21340-133">Similarly, RunAsync may end up invoked before hello communication listeners are open or have even been constructed.</span></span> <span data-ttu-id="21340-134">Bármely szinkronizálásra szükség, ha azt egy a gyakorlatban toohello végrehajtó állapotban maradt.</span><span class="sxs-lookup"><span data-stu-id="21340-134">If any synchronization is required, it is left as an exercise toohello implementer.</span></span> <span data-ttu-id="21340-135">Közös megoldások:</span><span class="sxs-lookup"><span data-stu-id="21340-135">Common solutions:</span></span>

  - <span data-ttu-id="21340-136">Egyes esetekben a figyelői nem működőképes, amíg az egyéb információk jön létre, vagy végzett munkát.</span><span class="sxs-lookup"><span data-stu-id="21340-136">Sometimes listeners can't function until some other information is created or work done.</span></span> <span data-ttu-id="21340-137">Az állapotmentes szolgáltatások munkahelyi általában végezheti el a más helyeken, például:</span><span class="sxs-lookup"><span data-stu-id="21340-137">For stateless services that work can usually be done in other locations, such as:</span></span> 
    - <span data-ttu-id="21340-138">hello szolgáltatás konstruktorában.</span><span class="sxs-lookup"><span data-stu-id="21340-138">in hello service's constructor</span></span>
    - <span data-ttu-id="21340-139">hello során `CreateServiceInstanceListeners()` hívása</span><span class="sxs-lookup"><span data-stu-id="21340-139">during hello `CreateServiceInstanceListeners()` call</span></span>
    - <span data-ttu-id="21340-140">hello építése maga hello figyelő részeként</span><span class="sxs-lookup"><span data-stu-id="21340-140">as a part of hello construction of hello listener itself</span></span>
  - <span data-ttu-id="21340-141">Néha hello RunAsync kód nem szeretné, hogy toostart amíg hello figyelői nyitva.</span><span class="sxs-lookup"><span data-stu-id="21340-141">Sometimes hello code in RunAsync does not want toostart until hello listeners are open.</span></span> <span data-ttu-id="21340-142">Ebben az esetben a további koordinációs szükség.</span><span class="sxs-lookup"><span data-stu-id="21340-142">In this case additional coordination is necessary.</span></span> <span data-ttu-id="21340-143">Egy gyakori megoldás, néhány jelzőt, amely jelzi, ha elvégezték hello figyelői belül.</span><span class="sxs-lookup"><span data-stu-id="21340-143">One common solution is some flag within hello listeners indicating when they have completed.</span></span> <span data-ttu-id="21340-144">Ez a jelző ellenőrizni kell a RunAsync tooactual munka folytatásához.</span><span class="sxs-lookup"><span data-stu-id="21340-144">This flag is then checked in RunAsync before continuing tooactual work.</span></span>

## <a name="stateless-service-shutdown"></a><span data-ttu-id="21340-145">Állapot nélküli szolgáltatás leállítása</span><span class="sxs-lookup"><span data-stu-id="21340-145">Stateless service shutdown</span></span>
<span data-ttu-id="21340-146">Ha egy állapotmentes szolgáltatások azonos mintát követi, csak a névkeresési hello leállítása:</span><span class="sxs-lookup"><span data-stu-id="21340-146">When shutting down a stateless service, hello same pattern is followed, just in reverse:</span></span>

1. <span data-ttu-id="21340-147">Párhuzamos</span><span class="sxs-lookup"><span data-stu-id="21340-147">In parallel</span></span>
    - <span data-ttu-id="21340-148">Bármely nyitott figyelők be van zárva.</span><span class="sxs-lookup"><span data-stu-id="21340-148">Any open listeners are Closed.</span></span> <span data-ttu-id="21340-149">`ICommunicationListener.CloseAsync()`a minden egyes figyelő neve.</span><span class="sxs-lookup"><span data-stu-id="21340-149">`ICommunicationListener.CloseAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="21340-150">hello cancellation token átadott túl`RunAsync()` megszakadt.</span><span class="sxs-lookup"><span data-stu-id="21340-150">hello cancellation token passed too`RunAsync()` is canceled.</span></span> <span data-ttu-id="21340-151">Felvételekor hello cancellation jogkivonat `IsCancellationRequested` tulajdonság igaz értéket ad vissza, és ha hello jogkivonat neve `ThrowIfCancellationRequested` metódus jelez egy `OperationCanceledException`.</span><span class="sxs-lookup"><span data-stu-id="21340-151">Checking hello cancellation token's `IsCancellationRequested` property returns true, and if called hello token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span></span>
2. <span data-ttu-id="21340-152">Egyszer `CloseAsync()` minden egyes figyelő működése befejeződött és `RunAsync()` is befejeződött, hello szolgáltatás `StatelessService.OnCloseAsync()` metódus lehívásra kerül, ha van ilyen.</span><span class="sxs-lookup"><span data-stu-id="21340-152">Once `CloseAsync()` completes on each listener and `RunAsync()` also completes, hello service's `StatelessService.OnCloseAsync()` method is called, if present.</span></span> <span data-ttu-id="21340-153">Ritka toooverride `StatelessService.OnCloseAsync()`.</span><span class="sxs-lookup"><span data-stu-id="21340-153">It is uncommon toooverride `StatelessService.OnCloseAsync()`.</span></span>
3. <span data-ttu-id="21340-154">Miután `StatelessService.OnCloseAsync()` befejezése hello szolgáltatás objektum destructed van</span><span class="sxs-lookup"><span data-stu-id="21340-154">After `StatelessService.OnCloseAsync()` completes, hello service object is destructed</span></span>

## <a name="stateful-service-startup"></a><span data-ttu-id="21340-155">Az állapotalapú szolgáltatás indítása</span><span class="sxs-lookup"><span data-stu-id="21340-155">Stateful service Startup</span></span>
<span data-ttu-id="21340-156">Állapotalapú szolgáltatások egy hasonló mintát toostateless szolgáltatások néhány módosításokkal rendelkezik.</span><span class="sxs-lookup"><span data-stu-id="21340-156">Stateful services have a similar pattern toostateless services, with a few changes.</span></span> <span data-ttu-id="21340-157">Az állapotalapú szolgáltatás indításakor hello események sorrendje az alábbiak szerint:</span><span class="sxs-lookup"><span data-stu-id="21340-157">When starting up a stateful service, hello order of events is as follows:</span></span>

1. <span data-ttu-id="21340-158">hello szolgáltatás összeállított</span><span class="sxs-lookup"><span data-stu-id="21340-158">hello Service is constructed</span></span>
2. <span data-ttu-id="21340-159">`StatefulServiceBase.OnOpenAsync()`nevezik.</span><span class="sxs-lookup"><span data-stu-id="21340-159">`StatefulServiceBase.OnOpenAsync()` is called.</span></span> <span data-ttu-id="21340-160">Ez uncommonly felülbírálja a hello szolgáltatásban.</span><span class="sxs-lookup"><span data-stu-id="21340-160">This is uncommonly overridden in hello service.</span></span>
3. <span data-ttu-id="21340-161">hello következő dolgokat okozhat párhuzamosan</span><span class="sxs-lookup"><span data-stu-id="21340-161">hello following things happen in parallel</span></span>
    - <span data-ttu-id="21340-162">`StatefulServiceBase.CreateServiceReplicaListeners()`meghívták</span><span class="sxs-lookup"><span data-stu-id="21340-162">`StatefulServiceBase.CreateServiceReplicaListeners()` is invoked</span></span> 
      - <span data-ttu-id="21340-163">Ha hello szolgáltatás elsődleges minden visszaadott figyelői megnyitása.</span><span class="sxs-lookup"><span data-stu-id="21340-163">If hello service is a Primary all returned listeners are Opened.</span></span> <span data-ttu-id="21340-164">`ICommunicationListener.OpenAsync()`a minden egyes figyelő neve.</span><span class="sxs-lookup"><span data-stu-id="21340-164">`ICommunicationListener.OpenAsync()` is called on each listener.</span></span>
      - <span data-ttu-id="21340-165">Ha hello szolgáltatást egy másodlagos, csak ezek a figyelők jelölésű `ListenOnSecondary = true` megnyitása.</span><span class="sxs-lookup"><span data-stu-id="21340-165">If hello service is a Secondary, only those listeners marked as `ListenOnSecondary = true` are opened.</span></span> <span data-ttu-id="21340-166">Figyelők, amelyek nyitva a másodlagos adatbázist, akkor az ritkább.</span><span class="sxs-lookup"><span data-stu-id="21340-166">Having listeners that are open on Secondaries is less common.</span></span>
    - <span data-ttu-id="21340-167">Ha hello szolgáltatás jelenleg egy elsődleges, hello szolgáltatás hello `StatefulServiceBase.RunAsync()` módszer neve</span><span class="sxs-lookup"><span data-stu-id="21340-167">hello if hello Service is currently a Primary, hello service's `StatefulServiceBase.RunAsync()` method is called</span></span>
4. <span data-ttu-id="21340-168">Amennyiben az összes replika figyelője hello `OpenAsync()` hívás befejezéséhez és `RunAsync()` nevezik, `StatefulServiceBase.OnChangeRoleAsync()` nevezzük.</span><span class="sxs-lookup"><span data-stu-id="21340-168">Once all hello replica listener's `OpenAsync()` calls complete and `RunAsync()` is called, `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="21340-169">Ez uncommonly felülbírálja a hello szolgáltatásban.</span><span class="sxs-lookup"><span data-stu-id="21340-169">This is uncommonly overridden in hello service.</span></span>

<span data-ttu-id="21340-170">Hasonlóképpen toostateless szolgáltatásokat, nincs hello sorrendje a mely hello figyelői vannak létrejött, és nem összehangolását és RunAsync meghívásakor.</span><span class="sxs-lookup"><span data-stu-id="21340-170">Similarly toostateless services, there's no coordination between hello order in which hello listeners are created and opened and when RunAsync is called.</span></span> <span data-ttu-id="21340-171">Ha koordinációs van szüksége, a hello megoldások vannak sokkal hello azonos.</span><span class="sxs-lookup"><span data-stu-id="21340-171">If you need coordination, hello solutions are much hello same.</span></span> <span data-ttu-id="21340-172">Egy további esetben van: Tegyük fel például, hogy a bejövő hello kommunikációs figyelőket hello hívások belüli egyes tartani ismereteket igényel [megbízható gyűjtemények](service-fabric-reliable-services-reliable-collections.md).</span><span class="sxs-lookup"><span data-stu-id="21340-172">THere is one additional case: say that hello calls arriving at hello communication listeners require information kept inside some [Reliable Collections](service-fabric-reliable-services-reliable-collections.md).</span></span> <span data-ttu-id="21340-173">Mert sikerült megnyitni a hello kommunikációs figyelőket, mielőtt a megbízható gyűjtemények hello olvasható és írható, és mielőtt a RunAsync elindítása volt, néhány további koordinációs szükség.</span><span class="sxs-lookup"><span data-stu-id="21340-173">Because hello communication listeners could open before hello reliable collections are readable or writeable, and before RunAsync could start, some additional coordination is necessary.</span></span> <span data-ttu-id="21340-174">hello legegyszerűbb és leggyakoribb megoldás hello kommunikációs figyelői tooreturn néhány, az ügyfél által használt tooknow tooretry hello kérelem hello hibakód.</span><span class="sxs-lookup"><span data-stu-id="21340-174">hello simplest and most common solution is for hello communication listeners tooreturn some error code that hello client uses tooknow tooretry hello request.</span></span>

## <a name="stateful-service-shutdown"></a><span data-ttu-id="21340-175">Az állapotalapú szolgáltatás leállítása</span><span class="sxs-lookup"><span data-stu-id="21340-175">Stateful service Shutdown</span></span>
<span data-ttu-id="21340-176">Hasonlóképpen tooStateless szolgáltatások hello életciklus-események leállítás során hello ugyanaz a rendszerindítás során, de fordított irányú.</span><span class="sxs-lookup"><span data-stu-id="21340-176">Similarly tooStateless services, hello lifecycle events during shutdown are hello same as during startup, but reversed.</span></span> <span data-ttu-id="21340-177">Ha egy állapotalapú szolgáltatás leáll, hello következő történik:</span><span class="sxs-lookup"><span data-stu-id="21340-177">When a stateful service is being shut down, hello following events occur:</span></span>

1. <span data-ttu-id="21340-178">Párhuzamos</span><span class="sxs-lookup"><span data-stu-id="21340-178">In parallel</span></span>
    - <span data-ttu-id="21340-179">Bármely nyitott figyelők be van zárva.</span><span class="sxs-lookup"><span data-stu-id="21340-179">Any open listeners are Closed.</span></span> <span data-ttu-id="21340-180">`ICommunicationListener.CloseAsync()`a minden egyes figyelő neve.</span><span class="sxs-lookup"><span data-stu-id="21340-180">`ICommunicationListener.CloseAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="21340-181">hello cancellation token átadott túl`RunAsync()` megszakadt.</span><span class="sxs-lookup"><span data-stu-id="21340-181">hello cancellation token passed too`RunAsync()` is canceled.</span></span> <span data-ttu-id="21340-182">Felvételekor hello cancellation jogkivonat `IsCancellationRequested` tulajdonság igaz értéket ad vissza, és ha hello jogkivonat neve `ThrowIfCancellationRequested` metódus jelez egy `OperationCanceledException`.</span><span class="sxs-lookup"><span data-stu-id="21340-182">Checking hello cancellation token's `IsCancellationRequested` property returns true, and if called hello token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span></span>
2. <span data-ttu-id="21340-183">Egyszer `CloseAsync()` minden egyes figyelő működése befejeződött és `RunAsync()` is befejeződött, hello szolgáltatás `StatefulServiceBase.OnChangeRoleAsync()` nevezik.</span><span class="sxs-lookup"><span data-stu-id="21340-183">Once `CloseAsync()` completes on each listener and `RunAsync()` also completes, hello service's `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="21340-184">(Ez uncommonly felülbírálja a hello szolgáltatásban.)</span><span class="sxs-lookup"><span data-stu-id="21340-184">(This is uncommonly overridden in hello service.)</span></span>
    - <span data-ttu-id="21340-185">Várakozás a RunAsync toocomplete csak szükség, ha ez a szolgáltatás másodpéldány nem elsődleges.</span><span class="sxs-lookup"><span data-stu-id="21340-185">Waiting for RunAsync toocomplete is only necessary if this service replica was a Primary.</span></span>
3. <span data-ttu-id="21340-186">Egyszer hello `StatefulServiceBase.OnChangeRoleAsync()` metódus befejezése hello `StatefulServiceBase.OnCloseAsync()` metódust.</span><span class="sxs-lookup"><span data-stu-id="21340-186">Once hello `StatefulServiceBase.OnChangeRoleAsync()` method completes, hello `StatefulServiceBase.OnCloseAsync()` method is called.</span></span> <span data-ttu-id="21340-187">Ez egy ritka felülbírálást, de érhető el.</span><span class="sxs-lookup"><span data-stu-id="21340-187">This is an uncommon override, but it is available.</span></span>
3. <span data-ttu-id="21340-188">Miután `StatefulServiceBase.OnCloseAsync()` befejezése hello szolgáltatás objektum destructed van.</span><span class="sxs-lookup"><span data-stu-id="21340-188">After `StatefulServiceBase.OnCloseAsync()` completes, hello service object is destructed.</span></span>

## <a name="stateful-service-primary-swaps"></a><span data-ttu-id="21340-189">Az állapotalapú szolgáltatás elsődleges cseréje</span><span class="sxs-lookup"><span data-stu-id="21340-189">Stateful service primary swaps</span></span>
<span data-ttu-id="21340-190">Egy állapotalapú szolgáltatás futása csak hello elsődleges adott állapotalapú szolgáltatások replikának a megnyitott kommunikációs figyelőket és azok nevű RunAsync metódusában.</span><span class="sxs-lookup"><span data-stu-id="21340-190">While a stateful service is running, only hello Primary replicas of that stateful services have their communication listeners opened and their RunAsync method called.</span></span> <span data-ttu-id="21340-191">Másodlagos össze, de nincs további hívásainak.</span><span class="sxs-lookup"><span data-stu-id="21340-191">Secondary are constructed but see no further calls.</span></span> <span data-ttu-id="21340-192">Az állapotalapú szolgáltatás futása közben azonban melyik replika jelenleg hello elsődleges módosíthatja.</span><span class="sxs-lookup"><span data-stu-id="21340-192">While a stateful service is running however, which replica is currently hello Primary can change.</span></span> <span data-ttu-id="21340-193">Ez mit jelent a replika látható hello életciklus események feltételeit? hello viselkedés hello állapot-nyilvántartó replika láthatják attól függ, hogy-e hello replika lefokozásra vagy előléptetett hello swap során.</span><span class="sxs-lookup"><span data-stu-id="21340-193">What does this mean in terms of hello lifecycle events that a replica can see? hello behavior hello stateful replica sees depends on whether it is hello replica being demoted or promoted during hello swap.</span></span>

### <a name="for-hello-primary-being-demoted"></a><span data-ttu-id="21340-194">Az elsődleges lefokozni hello</span><span class="sxs-lookup"><span data-stu-id="21340-194">For hello primary being demoted</span></span>
<span data-ttu-id="21340-195">A Service Fabric a replika toostop üzenetek feldolgozása kell, és lépjen ki a háttérműveletek műveletet.</span><span class="sxs-lookup"><span data-stu-id="21340-195">Service Fabric needs this replica toostop processing messages and quit any background work it is doing.</span></span> <span data-ttu-id="21340-196">Ennek eredményeképpen a lépés láthatóhoz hasonló toowhen hello szolgáltatás leállítása folyamatban van.</span><span class="sxs-lookup"><span data-stu-id="21340-196">As a result, this step looks similar toowhen hello service is being shut down.</span></span> <span data-ttu-id="21340-197">Egy különbség, hogy hello szolgáltatást nem destructed vagy zárva, mert egy másodlagos marad.</span><span class="sxs-lookup"><span data-stu-id="21340-197">One difference is that hello Service isn't destructed or closed since it remains as a Secondary.</span></span> <span data-ttu-id="21340-198">a következő API-k hello nevezzük:</span><span class="sxs-lookup"><span data-stu-id="21340-198">hello following APIs are called:</span></span>

1. <span data-ttu-id="21340-199">Párhuzamos</span><span class="sxs-lookup"><span data-stu-id="21340-199">In parallel</span></span>
    - <span data-ttu-id="21340-200">Bármely nyitott figyelők be van zárva.</span><span class="sxs-lookup"><span data-stu-id="21340-200">Any open listeners are Closed.</span></span> <span data-ttu-id="21340-201">`ICommunicationListener.CloseAsync()`a minden egyes figyelő neve.</span><span class="sxs-lookup"><span data-stu-id="21340-201">`ICommunicationListener.CloseAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="21340-202">hello cancellation token átadott túl`RunAsync()` megszakadt.</span><span class="sxs-lookup"><span data-stu-id="21340-202">hello cancellation token passed too`RunAsync()` is canceled.</span></span> <span data-ttu-id="21340-203">Felvételekor hello cancellation jogkivonat `IsCancellationRequested` tulajdonság igaz értéket ad vissza, és ha hello jogkivonat neve `ThrowIfCancellationRequested` metódus jelez egy `OperationCanceledException`.</span><span class="sxs-lookup"><span data-stu-id="21340-203">Checking hello cancellation token's `IsCancellationRequested` property returns true, and if called hello token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span></span>
2. <span data-ttu-id="21340-204">Egyszer `CloseAsync()` minden egyes figyelő működése befejeződött és `RunAsync()` is befejeződött, hello szolgáltatás `StatefulServiceBase.OnChangeRoleAsync()` nevezik.</span><span class="sxs-lookup"><span data-stu-id="21340-204">Once `CloseAsync()` completes on each listener and `RunAsync()` also completes, hello service's `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="21340-205">Ez uncommonly felülbírálja a hello szolgáltatásban.</span><span class="sxs-lookup"><span data-stu-id="21340-205">This is uncommonly overridden in hello service.</span></span>

### <a name="for-hello-secondary-being-promoted"></a><span data-ttu-id="21340-206">A másodlagos előléptetendő hello</span><span class="sxs-lookup"><span data-stu-id="21340-206">For hello secondary being promoted</span></span>
<span data-ttu-id="21340-207">Ehhez hasonlóan a Service Fabric van szüksége a replika toostart figyeli a üzenetek hello keresztülhaladnak a hálózaton, és bármely azt ügyel háttérfeladatok indítása.</span><span class="sxs-lookup"><span data-stu-id="21340-207">Similarly, Service Fabric needs this replica toostart listening for messages on hello wire and start any background tasks it cares about.</span></span> <span data-ttu-id="21340-208">Ennek eredményeképpen a folyamat láthatóhoz hasonló toowhen hello szolgáltatást jön létre, kivéve, hogy hello replika maga már létezik.</span><span class="sxs-lookup"><span data-stu-id="21340-208">As a result, this process looks similar toowhen hello service is created, except that hello replica itself already exists.</span></span> <span data-ttu-id="21340-209">a következő API-k hello nevezzük:</span><span class="sxs-lookup"><span data-stu-id="21340-209">hello following APIs are called:</span></span>

1. <span data-ttu-id="21340-210">Párhuzamos</span><span class="sxs-lookup"><span data-stu-id="21340-210">In parallel</span></span>
    - <span data-ttu-id="21340-211">`StatefulServiceBase.CreateServiceReplicaListeners()`meghívták és bármely visszaadott figyelői megnyitása.</span><span class="sxs-lookup"><span data-stu-id="21340-211">`StatefulServiceBase.CreateServiceReplicaListeners()` is invoked and any returned listeners are Opened.</span></span> <span data-ttu-id="21340-212">`ICommunicationListener.OpenAsync()`a minden egyes figyelő neve.</span><span class="sxs-lookup"><span data-stu-id="21340-212">`ICommunicationListener.OpenAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="21340-213">hello szolgáltatás `StatefulServiceBase.RunAsync()` módszer neve</span><span class="sxs-lookup"><span data-stu-id="21340-213">hello service's `StatefulServiceBase.RunAsync()` method is called</span></span>
2. <span data-ttu-id="21340-214">Amennyiben az összes replika figyelője hello `OpenAsync()` hívás befejezéséhez és `RunAsync()` hívása történt, `StatefulServiceBase.OnChangeRoleAsync()` nevezzük.</span><span class="sxs-lookup"><span data-stu-id="21340-214">Once all hello replica listener's `OpenAsync()` calls complete and `RunAsync()` has been called,  `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="21340-215">Ez uncommonly felülbírálja a hello szolgáltatásban.</span><span class="sxs-lookup"><span data-stu-id="21340-215">This is uncommonly overridden in hello service.</span></span>

### <a name="common-issues-during-stateful-service-shutdown-and-primary-demotion"></a><span data-ttu-id="21340-216">Az állapotalapú szolgáltatás leállítása és elsődleges lefokozás során kapcsolatos gyakori hibák</span><span class="sxs-lookup"><span data-stu-id="21340-216">Common issues during stateful service shutdown and primary demotion</span></span>
<span data-ttu-id="21340-217">A Service Fabric módosítások hello elsődleges számos okból az állapotalapú szolgáltatás.</span><span class="sxs-lookup"><span data-stu-id="21340-217">Service Fabric changes hello Primary of a stateful service for a variety of reasons.</span></span> <span data-ttu-id="21340-218">hello leggyakoribb vannak [fürt újraelosztás](service-fabric-cluster-resource-manager-balancing.md) és [az alkalmazásfrissítés](service-fabric-application-upgrade.md).</span><span class="sxs-lookup"><span data-stu-id="21340-218">hello most common are [cluster rebalancing](service-fabric-cluster-resource-manager-balancing.md) and [application upgrade](service-fabric-application-upgrade.md).</span></span> <span data-ttu-id="21340-219">Ezek a műveletek során (és a normál szolgáltatás leállítása, például szeretné látni, hogy ha hello szolgáltatást törölték-e), akkor fontos, hogy hello szolgáltatást illetően hello `CancellationToken`.</span><span class="sxs-lookup"><span data-stu-id="21340-219">During these operations (as well as during normal service shutdown, like you'd see if hello service was deleted), it is important that hello service respect hello `CancellationToken`.</span></span> <span data-ttu-id="21340-220">Szolgáltatások szabályszerűen nem kezelő cancellation fog több problémákba ütközhetnek.</span><span class="sxs-lookup"><span data-stu-id="21340-220">Services that do not handle cancellation cleanly will experience several issues.</span></span> <span data-ttu-id="21340-221">Különösen ezek a műveletek lassú lesz, mivel a Service Fabric megvárja-e a hello szolgáltatások toostop szabályosan.</span><span class="sxs-lookup"><span data-stu-id="21340-221">In particular, these operations will be slow since Service Fabric waits for hello services toostop gracefully.</span></span> <span data-ttu-id="21340-222">Ez végső soron toofailed frissítések vezethet, hogy túllépi az időkorlátot, és állítsa vissza.</span><span class="sxs-lookup"><span data-stu-id="21340-222">This can ultimately lead toofailed upgrades that time out and roll back.</span></span> <span data-ttu-id="21340-223">Hiba toohonor hello cancellation token is eredményezheti, hogy imbalanced fürtök csomópontok gyakran használt adatok lekérése, de hello szolgáltatások nem rebalanced, mert túl hosszú toomove tart máshol őket.</span><span class="sxs-lookup"><span data-stu-id="21340-223">Failure toohonor hello cancellation token can also cause imbalanced clusters because nodes get hot but hello services can't be rebalanced since it takes too long toomove them elsewhere.</span></span> 

<span data-ttu-id="21340-224">Mivel hello szolgáltatások állapotalapú, akkor valószínű is, hogy használják hello [megbízható gyűjtemények](service-fabric-reliable-services-reliable-collections.md).</span><span class="sxs-lookup"><span data-stu-id="21340-224">Since hello services are stateful, it is also likely that they are using hello [Reliable Collections](service-fabric-reliable-services-reliable-collections.md).</span></span> <span data-ttu-id="21340-225">A Service Fabric egy elsődleges lefokozása, hello első dolog, ami történik esetén meg kell, hogy visszavonódik az írási hozzáférést toohello mögöttes állapota.</span><span class="sxs-lookup"><span data-stu-id="21340-225">In Service Fabric, when a Primary is demoted, one of hello first things that happens is that write access toohello underlying state is revoked.</span></span> <span data-ttu-id="21340-226">Ennek eredménye tooa problémákat, amelyek hatással lehet a hello szolgáltatás életciklus második csoportja.</span><span class="sxs-lookup"><span data-stu-id="21340-226">This leads tooa second set of issues that can impact hello service lifecycle.</span></span> <span data-ttu-id="21340-227">visszatérési kivételek alapuló hello időzítési, és hogy hello replika áthelyezik hello gyűjtemények vagy leáll.</span><span class="sxs-lookup"><span data-stu-id="21340-227">hello collections return Exceptions based on hello timing and whether hello replica is being moved or shut down.</span></span> <span data-ttu-id="21340-228">Az ilyen kivételek megfelelően kell kezelni.</span><span class="sxs-lookup"><span data-stu-id="21340-228">These exceptions should be handled correctly.</span></span> <span data-ttu-id="21340-229">A Service Fabric által okozott kivételeket sorolhatók állandó [(`FabricException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabricexception?view=azure-dotnet) és átmeneti [(`FabricTransientException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabrictransientexception?view=azure-dotnet) kategóriák.</span><span class="sxs-lookup"><span data-stu-id="21340-229">Exceptions thrown by Service Fabric fall into permanent [(`FabricException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabricexception?view=azure-dotnet) and transient [(`FabricTransientException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabrictransientexception?view=azure-dotnet) categories.</span></span> <span data-ttu-id="21340-230">Állandó kivételek legyen naplózva, és történt, miközben hello átmeneti kivételek néhány újrapróbálkozási logika alapján kell ismételni.</span><span class="sxs-lookup"><span data-stu-id="21340-230">Permanent exceptions should be logged and thrown, while hello transient exceptions may be retried based on some retry logic.</span></span>

<span data-ttu-id="21340-231">Hello használata érkező hello kivételek kezelése `ReliableCollections` szolgáltatás életciklus-események együtt tesztelése és ellenőrzése egy megbízható szolgáltatás fontos részét képezi.</span><span class="sxs-lookup"><span data-stu-id="21340-231">Handling hello exceptions that come from use of hello `ReliableCollections` in conjunction with service lifecycle events is an important part of testing and validating a Reliable Service.</span></span> <span data-ttu-id="21340-232">a javaslat hello egy mindig toorun a szolgáltatás terhelés frissítések végrehajtása közben és [chaos tesztelés](service-fabric-controlled-chaos.md) tooproduction legalább egyszer telepítése előtt.</span><span class="sxs-lookup"><span data-stu-id="21340-232">hello recommendation is always toorun your service under load while performing upgrades and [chaos testing](service-fabric-controlled-chaos.md) before ever deploying tooproduction.</span></span> <span data-ttu-id="21340-233">Az alábbi alapvető lépések segítségével, győződjön meg arról, hogy a szolgáltatás megfelelően van megvalósítva, és életciklus-események megfelelően kezeli.</span><span class="sxs-lookup"><span data-stu-id="21340-233">These basic steps help ensure that your service is correctly implemented and handles lifecycle events correctly.</span></span>


## <a name="notes-on-service-lifecycle"></a><span data-ttu-id="21340-234">Tudnivalók a szolgáltatási életciklus</span><span class="sxs-lookup"><span data-stu-id="21340-234">Notes on service lifecycle</span></span>
  - <span data-ttu-id="21340-235">Mindkét hello `RunAsync()` metódus és hello `CreateServiceReplicaListeners/CreateServiceInstanceListeners` hívások nem kötelező.</span><span class="sxs-lookup"><span data-stu-id="21340-235">Both hello `RunAsync()` method and hello `CreateServiceReplicaListeners/CreateServiceInstanceListeners` calls are optional.</span></span> <span data-ttu-id="21340-236">Szolgáltatásként lehet őket, egyaránt, vagy egyiket sem.</span><span class="sxs-lookup"><span data-stu-id="21340-236">A service may have one of them, both, or neither.</span></span> <span data-ttu-id="21340-237">Például ha hello szolgáltatásnak nincs válasz toouser hívások a munkáját, nincs szükség az tooimplement `RunAsync()`.</span><span class="sxs-lookup"><span data-stu-id="21340-237">For example, if hello service does all its work in response toouser calls, there is no need for it tooimplement `RunAsync()`.</span></span> <span data-ttu-id="21340-238">Csak a hello kommunikációs figyelőket és a kapcsolódó kódra szükség.</span><span class="sxs-lookup"><span data-stu-id="21340-238">Only hello communication listeners and their associated code are necessary.</span></span> <span data-ttu-id="21340-239">Hasonlóképpen létrehozása és a kommunikációs figyelőket visszaadó nem kötelező, hello szolgáltatás esetleg csak a háttér toodo működik, és tooimplement csak úgy kell`RunAsync()`</span><span class="sxs-lookup"><span data-stu-id="21340-239">Similarly, creating and returning communication listeners is optional, as hello service may have only background work toodo, and so only needs tooimplement `RunAsync()`</span></span>
  - <span data-ttu-id="21340-240">A szolgáltatás toocomplete érvényes `RunAsync()` sikeresen és visszatérési belőle.</span><span class="sxs-lookup"><span data-stu-id="21340-240">It is valid for a service toocomplete `RunAsync()` successfully and return from it.</span></span> <span data-ttu-id="21340-241">Befejezése nincs hiba feltétel.</span><span class="sxs-lookup"><span data-stu-id="21340-241">Completing is not a failure condition.</span></span> <span data-ttu-id="21340-242">Befejezése `RunAsync()` azt jelzi, hogy befejeződött-hello háttérműveletek hello szolgáltatást.</span><span class="sxs-lookup"><span data-stu-id="21340-242">Completing `RunAsync()` indicates that hello background work of hello service has completed.</span></span> <span data-ttu-id="21340-243">Állapot-nyilvántartó megbízható szolgáltatások esetén `RunAsync()` nem hívják újra történik, ha hello replika az elsődleges tooSecondary lefokozása volt, és majd a hátsó tooPrimary elő.</span><span class="sxs-lookup"><span data-stu-id="21340-243">For stateful reliable services, `RunAsync()` is called again if hello replica were demoted from Primary tooSecondary and then promoted back tooPrimary.</span></span>
  - <span data-ttu-id="21340-244">Ha egy szolgáltatás kilép a `RunAsync()` által egy váratlan kivétel kiváltása, ez jelent hibát.</span><span class="sxs-lookup"><span data-stu-id="21340-244">If a service exits from `RunAsync()` by throwing some unexpected exception, this constitutes a failure.</span></span> <span data-ttu-id="21340-245">hello szolgáltatás objektum le van állítva, és a rendszerállapot hibát jelzett.</span><span class="sxs-lookup"><span data-stu-id="21340-245">hello service object is shut down and a health error reported.</span></span>
  - <span data-ttu-id="21340-246">Ezen módszerek visszatérése ideig van, amíg azonnal elveszti hello képességét toowrite tooReliable gyűjtemények, és ezért nem tudja végrehajtani a valódi munkát.</span><span class="sxs-lookup"><span data-stu-id="21340-246">While there is no time limit on returning from these methods, you immediately lose hello ability toowrite tooReliable Collections and therefore cannot complete any real work.</span></span> <span data-ttu-id="21340-247">Ajánlott, hogy ismét lehető leggyorsabban hello visszavonási kérelem fogadásakor.</span><span class="sxs-lookup"><span data-stu-id="21340-247">It is recommended that you return as quickly as possible upon receiving hello cancellation request.</span></span> <span data-ttu-id="21340-248">Ha a szolgáltatás nem válaszol a Service Fabric előfordulhat, hogy kényszerített elfogadható időn belül toothese API-hívások leáll a szolgáltatás.</span><span class="sxs-lookup"><span data-stu-id="21340-248">If your service does not respond toothese API calls in a reasonable amount of time Service Fabric may forcibly terminate your service.</span></span> <span data-ttu-id="21340-249">Általában ez csak akkor fordul elő alkalmazásfrissítések vagy egy szolgáltatás törlésekor során.</span><span class="sxs-lookup"><span data-stu-id="21340-249">Usually this only happens during application upgrades or when a service is being deleted.</span></span> <span data-ttu-id="21340-250">Ez az időkorlát értéke alapértelmezés szerint 15 percenként.</span><span class="sxs-lookup"><span data-stu-id="21340-250">This timeout is 15 minutes by default.</span></span>
  - <span data-ttu-id="21340-251">Hello hibáinak `OnCloseAsync()` elérési eredményez `OnAbort()` Ez az egy utolsó-alkalommal legjobb lehetőség hello meghívott tooclean szolgáltatás fel, és felszabadíthatja a minden olyan erőforrásnál, amely azt állítják.</span><span class="sxs-lookup"><span data-stu-id="21340-251">Failures in hello `OnCloseAsync()` path result in `OnAbort()` being called which is a last-chance best-effort opportunity for hello service tooclean up and release any resources that they have claimed.</span></span>

## <a name="next-steps"></a><span data-ttu-id="21340-252">Következő lépések</span><span class="sxs-lookup"><span data-stu-id="21340-252">Next steps</span></span>
- [<span data-ttu-id="21340-253">TooReliable szolgáltatások bemutatása</span><span class="sxs-lookup"><span data-stu-id="21340-253">Introduction tooReliable Services</span></span>](service-fabric-reliable-services-introduction.md)
- [<span data-ttu-id="21340-254">Megbízható szolgáltatások – első lépések</span><span class="sxs-lookup"><span data-stu-id="21340-254">Reliable Services quick start</span></span>](service-fabric-reliable-services-quick-start.md)
- [<span data-ttu-id="21340-255">Megbízható szolgáltatás használati speciális</span><span class="sxs-lookup"><span data-stu-id="21340-255">Reliable Services advanced usage</span></span>](service-fabric-reliable-services-advanced-usage.md)
