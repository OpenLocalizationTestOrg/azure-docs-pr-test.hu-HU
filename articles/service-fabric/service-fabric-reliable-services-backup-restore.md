---
title: "aaaService háló biztonsági mentése és visszaállítása |} Microsoft Docs"
description: "Service Fabric biztonsági mentési és visszaállítási fogalmi dokumentációja"
services: service-fabric
documentationcenter: .net
author: mcoskun
manager: timlt
editor: subramar,jessebenson
ms.assetid: 91ea6ca4-cc2a-4155-9823-dcbd0b996349
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 08/18/2017
ms.author: mcoskun
ms.openlocfilehash: e502b59c84999c3fe825167383f00a5ebd70c9b5
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 10/06/2017
---
# <a name="back-up-and-restore-reliable-services-and-reliable-actors"></a><span data-ttu-id="16fd5-103">Biztonsági mentése és visszaállítása a Reliable Services és Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="16fd5-103">Back up and restore Reliable Services and Reliable Actors</span></span>
<span data-ttu-id="16fd5-104">Az Azure Service Fabric egy magas rendelkezésre állású platformon keresztül replikálásra kerülő hello állapot több csomópontok toomaintain a magas rendelkezésre állású.</span><span class="sxs-lookup"><span data-stu-id="16fd5-104">Azure Service Fabric is a high-availability platform that replicates hello state across multiple nodes toomaintain this high availability.</span></span>  <span data-ttu-id="16fd5-105">Így még akkor is, ha hello fürtben egy csomópont meghibásodik, a hello szolgáltatások elérhető toobe továbbra is.</span><span class="sxs-lookup"><span data-stu-id="16fd5-105">Thus, even if one node in hello cluster fails, hello services continue toobe available.</span></span> <span data-ttu-id="16fd5-106">Amikor ezt a beépített redundanciát hello platform által biztosított lehet, hogy elegendő-e egyes, bizonyos esetekben kívánatos hello szolgáltatás tooback adatokat (tooan külső áruházban).</span><span class="sxs-lookup"><span data-stu-id="16fd5-106">While this in-built redundancy provided by hello platform may be sufficient for some, in certain cases it is desirable for hello service tooback up data (tooan external store).</span></span>

> [!NOTE]
> <span data-ttu-id="16fd5-107">Kritikus toobackup, és állítsa vissza az adatait (és tesztelje, hogy a várt módon működik), akkor helyreállíthatja az adatvesztés.</span><span class="sxs-lookup"><span data-stu-id="16fd5-107">It is critical toobackup and restore your data (and test that it works as expected) so you can recover from data loss scenarios.</span></span>
> 
> 

<span data-ttu-id="16fd5-108">Például egy szolgáltatás érdemes tooback rendelés tooprotect a következő forgatókönyvek hello adatokat:</span><span class="sxs-lookup"><span data-stu-id="16fd5-108">For example, a service may want tooback up data in order tooprotect from hello following scenarios:</span></span>

- <span data-ttu-id="16fd5-109">A teljes Service Fabric-fürt hello végleges adatvesztést hello eseményben.</span><span class="sxs-lookup"><span data-stu-id="16fd5-109">In hello event of hello permanent loss of an entire Service Fabric cluster.</span></span>
- <span data-ttu-id="16fd5-110">Szolgáltatás partíció hello replikák többsége végleges adatvesztést</span><span class="sxs-lookup"><span data-stu-id="16fd5-110">Permanent loss of a majority of hello replicas of a service partition</span></span>
- <span data-ttu-id="16fd5-111">Felügyeleti hibák, amelyek hello állapot véletlenül lekérdezi törölt vagy sérült.</span><span class="sxs-lookup"><span data-stu-id="16fd5-111">Administrative errors whereby hello state accidentally gets deleted or corrupted.</span></span> <span data-ttu-id="16fd5-112">Ez például akkor fordulhat elő, ha egy megfelelő jogosultsággal rendelkező rendszergazda tévesen törli hello szolgáltatást.</span><span class="sxs-lookup"><span data-stu-id="16fd5-112">For example, this may happen if an administrator with sufficient privilege erroneously deletes hello service.</span></span>
- <span data-ttu-id="16fd5-113">Hibák hello szolgáltatásban adatvesztést okozhat.</span><span class="sxs-lookup"><span data-stu-id="16fd5-113">Bugs in hello service that cause data corruption.</span></span> <span data-ttu-id="16fd5-114">Ez például akkor fordulhat elő, a kód frissítése indításakor hibás adatok tooa megbízható gyűjtemény írása.</span><span class="sxs-lookup"><span data-stu-id="16fd5-114">For example, this may happen when a service code upgrade starts writing faulty data tooa Reliable Collection.</span></span> <span data-ttu-id="16fd5-115">Ebben az esetben is hello kódot, és hello adatok lehet toobe tooan vissza korábbi állapot.</span><span class="sxs-lookup"><span data-stu-id="16fd5-115">In such a case, both hello code and hello data may have toobe reverted tooan earlier state.</span></span>
- <span data-ttu-id="16fd5-116">Kapcsolat nélküli adatok feldolgozása.</span><span class="sxs-lookup"><span data-stu-id="16fd5-116">Offline data processing.</span></span> <span data-ttu-id="16fd5-117">Előfordulhat, hogy kényelmes toohave offline üzleti intelligencia, külön-külön történik, hello szolgáltatásból való, hello adatokat állít elő az adatok feldolgozása.</span><span class="sxs-lookup"><span data-stu-id="16fd5-117">It might be convenient toohave offline processing of data for business intelligence that happens separately from hello service that generates hello data.</span></span>

<span data-ttu-id="16fd5-118">hello biztonsági mentési/visszaállítási funkció lehetővé teszi, hogy a szolgáltatások hello megbízható szolgáltatások API toocreate és visszaállítási biztonsági mentést készített.</span><span class="sxs-lookup"><span data-stu-id="16fd5-118">hello Backup/Restore feature allows services built on hello Reliable Services API toocreate and restore backups.</span></span> <span data-ttu-id="16fd5-119">hello hello platform által biztosított biztonsági mentési API-k engedélyezése biztonsági mentését vagy mentéseit szolgáltatás partíció állapot nélkül blokkoló olvasási vagy írási műveleteket.</span><span class="sxs-lookup"><span data-stu-id="16fd5-119">hello backup APIs provided by hello platform allow backup(s) of a service partition's state, without blocking read or write operations.</span></span> <span data-ttu-id="16fd5-120">hello visszaállítási API-k engedélyezése egy szolgáltatás partíció állapot toobe választott másolatból állítottak vissza.</span><span class="sxs-lookup"><span data-stu-id="16fd5-120">hello restore APIs allow a service partition's state toobe restored from a chosen backup.</span></span>

## <a name="types-of-backup"></a><span data-ttu-id="16fd5-121">Biztonsági mentés típusai</span><span class="sxs-lookup"><span data-stu-id="16fd5-121">Types of Backup</span></span>
<span data-ttu-id="16fd5-122">Két biztonsági mentési lehetőség: teljes és növekményes.</span><span class="sxs-lookup"><span data-stu-id="16fd5-122">There are two backup options: Full and Incremental.</span></span>
<span data-ttu-id="16fd5-123">Teljes biztonsági mentés egy összes hello szükséges adatok toorecreate hello állapotának hello replika magában foglaló biztonsági másolat: ellenőrzőpontok és az összes naplófájl rögzíti.</span><span class="sxs-lookup"><span data-stu-id="16fd5-123">A full backup is a backup that contains all hello data required toorecreate hello state of hello replica: checkpoints and all log records.</span></span>
<span data-ttu-id="16fd5-124">Hello ellenőrzőpontok és hello naplófájl van, mert egy teljes biztonsági mentés önállóan állíthatók vissza.</span><span class="sxs-lookup"><span data-stu-id="16fd5-124">Since it has hello checkpoints and hello log, a full backup can be restored by itself.</span></span>

<span data-ttu-id="16fd5-125">a teljes biztonsági mentés hello probléma merül fel, ha nagy hello ellenőrzőpontokat.</span><span class="sxs-lookup"><span data-stu-id="16fd5-125">hello problem with full backups arises when hello checkpoints are large.</span></span>
<span data-ttu-id="16fd5-126">Például egy replikát, amelynek állapota 16 GB lesz, amely körülbelül too16 GB egyezzen az ellenőrzőpontokat.</span><span class="sxs-lookup"><span data-stu-id="16fd5-126">For example, a replica that has 16 GB of state will have checkpoints that add up approximately too16 GB.</span></span>
<span data-ttu-id="16fd5-127">Ha öt percig Helyreállításipont-célkitűzés van, a hello replikának szüksége lesz a biztonsági másolat, ötpercenként toobe.</span><span class="sxs-lookup"><span data-stu-id="16fd5-127">If we have a Recovery Point Objective of five minutes, hello replica needs toobe backed up every five minutes.</span></span>
<span data-ttu-id="16fd5-128">Toocopy kell minden alkalommal, amikor biztonsági mentést készít az ellenőrzőpontok továbbá 16 GB too50 MB (konfigurálható használatával `CheckpointThresholdInMB`) értéke a naplók.</span><span class="sxs-lookup"><span data-stu-id="16fd5-128">Each time it backs up it needs toocopy 16 GB of checkpoints in addition too50 MB (configurable using `CheckpointThresholdInMB`) worth of logs.</span></span>

![Teljes biztonsági mentés példa.](media/service-fabric-reliable-services-backup-restore/FullBackupExample.PNG)

<span data-ttu-id="16fd5-130">hello megoldás toothis probléma a növekményes biztonsági mentést, ha biztonsági mentést csak tartalmaz megváltozott hello naplórekordokat hello utolsó biztonsági mentés óta.</span><span class="sxs-lookup"><span data-stu-id="16fd5-130">hello solution toothis problem is incremental backups, where backup only contains hello changed log records since hello last backup.</span></span>

![Növekményes biztonsági mentési példa.](media/service-fabric-reliable-services-backup-restore/IncrementalBackupExample.PNG)

<span data-ttu-id="16fd5-132">Mivel a növekményes biztonsági mentések csak történt változások hello utolsó biztonsági mentés óta (nem tartalmaz hello ellenőrzőpontokat), toobe gyorsabban általában, de azok nem állítható vissza, hogy saját maguk.</span><span class="sxs-lookup"><span data-stu-id="16fd5-132">Since incremental backups are only changes since hello last backup (does not include hello checkpoints), they tend toobe faster but they cannot be restored on their own.</span></span>
<span data-ttu-id="16fd5-133">toorestore növekményes biztonsági mentést, a teljes biztonsági mentési láncolatát hello szükség.</span><span class="sxs-lookup"><span data-stu-id="16fd5-133">toorestore an incremental backup, hello entire backup chain is required.</span></span>
<span data-ttu-id="16fd5-134">A biztonsági mentési láncolatát lánc csatlakozik a biztonsági mentések teljes biztonsági mentés kezdve, és egy egybefüggő növekményes biztonsági mentések számát.</span><span class="sxs-lookup"><span data-stu-id="16fd5-134">A backup chain is a chain of backups starting with a full backup and followed by a number of contiguous incremental backups.</span></span>

## <a name="backup-reliable-services"></a><span data-ttu-id="16fd5-135">Biztonsági mentési megbízható szolgáltatások</span><span class="sxs-lookup"><span data-stu-id="16fd5-135">Backup Reliable Services</span></span>
<span data-ttu-id="16fd5-136">hello szolgáltatás Szerző teljes körű vezérléssel rendelkezik a toomake biztonsági mentések és a biztonsági másolatok tárolásához.</span><span class="sxs-lookup"><span data-stu-id="16fd5-136">hello service author has full control of when toomake backups and where backups will be stored.</span></span>

<span data-ttu-id="16fd5-137">biztonsági másolat toostart, hello szolgáltatást kell tooinvoke hello örökölt tagot függvény `BackupAsync`.</span><span class="sxs-lookup"><span data-stu-id="16fd5-137">toostart a backup, hello service needs tooinvoke hello inherited member function `BackupAsync`.</span></span>  
<span data-ttu-id="16fd5-138">Biztonsági mentések tehető csak az elsődleges replikára változott, és igényelnek-e írási állapot toobe kap.</span><span class="sxs-lookup"><span data-stu-id="16fd5-138">Backups can be made only from primary replicas, and they require write status toobe granted.</span></span>

<span data-ttu-id="16fd5-139">Az alábbi módon `BackupAsync` veszi a `BackupDescription` objektum, ahol egy adhat meg egy teljes vagy növekményes biztonsági mentés, valamint a visszahívási függvény, `Func<< BackupInfo, CancellationToken, Task<bool>>>` , amely nyílik meg, ha a biztonsági mentési mappája hello helyileg létrejött, és készen áll a toobe kimenő toosome áthelyezése külső tárhelyen.</span><span class="sxs-lookup"><span data-stu-id="16fd5-139">As shown below, `BackupAsync` takes in a `BackupDescription` object, where one can specify a full or incremental backup, as well as a callback function, `Func<< BackupInfo, CancellationToken, Task<bool>>>` that is invoked when hello backup folder has been created locally and is ready toobe moved out toosome external storage.</span></span>

```csharp

BackupDescription myBackupDescription = new BackupDescription(backupOption.Incremental,this.BackupCallbackAsync);

await this.BackupAsync(myBackupDescription);

```

<span data-ttu-id="16fd5-140">A növekményes biztonsági mentés meghiúsulhat kérelem tootake `FabricMissingFullBackupException`.</span><span class="sxs-lookup"><span data-stu-id="16fd5-140">Request tootake an incremental backup can fail with `FabricMissingFullBackupException`.</span></span> <span data-ttu-id="16fd5-141">Ezt a kivételt azt jelzi, hogy a következő dolgot hello egyik történik:</span><span class="sxs-lookup"><span data-stu-id="16fd5-141">This exception indicates that one of hello following things is happening:</span></span>

- <span data-ttu-id="16fd5-142">hello replika soha nem tartott egy teljes biztonsági mentés óta elsődleges, vált</span><span class="sxs-lookup"><span data-stu-id="16fd5-142">hello replica has never taken a full backup since it has become primary,</span></span>
- <span data-ttu-id="16fd5-143">Néhány hello rekordok naplózására, mivel a rendszer csonkolta a hello utolsó biztonsági mentés vagy</span><span class="sxs-lookup"><span data-stu-id="16fd5-143">some of hello log records since hello last backup has been truncated or</span></span>
- <span data-ttu-id="16fd5-144">az átadott hello replika `MaxAccumulatedBackupLogSizeInMB` korlátot.</span><span class="sxs-lookup"><span data-stu-id="16fd5-144">replica passed hello `MaxAccumulatedBackupLogSizeInMB` limit.</span></span>

<span data-ttu-id="16fd5-145">Felhasználók megnövelik hello valószínűségét, hogy az képes toodo növekményes biztonsági mentések konfigurálásával `MinLogSizeInMB` vagy `TruncationThresholdFactor`.</span><span class="sxs-lookup"><span data-stu-id="16fd5-145">Users can increase hello likelihood of being able toodo incremental backups by configuring `MinLogSizeInMB` or `TruncationThresholdFactor`.</span></span>
<span data-ttu-id="16fd5-146">Vegye figyelembe, hogy ezek az értékek növelése növeli a hello / replika lemezek használata terén.</span><span class="sxs-lookup"><span data-stu-id="16fd5-146">Note that increasing these values increases hello per replica disk usage.</span></span>
<span data-ttu-id="16fd5-147">További információkért lásd: [megbízható konfigurálása](service-fabric-reliable-services-configuration.md)</span><span class="sxs-lookup"><span data-stu-id="16fd5-147">For more information, see [Reliable Services Configuration](service-fabric-reliable-services-configuration.md)</span></span>

<span data-ttu-id="16fd5-148">`BackupInfo`hello biztonsági mentés, beleértve a hello hello mappát, ahol hello futásidejű hello biztonsági mentés vonatkozóan nyújt információkat (`BackupInfo.Directory`).</span><span class="sxs-lookup"><span data-stu-id="16fd5-148">`BackupInfo` provides information regarding hello backup, including hello location of hello folder where hello runtime saved hello backup (`BackupInfo.Directory`).</span></span> <span data-ttu-id="16fd5-149">hello visszahívási függvény áthelyezheti hello `BackupInfo.Directory` tooan külső tároló vagy egy másik helyen.</span><span class="sxs-lookup"><span data-stu-id="16fd5-149">hello callback function can move hello `BackupInfo.Directory` tooan external store or another location.</span></span>  <span data-ttu-id="16fd5-150">Ez a funkció is egy logikai érték, amely jelzi, hogy volt-e képes toosuccessfully áthelyezés hello biztonsági mentési mappája tooits célhelyet adja vissza.</span><span class="sxs-lookup"><span data-stu-id="16fd5-150">This function also returns a bool that indicates whether it was able toosuccessfully move hello backup folder tooits target location.</span></span>

<span data-ttu-id="16fd5-151">hello következő kód bemutatja, hogyan hello `BackupCallbackAsync` metódus lehet használt tooupload hello biztonsági mentési tooAzure tároló:</span><span class="sxs-lookup"><span data-stu-id="16fd5-151">hello following code demonstrates how hello `BackupCallbackAsync` method can be used tooupload hello backup tooAzure Storage:</span></span>

```csharp
private async Task<bool> BackupCallbackAsync(BackupInfo backupInfo, CancellationToken cancellationToken)
{
    var backupId = Guid.NewGuid();

    await externalBackupStore.UploadBackupFolderAsync(backupInfo.Directory, backupId, cancellationToken);

    return true;
}
```

<span data-ttu-id="16fd5-152">Hello portáladatbázis előző példában `ExternalBackupStore` hello minta osztály, amely az Azure Blob storage szolgáltatással használt toointerface és `UploadBackupFolderAsync` hello módszer, amelynek hello mappa tömöríti, és elhelyezi hello Azure Blob-tárolóban.</span><span class="sxs-lookup"><span data-stu-id="16fd5-152">In hello preceeding example, `ExternalBackupStore` is hello sample class that is used toointerface with Azure Blob storage, and `UploadBackupFolderAsync` is hello method that compresses hello folder and places it in hello Azure Blob store.</span></span>

<span data-ttu-id="16fd5-153">Vegye figyelembe:</span><span class="sxs-lookup"><span data-stu-id="16fd5-153">Note that:</span></span>

  - <span data-ttu-id="16fd5-154">Lehetnek csak egy biztonsági mentési művelet egy replika az üzenetsoroktól egy adott időpontban.</span><span class="sxs-lookup"><span data-stu-id="16fd5-154">There can be only one backup operation in-flight per replica at any given time.</span></span> <span data-ttu-id="16fd5-155">Egynél több `BackupAsync` egyszerre hívás kivételhibát `FabricBackupInProgressException` toolimit aktív biztonsági mentések tooone.</span><span class="sxs-lookup"><span data-stu-id="16fd5-155">More than one `BackupAsync` call at a time will throw `FabricBackupInProgressException` toolimit inflight backups tooone.</span></span>
  - <span data-ttu-id="16fd5-156">Ha egy replika átadja, amíg folyamatban van egy biztonsági mentés, hello biztonsági mentés lehetséges, hogy nem már befejeződött.</span><span class="sxs-lookup"><span data-stu-id="16fd5-156">If a replica fails over while a backup is in progress, hello backup may not have been completed.</span></span> <span data-ttu-id="16fd5-157">Ebből kifolyólag hello feladatátvétel befejezése után is hello szolgáltatás feladata toorestart hello biztonsági mentés figyelőn `BackupAsync` szükség szerint.</span><span class="sxs-lookup"><span data-stu-id="16fd5-157">Thus, once hello failover finishes, it is hello service's responsibility toorestart hello backup by invoking `BackupAsync` as necessary.</span></span>

## <a name="restore-reliable-services"></a><span data-ttu-id="16fd5-158">Megbízható szolgáltatások visszaállítása</span><span class="sxs-lookup"><span data-stu-id="16fd5-158">Restore Reliable Services</span></span>
<span data-ttu-id="16fd5-159">Általában hello esetekben, amikor előfordulhat, hogy a visszaállítási művelet tooperform egyikébe ezen kategóriák:</span><span class="sxs-lookup"><span data-stu-id="16fd5-159">In general, hello cases when you might need tooperform a restore operation fall into one of these categories:</span></span>

  - <span data-ttu-id="16fd5-160">hello szolgáltatás elveszett adatok particionálása.</span><span class="sxs-lookup"><span data-stu-id="16fd5-160">hello service partition lost data.</span></span> <span data-ttu-id="16fd5-161">Például hello lemeze (beleértve az elsődleges replika hello) partíció két kívüli három replikák lekérdezi sérült vagy tartalmának végleges törléséig.</span><span class="sxs-lookup"><span data-stu-id="16fd5-161">For example, hello disk for two out of three replicas for a partition (including hello primary replica) gets corrupted or wiped.</span></span> <span data-ttu-id="16fd5-162">új elsődleges hello esetleg toorestore adatokat egy biztonsági másolatból.</span><span class="sxs-lookup"><span data-stu-id="16fd5-162">hello new primary may need toorestore data from a backup.</span></span>
  - <span data-ttu-id="16fd5-163">hello teljes szolgáltatási elvész.</span><span class="sxs-lookup"><span data-stu-id="16fd5-163">hello entire service is lost.</span></span> <span data-ttu-id="16fd5-164">Például a rendszergazda törli a teljes hello szolgáltatást, és így hello szolgáltatást és hello adatokat kell toobe vissza.</span><span class="sxs-lookup"><span data-stu-id="16fd5-164">For example, an administrator removes hello entire service and thus hello service and hello data need toobe restored.</span></span>
  - <span data-ttu-id="16fd5-165">hello szolgáltatás replikált sérült alkalmazás adatokat (például egy alkalmazás-hibák) miatt.</span><span class="sxs-lookup"><span data-stu-id="16fd5-165">hello service replicated corrupt application data (e.g., because of an application bug).</span></span> <span data-ttu-id="16fd5-166">Ebben az esetben hello szolgáltatást rendelkezik toobe frissítése vagy visszatért tooremove hello okát hello sérülést, és nem sérült toobe visszaállítva.</span><span class="sxs-lookup"><span data-stu-id="16fd5-166">In this case, hello service has toobe upgraded or reverted tooremove hello cause of hello corruption, and non-corrupt data has toobe restored.</span></span>

<span data-ttu-id="16fd5-167">Számos különböző módszer is előfordulhatnak, amíg fel néhány példa használatával `RestoreAsync` a fenti forgatókönyvek hello toorecover.</span><span class="sxs-lookup"><span data-stu-id="16fd5-167">While many approaches are possible, we offer some examples on using `RestoreAsync` toorecover from hello above scenarios.</span></span>

## <a name="partition-data-loss-in-reliable-services"></a><span data-ttu-id="16fd5-168">Partíció adatvesztést a Reliable Services</span><span class="sxs-lookup"><span data-stu-id="16fd5-168">Partition data loss in Reliable Services</span></span>
<span data-ttu-id="16fd5-169">Ebben az esetben hello futásidejű volna automatikus észlelése hello adatvesztés és invoke hello `OnDataLossAsync` API.</span><span class="sxs-lookup"><span data-stu-id="16fd5-169">In this case, hello runtime would automatically detect hello data loss and invoke hello `OnDataLossAsync` API.</span></span>

<span data-ttu-id="16fd5-170">hello szolgáltatás szerzőjének kell a következő toorecover tooperform hello:</span><span class="sxs-lookup"><span data-stu-id="16fd5-170">hello service author needs tooperform hello following toorecover:</span></span>

  - <span data-ttu-id="16fd5-171">Bírálja felül hello virtuális alaposztály metódust `OnDataLossAsync`.</span><span class="sxs-lookup"><span data-stu-id="16fd5-171">Override hello virtual base class method `OnDataLossAsync`.</span></span>
  - <span data-ttu-id="16fd5-172">Hello legutóbbi biztonsági mentés található hello külső helyen hello szolgáltatás biztonsági másolatait tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="16fd5-172">Find hello latest backup in hello external location that contains hello service's backups.</span></span>
  - <span data-ttu-id="16fd5-173">Töltse le a legutóbbi biztonsági hello (és hello biztonsági mentés kibontani hello biztonsági mentési mappába, ha azt tömörítették).</span><span class="sxs-lookup"><span data-stu-id="16fd5-173">Download hello latest backup (and uncompress hello backup into hello backup folder if it was compressed).</span></span>
  - <span data-ttu-id="16fd5-174">Hello `OnDataLossAsync` módszer lehetővé teszi egy `RestoreContext`.</span><span class="sxs-lookup"><span data-stu-id="16fd5-174">hello `OnDataLossAsync` method provides a `RestoreContext`.</span></span> <span data-ttu-id="16fd5-175">Hello hívás `RestoreAsync` API a megadott hello `RestoreContext`.</span><span class="sxs-lookup"><span data-stu-id="16fd5-175">Call hello `RestoreAsync` API on hello provided `RestoreContext`.</span></span>
  - <span data-ttu-id="16fd5-176">Térjen vissza IGAZ, ha hello visszaállítása sikeres.</span><span class="sxs-lookup"><span data-stu-id="16fd5-176">Return true if hello restoration was a success.</span></span>

<span data-ttu-id="16fd5-177">Az alábbiakban látható egy példa végrehajtásának hello `OnDataLossAsync` módszert:</span><span class="sxs-lookup"><span data-stu-id="16fd5-177">Following is an example implementation of hello `OnDataLossAsync` method:</span></span>

```csharp
protected override async Task<bool> OnDataLossAsync(RestoreContext restoreCtx, CancellationToken cancellationToken)
{
    var backupFolder = await this.externalBackupStore.DownloadLastBackupAsync(cancellationToken);

    var restoreDescription = new RestoreDescription(backupFolder);

    await restoreCtx.RestoreAsync(restoreDescription);

    return true;
}
```

<span data-ttu-id="16fd5-178">`RestoreDescription`az átadott toohello `RestoreContext.RestoreAsync` hívás nevű tagot tartalmaz `BackupFolderPath`.</span><span class="sxs-lookup"><span data-stu-id="16fd5-178">`RestoreDescription` passed in toohello `RestoreContext.RestoreAsync` call contains a member called `BackupFolderPath`.</span></span>
<span data-ttu-id="16fd5-179">Egy teljes biztonsági mentés, visszaállításakor ez `BackupFolderPath` toohello hello mappa, amely tartalmazza a teljes biztonsági mentés helyi elérési utat kell megadni.</span><span class="sxs-lookup"><span data-stu-id="16fd5-179">When restoring a single full backup, this `BackupFolderPath` should be set toohello local path of hello folder that contains your full backup.</span></span>
<span data-ttu-id="16fd5-180">Teljes és növekményes biztonsági mentések, számos visszaállításakor `BackupFolderPath` toohello hello mappa nem csak hello teljes biztonsági mentés, de is összes hello növekményes biztonsági mentés helyi elérési utat kell megadni.</span><span class="sxs-lookup"><span data-stu-id="16fd5-180">When restoring a full backup and a number of incremental backups, `BackupFolderPath` should be set toohello local path of hello folder that not only contains hello full backup, but also all hello incremental backups.</span></span>
<span data-ttu-id="16fd5-181">`RestoreAsync`hívás segítségével throw `FabricMissingFullBackupException` Ha hello `BackupFolderPath` megadott egy teljes biztonsági mentést tartalmaz.</span><span class="sxs-lookup"><span data-stu-id="16fd5-181">`RestoreAsync` call can throw `FabricMissingFullBackupException` if hello `BackupFolderPath` provided does not contain a full backup.</span></span>
<span data-ttu-id="16fd5-182">Azt is segítségével throw `ArgumentException` Ha `BackupFolderPath` növekményes biztonsági mentések hibás lánca.</span><span class="sxs-lookup"><span data-stu-id="16fd5-182">It can also throw `ArgumentException` if `BackupFolderPath` has a broken chain of incremental backups.</span></span>
<span data-ttu-id="16fd5-183">Ha teljes biztonsági mentés hello tartalmaz, például hello először növekményes, és hello harmadik növekményes biztonsági mentést, de nincs hello második növekményes biztonsági mentés.</span><span class="sxs-lookup"><span data-stu-id="16fd5-183">For example, if it contains hello full backup, hello first incremental and hello third incremental backup but no hello second incremental backup.</span></span>

> [!NOTE]
> <span data-ttu-id="16fd5-184">hello RestorePolicy alapértelmezés szerint beállított tooSafe.</span><span class="sxs-lookup"><span data-stu-id="16fd5-184">hello RestorePolicy is set tooSafe by default.</span></span>  <span data-ttu-id="16fd5-185">Ez azt jelenti, hogy hello `RestoreAsync` API sikertelen lesz, és ArgumentException hello biztonsági mentési mappa tartalmazza, amely a replikában tárolt régebbi, mint vagy egyenlő toohello állapottal állapotának észlelésekor.</span><span class="sxs-lookup"><span data-stu-id="16fd5-185">This means that hello `RestoreAsync` API will fail with ArgumentException if it detects that hello backup folder contains a state that is older than or equal toohello state contained in this replica.</span></span>  <span data-ttu-id="16fd5-186">`RestorePolicy.Force`lehet használt tooskip biztonsági ellenőrzés.</span><span class="sxs-lookup"><span data-stu-id="16fd5-186">`RestorePolicy.Force` can be used tooskip this safety check.</span></span> <span data-ttu-id="16fd5-187">Ennek részeként van megadva `RestoreDescription`.</span><span class="sxs-lookup"><span data-stu-id="16fd5-187">This is specified as part of `RestoreDescription`.</span></span>
> 

## <a name="deleted-or-lost-service"></a><span data-ttu-id="16fd5-188">A törölt vagy elveszett szolgáltatás</span><span class="sxs-lookup"><span data-stu-id="16fd5-188">Deleted or lost service</span></span>
<span data-ttu-id="16fd5-189">Ha a szolgáltatás el lett távolítva, meg kell először hozza létre hello szolgáltatás előtt hello vissza tudja állítani.</span><span class="sxs-lookup"><span data-stu-id="16fd5-189">If a service is removed, you must first re-create hello service before hello data can be restored.</span></span>  <span data-ttu-id="16fd5-190">Fontos toocreate hello szolgáltatást, amely ugyanazt a konfigurációt, például particionálási sémát úgy, hogy hello adatok zökkenőmentesen visszaállíthatók hello.</span><span class="sxs-lookup"><span data-stu-id="16fd5-190">It is important toocreate hello service with hello same configuration, e.g., partitioning scheme, so that hello data can be restored seamlessly.</span></span>  <span data-ttu-id="16fd5-191">Miután hello szolgáltatás működik-e, hello API toorestore adatok (`OnDataLossAsync` fent) rendelkezik a szolgáltatás minden partícióján meghívott toobe.</span><span class="sxs-lookup"><span data-stu-id="16fd5-191">Once hello service is up, hello API toorestore data (`OnDataLossAsync` above) has toobe invoked on every partition of this service.</span></span> <span data-ttu-id="16fd5-192">Egyik módszere azt használatával `[FabricClient.TestManagementClient.StartPartitionDataLossAsync](https://msdn.microsoft.com/library/mt693569.aspx)` minden partícióján.</span><span class="sxs-lookup"><span data-stu-id="16fd5-192">One way of achieving this is by using `[FabricClient.TestManagementClient.StartPartitionDataLossAsync](https://msdn.microsoft.com/library/mt693569.aspx)` on every partition.</span></span>  

<span data-ttu-id="16fd5-193">Ettől a ponttól kezdve megvalósítási hello ugyanaz, mint a fenti forgatókönyv hello.</span><span class="sxs-lookup"><span data-stu-id="16fd5-193">From this point, implementation is hello same as hello above scenario.</span></span> <span data-ttu-id="16fd5-194">Mindegyik partíció kell toorestore hello legújabb vonatkozó biztonsági mentési hello külső áruházban.</span><span class="sxs-lookup"><span data-stu-id="16fd5-194">Each partition needs toorestore hello latest relevant backup from hello external store.</span></span> <span data-ttu-id="16fd5-195">Egy szerint azonosítója most megváltozhatott, mivel hello futásidejű hoz partíció azonosítók dinamikusan hello partíció.</span><span class="sxs-lookup"><span data-stu-id="16fd5-195">One caveat is that hello partition ID may have now changed, since hello runtime creates partition IDs dynamically.</span></span> <span data-ttu-id="16fd5-196">Ebből kifolyólag hello szolgáltatást kell toostore hello megfelelő partíciónak az adatait és a szolgáltatás neve tooidentify hello megfelelő legfrissebb biztonsági mentési toorestore származó minden partíció esetében.</span><span class="sxs-lookup"><span data-stu-id="16fd5-196">Thus, hello service needs toostore hello appropriate partition information and service name tooidentify hello correct latest backup toorestore from for each partition.</span></span>

> [!NOTE]
> <span data-ttu-id="16fd5-197">Nem ajánlott toouse `FabricClient.ServiceManager.InvokeDataLossAsync` minden partíció toorestore hello teljes szolgáltatáson, mert, megsérülhet a fürt állapota.</span><span class="sxs-lookup"><span data-stu-id="16fd5-197">It is not recommended toouse `FabricClient.ServiceManager.InvokeDataLossAsync` on each partition toorestore hello entire service, since that may corrupt your cluster state.</span></span>
> 

## <a name="replication-of-corrupt-application-data"></a><span data-ttu-id="16fd5-198">A sérült alkalmazás adatainak replikálása</span><span class="sxs-lookup"><span data-stu-id="16fd5-198">Replication of corrupt application data</span></span>
<span data-ttu-id="16fd5-199">Ha újonnan telepített hello az alkalmazásfrissítés programhiba van, az adatok sérülése okozhatnak.</span><span class="sxs-lookup"><span data-stu-id="16fd5-199">If hello newly deployed application upgrade has a bug, that may cause corruption of data.</span></span> <span data-ttu-id="16fd5-200">Például az alkalmazásfrissítés előfordulhat, hogy elindítása tooupdate phone számú rekordot egy megbízható szótár érvénytelen területen kódot.</span><span class="sxs-lookup"><span data-stu-id="16fd5-200">For example, an application upgrade may start tooupdate every phone number record in a Reliable Dictionary with an invalid area code.</span></span>  <span data-ttu-id="16fd5-201">Ebben az esetben az érvénytelen telefonszámmal hello replikálja mivel a Service Fabric nem kompatibilis hello jellegű hello adatot tárol.</span><span class="sxs-lookup"><span data-stu-id="16fd5-201">In this case, hello invalid phone numbers will be replicated since Service Fabric is not aware of hello nature of hello data that is being stored.</span></span>

<span data-ttu-id="16fd5-202">hello először thing toodo után észlelni az ilyen egy súlyos hiba adatsérülést okozó toofreeze hello szolgáltatás hello alkalmazás szintjén, és ha lehetséges, a hello alkalmazás kódja nem rendelkező hello hiba toohello verziójának frissítése.</span><span class="sxs-lookup"><span data-stu-id="16fd5-202">hello first thing toodo after you detect such an egregious bug that causes data corruption is toofreeze hello service at hello application level and, if possible, upgrade toohello version of hello application code that does not have hello bug.</span></span>  <span data-ttu-id="16fd5-203">Hello szolgáltatást kód megszüntetése után is hello adatok továbbra is megsérült, és így az adatok esetleg toobe visszaállítva.</span><span class="sxs-lookup"><span data-stu-id="16fd5-203">However, even after hello service code is fixed, hello data may still be corrupt and thus data may need toobe restored.</span></span>  <span data-ttu-id="16fd5-204">Ebben az esetben nem lenne megfelelő toorestore hello legutóbbi biztonsági, mivel lehetséges, hogy hello legfrissebb biztonsági mentéseket is megsérült.</span><span class="sxs-lookup"><span data-stu-id="16fd5-204">In such cases, it may not be sufficient toorestore hello latest backup, since hello latest backups may also be corrupt.</span></span>  <span data-ttu-id="16fd5-205">Így lehetősége van toofind hello utolsó biztonsági mentés óta történt előtt hello adatokat kapott sérült.</span><span class="sxs-lookup"><span data-stu-id="16fd5-205">Thus, you have toofind hello last backup that was made before hello data got corrupted.</span></span>

<span data-ttu-id="16fd5-206">Ha nem biztos benne, hogy mely biztonsági mentések sérült, képes egy új Service Fabric-fürt központi telepítése és hello biztonsági másolatok hasonlóan a fenti "Törölt vagy elveszett szolgáltatás" hello érintett partíciók forgatókönyv.</span><span class="sxs-lookup"><span data-stu-id="16fd5-206">If you are not sure which backups are corrupt, you could deploy a new Service Fabric cluster and restore hello backups of affected partitions just like hello above "Deleted or lost service" scenario.</span></span>  <span data-ttu-id="16fd5-207">Minden partíció esetében hello biztonsági másolatok visszaállítása a hello legutóbbi toohello legalább elindításához.</span><span class="sxs-lookup"><span data-stu-id="16fd5-207">For each partition, start restoring hello backups from hello most recent toohello least.</span></span> <span data-ttu-id="16fd5-208">Miután megtalálta az olyan biztonsági mentésből nincs hello sérülése, áthelyezés vagy törlése az összes biztonsági mentés a partíció volt újabb (mint a biztonsági másolat).</span><span class="sxs-lookup"><span data-stu-id="16fd5-208">Once you find a backup that does not have hello corruption, move/delete all backups of this partition that were more recent (than that backup).</span></span> <span data-ttu-id="16fd5-209">Ismételje meg az eljárást minden partíció esetében.</span><span class="sxs-lookup"><span data-stu-id="16fd5-209">Repeat this process for each partition.</span></span> <span data-ttu-id="16fd5-210">Most, amikor `OnDataLossAsync` nevezik hello éles fürt hello partíción hello utolsó biztonsági mentés található hello külső tároló hello fent folyamat egyik kivételezett hello lesz.</span><span class="sxs-lookup"><span data-stu-id="16fd5-210">Now, when `OnDataLossAsync` is called on hello partition in hello production cluster, hello last backup found in hello external store will be hello one picked by hello above process.</span></span>

<span data-ttu-id="16fd5-211">Most, "Deleted vagy elveszett szolgáltatás" hello hello lépéseit szakasz lehet toorestore hello állapotának hello szolgáltatás toohello állapotának használt előtt hello buggy kód hello állapota sérült.</span><span class="sxs-lookup"><span data-stu-id="16fd5-211">Now, hello steps in hello "Deleted or lost service" section can be used toorestore hello state of hello service toohello state before hello buggy code corrupted hello state.</span></span>

<span data-ttu-id="16fd5-212">Vegye figyelembe:</span><span class="sxs-lookup"><span data-stu-id="16fd5-212">Note that:</span></span>

  - <span data-ttu-id="16fd5-213">Történő visszaállításához, folyamatban van egy esélyét, hogy a biztonsági mentés hello vissza nincs régebbi, mint hello partíció hello állapotát előtt hello adatok megszakadt.</span><span class="sxs-lookup"><span data-stu-id="16fd5-213">When you restore, there is a chance that hello backup being restored is older than hello state of hello partition before hello data was lost.</span></span> <span data-ttu-id="16fd5-214">Ebből kifolyólag állítsa vissza a legutóbbi megoldásként toorecover, csak adatmennyiség lehető.</span><span class="sxs-lookup"><span data-stu-id="16fd5-214">Because of this, you should restore only as a last resort toorecover as much data as possible.</span></span>
  - <span data-ttu-id="16fd5-215">hello biztonsági mentési mappa elérési útja jelölő karakterlánc hello és hello olyan biztonsági mentési hello mappában lévő fájlok elérési útjait lehet attól függően, hogy hello FabricDataRoot elérési útját és alkalmazástípus nevének hossza 255 karakternél.</span><span class="sxs-lookup"><span data-stu-id="16fd5-215">hello string that represents hello backup folder path and hello paths of files inside hello backup folder can be greater than 255 characters, depending on hello FabricDataRoot path and Application Type name's length.</span></span> <span data-ttu-id="16fd5-216">Emiatt néhány .NET módszerek, például `Directory.Move`, toothrow hello `PathTooLongException` kivétel.</span><span class="sxs-lookup"><span data-stu-id="16fd5-216">This can cause some .NET methods, like `Directory.Move`, toothrow hello `PathTooLongException` exception.</span></span> <span data-ttu-id="16fd5-217">Egy megoldás, toodirectly kernel32 API-k, például a hívás `CopyFile`.</span><span class="sxs-lookup"><span data-stu-id="16fd5-217">One workaround is toodirectly call kernel32 APIs, like `CopyFile`.</span></span>

## <a name="backup-and-restore-reliable-actors"></a><span data-ttu-id="16fd5-218">Biztonsági mentés és visszaállítás Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="16fd5-218">Backup and restore Reliable Actors</span></span>


<span data-ttu-id="16fd5-219">Megbízható szereplője keretrendszer Reliable Services épül.</span><span class="sxs-lookup"><span data-stu-id="16fd5-219">Reliable Actors Framework is built on top of Reliable Services.</span></span> <span data-ttu-id="16fd5-220">hello hello actor(s) futtató ActorService egy olyan állapot-nyilvántartó megbízható szolgáltatás.</span><span class="sxs-lookup"><span data-stu-id="16fd5-220">hello ActorService which hosts hello actor(s) is a stateful reliable service.</span></span> <span data-ttu-id="16fd5-221">Emiatt összes hello biztonsági mentési és visszaállítási funkció érhető el a Reliable Services is elérhető tooReliable szereplője (kivéve, amelyek adott állapotszolgáltató viselkedések).</span><span class="sxs-lookup"><span data-stu-id="16fd5-221">Hence, all hello backup and restore functionality available in Reliable Services is also available tooReliable Actors (except behaviors that are state provider specific).</span></span> <span data-ttu-id="16fd5-222">Mivel biztonsági mentések partíciónkénti alapon veszik, állapotai összes szereplő, hogy a partíció készül biztonsági másolat (visszaállítás hasonló, és partíciónkénti alapon történik).</span><span class="sxs-lookup"><span data-stu-id="16fd5-222">Since backups will be taken on a per-partition basis, states for all actors in that partition will be backed up (and restoration is similar and will happen on a per-partition basis).</span></span> <span data-ttu-id="16fd5-223">tooperform biztonsági mentés/visszaállítás, hello szolgáltatás tulajdonosa hozzon létre egy egyéni szereplő osztály, amely ActorService osztályból származik, és majd biztonsági mentés/visszaállítás hasonló tooReliable szolgáltatások korábbi szakaszokban a fent leírt módon.</span><span class="sxs-lookup"><span data-stu-id="16fd5-223">tooperform backup/restore, hello service owner should create a custom actor service class that derives from ActorService class and then do backup/restore similar tooReliable Services as described above in previous sections.</span></span>

```csharp
class MyCustomActorService : ActorService
{
     public MyCustomActorService(StatefulServiceContext context, ActorTypeInformation actorTypeInfo)
            : base(context, actorTypeInfo)
     {                  
     }
    
    //
   // Method overrides and other code.
    //
}
```

<span data-ttu-id="16fd5-224">Egyéni szereplő szolgáltatás osztályt hoz létre, meg kell, amely is tooregister hello szereplő regisztrálásakor.</span><span class="sxs-lookup"><span data-stu-id="16fd5-224">When you create a custom actor service class, you need tooregister that as well when registering hello actor.</span></span>

```csharp
ActorRuntime.RegisterActorAsync<MyActor>(
   (context, typeInfo) => new MyCustomActorService(context, typeInfo)).GetAwaiter().GetResult();
```

<span data-ttu-id="16fd5-225">hello alapértelmezett állapota szolgáltató Reliable Actors `KvsActorStateProvider`.</span><span class="sxs-lookup"><span data-stu-id="16fd5-225">hello default state provider for Reliable Actors is `KvsActorStateProvider`.</span></span> <span data-ttu-id="16fd5-226">Alapértelmezés szerint nincs engedélyezve a növekményes biztonsági mentés `KvsActorStateProvider`.</span><span class="sxs-lookup"><span data-stu-id="16fd5-226">Incremental backup is not enabled by default for `KvsActorStateProvider`.</span></span> <span data-ttu-id="16fd5-227">Engedélyezheti a növekményes biztonsági mentés létrehozásával `KvsActorStateProvider` hello megfelelő saját konstruktoraikban beállítása, majd átadja azt a tooActorService konstruktor, ahogy az alábbi kódrészletet:</span><span class="sxs-lookup"><span data-stu-id="16fd5-227">You can enable incremental backup by creating `KvsActorStateProvider` with hello appropriate setting in its constructor and then passing it tooActorService constructor as shown in following code snippet:</span></span>

```csharp
class MyCustomActorService : ActorService
{
     public MyCustomActorService(StatefulServiceContext context, ActorTypeInformation actorTypeInfo)
            : base(context, actorTypeInfo, null, null, new KvsActorStateProvider(true)) // Enable incremental backup
     {                  
     }
    
    //
   // Method overrides and other code.
    //
}
```

<span data-ttu-id="16fd5-228">A növekményes biztonsági mentés engedélyezése után egy növekményes biztonsági másolat FabricMissingFullBackupException a következő okok valamelyike miatt meghiúsulhat, és mielőtt kilépteti a növekményes biztonsági mentését vagy mentéseit tootake teljes biztonsági mentést kell:</span><span class="sxs-lookup"><span data-stu-id="16fd5-228">After incremental backup has been enabled, taking an incremental backup can fail with FabricMissingFullBackupException for one of following reasons and you will need tootake a full backup before taking incremental backup(s):</span></span>

  - <span data-ttu-id="16fd5-229">hello replika soha nem tartott egy teljes biztonsági mentés óta elsődleges vált.</span><span class="sxs-lookup"><span data-stu-id="16fd5-229">hello replica has never taken a full backup since it became primary.</span></span>
  - <span data-ttu-id="16fd5-230">Néhány hello naplórekordokat csonkultak óta utolsó biztonsági mentés készült.</span><span class="sxs-lookup"><span data-stu-id="16fd5-230">Some of hello log records were truncated since last backup was taken.</span></span>

<span data-ttu-id="16fd5-231">Ha engedélyezve van a növekményes biztonsági mentést, `KvsActorStateProvider` körkörös puffer toomanage a naplót rögzíti, és rendszeres időközönként csonkolja azt nem használja.</span><span class="sxs-lookup"><span data-stu-id="16fd5-231">When incremental backup is enabled, `KvsActorStateProvider` does not use circular buffer toomanage its log records and periodically truncates it.</span></span> <span data-ttu-id="16fd5-232">Biztonsági mentés nélküli felhasználó 45 percig történik, ha a hello rendszer automatikusan levágja hello naplórekordokat.</span><span class="sxs-lookup"><span data-stu-id="16fd5-232">If no backup is taken by user for a period of 45 minutes, hello system automatically truncates hello log records.</span></span> <span data-ttu-id="16fd5-233">Ez az időtartam alatt konfigurálható megadásával `logTrunctationIntervalInMinutes` a `KvsActorStateProvider` konstruktor (hasonló toowhen növekményes biztonsági mentés engedélyezése).</span><span class="sxs-lookup"><span data-stu-id="16fd5-233">This interval can be configured by specifying `logTrunctationIntervalInMinutes` in `KvsActorStateProvider` constructor (similar toowhen enabling incremental backup).</span></span> <span data-ttu-id="16fd5-234">hello naplórekordokat is beolvasása csonkolva lesz, ha elsődleges replikán kell toobuild replikává úgy, hogy az összes adatot küld.</span><span class="sxs-lookup"><span data-stu-id="16fd5-234">hello log records may also get truncated if primary replica need toobuild another replica by sending all its data.</span></span>

<span data-ttu-id="16fd5-235">A biztonsági mentési láncolatát, hasonló tooReliable szolgáltatások való visszaállítása során hello BackupFolderPath tartalmaznia kell az egyik alkönyvtár tartalmazó teljes biztonsági mentés, míg mások növekményes biztonsági mentését vagy mentéseit tartalmazó alkönyvtárakat alkönyvtárak.</span><span class="sxs-lookup"><span data-stu-id="16fd5-235">When doing restore from a backup chain, similar tooReliable Services, hello BackupFolderPath should contain subdirectories with one subdirectory containing full backup and others subdirectories containing incremental backup(s).</span></span> <span data-ttu-id="16fd5-236">hello visszaállítási API kivételhibát FabricException megfelelő hibaüzenet Ha hello biztonsági mentési tanúsítványlánc érvényesítése sikertelen.</span><span class="sxs-lookup"><span data-stu-id="16fd5-236">hello restore API will throw FabricException with appropriate error message if hello backup chain validation fails.</span></span> 

> [!NOTE]
> <span data-ttu-id="16fd5-237">`KvsActorStateProvider`jelenleg figyelmen kívül hagyja a RestorePolicy.Safe hello lehetőséget.</span><span class="sxs-lookup"><span data-stu-id="16fd5-237">`KvsActorStateProvider` currently ignores hello option RestorePolicy.Safe.</span></span> <span data-ttu-id="16fd5-238">Ez a szolgáltatás támogatása tervezett egy jövőbeli verzióban.</span><span class="sxs-lookup"><span data-stu-id="16fd5-238">Support for this feature is planned in an upcoming release.</span></span>
> 

## <a name="testing-backup-and-restore"></a><span data-ttu-id="16fd5-239">Tesztelési biztonsági mentése és visszaállítása</span><span class="sxs-lookup"><span data-stu-id="16fd5-239">Testing Backup and Restore</span></span>
<span data-ttu-id="16fd5-240">Kritikus fontosságú adatok biztonsági mentése van folyamatban, amely visszaállíthatóak fontos tooensure.</span><span class="sxs-lookup"><span data-stu-id="16fd5-240">It is important tooensure that critical data is being backed up, and can be restored from.</span></span> <span data-ttu-id="16fd5-241">Ezt megteheti hello figyelőn `Start-ServiceFabricPartitionDataLoss` parancsmag a PowerShellben, amely egy adott partíció tootest adatvesztés lehet szükség, hogy hello adatok biztonsági mentése és visszaállítása funkciót az a szolgáltatás a várt módon működik.</span><span class="sxs-lookup"><span data-stu-id="16fd5-241">This can be done by invoking hello `Start-ServiceFabricPartitionDataLoss` cmdlet in PowerShell that can induce data loss in a particular partition tootest whether hello data backup and restore functionality for your service is working as expected.</span></span>  <span data-ttu-id="16fd5-242">Az is lehetséges tooprogrammatically adatvesztés el, és szeretné visszaállítani, valamint az, hogy az esemény.</span><span class="sxs-lookup"><span data-stu-id="16fd5-242">It is also possible tooprogrammatically invoke data loss and restore from that event as well.</span></span>

> [!NOTE]
> <span data-ttu-id="16fd5-243">Keresse meg a biztonsági mentés minta végrehajtásának, és működőképes állapotba hozni a hello webalkalmazás hivatkozás a Githubon.</span><span class="sxs-lookup"><span data-stu-id="16fd5-243">You can find a sample implementation of backup and restore functionality in hello Web Reference App on GitHub.</span></span> <span data-ttu-id="16fd5-244">Tekintse meg hello `Inventory.Service` szolgáltatás további részleteket.</span><span class="sxs-lookup"><span data-stu-id="16fd5-244">Please look at hello `Inventory.Service` service for more details.</span></span>
> 
> 

## <a name="under-hello-hood-more-details-on-backup-and-restore"></a><span data-ttu-id="16fd5-245">A hello technikai részletek: további részleteket a biztonsági mentés és helyreállítás</span><span class="sxs-lookup"><span data-stu-id="16fd5-245">Under hello hood: more details on backup and restore</span></span>
<span data-ttu-id="16fd5-246">Íme, néhány további részleteket a biztonsági mentését és helyreállítását.</span><span class="sxs-lookup"><span data-stu-id="16fd5-246">Here's some more details on backup and restore.</span></span>

### <a name="backup"></a><span data-ttu-id="16fd5-247">Biztonsági mentés</span><span class="sxs-lookup"><span data-stu-id="16fd5-247">Backup</span></span>
<span data-ttu-id="16fd5-248">hello megbízható állapotkezelője hello képességét toocreate konzisztens biztonsági mentések tiltása nélkül olvasási / írási műveleteket biztosít.</span><span class="sxs-lookup"><span data-stu-id="16fd5-248">hello Reliable State Manager provides hello ability toocreate consistent backups without blocking any read or write operations.</span></span> <span data-ttu-id="16fd5-249">toodo úgy, hogy használja egy ellenőrzőpont- és naplófájlok mechanizmus.</span><span class="sxs-lookup"><span data-stu-id="16fd5-249">toodo so, it utilizes a checkpoint and log persistence mechanism.</span></span>  <span data-ttu-id="16fd5-250">hello megbízható állapotkezelője zavaros (lightweight) ad hozzá ellenőrzőpontokat egyes pontok toorelieve nyomás hello tranzakciós naplóból vesz igénybe, és növeli a helyreállításra.</span><span class="sxs-lookup"><span data-stu-id="16fd5-250">hello Reliable State Manager takes fuzzy (lightweight) checkpoints at certain points toorelieve pressure from hello transactional log and improve recovery times.</span></span>  <span data-ttu-id="16fd5-251">Amikor `BackupAsync` nevezik, megbízható állapotkezelője hello arra utasítja az összes megbízható objektumok toocopy a legújabb ellenőrzőpont fájlok tooa helyi biztonsági mentés mappájába.</span><span class="sxs-lookup"><span data-stu-id="16fd5-251">When `BackupAsync` is called, hello Reliable State Manager instructs all Reliable objects toocopy their latest checkpoint files tooa local backup folder.</span></span>  <span data-ttu-id="16fd5-252">Hello megbízható állapotkezelője, majd minden naplórekordok hello "mutató start" toohello legújabb naplóbejegyzés kiindulva hello biztonsági mentési mappába másolja.</span><span class="sxs-lookup"><span data-stu-id="16fd5-252">Then, hello Reliable State Manager copies all log records, starting from hello "start pointer" toohello latest log record into hello backup folder.</span></span>  <span data-ttu-id="16fd5-253">Hello biztonsági mentés szereplő összes hello napló rekordok toohello legújabb naplórekord fel, és megbízható állapotkezelője hello írási előre naplózási megőrzi, hello megbízható állapotkezelője biztosítja, hogy az, hogy minden tranzakciók, amelyek véglegesített (`CommitAsync` adott vissza sikeresen) szerepelnek hello biztonsági mentés.</span><span class="sxs-lookup"><span data-stu-id="16fd5-253">Since all hello log records up toohello latest log record are included in hello backup and hello Reliable State Manager preserves write-ahead logging, hello Reliable State Manager guarantees that all transactions that are committed (`CommitAsync` has returned successfully) are included in hello backup.</span></span>

<span data-ttu-id="16fd5-254">Bármely tranzakció, amely véglegesíti után `BackupAsync` előfordulhat, hogy hívása történt, vagy nem hello biztonsági mentése.</span><span class="sxs-lookup"><span data-stu-id="16fd5-254">Any transaction that commits after `BackupAsync` has been called may or may not be in hello backup.</span></span>  <span data-ttu-id="16fd5-255">Miután hello helyi biztonsági mentési mappája töltöttek hello platform (azaz, helyi biztonsági másolat elkészült hello futtatókörnyezet), hello szolgáltatás biztonsági mentési visszahívási hívják.</span><span class="sxs-lookup"><span data-stu-id="16fd5-255">Once hello local backup folder has been populated by hello platform (i.e., local backup is completed by hello runtime), hello service's backup callback is invoked.</span></span>  <span data-ttu-id="16fd5-256">A visszahívási hello biztonsági mentési mappája tooan külső helyre például az Azure Storage áthelyezése felelős.</span><span class="sxs-lookup"><span data-stu-id="16fd5-256">This callback is responsible for moving hello backup folder tooan external location such as Azure Storage.</span></span>

### <a name="restore"></a><span data-ttu-id="16fd5-257">Visszaállítás</span><span class="sxs-lookup"><span data-stu-id="16fd5-257">Restore</span></span>
<span data-ttu-id="16fd5-258">hello használatával hello megbízható állapotkezelője nyújt az olyan biztonsági hello képességét toorestore `RestoreAsync` API.</span><span class="sxs-lookup"><span data-stu-id="16fd5-258">hello Reliable State Manager provides hello ability toorestore from a backup by using hello `RestoreAsync` API.</span></span>  
<span data-ttu-id="16fd5-259">Hello `RestoreAsync` metódusa `RestoreContext` csak belül hello hívható `OnDataLossAsync` metódust.</span><span class="sxs-lookup"><span data-stu-id="16fd5-259">hello `RestoreAsync` method on `RestoreContext` can be called only inside hello `OnDataLossAsync` method.</span></span>
<span data-ttu-id="16fd5-260">logikai érték által visszaadott hello `OnDataLossAsync` azt jelzi, hogy hello szolgáltatás visszaállítva-e külső forrásból állapotában.</span><span class="sxs-lookup"><span data-stu-id="16fd5-260">hello bool returned by `OnDataLossAsync` indicates whether hello service restored its state from an external source.</span></span>
<span data-ttu-id="16fd5-261">Ha hello `OnDataLossAsync` igaz értéket ad vissza, a Service Fabric újra létrehozza az összes többi replikáit az elsődleges.</span><span class="sxs-lookup"><span data-stu-id="16fd5-261">If hello `OnDataLossAsync` returns true, Service Fabric will rebuild all other replicas from this primary.</span></span> <span data-ttu-id="16fd5-262">A Service Fabric biztosítja, hogy fogadó replikák `OnDataLossAsync` elsődleges szerepkör első átmenet toohello hívja, de vannak nem rendelkeznek állapot írási vagy olvasási állapota.</span><span class="sxs-lookup"><span data-stu-id="16fd5-262">Service Fabric ensures that replicas that will receive `OnDataLossAsync` call first transition toohello primary role but are not granted read status or write status.</span></span>
<span data-ttu-id="16fd5-263">Ez azt jelenti, hogy a StatefulService implementers `RunAsync` nem lesz meghívva, amíg `OnDataLossAsync` futtatása sikeresen befejeződött.</span><span class="sxs-lookup"><span data-stu-id="16fd5-263">This implies that for StatefulService implementers, `RunAsync` will not be called until `OnDataLossAsync` finishes successfully.</span></span>
<span data-ttu-id="16fd5-264">Ezt követően `OnDataLossAsync` hello új elsődleges fogja meghívni.</span><span class="sxs-lookup"><span data-stu-id="16fd5-264">Then, `OnDataLossAsync` will be invoked on hello new primary.</span></span>
<span data-ttu-id="16fd5-265">Mindaddig, amíg a szolgáltatás teszi teljessé az API sikeresen (ad vissza IGAZ vagy hamis), és végül hello vonatkozó újrakonfigurálás, hello API fog tartani meghívott egyenként.</span><span class="sxs-lookup"><span data-stu-id="16fd5-265">Until a service completes this API successfully (by returning true or false) and finishes hello relevant reconfiguration, hello API will keep being called one at a time.</span></span>

<span data-ttu-id="16fd5-266">`RestoreAsync`először elutasítja azokat az összes meglévő állapot hello elsődleges replika lett meghívva.</span><span class="sxs-lookup"><span data-stu-id="16fd5-266">`RestoreAsync` first drops all existing state in hello primary replica that it was called on.</span></span>  
<span data-ttu-id="16fd5-267">Hello megbízható állapotkezelője majd hello biztonsági mentési mappája szereplő összes megbízható hello-objektumokat hoz létre.</span><span class="sxs-lookup"><span data-stu-id="16fd5-267">Then hello Reliable State Manager creates all hello Reliable objects that exist in hello backup folder.</span></span>  
<span data-ttu-id="16fd5-268">A következő hello megbízható objektum utasításai toorestore a biztonsági mentési mappája hello az ellenőrzőpontokat.</span><span class="sxs-lookup"><span data-stu-id="16fd5-268">Next, hello Reliable objects are instructed toorestore from their checkpoints in hello backup folder.</span></span>  
<span data-ttu-id="16fd5-269">Végül hello megbízható állapotkezelője saját állapot helyreállít a hello naplórekordok hello biztonsági mentési mappában, és helyreállítást hajt végre.</span><span class="sxs-lookup"><span data-stu-id="16fd5-269">Finally, hello Reliable State Manager recovers its own state from hello log records in hello backup folder and performs recovery.</span></span>  
<span data-ttu-id="16fd5-270">Hello helyreállítási folyamat részeként ponttól hello "kezdő" hello biztonsági mentési mappája véglegesítési naplórekordokat rendelkezik olyan megismételt toohello megbízható objektumok.</span><span class="sxs-lookup"><span data-stu-id="16fd5-270">As part of hello recovery process, operations starting from hello "starting point" that have commit log records in hello backup folder are replayed toohello Reliable objects.</span></span>  
<span data-ttu-id="16fd5-271">Ez a lépés biztosítja, hogy hello helyreállított állapot.</span><span class="sxs-lookup"><span data-stu-id="16fd5-271">This step ensures that hello recovered state is consistent.</span></span>

## <a name="next-steps"></a><span data-ttu-id="16fd5-272">Következő lépések</span><span class="sxs-lookup"><span data-stu-id="16fd5-272">Next steps</span></span>
  - [<span data-ttu-id="16fd5-273">Reliable Collections</span><span class="sxs-lookup"><span data-stu-id="16fd5-273">Reliable Collections</span></span>](service-fabric-work-with-reliable-collections.md)
  - [<span data-ttu-id="16fd5-274">Megbízható szolgáltatások – első lépések</span><span class="sxs-lookup"><span data-stu-id="16fd5-274">Reliable Services quick start</span></span>](service-fabric-reliable-services-quick-start.md)
  - [<span data-ttu-id="16fd5-275">Megbízható szolgáltatások értesítések</span><span class="sxs-lookup"><span data-stu-id="16fd5-275">Reliable Services notifications</span></span>](service-fabric-reliable-services-notifications.md)
  - [<span data-ttu-id="16fd5-276">Megbízható konfigurálása</span><span class="sxs-lookup"><span data-stu-id="16fd5-276">Reliable Services configuration</span></span>](service-fabric-reliable-services-configuration.md)
  - [<span data-ttu-id="16fd5-277">Fejlesztői leírás megbízható gyűjtemények</span><span class="sxs-lookup"><span data-stu-id="16fd5-277">Developer reference for Reliable Collections</span></span>](https://msdn.microsoft.com/library/azure/microsoft.servicefabric.data.collections.aspx)

