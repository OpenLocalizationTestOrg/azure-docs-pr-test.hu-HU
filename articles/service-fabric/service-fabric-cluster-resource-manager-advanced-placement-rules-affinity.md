---
title: "Service Fabric fürt erőforrás-kezelő - affinitás |} Microsoft Docs"
description: "A Service Fabric szolgáltatások kapcsolat konfigurálása – áttekintés"
services: service-fabric
documentationcenter: .net
author: masnider
manager: timlt
editor: 
ms.assetid: 678073e1-d08d-46c4-a811-826e70aba6c4
ms.service: Service-Fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 08/18/2017
ms.author: masnider
ms.openlocfilehash: 3efda4ee4016245668e5da431d7b8868a21c790e
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 08/18/2017
---
# <a name="configuring-and-using-service-affinity-in-service-fabric"></a><span data-ttu-id="48ace-103">Konfigurálásával és a Service Fabric szolgáltatás affinitás használatával</span><span class="sxs-lookup"><span data-stu-id="48ace-103">Configuring and using service affinity in Service Fabric</span></span>
<span data-ttu-id="48ace-104">Kapcsolat az biztosított főként a vezérlőelem megkönnyítik az átmenet nagyobb egységes alkalmazások be a felhő- és mikroszolgáltatások világ segítségével.</span><span class="sxs-lookup"><span data-stu-id="48ace-104">Affinity is a control that is provided mainly to help ease the transition of larger monolithic applications into the cloud and microservices world.</span></span> <span data-ttu-id="48ace-105">Azt is szolgál az optimalizálás szolgáltatások teljesítményének növelése, így bár mellékhatásokkal is.</span><span class="sxs-lookup"><span data-stu-id="48ace-105">It is also used as an optimization for improving the performance of services, although doing so can have side effects.</span></span>

<span data-ttu-id="48ace-106">Tegyük fel, most gépidőt, egy nagyobb alkalmazást, vagy olyat, amely nem csupán kialakítása során vegye figyelembe, hogy a Service Fabric mikroszolgáltatások (vagy bármely elosztott környezetben).</span><span class="sxs-lookup"><span data-stu-id="48ace-106">Let’s say you’re bringing a larger app, or one that just wasn’t designed with microservices in mind, to Service Fabric (or any distributed environment).</span></span> <span data-ttu-id="48ace-107">Ez a átviteli típus általános.</span><span class="sxs-lookup"><span data-stu-id="48ace-107">This type of transition is common.</span></span> <span data-ttu-id="48ace-108">Indítsa el a teljes alkalmazás feloldása a környezetbe, csomagolás, valamint annak biztosítása, hogy zökkenőmentesen fut.</span><span class="sxs-lookup"><span data-stu-id="48ace-108">You start by lifting the entire app into the environment, packaging it, and making sure it is running smoothly.</span></span> <span data-ttu-id="48ace-109">Majd megkezdése ossza fel különböző kisebb szolgáltatásokat, hogy az összes kommunikálni egymással.</span><span class="sxs-lookup"><span data-stu-id="48ace-109">Then you start breaking it down into different smaller services that all talk to each other.</span></span>

<span data-ttu-id="48ace-110">Végül azt tapasztalhatja, hogy az alkalmazás egyes hibákat észlelt.</span><span class="sxs-lookup"><span data-stu-id="48ace-110">Eventually you may find that the application is experiencing some issues.</span></span> <span data-ttu-id="48ace-111">A problémák általában egyikébe ezen kategóriák:</span><span class="sxs-lookup"><span data-stu-id="48ace-111">The issues usually fall into one of these categories:</span></span>

1. <span data-ttu-id="48ace-112">Néhány összetevőt X az egységes alkalmazásban volt egy nem dokumentált függőség összetevő Y, és az összetevőket külön szolgáltatás csak kapcsolva.</span><span class="sxs-lookup"><span data-stu-id="48ace-112">Some component X in the monolithic app had an undocumented dependency on component Y, and you just turned those components into separate services.</span></span> <span data-ttu-id="48ace-113">Mivel ezek a szolgáltatások a fürt különböző csomópontokon futnak, fontosságúak megszakadt.</span><span class="sxs-lookup"><span data-stu-id="48ace-113">Since these services are now running on different nodes in the cluster, they're broken.</span></span>
2. <span data-ttu-id="48ace-114">Ezek az összetevők kommunikációra keresztül (nevesített csövek helyi |} megosztott memória |} lemezen tárolt fájlok) és azok valóban képesnek kell lenniük a teljesítményre vonatkozó megfontolásból megosztott helyi erőforrás most írni.</span><span class="sxs-lookup"><span data-stu-id="48ace-114">These components communicate via (local named pipes | shared memory | files on disk) and they really need to be able to write to a shared local resource for performance reasons right now.</span></span> <span data-ttu-id="48ace-115">Rögzített függőséget is törlődik, talán.</span><span class="sxs-lookup"><span data-stu-id="48ace-115">That hard dependency gets removed later, maybe.</span></span>
3. <span data-ttu-id="48ace-116">Minden megfelelően működik, de azt elemről kiderül, hogy, hogy a két összetevő-e a ténylegesen chatty/teljesítmény-és nagybetűket.</span><span class="sxs-lookup"><span data-stu-id="48ace-116">Everything is fine, but it turns out that these two components are actually chatty/performance sensitive.</span></span> <span data-ttu-id="48ace-117">Ha azok áthelyezi őket szolgáltatások külön teljes tanked az alkalmazások teljesítményének és késést növelni.</span><span class="sxs-lookup"><span data-stu-id="48ace-117">When they moved them into separate services overall application performance tanked or latency increased.</span></span> <span data-ttu-id="48ace-118">Emiatt az alkalmazás általános nem teljesíti elvárásainak.</span><span class="sxs-lookup"><span data-stu-id="48ace-118">As a result, the overall application is not meeting expectations.</span></span>

<span data-ttu-id="48ace-119">Ebben az esetben azt szeretne tartani az újrabontási munka, és nem szeretné, ha vissza kíván térni a monolit.</span><span class="sxs-lookup"><span data-stu-id="48ace-119">In these cases, we don’t want to lose our refactoring work, and don’t want to go back to the monolith.</span></span> <span data-ttu-id="48ace-120">Az utolsó feltétel lehet egy egyszerű optimalizálás kívánatos.</span><span class="sxs-lookup"><span data-stu-id="48ace-120">The last condition may even be desirable as a plain optimization.</span></span> <span data-ttu-id="48ace-121">Azonban amíg azt lehet átalakítani az összetevők működéséhez természetes szolgáltatásként (vagy igazolnia megoldható a teljesítményre vonatkozó elvárásokat bármilyen más módon) lesz, bizonyos értelemben helység kell.</span><span class="sxs-lookup"><span data-stu-id="48ace-121">However, until we can redesign the components to work naturally as services (or until we can solve the performance expectations some other way) we're going to need some sense of locality.</span></span>

<span data-ttu-id="48ace-122">Mi a teendő ilyenkor?</span><span class="sxs-lookup"><span data-stu-id="48ace-122">What to do?</span></span> <span data-ttu-id="48ace-123">Jól próbálkozzon affinitás bekapcsolásával.</span><span class="sxs-lookup"><span data-stu-id="48ace-123">Well, you could try turning on affinity.</span></span>

## <a name="how-to-configure-affinity"></a><span data-ttu-id="48ace-124">Kapcsolat konfigurálása</span><span class="sxs-lookup"><span data-stu-id="48ace-124">How to configure affinity</span></span>
<span data-ttu-id="48ace-125">Kapcsolat beállításához adja meg egy két különböző szolgáltatások közötti kapcsolat.</span><span class="sxs-lookup"><span data-stu-id="48ace-125">To set up affinity, you define an affinity relationship between two different services.</span></span> <span data-ttu-id="48ace-126">Az eltolásokat tekintheti affinitás "mutató" egy szolgáltatás más, valamint arról, hogy "csak fut, ahol, hogy fut-e a szolgáltatás."</span><span class="sxs-lookup"><span data-stu-id="48ace-126">You can think of affinity as “pointing” one service at another and saying “This service can only run where that service is running.”</span></span> <span data-ttu-id="48ace-127">Egyes esetekben affinitás lesz az (ahol, mutasson a gyermek a szülő) szülő-gyermek kapcsolat.</span><span class="sxs-lookup"><span data-stu-id="48ace-127">Sometimes we refer to affinity as a parent/child relationship (where you point the child at the parent).</span></span> <span data-ttu-id="48ace-128">Affinitás biztosítja, hogy a replikák és a szolgáltatás egy példánya kerülnek, mint egy másik szolgáltatás ugyanazon csomópontok.</span><span class="sxs-lookup"><span data-stu-id="48ace-128">Affinity ensures that the replicas or instances of one service are placed on the same nodes as those of another service.</span></span>

```csharp
ServiceCorrelationDescription affinityDescription = new ServiceCorrelationDescription();
affinityDescription.Scheme = ServiceCorrelationScheme.Affinity;
affinityDescription.ServiceName = new Uri("fabric:/otherApplication/parentService");
serviceDescription.Correlations.Add(affinityDescription);
await fabricClient.ServiceManager.CreateServiceAsync(serviceDescription);
```

> [!NOTE]
> <span data-ttu-id="48ace-129">Egy alárendelt szolgáltatás csak egyetlen kapcsolat vehet részt.</span><span class="sxs-lookup"><span data-stu-id="48ace-129">A child service can only participate in a single affinity relationship.</span></span> <span data-ttu-id="48ace-130">Ha a gyermek rendelhetők affinitás alapján két szülő szolgáltatások egyszerre néhány lehetőség közül választhat:</span><span class="sxs-lookup"><span data-stu-id="48ace-130">If you wanted the child to be affinitized to two parent services at once you have a couple options:</span></span>
> - <span data-ttu-id="48ace-131">A kapcsolatok fordított (parentService1 és az aktuális gyermek szolgáltatási pont parentService2 rendelkeznek), vagy</span><span class="sxs-lookup"><span data-stu-id="48ace-131">Reverse the relationships (have parentService1 and parentService2 point at the current child service), or</span></span>
> - <span data-ttu-id="48ace-132">Konvenció hubot kijelölni a szülő egyikét, és mutasson, hogy a szolgáltatás minden szolgáltatás van.</span><span class="sxs-lookup"><span data-stu-id="48ace-132">Designate one of the parents as a hub by convention and have all services point at that service.</span></span> 
>
> <span data-ttu-id="48ace-133">A fürt elhelyezési viselkedésről azonosnak kell lennie.</span><span class="sxs-lookup"><span data-stu-id="48ace-133">The resulting placement behavior in the cluster should be the same.</span></span>
>

## <a name="different-affinity-options"></a><span data-ttu-id="48ace-134">Másik kapcsolat beállításai</span><span class="sxs-lookup"><span data-stu-id="48ace-134">Different affinity options</span></span>
<span data-ttu-id="48ace-135">Kapcsolat több korrelációs rendszer keresztül képviseli, és két különböző módja van.</span><span class="sxs-lookup"><span data-stu-id="48ace-135">Affinity is represented via one of several correlation schemes, and has two different modes.</span></span> <span data-ttu-id="48ace-136">A kapcsolat a leggyakoribb módja a úgynevezett NonAlignedAffinity.</span><span class="sxs-lookup"><span data-stu-id="48ace-136">The most common mode of affinity is what we call NonAlignedAffinity.</span></span> <span data-ttu-id="48ace-137">NonAlignedAffinity a replikák és a különböző szolgáltatáspéldánynak ugyanazon a csomóponton elhelyezni.</span><span class="sxs-lookup"><span data-stu-id="48ace-137">In NonAlignedAffinity, the replicas or instances of the different services are placed on the same nodes.</span></span> <span data-ttu-id="48ace-138">A más módja AlignedAffinity.</span><span class="sxs-lookup"><span data-stu-id="48ace-138">The other mode is AlignedAffinity.</span></span> <span data-ttu-id="48ace-139">Igazított affinitás akkor hasznos, csak a állapotalapú szolgáltatás.</span><span class="sxs-lookup"><span data-stu-id="48ace-139">Aligned Affinity is useful only with stateful services.</span></span> <span data-ttu-id="48ace-140">Van igazítva a kapcsolat a két állapotalapú szolgáltatások konfigurálása biztosítja, hogy a szolgáltatások eredményezi kerülnek-e egymással a azonos csomópontokon.</span><span class="sxs-lookup"><span data-stu-id="48ace-140">Configuring two stateful services to have aligned affinity ensures that the primaries of those services are placed on the same nodes as each other.</span></span> <span data-ttu-id="48ace-141">Több másodlagos adatbázist, az ezekbe a szolgáltatásokba, az ugyanazon a csomóponton kell elhelyezni minden párt is okoz.</span><span class="sxs-lookup"><span data-stu-id="48ace-141">It also causes each pair of secondaries for those services to be placed on the same nodes.</span></span> <span data-ttu-id="48ace-142">Lehetőség arra is (bár a kevésbé közös) NonAlignedAffinity állapotalapú szolgáltatások konfigurálásához.</span><span class="sxs-lookup"><span data-stu-id="48ace-142">It is also possible (though less common) to configure NonAlignedAffinity for stateful services.</span></span> <span data-ttu-id="48ace-143">NonAlignedAffinity a két állapotalapú szolgáltatások különböző replikáinak futna ugyanazon a csomóponton, de az elsődleges különböző csomópontokon sikerült befejezéséhez.</span><span class="sxs-lookup"><span data-stu-id="48ace-143">For NonAlignedAffinity, the different replicas of the two stateful services would run on the same nodes, but their primaries could end up on different nodes.</span></span>

<span data-ttu-id="48ace-144"><center>
![Kapcsolat módok és azok által okozott hatások][Image1]
</center></span><span class="sxs-lookup"><span data-stu-id="48ace-144"><center>
![Affinity Modes and Their Effects][Image1]
</center></span></span>

### <a name="best-effort-desired-state"></a><span data-ttu-id="48ace-145">Szükséges elérhető legjobb állapota</span><span class="sxs-lookup"><span data-stu-id="48ace-145">Best effort desired state</span></span>
<span data-ttu-id="48ace-146">Egy kapcsolat a lehető legkedvezőbb módon.</span><span class="sxs-lookup"><span data-stu-id="48ace-146">An affinity relationship is best effort.</span></span> <span data-ttu-id="48ace-147">Nem biztosít közös elhelyezés vagy megbízhatóságát, hogy a futó megegyezik a folyamat végrehajtható nem azonos garanciát.</span><span class="sxs-lookup"><span data-stu-id="48ace-147">It does not provide the same guarantees of collocation or reliability that running in the same executable process does.</span></span> <span data-ttu-id="48ace-148">Egy kapcsolat a szolgáltatások sikertelen lehet, és egymástól függetlenül helyezhető alapvetően különböző entitások.</span><span class="sxs-lookup"><span data-stu-id="48ace-148">The services in an affinity relationship are fundamentally different entities that can fail and be moved independently.</span></span> <span data-ttu-id="48ace-149">Egy kapcsolat is érvénytelenítheti, bár ezeket ideiglenes.</span><span class="sxs-lookup"><span data-stu-id="48ace-149">An affinity relationship could also break, though these breaks are temporary.</span></span> <span data-ttu-id="48ace-150">Például kapacitás korlátozások jelentheti, hogy a szolgáltatás objektumokat a kapcsolat némelyike csak egy adott csomópont kiférjen.</span><span class="sxs-lookup"><span data-stu-id="48ace-150">For example, capacity limitations may mean that only some of the service objects in the affinity relationship can fit on a given node.</span></span> <span data-ttu-id="48ace-151">Ezekben az esetekben annak ellenére, hogy egy kapcsolat van érvényben, akkor nem kényszeríthető a más korlátok miatt.</span><span class="sxs-lookup"><span data-stu-id="48ace-151">In these cases even though there's an affinity relationship in place, it can't be enforced due to the other constraints.</span></span> <span data-ttu-id="48ace-152">Ha lehetséges, a megsértése automatikusan kijavításáig később.</span><span class="sxs-lookup"><span data-stu-id="48ace-152">If it is possible to do so, the violation is automatically corrected later.</span></span>

### <a name="chains-vs-stars"></a><span data-ttu-id="48ace-153">Csillag és láncok</span><span class="sxs-lookup"><span data-stu-id="48ace-153">Chains vs. stars</span></span>
<span data-ttu-id="48ace-154">Ma a fürt erőforrás-kezelő nem tudta modell láncok affinitás kapcsolatok.</span><span class="sxs-lookup"><span data-stu-id="48ace-154">Today the Cluster Resource Manager isn't able to model chains of affinity relationships.</span></span> <span data-ttu-id="48ace-155">Ez azt jelenti, hogy egy szolgáltatás, amely egy kapcsolat a gyermek nem lehet szülője egy másik kapcsolat.</span><span class="sxs-lookup"><span data-stu-id="48ace-155">What this means is that a service that is a child in one affinity relationship can’t be a parent in another affinity relationship.</span></span> <span data-ttu-id="48ace-156">Ha azt szeretné, a következő modellre: a kapcsolat típusát, hatékonyan csillag, nem pedig a lánc a modell rendelkezik.</span><span class="sxs-lookup"><span data-stu-id="48ace-156">If you want to model this type of relationship, you effectively have to model it as a star, rather than a chain.</span></span> <span data-ttu-id="48ace-157">Áthelyezése egy csillag, a legalsó gyermek volna szülőjének megadni az első gyermek szülő helyette.</span><span class="sxs-lookup"><span data-stu-id="48ace-157">To move from a chain to a star, the bottommost child would be parented to the first child’s parent instead.</span></span> <span data-ttu-id="48ace-158">Attól függően, hogy a szolgáltatások elrendezésének előfordulhat, hogy ezt többször elvégzéséhez.</span><span class="sxs-lookup"><span data-stu-id="48ace-158">Depending on the arrangement of your services, you may have to do this multiple times.</span></span> <span data-ttu-id="48ace-159">Ha nincs természetes szülő szolgáltatás, előfordulhat, szeretne létrehozni egyet, amely helyőrzőként szolgál.</span><span class="sxs-lookup"><span data-stu-id="48ace-159">If there's no natural parent service, you may have to create one that serves as a placeholder.</span></span> <span data-ttu-id="48ace-160">A követelményeitől függően előfordulhat, hogy szeretné megismerhetők [alkalmazáscsoportok](service-fabric-cluster-resource-manager-application-groups.md).</span><span class="sxs-lookup"><span data-stu-id="48ace-160">Depending on your requirements, you may also want to look into [Application Groups](service-fabric-cluster-resource-manager-application-groups.md).</span></span>

<span data-ttu-id="48ace-161"><center>
![Láncok vs. A környezeti kapcsolat kapcsolatok csillagokra][Image2]
</center></span><span class="sxs-lookup"><span data-stu-id="48ace-161"><center>
![Chains vs. Stars in the Context of Affinity Relationships][Image2]
</center></span></span>

<span data-ttu-id="48ace-162">Ma megjegyezni affinitás kapcsolatok egy másik művelet, hogy azok irányt.</span><span class="sxs-lookup"><span data-stu-id="48ace-162">Another thing to note about affinity relationships today is that they are directional.</span></span> <span data-ttu-id="48ace-163">Ez azt jelenti, hogy a kapcsolatot a szabály csak kényszeríti, hogy a gyermek elhelyezni, hogy a szülő.</span><span class="sxs-lookup"><span data-stu-id="48ace-163">This means that the affinity rule only enforces that the child placed with the parent.</span></span> <span data-ttu-id="48ace-164">Ezért nem biztosítja, hogy a szülő elhelyezve a gyermek.</span><span class="sxs-lookup"><span data-stu-id="48ace-164">It does not ensure that the parent is located with the child.</span></span> <span data-ttu-id="48ace-165">Is fontos megjegyezni, hogy a kapcsolat nem perfect vagy azonnal kényszeríthető óta különböző szolgáltatásokhoz különböző életciklusának rendelkező és is sikertelen mozognak.</span><span class="sxs-lookup"><span data-stu-id="48ace-165">It is also important to note that the affinity relationship can't be perfect or instantly enforced since different services have with different lifecycles and can fail and move independently.</span></span> <span data-ttu-id="48ace-166">Például tegyük fel, a szülő hirtelen átadja a feladatokat egy másik csomópontra, mert lefagyott.</span><span class="sxs-lookup"><span data-stu-id="48ace-166">For example, let's say the parent suddenly fails over to another node because it crashed.</span></span> <span data-ttu-id="48ace-167">A fürt erőforrás-kezelő és a Feladatátvevőfürt-kezelő a feladatátvétel először óta, a szolgáltatások konzisztens, tartása és kezelésére használható a prioritás van.</span><span class="sxs-lookup"><span data-stu-id="48ace-167">The Cluster Resource Manager and Failover Manager handle the failover first, since keeping the services up, consistent, and available is the priority.</span></span> <span data-ttu-id="48ace-168">Miután befejeződött a feladatátvétel, a kapcsolat megszakad, de a erőforrás-kezelőt úgy értelmezi, minden rendben mindaddig, amíg azt észleli, hogy az alárendelt helye nem a szülő.</span><span class="sxs-lookup"><span data-stu-id="48ace-168">Once the failover completes, the affinity relationship is broken, but the Cluster Resource Manager thinks everything is fine until it notices that the child is not located with the parent.</span></span> <span data-ttu-id="48ace-169">Ezek rendezi az ellenőrzések rendszeres időközönként kerül sor.</span><span class="sxs-lookup"><span data-stu-id="48ace-169">These sorts of checks are performed periodically.</span></span> <span data-ttu-id="48ace-170">További információkat a hogyan értékeli ki a fürt erőforrás-kezelő a megkötések [Ez a cikk](service-fabric-cluster-resource-manager-management-integration.md#constraint-types), és [a](service-fabric-cluster-resource-manager-balancing.md) -kiszolgálóhoz a ütemben történik, amelyen ezek a megkötések teljesíthetők a konfigurálásával kapcsolatos további értékeli ki.</span><span class="sxs-lookup"><span data-stu-id="48ace-170">More information on how the Cluster Resource Manager evaluates constraints is available in [this article](service-fabric-cluster-resource-manager-management-integration.md#constraint-types), and [this one](service-fabric-cluster-resource-manager-balancing.md) talks more about how to configure the cadence on which these constraints are evaluated.</span></span>   


### <a name="partitioning-support"></a><span data-ttu-id="48ace-171">Particionálás támogatása</span><span class="sxs-lookup"><span data-stu-id="48ace-171">Partitioning support</span></span>
<span data-ttu-id="48ace-172">A végső lépés kapcsolatra vonatkozó figyelje meg, hogy kapcsolatok nem támogatottak, ha a szülő particionálva van kapcsolat.</span><span class="sxs-lookup"><span data-stu-id="48ace-172">The final thing to notice about affinity is that affinity relationships aren’t supported where the parent is partitioned.</span></span> <span data-ttu-id="48ace-173">Lehet, hogy végül támogatja a particionált szülő szolgáltatások, de jelenleg nem engedélyezett.</span><span class="sxs-lookup"><span data-stu-id="48ace-173">Partitioned parent services may be supported eventually, but today it is not allowed.</span></span>

## <a name="next-steps"></a><span data-ttu-id="48ace-174">Következő lépések</span><span class="sxs-lookup"><span data-stu-id="48ace-174">Next steps</span></span>
- <span data-ttu-id="48ace-175">A szolgáltatások konfigurálásáról [további információ a szolgáltatások konfigurálása](service-fabric-cluster-resource-manager-configure-services.md)</span><span class="sxs-lookup"><span data-stu-id="48ace-175">For more information on configuring services, [Learn about configuring Services](service-fabric-cluster-resource-manager-configure-services.md)</span></span>
- <span data-ttu-id="48ace-176">Korlátozza a gépek egy kis készletét a szolgáltatások vagy szolgáltatások, a terhelés összesítése [alkalmazáscsoportok](service-fabric-cluster-resource-manager-application-groups.md)</span><span class="sxs-lookup"><span data-stu-id="48ace-176">To limit services to a small set of machines or aggregating the load of services, use [Application Groups](service-fabric-cluster-resource-manager-application-groups.md)</span></span>

[Image1]:./media/service-fabric-cluster-resource-manager-advanced-placement-rules-affinity/cluster-resrouce-manager-affinity-modes.png
[Image2]:./media/service-fabric-cluster-resource-manager-advanced-placement-rules-affinity/cluster-resource-manager-chains-vs-stars.png