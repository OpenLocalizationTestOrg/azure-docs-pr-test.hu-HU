---
title: "A rugalmas adatbázis ügyféloldali kódtár használata Entity Framework |} Microsoft Docs"
description: "Elastic Database ügyféloldali kódtár és Entity Framework használja az adatbázisok kódolása"
services: sql-database
documentationcenter: 
manager: jhubbard
author: torsteng
editor: 
ms.assetid: b9c3065b-cb92-41be-aa7f-deba23e7e159
ms.service: sql-database
ms.custom: scale out apps
ms.workload: sql-database
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 03/06/2017
ms.author: torsteng
ms.openlocfilehash: 2f0bff394c1e11a270cb324be5a1a45e9e531d7f
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 07/11/2017
---
# <a name="elastic-database-client-library-with-entity-framework"></a><span data-ttu-id="1ffe5-103">Az Entity Framework rugalmas adatbázis ügyféloldali kódtár</span><span class="sxs-lookup"><span data-stu-id="1ffe5-103">Elastic Database client library with Entity Framework</span></span>
<span data-ttu-id="1ffe5-104">Ez a dokumentum láthatók, amelyek szükségesek ahhoz, hogy integrálható az Entity Framework alkalmazásban a [skálázáshoz rugalmas adatbáziseszközöket](sql-database-elastic-scale-introduction.md).</span><span class="sxs-lookup"><span data-stu-id="1ffe5-104">This document shows the changes in an Entity Framework application that are needed to integrate with the [Elastic Database tools](sql-database-elastic-scale-introduction.md).</span></span> <span data-ttu-id="1ffe5-105">A elsősorban összeállítása [shard térkép felügyeleti](sql-database-elastic-scale-shard-map-management.md) és [adatok függő útválasztási](sql-database-elastic-scale-data-dependent-routing.md) az Entity Framework rendelkező **Code First** megközelítést.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-105">The focus is on composing [shard map management](sql-database-elastic-scale-shard-map-management.md) and [data-dependent routing](sql-database-elastic-scale-data-dependent-routing.md) with the Entity Framework **Code First** approach.</span></span> <span data-ttu-id="1ffe5-106">A [Code először - új adatbázis](http://msdn.microsoft.com/data/jj193542.aspx) EF útmutató futó példánkban ez a dokumentum funkcionál.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-106">The [Code First - New Database](http://msdn.microsoft.com/data/jj193542.aspx) tutorial for EF serves as our running example throughout this document.</span></span> <span data-ttu-id="1ffe5-107">Ez a dokumentum kísérő mintakód beállítása a Visual Studio-Kódminták található minták rugalmas adatbázis eszközök részét képezi.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-107">The sample code accompanying this document is part of elastic database tools' set of samples in the Visual Studio Code Samples.</span></span>

## <a name="downloading-and-running-the-sample-code"></a><span data-ttu-id="1ffe5-108">Töltsön le és futtasson példakód</span><span class="sxs-lookup"><span data-stu-id="1ffe5-108">Downloading and Running the Sample Code</span></span>
<span data-ttu-id="1ffe5-109">Ez a cikk kódjának letöltése:</span><span class="sxs-lookup"><span data-stu-id="1ffe5-109">To download the code for this article:</span></span>

* <span data-ttu-id="1ffe5-110">A Visual Studio 2012 vagy újabb rendszer szükséges.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-110">Visual Studio 2012 or later is required.</span></span> 
* <span data-ttu-id="1ffe5-111">Töltse le a [rugalmas adatbázis-eszközök az Azure SQL - entitás Keretrendszeri integrációját minta](https://code.msdn.microsoft.com/windowsapps/Elastic-Scale-with-Azure-bae904ba) msdn.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-111">Download the [Elastic DB Tools for Azure SQL - Entity Framework Integration sample](https://code.msdn.microsoft.com/windowsapps/Elastic-Scale-with-Azure-bae904ba) from MSDN.</span></span> <span data-ttu-id="1ffe5-112">Bontsa ki a minta a helyre.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-112">Unzip the sample to a location of your choosing.</span></span>
* <span data-ttu-id="1ffe5-113">Indítsa el a Visual Studiót.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-113">Start Visual Studio.</span></span> 
* <span data-ttu-id="1ffe5-114">A Visual Studio alkalmazásban válassza ki a fájl -> Nyissa meg a projekt/megoldás.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-114">In Visual Studio, select File -> Open Project/Solution.</span></span> 
* <span data-ttu-id="1ffe5-115">Az a **nyissa meg a projekt** párbeszédpanel, nyissa meg a letöltött minta, és válassza ki **EntityFrameworkCodeFirst.sln** a minta megnyitásához.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-115">In the **Open Project** dialog, navigate to the sample you downloaded and select **EntityFrameworkCodeFirst.sln** to open the sample.</span></span> 

<span data-ttu-id="1ffe5-116">A minta futtatásához szükséges három üres adatbázisok létrehozására az Azure SQL Database:</span><span class="sxs-lookup"><span data-stu-id="1ffe5-116">To run the sample, you need to create three empty databases in Azure SQL Database:</span></span>

* <span data-ttu-id="1ffe5-117">A shard térkép Manager-adatbázis</span><span class="sxs-lookup"><span data-stu-id="1ffe5-117">Shard Map Manager database</span></span>
* <span data-ttu-id="1ffe5-118">A shard 1 adatbázis</span><span class="sxs-lookup"><span data-stu-id="1ffe5-118">Shard 1 database</span></span>
* <span data-ttu-id="1ffe5-119">A shard 2 adatbázis</span><span class="sxs-lookup"><span data-stu-id="1ffe5-119">Shard 2 database</span></span>

<span data-ttu-id="1ffe5-120">Miután létrehozta ezeket az adatbázisokat, töltse ki a hely tartozó felhasználók számára a **Program.cs** az Azure SQL adatbázis-kiszolgáló neve, az adatbázis nevét, és csatlakozzon az adatbázishoz a hitelesítő adatait.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-120">Once you have created these databases, fill in the place holders in **Program.cs** with your Azure SQL DB server name, the database names and your credentials to connect to the databases.</span></span> <span data-ttu-id="1ffe5-121">A Visual Studio megoldás felépítéséhez.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-121">Build the solution in Visual Studio.</span></span> <span data-ttu-id="1ffe5-122">A Visual Studio letölti a szükséges NuGet-csomagok az elastic database ügyféloldali kódtár Entity Framework, és átmeneti hiba kezelésére szolgál az összeállítási folyamat részeként.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-122">Visual Studio will download the required NuGet packages for the elastic database client library, Entity Framework, and Transient Fault handling as part of the build process.</span></span> <span data-ttu-id="1ffe5-123">Győződjön meg arról, hogy a megoldás NuGet-csomagok visszaállítására engedélyezve.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-123">Make sure that restoring NuGet packages is enabled for your solution.</span></span> <span data-ttu-id="1ffe5-124">Kattintson a jobb gombbal a megoldás fájlra a Visual Studio Solution Explorer engedélyezheti ezt a beállítást.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-124">You can enable this setting by right-clicking on the solution file in the Visual Studio Solution Explorer.</span></span> 

## <a name="entity-framework-workflows"></a><span data-ttu-id="1ffe5-125">Entity Framework munkafolyamatai</span><span class="sxs-lookup"><span data-stu-id="1ffe5-125">Entity Framework workflows</span></span>
<span data-ttu-id="1ffe5-126">Entitás-keretrendszer fejlesztői egyet a következő négy munkafolyamatok olyan alkalmazásokat hozhat létre és alkalmazás objektumának megőrzését támaszkodnak:</span><span class="sxs-lookup"><span data-stu-id="1ffe5-126">Entity Framework developers rely on one of the following four workflows to build applications and to ensure persistence for application objects:</span></span> 

* <span data-ttu-id="1ffe5-127">**Első (új adatbázis) code**: az EF fejlesztői hoz létre a modell az alkalmazáskódban, és akkor EF hoz létre az adatbázist.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-127">**Code First (New Database)**: The EF developer creates the model in the application code and then EF generates the database from it.</span></span> 
* <span data-ttu-id="1ffe5-128">**Első (meglévő adatbázis) code**: A fejlesztői lehetővé teszi, hogy az alkalmazás kódjának a modell létrehozása egy létező adatbázisból EF.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-128">**Code First (Existing Database)**: The developer lets EF generate the application code for the model from an existing database.</span></span>
* <span data-ttu-id="1ffe5-129">**A modell első**: A fejlesztői hoz létre a modell az EF-tervezőben, és ezután EF hoz létre az adatbázist a modellből.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-129">**Model First**: The developer creates the model in the EF designer and then EF creates the database from the model.</span></span>
* <span data-ttu-id="1ffe5-130">**Adatbázis-első**: A fejlesztő EF tooling eszköz, amelyből megállapítható a modell egy meglévő adatbázist.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-130">**Database First**: The developer uses EF tooling to infer the model from an existing database.</span></span> 

<span data-ttu-id="1ffe5-131">Ezek a módszerek a DbContext osztályt transzparens módon kezelheti a Helyadatbázis-kapcsolatot, és az alkalmazás adatbázisséma támaszkodnak.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-131">All these approaches rely on the DbContext class to transparently manage database connections and database schema for an application.</span></span> <span data-ttu-id="1ffe5-132">Ismertetik részletesebben a dokumentum későbbi szakaszában a DbContext alaposztályban különböző konstruktorok lehetővé teszik a különböző szintű kapcsolat létrehozásakor, ellenőrzésre adatbázis rendszerindítása és séma létrehozásához.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-132">As we will discuss in more detail later in the document, different constructors on the DbContext base class allow for different levels of control over connection creation, database bootstrapping and schema creation.</span></span> <span data-ttu-id="1ffe5-133">Kihívást erednek elsősorban az, hogy az adatbázis-kapcsolat EF által biztosított kezelése az adatok függő útválasztási felületek kapcsolat kezelési lehetőségeinek metszi a rugalmas adatbázis ügyféloldali kódtár által.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-133">Challenges arise primarily from the fact that the database connection management provided by EF intersects with the connection management capabilities of the data dependent routing interfaces provided by the elastic database client library.</span></span> 

## <a name="elastic-database-tools-assumptions"></a><span data-ttu-id="1ffe5-134">A rugalmas adatbázis eszközök Előfeltételek</span><span class="sxs-lookup"><span data-stu-id="1ffe5-134">Elastic database tools assumptions</span></span>
<span data-ttu-id="1ffe5-135">Kifejezés-definíciók, lásd: [rugalmas adatbázis eszközök szószedet](sql-database-elastic-scale-glossary.md).</span><span class="sxs-lookup"><span data-stu-id="1ffe5-135">For term definitions, see [Elastic Database tools glossary](sql-database-elastic-scale-glossary.md).</span></span>

<span data-ttu-id="1ffe5-136">A rugalmas adatbázis ügyféloldali kódtár az alkalmazásadatok shardlets nevű partíciója határozza meg.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-136">With elastic database client library, you define partitions of your application data called shardlets.</span></span> <span data-ttu-id="1ffe5-137">Shardlets egy horizontális skálázási kulcs azonosítják, és konkrét adatbázisaihoz van leképezve.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-137">Shardlets are identified by a sharding key and are mapped to specific databases.</span></span> <span data-ttu-id="1ffe5-138">Egy alkalmazás előfordulhat, hogy annyi adatbázis igény szerint, és ossza ki a shardlets elég kapacitás vagy a teljesítmény aktuális üzleti követelmények biztosításához.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-138">An application may have as many databases as needed and distribute the shardlets to provide enough capacity or performance given current business requirements.</span></span> <span data-ttu-id="1ffe5-139">Az adatbázisok horizontális kulcsértékei leképezése egy API-k rugalmas adatbázis-ügyfél által megadott shard leképezés tárolja.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-139">The mapping of sharding key values to the databases is stored by a shard map provided by the elastic database client APIs.</span></span> <span data-ttu-id="1ffe5-140">Ez a funkció hívása **Shard térkép felügyeleti**, vagy röviden SMM.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-140">We call this capability **Shard Map Management**, or SMM for short.</span></span> <span data-ttu-id="1ffe5-141">A szilánkok térkép is szolgál az átvitelszervező adatbázis-kapcsolatok a kéréseket, amelyben egy horizontális skálázási kulcsot.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-141">The shard map also serves as the broker of database connections for requests that carry a sharding key.</span></span> <span data-ttu-id="1ffe5-142">Ezt a képességet, hivatkozunk **adatok függő útválasztási**.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-142">We refer to this capability as **data-dependent routing**.</span></span> 

<span data-ttu-id="1ffe5-143">A szilánkok térkép-kezelő felhasználók védi a inkonzisztens nézetek, amely akkor fordulhat elő, amikor párhuzamos shardlet felügyeleti műveletek (például az adatok áthelyezése egy shard a másik) hogy shardlet adatokká.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-143">The shard map manager protects users from inconsistent views into shardlet data that can occur when concurrent shardlet management operations (such as relocating data from one shard to another) are happening.</span></span> <span data-ttu-id="1ffe5-144">Ehhez a shard maps felügyeli az ügyfél könyvtár broker a Helyadatbázis-kapcsolatot az alkalmazás.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-144">To do so, the shard maps managed by the client library broker the database connections for an application.</span></span> <span data-ttu-id="1ffe5-145">Ez lehetővé teszi a shard leképezés funkció automatikusan leállítani az adatbázis-kapcsolat, ha shard felügyeleti műveletek jelentős hatással lehet a shardlet, amely a kapcsolat jött létre a(z).</span><span class="sxs-lookup"><span data-stu-id="1ffe5-145">This allows the shard map functionality to automatically kill a database connection when shard management operations could impact the shardlet that the connection has been created for.</span></span> <span data-ttu-id="1ffe5-146">Ezt a módszert kell néhány EF-EK funkciókat, például új kapcsolatok létrehozására, az adatbázis létezését keressen egy meglévő integrálható.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-146">This approach needs to integrate with some of EF’s functionality, such as creating new connections from an existing one to check for database existence.</span></span> <span data-ttu-id="1ffe5-147">Általában a megfigyelési lett, hogy működik-e a szabványos DbContext konstruktorok csak munkahelyi megbízhatóan EF biztonságosan klónozható lezárt adatbázis-kapcsolatok esetében.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-147">In general, our observation has been that the standard DbContext constructors only work reliably for closed database connections that can safely be cloned for EF work.</span></span> <span data-ttu-id="1ffe5-148">Rugalmas kialakítás elve-kapcsolatok csak replikaszervező helyette hoz.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-148">The design principle of elastic database instead is to only broker opened connections.</span></span> <span data-ttu-id="1ffe5-149">Egy hiszi, hogy az ügyfél kódtára előtt továbbításáért azt az EF DbContext közvetítőalapú kapcsolat bezárása előfordulhat, hogy a probléma megoldására.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-149">One might think that closing a connection brokered by the client library before handing it over to the EF DbContext may solve this issue.</span></span> <span data-ttu-id="1ffe5-150">Azonban lezárja a kapcsolatot, és nyissa meg újra az EF hagyatkoznia, egy foregoes az érvényesítési és a konzisztencia ellenőrzések végzi el a könyvtárban.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-150">However, by closing the connection and relying on EF to re-open it, one foregoes the validation and consistency checks performed by the library.</span></span> <span data-ttu-id="1ffe5-151">A áttelepítések funkciói EF, azonban ezek a kapcsolatok kezelésére használ az alapul szolgáló adatbázisséma oly módon, hogy az alkalmazás átlátható.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-151">The migrations functionality in EF, however, uses these connections to manage the underlying database schema in a way that is transparent to the application.</span></span> <span data-ttu-id="1ffe5-152">Ideális esetben szeretnénk és az összes ezeket a képességeket a rugalmas adatbázis ügyféloldali kódtár és az EF ugyanabban az alkalmazásban kombinálni.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-152">Ideally, we would like to retain and combine all these capabilities from both the elastic database client library and EF in the same application.</span></span> <span data-ttu-id="1ffe5-153">Az alábbi szakasz ismerteti, ezek a tulajdonságok és részletes követelményeket.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-153">The following section discusses these properties and requirements in more detail.</span></span> 

## <a name="requirements"></a><span data-ttu-id="1ffe5-154">Követelmények</span><span class="sxs-lookup"><span data-stu-id="1ffe5-154">Requirements</span></span>
<span data-ttu-id="1ffe5-155">Az elastic database ügyféloldali kódtárának mind az Entity Framework API-k használatakor szeretnénk tartsa meg az alábbi tulajdonságokat:</span><span class="sxs-lookup"><span data-stu-id="1ffe5-155">When working with both the elastic database client library and Entity Framework APIs, we want to retain the following properties:</span></span> 

* <span data-ttu-id="1ffe5-156">**Kibővített**: hozzáadásához vagy eltávolításához adatbázisok alkalmazásának a szilánkos a kapacitás iránti igények kielégítése érdekében a megfelelő az alkalmazás az adatok réteg alapján.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-156">**Scale-out**: To add or remove databases from the data tier of the sharded application as necessary for the capacity demands of the application.</span></span> <span data-ttu-id="1ffe5-157">Ez azt jelenti, hogy vezérlő keresztül a létrehozását és törlését az adatbázisok és a rugalmas adatbázis shard használatával leképezése manager API-k, adatbázisok és shardlets leképezéseit kezeléséhez.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-157">This means control over the the creation and deletion of databases and using the elastic database shard map manager APIs to manage databases, and mappings of shardlets.</span></span> 
* <span data-ttu-id="1ffe5-158">**Konzisztencia**: az alkalmazás horizontális alkalmazza, és adatok függő útválasztási szolgáltatásait használja az ügyféloldali kódtár.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-158">**Consistency**: The application employs sharding, and uses the data dependent routing capabilities of the client library.</span></span> <span data-ttu-id="1ffe5-159">Sérült vagy helytelen lekérdezési eredmények elkerülése érdekében kapcsolatok keresztül a shard térkép manager által felügyelt.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-159">To avoid corruption or wrong query results, connections are brokered through the shard map manager.</span></span> <span data-ttu-id="1ffe5-160">Ez megőrzi a érvényesítése és a konzisztencia is.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-160">This also retains validation and consistency.</span></span>
* <span data-ttu-id="1ffe5-161">**Első Code**: EF-EK kód első paradigma kényelmi megőrzését.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-161">**Code First**: To retain the convenience of EF’s code first paradigm.</span></span> <span data-ttu-id="1ffe5-162">A kód első a osztályok az alkalmazás átlátható módon vannak leképezve az alapul szolgáló adatbázis felépítését.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-162">In Code First, classes in the application are mapped transparently to the underlying database structures.</span></span> <span data-ttu-id="1ffe5-163">Az alkalmazás kódjában, amely a legtöbb területét az alapul szolgáló adatbázis-feldolgozási részt maszkolnia DbSets kommunikál.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-163">The application code interacts with DbSets that mask most aspects involved in the underlying database processing.</span></span>
* <span data-ttu-id="1ffe5-164">**Séma**: Entity Framework kezdeti adatbázis-séma létrehozása és későbbi séma alakulása áttelepítések keresztül kezeli.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-164">**Schema**: Entity Framework handles initial database schema creation and subsequent schema evolution through migrations.</span></span> <span data-ttu-id="1ffe5-165">Megtartja ezeket a képességeket, az alkalmazás testreszabásához az egyszerű az adatok fejlődésének.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-165">By retaining these capabilities, adapting your app is easy as the data evolves.</span></span> 

<span data-ttu-id="1ffe5-166">A következő útmutatást arra utasítja, hogy hogyan ezeknek a követelményeknek rugalmas adatbáziseszközöket Code First alkalmazásokhoz.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-166">The following guidance instructs how to satisfy these requirements for Code First applications using elastic database tools.</span></span> 

## <a name="data-dependent-routing-using-ef-dbcontext"></a><span data-ttu-id="1ffe5-167">Az adatok függő útválasztás EF DbContext használata</span><span class="sxs-lookup"><span data-stu-id="1ffe5-167">Data dependent routing using EF DbContext</span></span>
<span data-ttu-id="1ffe5-168">Adatbázis-kapcsolatok az Entity Framework általában kezelhetők alosztályokat **DbContext**.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-168">Database connections with Entity Framework are typically managed through subclasses of **DbContext**.</span></span> <span data-ttu-id="1ffe5-169">Hozzon létre a alosztályok származó **DbContext**.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-169">Create these subclasses by deriving from **DbContext**.</span></span> <span data-ttu-id="1ffe5-170">Itt adhatja meg azt a **DbSets** amelyek megvalósítják az adatbázis biztonsági objektumok gyűjteményeit adják CLR az alkalmazáshoz.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-170">This is where you define your **DbSets** that implement the database-backed collections of CLR objects for your application.</span></span> <span data-ttu-id="1ffe5-171">Az adatok függő útválasztási környezetben azt azonosíthatja a számos hasznos tulajdonság nem feltétlenül vonatkozik az egyéb EF code első alkalmazás forgatókönyvek, amelyek:</span><span class="sxs-lookup"><span data-stu-id="1ffe5-171">In the context of data dependent routing, we can identify several helpful properties that do not necessarily hold for other EF code first application scenarios:</span></span> 

* <span data-ttu-id="1ffe5-172">Az adatbázis már létezik, és a rugalmas adatbázis shard térkép regisztrálva van.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-172">The database already exists and has been registered in the elastic database shard map.</span></span> 
* <span data-ttu-id="1ffe5-173">A séma, az alkalmazás már telepítve van az adatbázishoz (alábbi leírásban is).</span><span class="sxs-lookup"><span data-stu-id="1ffe5-173">The schema of the application has already been deployed to the database (explained below).</span></span> 
* <span data-ttu-id="1ffe5-174">Adatok függő útválasztási kapcsolatok az adatbázis által a shard térkép vannak közvetítőalapú.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-174">Data-dependent routing connections to the database are brokered by the shard map.</span></span> 

<span data-ttu-id="1ffe5-175">Integrálni **DbContexts** kibővített az útválasztási adatok függő:</span><span class="sxs-lookup"><span data-stu-id="1ffe5-175">To integrate **DbContexts** with data-dependent routing for scale-out:</span></span>

1. <span data-ttu-id="1ffe5-176">A szilánkok térkép-kezelő, a rugalmas adatbázis ügyfél felületeken keresztül fizikai adatbázis-kapcsolatok létrehozása</span><span class="sxs-lookup"><span data-stu-id="1ffe5-176">Create physical database connections through the elastic database client interfaces of the shard map manager,</span></span> 
2. <span data-ttu-id="1ffe5-177">A kapcsolat burkolása a **DbContext** alosztálya lesz</span><span class="sxs-lookup"><span data-stu-id="1ffe5-177">Wrap the connection with the **DbContext** subclass</span></span>
3. <span data-ttu-id="1ffe5-178">Adja a kapcsolat át az a **DbContext** EF oldalán összes feldolgozása történik, valamint hogy osztályok alapjául.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-178">Pass the connection down into the **DbContext** base classes to ensure all the processing on the EF side happens as well.</span></span> 

<span data-ttu-id="1ffe5-179">Az alábbi példakód mutatja be ezt a módszert használja.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-179">The following code example illustrates this approach.</span></span> <span data-ttu-id="1ffe5-180">(Ez a kód egyben a hozzá tartozó Visual Studio-projekt)</span><span class="sxs-lookup"><span data-stu-id="1ffe5-180">(This code is also in the accompanying Visual Studio project)</span></span>

    public class ElasticScaleContext<T> : DbContext
    {
    public DbSet<Blog> Blogs { get; set; }
    …

        // C'tor for data dependent routing. This call will open a validated connection 
        // routed to the proper shard by the shard map manager. 
        // Note that the base class c'tor call will fail for an open connection
        // if migrations need to be done and SQL credentials are used. This is the reason for the 
        // separation of c'tors into the data-dependent routing case (this c'tor) and the internal c'tor for new shards.
        public ElasticScaleContext(ShardMap shardMap, T shardingKey, string connectionStr)
            : base(CreateDDRConnection(shardMap, shardingKey, connectionStr), 
            true /* contextOwnsConnection */)
        {
        }

        // Only static methods are allowed in calls into base class c'tors.
        private static DbConnection CreateDDRConnection(
        ShardMap shardMap, 
        T shardingKey, 
        string connectionStr)
        {
            // No initialization
            Database.SetInitializer<ElasticScaleContext<T>>(null);

            // Ask shard map to broker a validated connection for the given key
            SqlConnection conn = shardMap.OpenConnectionForKey<T>
                                (shardingKey, connectionStr, ConnectionOptions.Validate);
            return conn;
        }    

## <a name="main-points"></a><span data-ttu-id="1ffe5-181">Főbb pontjai</span><span class="sxs-lookup"><span data-stu-id="1ffe5-181">Main points</span></span>
* <span data-ttu-id="1ffe5-182">Egy új konstruktort a felváltja az alapértelmezett konstruktort a a DbContext alosztálya lesz</span><span class="sxs-lookup"><span data-stu-id="1ffe5-182">A new constructor replaces the default constructor in the DbContext subclass</span></span> 
* <span data-ttu-id="1ffe5-183">Az új konstruktor argumentummal szükséges adatok függő útválasztási elastic database ügyféloldali kódtárának keresztül:</span><span class="sxs-lookup"><span data-stu-id="1ffe5-183">The new constructor takes the arguments that are required for data dependent routing through elastic database client library:</span></span>
  
  * <span data-ttu-id="1ffe5-184">a szilánkok térkép elérni az adatok függő útválasztási felületek</span><span class="sxs-lookup"><span data-stu-id="1ffe5-184">the shard map to access the data-dependent routing interfaces,</span></span>
  * <span data-ttu-id="1ffe5-185">a horizontális kulcs a shardlet azonosításához</span><span class="sxs-lookup"><span data-stu-id="1ffe5-185">the sharding key to identify the shardlet,</span></span>
  * <span data-ttu-id="1ffe5-186">a kapcsolati karakterlánc az adatok függő a shard útválasztási kapcsolat hitelesítő adatait.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-186">a connection string with the credentials for the data-dependent routing connection to the shard.</span></span> 
* <span data-ttu-id="1ffe5-187">Az alaposztály konstruktor hívása veszi egy detour statikus metódus, amely a lépéseket végzi el az adatok függő útválasztási szükséges.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-187">The call to the base class constructor takes a detour into a static method that performs all the steps necessary for data-dependent routing.</span></span> 
  
  * <span data-ttu-id="1ffe5-188">Nyitott kapcsolatot létrehozni a shard térképen használ a rugalmas adatbázis-ügyfél adapterek OpenConnectionForKey hívása.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-188">It uses the OpenConnectionForKey call of the elastic database client interfaces on the shard map to establish an open connection.</span></span>
  * <span data-ttu-id="1ffe5-189">A szilánkok térkép a shard, amely tárolja a megadott horizontális skálázási kulcs shardlet a nyitott kapcsolatot hoz.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-189">The shard map creates the open connection to the shard that holds the shardlet for the given sharding key.</span></span>
  * <span data-ttu-id="1ffe5-190">A megnyitott kapcsolat vissza azt jelzi, hogy a kapcsolat ahelyett, hogy automatikusan hozzon létre egy új kapcsolatot EF EF által használandó DbContext alaposztály konstruktorának átadott.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-190">This open connection is passed back to the base class constructor of DbContext to indicate that this connection is to be used by EF instead of letting EF create a new connection automatically.</span></span> <span data-ttu-id="1ffe5-191">Így a kapcsolat címkézett a rugalmas adatbázis-ügyfél API-t, hogy garantálják, hogy a shard térkép felügyeleti műveletek konzisztencia.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-191">This way the connection has been tagged by the elastic database client API so that it can guarantee consistency under shard map management operations.</span></span>

<span data-ttu-id="1ffe5-192">Az új konstruktor használata helyett az alapértelmezett konstruktort a kódban a DbContext alosztálya.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-192">Use the new constructor for your DbContext subclass instead of the default constructor in your code.</span></span> <span data-ttu-id="1ffe5-193">Például:</span><span class="sxs-lookup"><span data-stu-id="1ffe5-193">Here is an example:</span></span> 

    // Create and save a new blog.

    Console.Write("Enter a name for a new blog: "); 
    var name = Console.ReadLine(); 

    using (var db = new ElasticScaleContext<int>( 
                            sharding.ShardMap,  
                            tenantId1,  
                            connStrBldr.ConnectionString)) 
    { 
        var blog = new Blog { Name = name }; 
        db.Blogs.Add(blog); 
        db.SaveChanges(); 

        // Display all Blogs for tenant 1 
        var query = from b in db.Blogs 
                    orderby b.Name 
                    select b; 
     … 
    }

<span data-ttu-id="1ffe5-194">Az új konstruktor megnyitja a kapcsolatot a shard értékének által azonosított shardlet használt adatokat tartalmazó **tenantid1**.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-194">The new constructor opens the connection to the shard that holds the data for the shardlet identified by the value of **tenantid1**.</span></span> <span data-ttu-id="1ffe5-195">A kód a **használatával** blokk hozzáférés változatlan marad a **DbSet** az EF szalaghasználata a shard blogok **tenantid1**.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-195">The code in the **using** block stays unchanged to access the **DbSet** for blogs using EF on the shard for **tenantid1**.</span></span> <span data-ttu-id="1ffe5-196">Ez módosítja szemantikáját be a kódját letiltása például, hogy az összes művelet hatóköre mostantól a következő egy shard ahol **tenantid1** maradnak.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-196">This changes semantics for the code in the using block such that all database operations are now scoped to the one shard where **tenantid1** is kept.</span></span> <span data-ttu-id="1ffe5-197">Például a blogok keresztül a LINQ lekérdezés **DbSet** csak alakítanák vissza, az aktuális shard tárolt blogok, de nem más szilánkok tárolja azokat.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-197">For instance, a LINQ query over the blogs **DbSet** would only return blogs stored on the current shard, but not the ones stored on other shards.</span></span>  

#### <a name="transient-faults-handling"></a><span data-ttu-id="1ffe5-198">Átmeneti hibák kezelése</span><span class="sxs-lookup"><span data-stu-id="1ffe5-198">Transient faults handling</span></span>
<span data-ttu-id="1ffe5-199">A Microsoft Patterns & eljárások csapat közzé a [az átmeneti hiba kezelési alkalmazás blokk](https://msdn.microsoft.com/library/dn440719.aspx).</span><span class="sxs-lookup"><span data-stu-id="1ffe5-199">The Microsoft Patterns & Practices team published the [The Transient Fault Handling Application Block](https://msdn.microsoft.com/library/dn440719.aspx).</span></span> <span data-ttu-id="1ffe5-200">A könyvtár a rugalmas bővítést ügyféloldali kódtár EF együtt használatos.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-200">The library is used with elastic scale client library in combination with EF.</span></span> <span data-ttu-id="1ffe5-201">Azonban ügyeljen arra, hogy átmeneti kivételen egy olyan helyre, ahol azt is győződjön meg arról, hogy az új konstruktor használatban van egy átmeneti hiba után, hogy minden új kapcsolódási kísérlet történik a konstruktorok azt rendelkezik tweaked használatával adja vissza.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-201">However, ensure that any transient exception returns to a place where we can ensure that the new constructor is being used after a transient fault so that any new connection attempt is made using the constructors we have tweaked.</span></span> <span data-ttu-id="1ffe5-202">Ellenkező esetben a megfelelő shard kapcsolat nem garantált, és nincs változás a shard leképezés a kapcsolat megmarad biztosítékok van.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-202">Otherwise, a connection to the correct shard is not guaranteed, and there are no assurances the connection is maintained as changes to the shard map occur.</span></span> 

<span data-ttu-id="1ffe5-203">A következő példakód azt szemlélteti, hogyan SQL újrapróbálkozási házirendje használható-e az új körül **DbContext** alosztály konstruktorok:</span><span class="sxs-lookup"><span data-stu-id="1ffe5-203">The following code sample illustrates how a SQL retry policy can be used around the new **DbContext** subclass constructors:</span></span> 

    SqlDatabaseUtils.SqlRetryPolicy.ExecuteAction(() => 
    { 
        using (var db = new ElasticScaleContext<int>( 
                                sharding.ShardMap,  
                                tenantId1,  
                                connStrBldr.ConnectionString)) 
            { 
                    var blog = new Blog { Name = name }; 
                    db.Blogs.Add(blog); 
                    db.SaveChanges(); 
            … 
            } 
        }); 

<span data-ttu-id="1ffe5-204">**SqlDatabaseUtils.SqlRetryPolicy** a kódban van definiálva, egy **SqlDatabaseTransientErrorDetectionStrategy** újrapróbálkozás-szám 10-es és 5 másodperc várjon az újrapróbálkozások között eltelt idő.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-204">**SqlDatabaseUtils.SqlRetryPolicy** in the code above is defined as a **SqlDatabaseTransientErrorDetectionStrategy** with a retry count of 10, and 5 seconds wait time between retries.</span></span> <span data-ttu-id="1ffe5-205">Ez a megközelítés hasonlít az útmutató EF és a felhasználó által kezdeményezett tranzakció (lásd: [korlátozásai a végrehajtási stratégiák újrapróbálkozás (EF6 és újabb verziók esetében)](http://msdn.microsoft.com/data/dn307226).</span><span class="sxs-lookup"><span data-stu-id="1ffe5-205">This approach is similar to the guidance for EF and user-initiated transactions (see [Limitations with Retrying Execution Strategies (EF6 onwards)](http://msdn.microsoft.com/data/dn307226).</span></span> <span data-ttu-id="1ffe5-206">Mindkét esetben szükséges, hogy az alkalmazás szabályozza a hatókör, amelyhez a átmeneti kivételt adja vissza: Nyissa meg újra a tranzakciót, vagy (ahogy) hozza létre újra a megfelelő konstruktor a környezetben, amely a rugalmas adatbázis ügyféloldali kódtár használ.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-206">Both situations require that the application program controls the scope to which the transient exception returns: to either reopen the transaction, or (as shown) recreate the context from the proper constructor that uses the elastic database client library.</span></span>

<span data-ttu-id="1ffe5-207">Történő ellenőrzése, ahol átmeneti kivételek a hálózatról, biztonsági hatókör is kizárja a beépített használatát **SqlAzureExecutionStrategy** az EF elérhető lesz.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-207">The need to control where transient exceptions take us back in scope also precludes the use of the built-in **SqlAzureExecutionStrategy** that comes with EF.</span></span> <span data-ttu-id="1ffe5-208">**SqlAzureExecutionStrategy** volna nyissa meg újra a kapcsolatot, de nem használható **OpenConnectionForKey** , és ezért az érvényesítési részeként végrehajtott műveletek a **OpenConnectionForKey** hívja.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-208">**SqlAzureExecutionStrategy** would reopen a connection but not use **OpenConnectionForKey** and therefore bypass all the validation that is performed as part of the **OpenConnectionForKey** call.</span></span> <span data-ttu-id="1ffe5-209">Ehelyett a kódminta használja a beépített **DefaultExecutionStrategy** az EF is elérhető lesz.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-209">Instead, the code sample uses the built-in **DefaultExecutionStrategy** that also comes with EF.</span></span> <span data-ttu-id="1ffe5-210">Helyett **SqlAzureExecutionStrategy**, megfelelően működik az újrapróbálkozási házirendet kezeljen átmeneti hiba együtt.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-210">As opposed to **SqlAzureExecutionStrategy**, it works correctly in combination with the retry policy from Transient Fault Handling.</span></span> <span data-ttu-id="1ffe5-211">A végrehajtási házirend beállítása a **ElasticScaleDbConfiguration** osztály.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-211">The execution policy is set in the **ElasticScaleDbConfiguration** class.</span></span> <span data-ttu-id="1ffe5-212">Vegye figyelembe, hogy nem használandó döntöttünk **DefaultSqlExecutionStrategy** óta használandó javasol **SqlAzureExecutionStrategy** átmeneti kivételek esetén – amely vezetne nem megfelelő viselkedésének című szakaszban leírtaknak megfelelően.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-212">Note that we decided not to use **DefaultSqlExecutionStrategy** since it suggests to use **SqlAzureExecutionStrategy** if transient exceptions occur - which would lead to wrong behavior as discussed.</span></span> <span data-ttu-id="1ffe5-213">A házirendek a különböző újrapróbálkozásos és EF további információkért lásd: [kapcsolati rugalmasságot az EF](http://msdn.microsoft.com/data/dn456835.aspx).</span><span class="sxs-lookup"><span data-stu-id="1ffe5-213">For more information on the different retry policies and EF, see [Connection Resiliency in EF](http://msdn.microsoft.com/data/dn456835.aspx).</span></span>     

#### <a name="constructor-rewrites"></a><span data-ttu-id="1ffe5-214">Konstruktor újraírások</span><span class="sxs-lookup"><span data-stu-id="1ffe5-214">Constructor rewrites</span></span>
<span data-ttu-id="1ffe5-215">A fenti példák bemutatják, hogy az alapértelmezett konstruktor átírja adatok függő az Entity Framework útválasztással használatához az alkalmazáshoz szükséges.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-215">The code examples above illustrate the default constructor re-writes required for your application in order to use  data dependent routing with the Entity Framework.</span></span> <span data-ttu-id="1ffe5-216">A következő táblázat a más konstruktorok megközelítése használatúvá.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-216">The following table generalizes this approach to other constructors.</span></span> 

| <span data-ttu-id="1ffe5-217">Aktuális konstruktor</span><span class="sxs-lookup"><span data-stu-id="1ffe5-217">Current Constructor</span></span> | <span data-ttu-id="1ffe5-218">Az adatok egy átírt konstruktor</span><span class="sxs-lookup"><span data-stu-id="1ffe5-218">Rewritten Constructor for data</span></span> | <span data-ttu-id="1ffe5-219">Alap konstruktor</span><span class="sxs-lookup"><span data-stu-id="1ffe5-219">Base Constructor</span></span> | <span data-ttu-id="1ffe5-220">Megjegyzések</span><span class="sxs-lookup"><span data-stu-id="1ffe5-220">Notes</span></span> |
| --- | --- | --- | --- |
| <span data-ttu-id="1ffe5-221">MyContext()</span><span class="sxs-lookup"><span data-stu-id="1ffe5-221">MyContext()</span></span> |<span data-ttu-id="1ffe5-222">ElasticScaleContext (ShardMap, TKey)</span><span class="sxs-lookup"><span data-stu-id="1ffe5-222">ElasticScaleContext(ShardMap, TKey)</span></span> |<span data-ttu-id="1ffe5-223">DbContext (DbConnection, bool)</span><span class="sxs-lookup"><span data-stu-id="1ffe5-223">DbContext(DbConnection, bool)</span></span> |<span data-ttu-id="1ffe5-224">A kapcsolat kell lennie a shard leképezés és az adatok függő útválasztási kulcsot.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-224">The connection needs to be a function of the shard map and the data-dependent routing key.</span></span> <span data-ttu-id="1ffe5-225">Kihagyva automatikus kapcsolat létrehozásának EF kell, és helyette a shard térkép segítségével replikaszervező a kapcsolatot.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-225">You need to by-pass automatic connection creation by EF and instead use the shard map to broker the connection.</span></span> |
| <span data-ttu-id="1ffe5-226">MyContext(string)</span><span class="sxs-lookup"><span data-stu-id="1ffe5-226">MyContext(string)</span></span> |<span data-ttu-id="1ffe5-227">ElasticScaleContext (ShardMap, TKey)</span><span class="sxs-lookup"><span data-stu-id="1ffe5-227">ElasticScaleContext(ShardMap, TKey)</span></span> |<span data-ttu-id="1ffe5-228">DbContext (DbConnection, bool)</span><span class="sxs-lookup"><span data-stu-id="1ffe5-228">DbContext(DbConnection, bool)</span></span> |<span data-ttu-id="1ffe5-229">A szilánkok leképezés és az adatok függő útválasztási kulcs létrejön a kapcsolat.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-229">The connection is a function of the shard map and the data-dependent routing key.</span></span> <span data-ttu-id="1ffe5-230">A rögzített adatbázis neve vagy a kapcsolati karakterlánc nem fognak működni azok által a shard térkép kihagyva érvényesítése.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-230">A fixed database name or connection string will not work as they by-pass validation by the shard map.</span></span> |
| <span data-ttu-id="1ffe5-231">MyContext(DbCompiledModel)</span><span class="sxs-lookup"><span data-stu-id="1ffe5-231">MyContext(DbCompiledModel)</span></span> |<span data-ttu-id="1ffe5-232">ElasticScaleContext (ShardMap, TKey, DbCompiledModel)</span><span class="sxs-lookup"><span data-stu-id="1ffe5-232">ElasticScaleContext(ShardMap, TKey, DbCompiledModel)</span></span> |<span data-ttu-id="1ffe5-233">DbContext (DbConnection, DbCompiledModel, logikai)</span><span class="sxs-lookup"><span data-stu-id="1ffe5-233">DbContext(DbConnection, DbCompiledModel, bool)</span></span> |<span data-ttu-id="1ffe5-234">A kapcsolat lesz létrehozása a megadott shard térkép és horizontális kulcs bemutatott minta.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-234">The connection will get created for the given shard map and sharding key with the model provided.</span></span> <span data-ttu-id="1ffe5-235">A kiinduló c'tor a lefordított modell fog átadásra.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-235">The compiled model will be passed on to the base c’tor.</span></span> |
| <span data-ttu-id="1ffe5-236">MyContext (DbConnection, bool)</span><span class="sxs-lookup"><span data-stu-id="1ffe5-236">MyContext(DbConnection, bool)</span></span> |<span data-ttu-id="1ffe5-237">ElasticScaleContext (ShardMap, TKey, logikai)</span><span class="sxs-lookup"><span data-stu-id="1ffe5-237">ElasticScaleContext(ShardMap, TKey, bool)</span></span> |<span data-ttu-id="1ffe5-238">DbContext (DbConnection, bool)</span><span class="sxs-lookup"><span data-stu-id="1ffe5-238">DbContext(DbConnection, bool)</span></span> |<span data-ttu-id="1ffe5-239">A kapcsolat kell következtethető ki a shard térkép és a kulcsot.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-239">The connection needs to be inferred from the shard map and the key.</span></span> <span data-ttu-id="1ffe5-240">Azt nem adható meg bemenetként (kivéve, ha a bemenetet a shard térkép és a kulcs már használja).</span><span class="sxs-lookup"><span data-stu-id="1ffe5-240">It cannot be provided as an input (unless that input was already using the shard map and the key).</span></span> <span data-ttu-id="1ffe5-241">A logikai értékek átadásra kerül.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-241">The Boolean will be passed on.</span></span> |
| <span data-ttu-id="1ffe5-242">MyContext (karakterlánc, DbCompiledModel)</span><span class="sxs-lookup"><span data-stu-id="1ffe5-242">MyContext(string, DbCompiledModel)</span></span> |<span data-ttu-id="1ffe5-243">ElasticScaleContext (ShardMap, TKey, DbCompiledModel)</span><span class="sxs-lookup"><span data-stu-id="1ffe5-243">ElasticScaleContext(ShardMap, TKey, DbCompiledModel)</span></span> |<span data-ttu-id="1ffe5-244">DbContext (DbConnection, DbCompiledModel, logikai)</span><span class="sxs-lookup"><span data-stu-id="1ffe5-244">DbContext(DbConnection, DbCompiledModel, bool)</span></span> |<span data-ttu-id="1ffe5-245">A kapcsolat kell következtethető ki a shard térkép és a kulcsot.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-245">The connection needs to be inferred from the shard map and the key.</span></span> <span data-ttu-id="1ffe5-246">Azt nem adható meg bemenetként (kivéve, ha a bemenetet a shard térkép és a kulcs lett használatával).</span><span class="sxs-lookup"><span data-stu-id="1ffe5-246">It cannot be provided as an input (unless that input was using the shard map and the key).</span></span> <span data-ttu-id="1ffe5-247">A lefordított modell átadásra kerül.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-247">The compiled model will be passed on.</span></span> |
| <span data-ttu-id="1ffe5-248">MyContext (ObjectContext, bool)</span><span class="sxs-lookup"><span data-stu-id="1ffe5-248">MyContext(ObjectContext, bool)</span></span> |<span data-ttu-id="1ffe5-249">ElasticScaleContext (ShardMap, TKey, ObjectContext, bool)</span><span class="sxs-lookup"><span data-stu-id="1ffe5-249">ElasticScaleContext(ShardMap, TKey, ObjectContext, bool)</span></span> |<span data-ttu-id="1ffe5-250">DbContext (ObjectContext, bool)</span><span class="sxs-lookup"><span data-stu-id="1ffe5-250">DbContext(ObjectContext, bool)</span></span> |<span data-ttu-id="1ffe5-251">Gondoskodjon arról, hogy a kapcsolat a adatként az ObjectContext objektumban található átirányítását kezeli a rugalmas bővítést kapcsolatra kell az új konstruktor.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-251">The new constructor needs to ensure that any connection in the ObjectContext passed as an input is re-routed to a connection managed by Elastic Scale.</span></span> <span data-ttu-id="1ffe5-252">Részletes leírását az ObjectContexts nem a jelen dokumentum terjed.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-252">A detailed discussion of ObjectContexts is beyond the scope of this document.</span></span> |
| <span data-ttu-id="1ffe5-253">MyContext (DbConnection, DbCompiledModel, logikai)</span><span class="sxs-lookup"><span data-stu-id="1ffe5-253">MyContext(DbConnection, DbCompiledModel,bool)</span></span> |<span data-ttu-id="1ffe5-254">ElasticScaleContext (ShardMap, TKey, DbCompiledModel, bool)</span><span class="sxs-lookup"><span data-stu-id="1ffe5-254">ElasticScaleContext(ShardMap, TKey, DbCompiledModel, bool)</span></span> |<span data-ttu-id="1ffe5-255">DbContext (DbConnection, DbCompiledModel, logikai);</span><span class="sxs-lookup"><span data-stu-id="1ffe5-255">DbContext(DbConnection, DbCompiledModel, bool);</span></span> |<span data-ttu-id="1ffe5-256">A kapcsolat kell következtethető ki a shard térkép és a kulcsot.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-256">The connection needs to be inferred from the shard map and the key.</span></span> <span data-ttu-id="1ffe5-257">A kapcsolat nem adható meg bemenetként (kivéve, ha a bemenetet a shard térkép és a kulcs már használja).</span><span class="sxs-lookup"><span data-stu-id="1ffe5-257">The connection cannot be provided as an input (unless that input was already using the shard map and the key).</span></span> <span data-ttu-id="1ffe5-258">Modell és a logikai átadott a alaposztály konstruktor.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-258">Model and Boolean are passed on to the base class constructor.</span></span> |

## <a name="shard-schema-deployment-through-ef-migrations"></a><span data-ttu-id="1ffe5-259">A shard séma telepítési keresztül EF-áttelepítések</span><span class="sxs-lookup"><span data-stu-id="1ffe5-259">Shard schema deployment through EF migrations</span></span>
<span data-ttu-id="1ffe5-260">Automatikus séma kezelésére szolgál az Entity Framework által biztosított, a könnyebb elérhetőség érdekében.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-260">Automatic schema management is a convenience provided by the Entity Framework.</span></span> <span data-ttu-id="1ffe5-261">A rugalmas adatbázis-eszközt használó alkalmazások a környezetben azt szeretnénk megőrizni ezt a képességet, hogy automatikusan kiépítést biztosítson a sémát, hogy az újonnan létrehozott szilánkok adatbázisok a szilánkos alkalmazás hozzáadásakor.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-261">In the context of applications using elastic database tools, we want to retain this capability to automatically provision the schema to newly created shards when databases are added to the sharded application.</span></span> <span data-ttu-id="1ffe5-262">Az elsődleges használati eset az adatréteg szilánkos alkalmazásokhoz EF-kapacitás növelése érdekében.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-262">The primary use case is to increase capacity at the data tier for sharded applications using EF.</span></span> <span data-ttu-id="1ffe5-263">Séma felügyeleti képességeket EF-EK hagyatkoznia csökkenti az adatbázis-felügyeleti elérhető EF épülő szilánkos alkalmazással.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-263">Relying on EF’s capabilities for schema management reduces the database administration effort with a sharded application built on EF.</span></span> 

<span data-ttu-id="1ffe5-264">Séma telepítési EF áttelepítések keresztül működik a legjobban a **ilyen formában kapcsolatok**.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-264">Schema deployment through EF migrations works best on **unopened connections**.</span></span> <span data-ttu-id="1ffe5-265">Ez az ellentétben a forgatókönyvet, az adatok függő útválasztási, amely a megnyitott kapcsolat, a rugalmas adatbázis-ügyfél API által megadott támaszkodik.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-265">This is in contrast to the scenario for data dependent routing that relies on the opened connection provided by the elastic database client API.</span></span> <span data-ttu-id="1ffe5-266">Egy másik különbség a konzisztencia-követelményt: az összes adat-függő útválasztási kapcsolathoz egyidejű shard térkép adatkezelési elleni védelem érdekében konzisztencia biztosításához szükséges, miközben még nincs egy probléma, amely az új adatbázist, amelyen még nincs regisztrálva a shard leképezés, és még nincs lefoglalva a shardlets tartsa a kezdeti séma központi telepítéshez.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-266">Another difference is the consistency requirement: While desirable to ensure consistency for all data-dependent routing connections to protect against concurrent shard map manipulation, it is not a concern with initial schema deployment to a new database that has not yet been registered in the shard map, and not yet been allocated to hold shardlets.</span></span> <span data-ttu-id="1ffe5-267">Ezért azt is támaszkodnak rendszeres adatbázis-kapcsolatok a forgatókönyvek esetén adatok függő útválasztási szemben.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-267">We can therefore rely on regular database connections for this scenarios, as opposed to data-dependent routing.</span></span>  

<span data-ttu-id="1ffe5-268">Ennek eredménye egy megközelítésre ahol séma telepítési keresztül EF áttelepítések szorosan együtt használja a regisztrációját, az új adatbázis, az alkalmazás shard leképezés a szilánkcímtárban.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-268">This leads to an approach where schema deployment through EF migrations is tightly coupled with the registration of the new database as a shard in the application’s shard map.</span></span> <span data-ttu-id="1ffe5-269">Ez a következő előfeltételek támaszkodik:</span><span class="sxs-lookup"><span data-stu-id="1ffe5-269">This relies on the following prerequisites:</span></span> 

* <span data-ttu-id="1ffe5-270">Az adatbázis már létezik.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-270">The database has already been created.</span></span> 
* <span data-ttu-id="1ffe5-271">Az adatbázis - magánál tartja nincs felhasználói séma és a nem felhasználói adatokat.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-271">The database is empty - it holds no user schema and no user data.</span></span>
* <span data-ttu-id="1ffe5-272">Az adatbázis nem még elérhetőek a rugalmas adatbázis-ügyfél API-k az adatok függő továbbításához.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-272">The database cannot yet be accessed through the elastic database client APIs for data-dependent routing.</span></span> 

<span data-ttu-id="1ffe5-273">Az előfeltételek teljesülnek, a szokványos létrehozhatjuk megbízhatatlan megnyitott **SqlConnection** az EF áttelepítések séma telepítéshez indítsa.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-273">With these prerequisites in place, we can create a regular un-opened **SqlConnection** to kick off EF migrations for schema deployment.</span></span> <span data-ttu-id="1ffe5-274">A következő példakód azt szemlélteti, hogy ezt a módszert használja.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-274">The following code sample illustrates this approach.</span></span> 

        // Enter a new shard - i.e. an empty database - to the shard map, allocate a first tenant to it  
        // and kick off EF intialization of the database to deploy schema 

        public void RegisterNewShard(string server, string database, string connStr, int key) 
        { 

            Shard shard = this.ShardMap.CreateShard(new ShardLocation(server, database)); 

            SqlConnectionStringBuilder connStrBldr = new SqlConnectionStringBuilder(connStr); 
            connStrBldr.DataSource = server; 
            connStrBldr.InitialCatalog = database; 

            // Go into a DbContext to trigger migrations and schema deployment for the new shard. 
            // This requires an un-opened connection. 
            using (var db = new ElasticScaleContext<int>(connStrBldr.ConnectionString)) 
            { 
                // Run a query to engage EF migrations 
                (from b in db.Blogs 
                    select b).Count(); 
            } 

            // Register the mapping of the tenant to the shard in the shard map. 
            // After this step, data-dependent routing on the shard map can be used 

            this.ShardMap.CreatePointMapping(key, shard); 
        } 


<span data-ttu-id="1ffe5-275">Ez a példa bemutatja a metódus **RegisterNewShard** , amely a shard regisztrálja a shard térkép, telepíti a séma EF áttelepítések és egy egy horizontális skálázási kulccsal, hogy a szilánkok leképezése tárolja.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-275">This sample shows the method **RegisterNewShard** that registers the shard in the shard map, deploys the schema through EF migrations, and stores a mapping of a sharding key to the shard.</span></span> <span data-ttu-id="1ffe5-276">A konstruktor támaszkodnak a **DbContext** alosztály (**ElasticScaleContext** minta) bemenetként SQL kapcsolati karakterlánc időt vesz igénybe.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-276">It relies on a constructor of the **DbContext** subclass (**ElasticScaleContext** in the sample) that takes a SQL connection string as input.</span></span> <span data-ttu-id="1ffe5-277">Ez a konstruktor kódját a következő egyszerű feladat, az alábbi példában látható módon:</span><span class="sxs-lookup"><span data-stu-id="1ffe5-277">The code of this constructor is straight-forward, as the following example shows:</span></span> 

        // C'tor to deploy schema and migrations to a new shard 
        protected internal ElasticScaleContext(string connectionString) 
            : base(SetInitializerForConnection(connectionString)) 
        { 
        } 

        // Only static methods are allowed in calls into base class c'tors 
        private static string SetInitializerForConnection(string connnectionString) 
        { 
            // We want existence checks so that the schema can get deployed 
            Database.SetInitializer<ElasticScaleContext<T>>( 
        new CreateDatabaseIfNotExists<ElasticScaleContext<T>>()); 

            return connnectionString; 
        } 

<span data-ttu-id="1ffe5-278">Előfordulhat, hogy egy használt a konstruktort az alaposztály öröklődik verzióját.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-278">One might have used the version of the constructor inherited from the base class.</span></span> <span data-ttu-id="1ffe5-279">De a kódot kell ellenőrizze, hogy az alapértelmezett inicializáló EF a kapcsolódáskor használja-e.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-279">But the code needs to ensure that the default initializer for EF is used when connecting.</span></span> <span data-ttu-id="1ffe5-280">Ezért a rövid detour be a statikus metódus az alaposztály konstruktornak a megadott kapcsolati karakterlánccal hívása előtt.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-280">Hence the short detour into the static method before calling into the base class constructor with the connection string.</span></span> <span data-ttu-id="1ffe5-281">Vegye figyelembe, hogy a regisztráció a szilánkok futtasson-e az eltérő alkalmazástartományból vagy folyamat végrehajtásával biztosítható, hogy nem ütköznek-EF inicializáló beállításait.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-281">Note that the registration of shards should run in a different app domain or process to ensure that the initializer settings for EF do not conflict.</span></span> 

## <a name="limitations"></a><span data-ttu-id="1ffe5-282">Korlátozások</span><span class="sxs-lookup"><span data-stu-id="1ffe5-282">Limitations</span></span>
<span data-ttu-id="1ffe5-283">A jelen dokumentumban ismertetett módszerekkel néhány korlátozásokkal jár:</span><span class="sxs-lookup"><span data-stu-id="1ffe5-283">The approaches outlined in this document entail a couple of limitations:</span></span> 

* <span data-ttu-id="1ffe5-284">EF használó alkalmazások **LocalDb** először át kell térnie az SQL Server-adatbázis rendszeres elastic database ügyféloldali kódtár használata előtt.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-284">EF applications that use **LocalDb** first need to migrate to a regular SQL Server database before using elastic database client library.</span></span> <span data-ttu-id="1ffe5-285">A rugalmas bővítést ki egy alkalmazást a horizontális skálázás nincs lehetőség a **LocalDb**.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-285">Scaling out an application through sharding with Elastic Scale is not possible with **LocalDb**.</span></span> <span data-ttu-id="1ffe5-286">Vegye figyelembe, hogy fejlesztési továbbra is használhatja **LocalDb**.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-286">Note that development can still use **LocalDb**.</span></span> 
* <span data-ttu-id="1ffe5-287">A módosításokat a, amelyek azt sugallják adatbázis sémamódosítások érdekében át kell haladnia EF áttelepítések minden szegmensben osztják meg.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-287">Any changes to the application that imply database schema changes need to go through EF migrations on all shards.</span></span> <span data-ttu-id="1ffe5-288">A mintakód a dokumentum nem bemutatják, hogyan lehet ezt.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-288">The sample code for this document does not demonstrate how to do this.</span></span> <span data-ttu-id="1ffe5-289">Érdemes lehet az adatbázis-frissítés a ConnectionString paraméterrel az összes szilánkok; ismétlés a T-SQL-parancsfájlt a függőben lévő áttelepítési adatbázis-frissítés használatával, illetve a - parancsfájllal lehetőséget, majd a T-SQL-parancsfájl a szilánkok vonatkoznak.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-289">Consider using Update-Database with a ConnectionString parameter to iterate over all shards; or extract the T-SQL script for the pending migration using Update-Database with the -Script option and apply the T-SQL script to your shards.</span></span>  
* <span data-ttu-id="1ffe5-290">A kérelemben megadott, feltételezzük, hogy az adatbázis-feldolgozási mindegyikét tartalmazza egyetlen shard a kérelem által biztosított horizontális kulcs által meghatározott.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-290">Given a request, it is assumed that all of its database processing is contained within a single shard as identified by the sharding key provided by the request.</span></span> <span data-ttu-id="1ffe5-291">Azonban ez a feltételezés nem mindig tartsa igaz.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-291">However, this assumption does not always hold true.</span></span> <span data-ttu-id="1ffe5-292">Például, ha nincs lehetőség egy horizontális skálázási kulcs elérhetővé.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-292">For example, when it is not possible to make a sharding key available.</span></span> <span data-ttu-id="1ffe5-293">A probléma orvoslása érdekében az ügyféloldali kódtár biztosít a **MultiShardQuery** osztály, amely a kapcsolat absztrakciós több szilánkok keresztül lekérdezése.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-293">To address this, the client library provides the **MultiShardQuery** class that implements a connection abstraction for querying over several shards.</span></span> <span data-ttu-id="1ffe5-294">Teszi használatát a **MultiShardQuery** EF együtt nem terjed a jelen dokumentum</span><span class="sxs-lookup"><span data-stu-id="1ffe5-294">Learning to use the **MultiShardQuery** in combination with EF is beyond the scope of this document</span></span>

## <a name="conclusion"></a><span data-ttu-id="1ffe5-295">Összegzés</span><span class="sxs-lookup"><span data-stu-id="1ffe5-295">Conclusion</span></span>
<span data-ttu-id="1ffe5-296">Ebben a dokumentumban leírt lépéseket, keresztül EF alkalmazások a rugalmas adatbázis ügyféloldali kódtár funkció segítségével az adatok függő konstruktora újrabontása útválasztást a **DbContext** alosztályok az EF alkalmazásban használt.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-296">Through the steps outlined in this document, EF applications can use the elastic database client library's capability for data dependent routing by refactoring constructors of the **DbContext** subclasses used in the EF application.</span></span> <span data-ttu-id="1ffe5-297">Ez csökkenti a helyek szükséges módosításokat ahol **DbContext** osztályok már léteznek.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-297">This limits the  changes required to those places where **DbContext** classes already exist.</span></span> <span data-ttu-id="1ffe5-298">Emellett EF alkalmazások továbbra is a lépéseket, amelyek a szükséges EF áttelepítések regisztrációját új szilánkok és a shard térkép tartalmazó meghívása kombinálásával automatikus séma telepítési kihasználhassa.</span><span class="sxs-lookup"><span data-stu-id="1ffe5-298">In addition, EF applications can continue to benefit from automatic schema deployment by combining the steps that invoke the necessary EF migrations with the registration of new shards and mappings in the shard map.</span></span> 

[!INCLUDE [elastic-scale-include](../../includes/elastic-scale-include.md)]

<!--Image references-->
[1]: ./media/sql-database-elastic-scale-use-entity-framework-applications-visual-studio/sample.png
