---
title: Azure Redis Cache aaaHow tootroubleshoot |} Microsoft Docs
description: "Ismerje meg, hogyan tooresolve közös Azure Redis Cache érintő problémákat."
services: redis-cache
documentationcenter: 
author: steved0x
manager: douge
editor: 
ms.assetid: 928b9b9c-d64f-4252-884f-af7ba8309af6
ms.service: cache
ms.workload: tbd
ms.tgt_pltfrm: cache-redis
ms.devlang: na
ms.topic: article
ms.date: 01/06/2017
ms.author: sdanie
ms.openlocfilehash: 4e736fce2b6d5200a2a8d802f3f1384b63458cab
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 10/06/2017
---
# <a name="how-tootroubleshoot-azure-redis-cache"></a><span data-ttu-id="a6229-103">Hogyan tootroubleshoot Azure Redis Cache-gyorsítótár</span><span class="sxs-lookup"><span data-stu-id="a6229-103">How tootroubleshoot Azure Redis Cache</span></span>
<span data-ttu-id="a6229-104">Ez a cikk a következő kategóriák Azure Redis Cache problémák hello iránymutatásokat tartalmaz.</span><span class="sxs-lookup"><span data-stu-id="a6229-104">This article provides guidance for troubleshooting hello following categories of Azure Redis Cache issues.</span></span>

* <span data-ttu-id="a6229-105">[Ügyfél oldal hibaelhárítási](#client-side-troubleshooting) – Ez a szakasz útmutatást nyújt azonosítására és csatlakozás tooAzure Redis Cache hello alkalmazás által okozott problémák megoldása.</span><span class="sxs-lookup"><span data-stu-id="a6229-105">[Client side troubleshooting](#client-side-troubleshooting) - This section provides guidelines on identifying and resolving issues caused by hello application connecting tooAzure Redis Cache.</span></span>
* <span data-ttu-id="a6229-106">[Kiszolgáló oldal hibaelhárítási](#server-side-troubleshooting) – Ez a szakasz útmutatást nyújt azonosítására és okozott problémák megoldása a hello Azure Redis Cache kiszolgálóoldali.</span><span class="sxs-lookup"><span data-stu-id="a6229-106">[Server side troubleshooting](#server-side-troubleshooting) - This section provides guidelines on identifying and resolving issues caused on hello Azure Redis Cache server side.</span></span>
* <span data-ttu-id="a6229-107">[Időtúllépési kivételek StackExchange.Redis](#stackexchangeredis-timeout-exceptions) – Ez a szakasz tájékoztatást nyújt hello StackExchange.Redis ügyfél használatával kapcsolatos hibák elhárítása.</span><span class="sxs-lookup"><span data-stu-id="a6229-107">[StackExchange.Redis timeout exceptions](#stackexchangeredis-timeout-exceptions) - This section provides information on troubleshooting issues when using hello StackExchange.Redis client.</span></span>

> [!NOTE]
> <span data-ttu-id="a6229-108">Utasításokat toorun Redis parancsokat, és figyelje a teljesítménymutatók hello hibaelhárítási lépések útmutatóban számos tartalmaznak.</span><span class="sxs-lookup"><span data-stu-id="a6229-108">Several of hello troubleshooting steps in this guide include instructions toorun Redis commands and monitor various performance metrics.</span></span> <span data-ttu-id="a6229-109">További információt és útmutatást lásd: hello hello cikkek [további információt](#additional-information) szakasz.</span><span class="sxs-lookup"><span data-stu-id="a6229-109">For more information and instructions, see hello articles in hello [Additional information](#additional-information) section.</span></span>
> 
> 

## <a name="client-side-troubleshooting"></a><span data-ttu-id="a6229-110">Ügyfél oldali hibaelhárítása</span><span class="sxs-lookup"><span data-stu-id="a6229-110">Client side troubleshooting</span></span>
<span data-ttu-id="a6229-111">Ez a szakasz ismerteti a hibaelhárítási problémák, amelyek miatt hello ügyfélalkalmazás vonatkozó feltétellel.</span><span class="sxs-lookup"><span data-stu-id="a6229-111">This section discusses troubleshooting issues that occur because of a condition on hello client application.</span></span>

* [<span data-ttu-id="a6229-112">Memóriaprobléma hello ügyfélen</span><span class="sxs-lookup"><span data-stu-id="a6229-112">Memory pressure on hello client</span></span>](#memory-pressure-on-the-client)
* [<span data-ttu-id="a6229-113">A forgalom kapacitásnövelés</span><span class="sxs-lookup"><span data-stu-id="a6229-113">Burst of traffic</span></span>](#burst-of-traffic)
* [<span data-ttu-id="a6229-114">Magas ügyfél CPU-használat</span><span class="sxs-lookup"><span data-stu-id="a6229-114">High client CPU usage</span></span>](#high-client-cpu-usage)
* [<span data-ttu-id="a6229-115">Ügyfél oldali sávszélesség túllépve</span><span class="sxs-lookup"><span data-stu-id="a6229-115">Client Side Bandwidth Exceeded</span></span>](#client-side-bandwidth-exceeded)
* [<span data-ttu-id="a6229-116">Nagy méretű kérelem/válasz mérete</span><span class="sxs-lookup"><span data-stu-id="a6229-116">Large Request/Response Size</span></span>](#large-requestresponse-size)
* [<span data-ttu-id="a6229-117">A Redis toomy történt adatok?</span><span class="sxs-lookup"><span data-stu-id="a6229-117">What happened toomy data in Redis?</span></span>](#what-happened-to-my-data-in-redis)

### <a name="memory-pressure-on-hello-client"></a><span data-ttu-id="a6229-118">Memóriaprobléma hello ügyfélen</span><span class="sxs-lookup"><span data-stu-id="a6229-118">Memory pressure on hello client</span></span>
#### <a name="problem"></a><span data-ttu-id="a6229-119">Probléma</span><span class="sxs-lookup"><span data-stu-id="a6229-119">Problem</span></span>
<span data-ttu-id="a6229-120">Memóriaprobléma hello ügyfélszámítógépen vezet, hogy késedelem nélkül hello Redis-példány által küldött adatok feldolgozása késleltetheti-e teljesítményproblémákat tooall típusú.</span><span class="sxs-lookup"><span data-stu-id="a6229-120">Memory pressure on hello client machine leads tooall kinds of performance problems that can delay processing of data that was sent by hello Redis instance without any delay.</span></span> <span data-ttu-id="a6229-121">Amikor Memóriaterhelést találatok, hello a rendszer általában van toopage adatokat a fizikai memória toovirtual memóriából, amely a lemezen.</span><span class="sxs-lookup"><span data-stu-id="a6229-121">When memory pressure hits, hello system typically has toopage data from physical memory toovirtual memory which is on disk.</span></span> <span data-ttu-id="a6229-122">Ez *lap hibás* okok hello rendszer tooslow le jelentősen.</span><span class="sxs-lookup"><span data-stu-id="a6229-122">This *page faulting* causes hello system tooslow down significantly.</span></span>

#### <a name="measurement"></a><span data-ttu-id="a6229-123">Mérési</span><span class="sxs-lookup"><span data-stu-id="a6229-123">Measurement</span></span>
1. <span data-ttu-id="a6229-124">Gép toomake meg arról, hogy azt nem haladja meg a rendelkezésre álló memória figyelése.</span><span class="sxs-lookup"><span data-stu-id="a6229-124">Monitor memory usage on machine toomake sure that it does not exceed available memory.</span></span> 
2. <span data-ttu-id="a6229-125">A figyelő hello `Page Faults/Sec` teljesítményszámláló.</span><span class="sxs-lookup"><span data-stu-id="a6229-125">Monitor hello `Page Faults/Sec` performance counter.</span></span> <span data-ttu-id="a6229-126">Rendszerek többsége fog néhány laphibák normál működés során, akkor is, a teljesítményt a lapon hibák teljesítményszámláló időtúllépések, amely így figyelendő.</span><span class="sxs-lookup"><span data-stu-id="a6229-126">Most systems will have some page faults even during normal operation, so watch for spikes in this page faults performance counter which correspond with timeouts.</span></span>

#### <a name="resolution"></a><span data-ttu-id="a6229-127">Megoldás:</span><span class="sxs-lookup"><span data-stu-id="a6229-127">Resolution</span></span>
<span data-ttu-id="a6229-128">Frissítse az ügyfél tooa nagyobb ügyfél Virtuálisgép-méretet több memória, vagy a memória használati minták tooreduce memória consuption a dig.</span><span class="sxs-lookup"><span data-stu-id="a6229-128">Upgrade your client tooa larger client VM size with more memory or dig into your memory usage patterns tooreduce memory consuption.</span></span>

### <a name="burst-of-traffic"></a><span data-ttu-id="a6229-129">A forgalom kapacitásnövelés</span><span class="sxs-lookup"><span data-stu-id="a6229-129">Burst of traffic</span></span>
#### <a name="problem"></a><span data-ttu-id="a6229-130">Probléma</span><span class="sxs-lookup"><span data-stu-id="a6229-130">Problem</span></span>
<span data-ttu-id="a6229-131">A forgalom felszakadásáig gyenge együtt `ThreadPool` beállítások adatfeldolgozás már hello Redis-kiszolgáló által küldött, de még nem használt hello ügyféloldalon késést okozhat.</span><span class="sxs-lookup"><span data-stu-id="a6229-131">Bursts of traffic combined with poor `ThreadPool` settings can result in delays in processing data already sent by hello Redis Server but not yet consumed on hello client side.</span></span>

#### <a name="measurement"></a><span data-ttu-id="a6229-132">Mérési</span><span class="sxs-lookup"><span data-stu-id="a6229-132">Measurement</span></span>
<span data-ttu-id="a6229-133">A figyelő hogyan a `ThreadPool` statisztika kóddal időbeli változását [, például a](https://github.com/JonCole/SampleCode/blob/master/ThreadPoolMonitor/ThreadPoolLogger.cs).</span><span class="sxs-lookup"><span data-stu-id="a6229-133">Monitor how your `ThreadPool` statistics change over time using code [like this](https://github.com/JonCole/SampleCode/blob/master/ThreadPoolMonitor/ThreadPoolLogger.cs).</span></span> <span data-ttu-id="a6229-134">Is megtalálhatja hello `TimeoutException` StackExchange.Redis üzenetét.</span><span class="sxs-lookup"><span data-stu-id="a6229-134">You can also look at hello `TimeoutException` message from StackExchange.Redis.</span></span> <span data-ttu-id="a6229-135">Íme egy példa:</span><span class="sxs-lookup"><span data-stu-id="a6229-135">Here is an example :</span></span>

    System.TimeoutException: Timeout performing EVAL, inst: 8, mgr: Inactive, queue: 0, qu: 0, qs: 0, qc: 0, wr: 0, wq: 0, in: 64221, ar: 0, 
    IOCP: (Busy=6,Free=999,Min=2,Max=1000), WORKER: (Busy=7,Free=8184,Min=2,Max=8191)

<span data-ttu-id="a6229-136">A fenti üzenet hello van néhány problémákra, amelyek a érdekes:</span><span class="sxs-lookup"><span data-stu-id="a6229-136">In hello above message, there are several issues that are interesting:</span></span>

1. <span data-ttu-id="a6229-137">Figyelje meg, hogy a hello `IOCP` szakasz és hello `WORKER` szakasz rendelkezik egy `Busy` érték, amely nagyobb, mint hello `Min` érték.</span><span class="sxs-lookup"><span data-stu-id="a6229-137">Notice that in hello `IOCP` section and hello `WORKER` section you have a `Busy` value that is greater than hello `Min` value.</span></span> <span data-ttu-id="a6229-138">Ez azt jelenti, hogy a `ThreadPool` beállításait kell hangolását.</span><span class="sxs-lookup"><span data-stu-id="a6229-138">This means that your `ThreadPool` settings need adjusting.</span></span>
2. <span data-ttu-id="a6229-139">Azt is láthatja, `in: 64221`.</span><span class="sxs-lookup"><span data-stu-id="a6229-139">You can also see `in: 64221`.</span></span> <span data-ttu-id="a6229-140">Ez azt jelzi, hogy 64211 bájt hello kernel szoftvercsatorna-réteg nem érkezett, de még nem hello alkalmazás (pl. StackExchange.Redis) beolvasva.</span><span class="sxs-lookup"><span data-stu-id="a6229-140">This indicates that 64211 bytes have been received at hello kernel socket layer but haven't yet been read by hello application (e.g. StackExchange.Redis).</span></span> <span data-ttu-id="a6229-141">Ez általában azt jelenti, hogy az alkalmazás nem adatok beolvasása hello hálózati gyorsan hello kiszolgáló küld az tooyou.</span><span class="sxs-lookup"><span data-stu-id="a6229-141">This typically means that your application isn't reading data from hello network as quickly as hello server is sending it tooyou.</span></span>

#### <a name="resolution"></a><span data-ttu-id="a6229-142">Megoldás:</span><span class="sxs-lookup"><span data-stu-id="a6229-142">Resolution</span></span>
<span data-ttu-id="a6229-143">Konfigurálja a [ThreadPool beállítások](https://gist.github.com/JonCole/e65411214030f0d823cb) meg arról, hogy a szálkészlet gyorsan, a rendszer növelheti toomake kapacitásnövelés forgatókönyvek.</span><span class="sxs-lookup"><span data-stu-id="a6229-143">Configure your [ThreadPool Settings](https://gist.github.com/JonCole/e65411214030f0d823cb) toomake sure that your thread pool will scale up quickly under burst scenarios.</span></span>

### <a name="high-client-cpu-usage"></a><span data-ttu-id="a6229-144">Magas ügyfél CPU-használat</span><span class="sxs-lookup"><span data-stu-id="a6229-144">High client CPU usage</span></span>
#### <a name="problem"></a><span data-ttu-id="a6229-145">Probléma</span><span class="sxs-lookup"><span data-stu-id="a6229-145">Problem</span></span>
<span data-ttu-id="a6229-146">Magas CPU-használat a hello ügyfél jelzi, hogy hello rendszer nem tud lépést tartani, hogy kérték tooperform hello munkával.</span><span class="sxs-lookup"><span data-stu-id="a6229-146">High CPU usage on hello client is an indication that hello system cannot keep up with hello work that it has been asked tooperform.</span></span> <span data-ttu-id="a6229-147">Ennek következménye, hogy az ügyfél hello tooprocess Redis időben választ annak ellenére, hogy a Redis nagyon gyorsan hello választ küldött.</span><span class="sxs-lookup"><span data-stu-id="a6229-147">This means that hello client may fail tooprocess a response from Redis in a timely fashion even though Redis sent hello response very quickly.</span></span>

#### <a name="measurement"></a><span data-ttu-id="a6229-148">Mérési</span><span class="sxs-lookup"><span data-stu-id="a6229-148">Measurement</span></span>
<span data-ttu-id="a6229-149">A figyelő hello rendszer nagy CPU-használat hello vagy hello Azure portálon keresztül kapcsolódó teljesítményszámláló.</span><span class="sxs-lookup"><span data-stu-id="a6229-149">Monitor hello System Wide CPU usage through hello Azure Portal or through hello associated performance counter.</span></span> <span data-ttu-id="a6229-150">Legyen óvatos nem toomonitor *folyamat* CPU mivel egyetlen folyamat alacsony CPU-használat: hello azonos időt, hogy a rendszer általános CPU magas lehet.</span><span class="sxs-lookup"><span data-stu-id="a6229-150">Be careful not toomonitor *process* CPU because a single process can have low CPU usage at hello same time that overall system CPU can be high.</span></span> <span data-ttu-id="a6229-151">A CPU-használat teljesítményt, amelyek megfelelnek a időtúllépések figyelje.</span><span class="sxs-lookup"><span data-stu-id="a6229-151">Watch for spikes in CPU usage that correspond with timeouts.</span></span> <span data-ttu-id="a6229-152">Magas CPU miatt is találkozhat magas `in: XXX` értékei `TimeoutException` hibaüzenet hello leírtak [forgalom kapacitásnövelés](#burst-of-traffic) szakasz.</span><span class="sxs-lookup"><span data-stu-id="a6229-152">As a result of high CPU, you may also see high `in: XXX` values in `TimeoutException` error messages as described in hello [Burst of traffic](#burst-of-traffic) section.</span></span>

> [!NOTE]
> <span data-ttu-id="a6229-153">StackExchange.Redis 1.1.603 és később is hello `local-cpu` a metrika `TimeoutException` hibaüzenetek.</span><span class="sxs-lookup"><span data-stu-id="a6229-153">StackExchange.Redis 1.1.603 and later includes hello `local-cpu` metric in `TimeoutException` error messages.</span></span> <span data-ttu-id="a6229-154">Győződjön meg arról, hogy hello hello legújabb verzióját használja [StackExchange.Redis NuGet-csomag](https://www.nuget.org/packages/StackExchange.Redis/).</span><span class="sxs-lookup"><span data-stu-id="a6229-154">Ensure you using hello latest version of hello [StackExchange.Redis NuGet package](https://www.nuget.org/packages/StackExchange.Redis/).</span></span> <span data-ttu-id="a6229-155">Nincsenek hibák folyamatosan alatt kijavította a hello kód toomake robusztusabb tootimeouts hello legújabb verzióját, akkor fontos.</span><span class="sxs-lookup"><span data-stu-id="a6229-155">There are bugs constantly being fixed in hello code toomake it more robust tootimeouts so having hello latest version is important.</span></span>
> 
> 

#### <a name="resolution"></a><span data-ttu-id="a6229-156">Megoldás:</span><span class="sxs-lookup"><span data-stu-id="a6229-156">Resolution</span></span>
<span data-ttu-id="a6229-157">Frissítse a virtuális gép méretének tooa további CPU-kapacitással rendelkező átjáróeszközt, vagy vizsgálja meg, mi okozza a CPU-teljesítményt.</span><span class="sxs-lookup"><span data-stu-id="a6229-157">Upgrade tooa larger VM size with more CPU capacity or investigate what is causing CPU spikes.</span></span> 

### <a name="client-side-bandwidth-exceeded"></a><span data-ttu-id="a6229-158">Ügyfél oldali sávszélesség túllépve</span><span class="sxs-lookup"><span data-stu-id="a6229-158">Client side bandwidth exceeded</span></span>
#### <a name="problem"></a><span data-ttu-id="a6229-159">Probléma</span><span class="sxs-lookup"><span data-stu-id="a6229-159">Problem</span></span>
<span data-ttu-id="a6229-160">Különböző méretű ügyfélgépek korlátozásokkal rendelkezik mekkora hálózati sávszélességre gyakorolt rendelkeznek érhető el.</span><span class="sxs-lookup"><span data-stu-id="a6229-160">Different sized client machines have limitations on how much network bandwidth they have available.</span></span> <span data-ttu-id="a6229-161">Ha hello ügyfél meghaladja a rendelkezésre álló sávszélesség hello, majd adatok nem fogja feldolgozni hello ügyféloldalon gyorsan hello server küld.</span><span class="sxs-lookup"><span data-stu-id="a6229-161">If hello client exceeds hello available bandwidth, then data will not be processed on hello client side as quickly as hello server is sending it.</span></span> <span data-ttu-id="a6229-162">Ennek eredményeképpen előfordulhat tootimeouts.</span><span class="sxs-lookup"><span data-stu-id="a6229-162">This can lead tootimeouts.</span></span>

#### <a name="measurement"></a><span data-ttu-id="a6229-163">Mérési</span><span class="sxs-lookup"><span data-stu-id="a6229-163">Measurement</span></span>
<span data-ttu-id="a6229-164">Figyelje meg, hogyan a sávszélesség-használat idővel kód használatával módosítani [, például a](https://github.com/JonCole/SampleCode/blob/master/BandWidthMonitor/BandwidthLogger.cs).</span><span class="sxs-lookup"><span data-stu-id="a6229-164">Monitor how your Bandwidth usage change over time using code [like this](https://github.com/JonCole/SampleCode/blob/master/BandWidthMonitor/BandwidthLogger.cs).</span></span> <span data-ttu-id="a6229-165">Vegye figyelembe, hogy ez a kód nem futtatható az sikeresen bizonyos környezetekben (például az Azure webhelyek) korlátozott engedélyekkel.</span><span class="sxs-lookup"><span data-stu-id="a6229-165">Note that this code may not run successfully in some environments with restricted permissions (like Azure web sites).</span></span>

#### <a name="resolution"></a><span data-ttu-id="a6229-166">Megoldás:</span><span class="sxs-lookup"><span data-stu-id="a6229-166">Resolution</span></span>
<span data-ttu-id="a6229-167">Növelje az ügyfél virtuális gép méretét, vagy csökkentse a hálózati sávszélességet.</span><span class="sxs-lookup"><span data-stu-id="a6229-167">Increase Client VM size or reduce network bandwidth consumption.</span></span>

### <a name="large-requestresponse-size"></a><span data-ttu-id="a6229-168">Nagy méretű kérelem/válasz mérete</span><span class="sxs-lookup"><span data-stu-id="a6229-168">Large Request/Response Size</span></span>
#### <a name="problem"></a><span data-ttu-id="a6229-169">Probléma</span><span class="sxs-lookup"><span data-stu-id="a6229-169">Problem</span></span>
<span data-ttu-id="a6229-170">A nagy méretű kérelem/válasz időtúllépések okozhat.</span><span class="sxs-lookup"><span data-stu-id="a6229-170">A large request/response can cause timeouts.</span></span> <span data-ttu-id="a6229-171">Tegyük fel tegyük fel, hogy az időkorlát az ügyfélhez konfigurált értéke 1 másodperc.</span><span class="sxs-lookup"><span data-stu-id="a6229-171">As an example, Suppose your timeout value configured on your client is 1 second.</span></span> <span data-ttu-id="a6229-172">Az alkalmazás (pl. kér két kulcs "A" és "B"): hello egy időben (azonos fizikai hálózati kapcsolat hello használata).</span><span class="sxs-lookup"><span data-stu-id="a6229-172">Your application requests two keys (e.g. 'A' and 'B') at hello same time (using hello same physical network connection).</span></span> <span data-ttu-id="a6229-173">A legtöbb ügyfél támogatja a "Pipelining" kérelmek, úgy, hogy mindkét kérések "A" és "B" érkeznek hello vezetékes toohello kiszolgálón egy hello után más hello válaszok várakozás nélkül.</span><span class="sxs-lookup"><span data-stu-id="a6229-173">Most clients support "Pipelining" of requests, such that both requests 'A' and 'B' are sent on hello wire toohello server one after hello other without waiting for hello responses.</span></span> <span data-ttu-id="a6229-174">hello server küldi hello válaszokhoz hello az azonos sorrendje.</span><span class="sxs-lookup"><span data-stu-id="a6229-174">hello server will send hello responses back in hello same order.</span></span> <span data-ttu-id="a6229-175">Ha a válasz "A" nagy elég azt is keleti-afrikai hello időtúllépés további kérelmeknél leggyakrabban.</span><span class="sxs-lookup"><span data-stu-id="a6229-175">If response 'A' is large enough it can eat up most of hello timeout for subsequent requests.</span></span> 

<span data-ttu-id="a6229-176">hello a következő példa bemutatja, ebben a forgatókönyvben.</span><span class="sxs-lookup"><span data-stu-id="a6229-176">hello following example demonstrates this scenario.</span></span> <span data-ttu-id="a6229-177">Ebben a forgatókönyvben "A" és "B" küldött gyorsan, hello kiszolgáló elkezdi gyors küldése válaszok "A" és "B", de adatátviteli idők, mert a "B" mögött elakadnak kérelem hello más kérés és az időpontokat, annak ellenére, hogy hello kiszolgáló válasza gyorsan.</span><span class="sxs-lookup"><span data-stu-id="a6229-177">In this scenario, Request 'A' and 'B' are sent quickly, hello server starts sending responses 'A' and 'B' quickly, but because of data transfer times, 'B' get stuck behind hello other request and times out even though hello server responded quickly.</span></span>

    |-------- 1 Second Timeout (A)----------|
    |-Request A-|
         |-------- 1 Second Timeout (B) ----------|
         |-Request B-|
                |- Read Response A --------|
                                           |- Read Response B-| (**TIMEOUT**)



#### <a name="measurement"></a><span data-ttu-id="a6229-178">Mérési</span><span class="sxs-lookup"><span data-stu-id="a6229-178">Measurement</span></span>
<span data-ttu-id="a6229-179">Ez az egy nehéz egy toomeasure.</span><span class="sxs-lookup"><span data-stu-id="a6229-179">This is a difficult one toomeasure.</span></span> <span data-ttu-id="a6229-180">Alapvetően, hogy tooinstrument az ügyfél kód tootrack nagy kérelmeit és válaszait.</span><span class="sxs-lookup"><span data-stu-id="a6229-180">You basically have tooinstrument your client code tootrack large requests and responses.</span></span> 

#### <a name="resolution"></a><span data-ttu-id="a6229-181">Megoldás:</span><span class="sxs-lookup"><span data-stu-id="a6229-181">Resolution</span></span>
1. <span data-ttu-id="a6229-182">A redis nagyszámú kis értékek ahelyett, hogy néhány nagy értékek van optimalizálva.</span><span class="sxs-lookup"><span data-stu-id="a6229-182">Redis is optimized for a large number of small values, rather than a few large values.</span></span> <span data-ttu-id="a6229-183">hello elsődleges megoldás toobreak másolatot az adatairól a kapcsolódó a kisebb értékek.</span><span class="sxs-lookup"><span data-stu-id="a6229-183">hello preferred solution is toobreak up your data into related smaller values.</span></span> <span data-ttu-id="a6229-184">Lásd: hello [hello ideális méretét értéktartománya redis újdonságai? Túl nagy érték 100KB? ](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ) utáni körül Miért ajánlott a kisebb értékek részleteiről.</span><span class="sxs-lookup"><span data-stu-id="a6229-184">See hello [What is hello ideal value size range for redis? Is 100KB too large?](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ) post for details around why smaller values are recommended.</span></span>
2. <span data-ttu-id="a6229-185">Hello méretének növelése a virtuális gép (az ügyfél és a Redis gyorsítótár-kiszolgáló), tooget nagyobb sávszélesség képességeit, csökkentve az adatok átvitele a nagyobb válaszok alkalommal.</span><span class="sxs-lookup"><span data-stu-id="a6229-185">Increase hello size of your VM (for client and Redis Cache Server), tooget higher bandwidth capabilities, reducing data transfer times for larger responses.</span></span> <span data-ttu-id="a6229-186">Vegye figyelembe, hogy első nagyobb sávszélességet csak hello kiszolgálón, vagy csak a hello ügyfél nem elegendő.</span><span class="sxs-lookup"><span data-stu-id="a6229-186">Note that getting more bandwidth on just hello server or just on hello client may not be enough.</span></span> <span data-ttu-id="a6229-187">A sávszélesség mérését, és összehasonlítják azt toohello képességek hello méretű VM-tal rendelkezik.</span><span class="sxs-lookup"><span data-stu-id="a6229-187">Measure your bandwidth usage and compare it toohello capabilities of hello size of VM you currently have.</span></span>
3. <span data-ttu-id="a6229-188">Az hello számának növeléséhez `ConnectionMultiplexer` meg különböző kapcsolatokon keresztül objektumokat használatát és ciklikus multiplexelés kérelmeket.</span><span class="sxs-lookup"><span data-stu-id="a6229-188">Increase hello number of `ConnectionMultiplexer` objects you use and round-robin requests over different connections.</span></span>

### <a name="what-happened-toomy-data-in-redis"></a><span data-ttu-id="a6229-189">A Redis toomy történt adatok?</span><span class="sxs-lookup"><span data-stu-id="a6229-189">What happened toomy data in Redis?</span></span>
#### <a name="problem"></a><span data-ttu-id="a6229-190">Probléma</span><span class="sxs-lookup"><span data-stu-id="a6229-190">Problem</span></span>
<span data-ttu-id="a6229-191">Várt bizonyos adatok toobe a saját Azure Redis Cache példányt, de ez nem tűnik toobe van.</span><span class="sxs-lookup"><span data-stu-id="a6229-191">I expected for certain data toobe in my Azure Redis Cache instance but it didn't seem toobe there.</span></span>

#### <a name="resolution"></a><span data-ttu-id="a6229-192">Megoldás:</span><span class="sxs-lookup"><span data-stu-id="a6229-192">Resolution</span></span>
<span data-ttu-id="a6229-193">Lásd: [a Redis toomy történt adatok?](https://gist.github.com/JonCole/b6354d92a2d51c141490f10142884ea4#file-whathappenedtomydatainredis-md) a lehetséges okokért és megoldásokért.</span><span class="sxs-lookup"><span data-stu-id="a6229-193">See [What happened toomy data in Redis?](https://gist.github.com/JonCole/b6354d92a2d51c141490f10142884ea4#file-whathappenedtomydatainredis-md) for possible causes and resolutions.</span></span>

## <a name="server-side-troubleshooting"></a><span data-ttu-id="a6229-194">Kiszolgáló oldalán hibaelhárítása</span><span class="sxs-lookup"><span data-stu-id="a6229-194">Server side troubleshooting</span></span>
<span data-ttu-id="a6229-195">Ez a szakasz ismerteti a hibaelhárítási problémák, amelyek miatt hello gyorsítótár-kiszolgálóra vonatkozó feltétellel.</span><span class="sxs-lookup"><span data-stu-id="a6229-195">This section discusses troubleshooting issues that occur because of a condition on hello cache server.</span></span>

* [<span data-ttu-id="a6229-196">Memóriaprobléma hello kiszolgálón</span><span class="sxs-lookup"><span data-stu-id="a6229-196">Memory Pressure on hello server</span></span>](#memory-pressure-on-the-server)
* [<span data-ttu-id="a6229-197">Magas CPU-használatot / Server betöltése</span><span class="sxs-lookup"><span data-stu-id="a6229-197">High CPU usage / Server Load</span></span>](#high-cpu-usage-server-load)
* [<span data-ttu-id="a6229-198">Túllépte a kiszolgáló ügyféloldali sávszélesség</span><span class="sxs-lookup"><span data-stu-id="a6229-198">Server Side Bandwidth Exceeded</span></span>](#server-side-bandwidth-exceeded)

### <a name="memory-pressure-on-hello-server"></a><span data-ttu-id="a6229-199">Memóriaprobléma hello kiszolgálón</span><span class="sxs-lookup"><span data-stu-id="a6229-199">Memory Pressure on hello server</span></span>
#### <a name="problem"></a><span data-ttu-id="a6229-200">Probléma</span><span class="sxs-lookup"><span data-stu-id="a6229-200">Problem</span></span>
<span data-ttu-id="a6229-201">Memóriaprobléma hello kiszolgáló oldalán, amely késleltetheti-e a kérelmek feldolgozásának teljesítményproblémákat tooall típusú vezet.</span><span class="sxs-lookup"><span data-stu-id="a6229-201">Memory pressure on hello server side leads tooall kinds of performance problems that can delay processing of requests.</span></span> <span data-ttu-id="a6229-202">Amikor Memóriaterhelést találatok, hello a rendszer általában van toopage adatokat a fizikai memória toovirtual memóriából, amely a lemezen.</span><span class="sxs-lookup"><span data-stu-id="a6229-202">When memory pressure hits, hello system typically has toopage data from physical memory toovirtual memory which is on disk.</span></span> <span data-ttu-id="a6229-203">Ez *lap hibás* okok hello rendszer tooslow le jelentősen.</span><span class="sxs-lookup"><span data-stu-id="a6229-203">This *page faulting* causes hello system tooslow down significantly.</span></span> <span data-ttu-id="a6229-204">Nincsenek a memóriaterhelése lehetséges okai:</span><span class="sxs-lookup"><span data-stu-id="a6229-204">There are several possible causes of this memory pressure:</span></span> 

1. <span data-ttu-id="a6229-205">Hello gyorsítótár toofull kapacitás töltötte adatokkal.</span><span class="sxs-lookup"><span data-stu-id="a6229-205">You have filled hello cache toofull capacity with data.</span></span> 
2. <span data-ttu-id="a6229-206">Redis kapja a nagy a memória töredezettségét - leggyakrabban okozta nagy objektumok tárolására (Redis úgy optimalizálták, hogy egy kis objektumok – Lásd: hello [hello ideális méretét értéktartománya redis újdonságai? Túl nagy érték 100KB? ](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ) részletes post).</span><span class="sxs-lookup"><span data-stu-id="a6229-206">Redis is seeing high memory fragmentation - most often caused by storing large objects (Redis is optimized for a small objects - See hello [What is hello ideal value size range for redis? Is 100KB too large?](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ) post for details).</span></span> 

#### <a name="measurement"></a><span data-ttu-id="a6229-207">Mérési</span><span class="sxs-lookup"><span data-stu-id="a6229-207">Measurement</span></span>
<span data-ttu-id="a6229-208">Redis mutatja meg, amelyek segítenek azonosítani azokat a probléma két metrikákat.</span><span class="sxs-lookup"><span data-stu-id="a6229-208">Redis exposes two metrics that can help you identify this issue.</span></span> <span data-ttu-id="a6229-209">hello első az `used_memory` és egyéb hello `used_memory_rss`.</span><span class="sxs-lookup"><span data-stu-id="a6229-209">hello first is `used_memory` and hello other is `used_memory_rss`.</span></span> <span data-ttu-id="a6229-210">[A metrikák](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) hello Azure portál vagy hello azon keresztül elérhető [Redis INFO](http://redis.io/commands/info) parancsot.</span><span class="sxs-lookup"><span data-stu-id="a6229-210">[These metrics](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) are available in hello Azure Portal or through hello [Redis INFO](http://redis.io/commands/info) command.</span></span>

#### <a name="resolution"></a><span data-ttu-id="a6229-211">Megoldás:</span><span class="sxs-lookup"><span data-stu-id="a6229-211">Resolution</span></span>
<span data-ttu-id="a6229-212">Van több lehetséges végrehajtott változtatásokat is toohelp megtartása memóriahasználat kifogástalan:</span><span class="sxs-lookup"><span data-stu-id="a6229-212">There are several possible changes that you can make toohelp keep memory usage healthy:</span></span>

1. <span data-ttu-id="a6229-213">[Memória-házirendet konfigurálhat](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) és a kulcsok lejárati idejének beállítására.</span><span class="sxs-lookup"><span data-stu-id="a6229-213">[Configure a memory policy](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) and set expiration times on your keys.</span></span> <span data-ttu-id="a6229-214">Előfordulhat, hogy ez nem elegendő, ha töredezettsége rendelkezik.</span><span class="sxs-lookup"><span data-stu-id="a6229-214">Note that this may not be sufficient if you have fragmentation.</span></span>
2. <span data-ttu-id="a6229-215">[Maxmemory fenntartott érték](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) a memória töredezettségét, amely elég nagy toocompensate.</span><span class="sxs-lookup"><span data-stu-id="a6229-215">[Configure a maxmemory-reserved value](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) that is large enough toocompensate for memory fragmentation.</span></span>
3. <span data-ttu-id="a6229-216">Szakítsa meg a nagy a gyorsítótárazott objektumok kisebb kapcsolódó objektumot.</span><span class="sxs-lookup"><span data-stu-id="a6229-216">Break up your large cached objects into smaller related objects.</span></span>
4. <span data-ttu-id="a6229-217">[Skála](cache-how-to-scale.md) tooa nagyobb gyorsítótár méretét.</span><span class="sxs-lookup"><span data-stu-id="a6229-217">[Scale](cache-how-to-scale.md) tooa larger cache size.</span></span>
5. <span data-ttu-id="a6229-218">Ha használ egy [prémium gyorsítótár engedélyezve van a Redis-fürt](cache-how-to-premium-clustering.md) is [a szilánkok hello értéknek a növelésével](cache-how-to-premium-clustering.md#change-the-cluster-size-on-a-running-premium-cache).</span><span class="sxs-lookup"><span data-stu-id="a6229-218">If you are using a [premium cache with Redis cluster enabled](cache-how-to-premium-clustering.md) you can [increase hello number of shards](cache-how-to-premium-clustering.md#change-the-cluster-size-on-a-running-premium-cache).</span></span>

### <a name="high-cpu-usage--server-load"></a><span data-ttu-id="a6229-219">Magas CPU-használatot / Server betöltése</span><span class="sxs-lookup"><span data-stu-id="a6229-219">High CPU usage / Server Load</span></span>
#### <a name="problem"></a><span data-ttu-id="a6229-220">Probléma</span><span class="sxs-lookup"><span data-stu-id="a6229-220">Problem</span></span>
<span data-ttu-id="a6229-221">Magas CPU-használatot azt, hogy hello ügyféloldali meghiúsulhatnak tooprocess Redis időben választ, annak ellenére, hogy a Redis nagyon gyorsan hello választ küldött.</span><span class="sxs-lookup"><span data-stu-id="a6229-221">High CPU usage can mean that hello client side can fail tooprocess a response from Redis in a timely fashion even though Redis sent hello response very quickly.</span></span>

#### <a name="measurement"></a><span data-ttu-id="a6229-222">Mérési</span><span class="sxs-lookup"><span data-stu-id="a6229-222">Measurement</span></span>
<span data-ttu-id="a6229-223">A figyelő hello rendszer nagy CPU-használat hello vagy hello Azure portálon keresztül kapcsolódó teljesítményszámláló.</span><span class="sxs-lookup"><span data-stu-id="a6229-223">Monitor hello System Wide CPU usage through hello Azure Portal or through hello associated performance counter.</span></span> <span data-ttu-id="a6229-224">Legyen óvatos nem toomonitor *folyamat* CPU mivel egyetlen folyamat alacsony CPU-használat: hello azonos időt, hogy a rendszer általános CPU magas lehet.</span><span class="sxs-lookup"><span data-stu-id="a6229-224">Be careful not toomonitor *process* CPU because a single process can have low CPU usage at hello same time that overall system CPU can be high.</span></span> <span data-ttu-id="a6229-225">A CPU-használat teljesítményt, amelyek megfelelnek a időtúllépések figyelje.</span><span class="sxs-lookup"><span data-stu-id="a6229-225">Watch for spikes in CPU usage that correspond with timeouts.</span></span>

#### <a name="resolution"></a><span data-ttu-id="a6229-226">Megoldás:</span><span class="sxs-lookup"><span data-stu-id="a6229-226">Resolution</span></span>
<span data-ttu-id="a6229-227">[Skála](cache-how-to-scale.md) tooa nagyobb gyorsítótár réteg további CPU-kapacitással rendelkező átjáróeszközt, vagy vizsgálja meg, mi okozza a CPU-teljesítményt.</span><span class="sxs-lookup"><span data-stu-id="a6229-227">[Scale](cache-how-to-scale.md) tooa larger cache tier with more CPU capacity or investigate what is causing CPU spikes.</span></span> 

### <a name="server-side-bandwidth-exceeded"></a><span data-ttu-id="a6229-228">Túllépte a kiszolgáló ügyféloldali sávszélesség</span><span class="sxs-lookup"><span data-stu-id="a6229-228">Server Side Bandwidth Exceeded</span></span>
#### <a name="problem"></a><span data-ttu-id="a6229-229">Probléma</span><span class="sxs-lookup"><span data-stu-id="a6229-229">Problem</span></span>
<span data-ttu-id="a6229-230">Különböző méretű gyorsítótár célpéldánynál korlátozások mekkora hálózati sávszélességre gyakorolt rendelkeznek érhető el.</span><span class="sxs-lookup"><span data-stu-id="a6229-230">Different sized cache instances have limitations on how much network bandwidth they have available.</span></span> <span data-ttu-id="a6229-231">Ha hello server meghaladja a rendelkezésre álló sávszélesség hello, majd adatok nem küldhetők toohello ügyfél leggyorsabban.</span><span class="sxs-lookup"><span data-stu-id="a6229-231">If hello server exceeds hello available bandwidth, then data will not be sent toohello client as quickly.</span></span> <span data-ttu-id="a6229-232">Ennek eredményeképpen előfordulhat tootimeouts.</span><span class="sxs-lookup"><span data-stu-id="a6229-232">This can lead tootimeouts.</span></span>

#### <a name="measurement"></a><span data-ttu-id="a6229-233">Mérési</span><span class="sxs-lookup"><span data-stu-id="a6229-233">Measurement</span></span>
<span data-ttu-id="a6229-234">Figyelheti a hello `Cache Read` metrika, amely hello hello megadott jelentéskészítési időszakban gyorsítótárból hello megabájtban (MB/s) másodpercenként beolvasott adatok mennyiségét.</span><span class="sxs-lookup"><span data-stu-id="a6229-234">You can monitor hello `Cache Read` metric, which is hello amount of data read from hello cache in Megabytes per second (MB/s) during hello specified reporting interval.</span></span> <span data-ttu-id="a6229-235">Ezt az értéket használják ezt a gyorsítótárat toohello sávszélesség felel meg.</span><span class="sxs-lookup"><span data-stu-id="a6229-235">This value corresponds toohello network bandwidth used by this cache.</span></span> <span data-ttu-id="a6229-236">Ha a kiszolgáló oldalán hálózati sávszélesség korlátja szeretne figyelmeztetéseket tooset, létrehozhat azokat a `Cache Read` számláló.</span><span class="sxs-lookup"><span data-stu-id="a6229-236">If you want tooset up alerts for server side network bandwidth limits, you can create them using this `Cache Read` counter.</span></span> <span data-ttu-id="a6229-237">A mérési hello értékekkel összehasonlítja [ezt a táblázatot](cache-faq.md#cache-performance) a megfigyelt sávszélességkorlátok különböző árképzési szinteket, és méretű gyorsítótár hello.</span><span class="sxs-lookup"><span data-stu-id="a6229-237">Compare your readings with hello values in [this table](cache-faq.md#cache-performance) for hello observed bandwidth limits for various cache pricing tiers and sizes.</span></span>

#### <a name="resolution"></a><span data-ttu-id="a6229-238">Megoldás:</span><span class="sxs-lookup"><span data-stu-id="a6229-238">Resolution</span></span>
<span data-ttu-id="a6229-239">Ha következetesen figyelhető meg az árképzési szint és a gyorsítótár méretének maximális sávszélessége hello közelében, fontolja meg [skálázás](cache-how-to-scale.md) tooa árképzési szint vagy mérete nagyobb hálózati sávszélesség álljon, a hello értékekkel [ezt a táblázatot](cache-faq.md#cache-performance) útmutatóként.</span><span class="sxs-lookup"><span data-stu-id="a6229-239">If you are consistently near hello observed maximum bandwidth for your pricing tier and cache size, consider [scaling](cache-how-to-scale.md) tooa pricing tier or size that has greater network bandwidth, using hello values in [this table](cache-faq.md#cache-performance) as a guide.</span></span>

## <a name="stackexchangeredis-timeout-exceptions"></a><span data-ttu-id="a6229-240">StackExchange.Redis időtúllépési kivétel</span><span class="sxs-lookup"><span data-stu-id="a6229-240">StackExchange.Redis timeout exceptions</span></span>
<span data-ttu-id="a6229-241">StackExchange.Redis nevű konfigurációs beállítást használja `synctimeout` szinkron műveletekhez, amely 1000 ms alapértelmezett értéke.</span><span class="sxs-lookup"><span data-stu-id="a6229-241">StackExchange.Redis uses a configuration setting named `synctimeout` for synchronous operations which has a default value  of 1000 ms.</span></span> <span data-ttu-id="a6229-242">Ha egy aszinkron hívás nem fejezi be a hello meghatározott idő, hello StackExchange.Redis ügyfél jelez egy időtúllépési hiba hasonló toohello a következő példa.</span><span class="sxs-lookup"><span data-stu-id="a6229-242">If a synchronous call doesn’t complete in hello stipulated time, hello StackExchange.Redis client throws a timeout error similar toohello following example.</span></span>

    System.TimeoutException: Timeout performing MGET 2728cc84-58ae-406b-8ec8-3f962419f641, inst: 1,mgr: Inactive, queue: 73, qu=6, qs=67, qc=0, wr=1/1, in=0/0 IOCP: (Busy=6, Free=999, Min=2,Max=1000), WORKER (Busy=7,Free=8184,Min=2,Max=8191)


<span data-ttu-id="a6229-243">Ez a hibaüzenet tartalmazza, amely segíthet a pont, akkor hello probléma okát és lehetséges megoldás toohello metrikákat.</span><span class="sxs-lookup"><span data-stu-id="a6229-243">This error message contains metrics that can help point you toohello cause and possible resolution of hello issue.</span></span> <span data-ttu-id="a6229-244">hello alábbi táblázat részleteket tartalmaz a hello hiba üzenet metrikákat.</span><span class="sxs-lookup"><span data-stu-id="a6229-244">hello following table contains details about hello error message metrics.</span></span>

| <span data-ttu-id="a6229-245">Hiba történt a üzenet metrika</span><span class="sxs-lookup"><span data-stu-id="a6229-245">Error message metric</span></span> | <span data-ttu-id="a6229-246">Részletek</span><span class="sxs-lookup"><span data-stu-id="a6229-246">Details</span></span> |
| --- | --- |
| <span data-ttu-id="a6229-247">INST</span><span class="sxs-lookup"><span data-stu-id="a6229-247">inst</span></span> |<span data-ttu-id="a6229-248">Az utolsó időszelet hello: 0 parancsok kiállították.</span><span class="sxs-lookup"><span data-stu-id="a6229-248">In hello last time slice: 0 commands have been issued</span></span> |
| <span data-ttu-id="a6229-249">kezelője</span><span class="sxs-lookup"><span data-stu-id="a6229-249">mgr</span></span> |<span data-ttu-id="a6229-250">hello szoftvercsatorna manager hajt végre `socket.select` ami azt jelenti, hogy azt kéri, az operációs rendszer hello tooindicate, amely rendelkezik egy szoftvercsatorna toodo; alapvetően: hello olvasó van nem aktívan olvasása hello hálózatból, mert az nem gondolja, hogy van toodo</span><span class="sxs-lookup"><span data-stu-id="a6229-250">hello socket manager is performing `socket.select` which means it is asking hello OS tooindicate a socket that has something toodo; basically: hello reader is not actively reading from hello network because it doesn't think there is anything toodo</span></span> |
| <span data-ttu-id="a6229-251">Várólista</span><span class="sxs-lookup"><span data-stu-id="a6229-251">queue</span></span> |<span data-ttu-id="a6229-252">73 összes folyamatban lévő műveletek</span><span class="sxs-lookup"><span data-stu-id="a6229-252">There are 73 total in-progress operations</span></span> |
| <span data-ttu-id="a6229-253">qu</span><span class="sxs-lookup"><span data-stu-id="a6229-253">qu</span></span> |<span data-ttu-id="a6229-254">6 hello folyamatban lévő műveletek hello elküldetlen várólistájuk, és nem még készült toohello kimenő hálózati</span><span class="sxs-lookup"><span data-stu-id="a6229-254">6 of hello in-progress operations are in hello unsent queue and have not yet been written toohello outbound network</span></span> |
| <span data-ttu-id="a6229-255">QS</span><span class="sxs-lookup"><span data-stu-id="a6229-255">qs</span></span> |<span data-ttu-id="a6229-256">67-es helykiszolgálójához folyamatban lévő műveletek elküldött toohello server, de a választ még nem érhető el.</span><span class="sxs-lookup"><span data-stu-id="a6229-256">67 of he in-progress operations have been sent toohello server but a response is not yet available.</span></span> <span data-ttu-id="a6229-257">hello válasz lehet `Not yet sent by hello server` vagy`sent by hello server but not yet processed by hello client.`</span><span class="sxs-lookup"><span data-stu-id="a6229-257">hello response could be `Not yet sent by hello server` or `sent by hello server but not yet processed by hello client.`</span></span> |
| <span data-ttu-id="a6229-258">QC</span><span class="sxs-lookup"><span data-stu-id="a6229-258">qc</span></span> |<span data-ttu-id="a6229-259">hello folyamatban lévő műveletek 0 választ láthatta, de nem még jelölt miatt el a hello befejezési hurok toowaiting</span><span class="sxs-lookup"><span data-stu-id="a6229-259">0 of hello in-progress operations have seen replies but have not yet been marked as complete due toowaiting on hello completion loop</span></span> |
| <span data-ttu-id="a6229-260">wR</span><span class="sxs-lookup"><span data-stu-id="a6229-260">wr</span></span> |<span data-ttu-id="a6229-261">Nincs egy aktív írási (azaz hello 6 el nem küldött kérelmek nem lesznek mellőzve) bájt/activewriters</span><span class="sxs-lookup"><span data-stu-id="a6229-261">There is an active writer (meaning hello 6 unsent requests are not being ignored) bytes/activewriters</span></span> |
| <span data-ttu-id="a6229-262">A</span><span class="sxs-lookup"><span data-stu-id="a6229-262">in</span></span> |<span data-ttu-id="a6229-263">Nincs aktív olvasó és nulla bájt elérhető toobe, olvassa el a hálózati bájtok/activereaders hello</span><span class="sxs-lookup"><span data-stu-id="a6229-263">There are no active readers and zero bytes are available toobe read on hello NIC bytes/activereaders</span></span> |

### <a name="steps-tooinvestigate"></a><span data-ttu-id="a6229-264">Lépéseket tooinvestigate</span><span class="sxs-lookup"><span data-stu-id="a6229-264">Steps tooinvestigate</span></span>
1. <span data-ttu-id="a6229-265">Gondoskodjon arról, hogy a legjobb hello StackExchange.Redis ügyfél használata esetén a következő mintát tooconnect hello használ.</span><span class="sxs-lookup"><span data-stu-id="a6229-265">As a best practice make sure you are using hello following pattern tooconnect when using hello StackExchange.Redis client.</span></span>

    ```c#
    private static Lazy<ConnectionMultiplexer> lazyConnection = new Lazy<ConnectionMultiplexer>(() =>
    {
        return ConnectionMultiplexer.Connect("cachename.redis.cache.windows.net,abortConnect=false,ssl=true,password=...");
    
    });
    
    public static ConnectionMultiplexer Connection
    {
        get
        {
            return lazyConnection.Value;
        }
    }
    ````

    <span data-ttu-id="a6229-266">További információkért lásd: [toohello gyorsítótár StackExchange.Redis használatával csatlakozzon](cache-dotnet-how-to-use-azure-redis-cache.md#connect-to-the-cache).</span><span class="sxs-lookup"><span data-stu-id="a6229-266">For more information, see [Connect toohello cache using StackExchange.Redis](cache-dotnet-how-to-use-azure-redis-cache.md#connect-to-the-cache).</span></span>

1. <span data-ttu-id="a6229-267">Győződjön meg arról, hogy az Azure Redis Cache és hello ügyfélalkalmazás hello Azure-ban ugyanabban a régióban.</span><span class="sxs-lookup"><span data-stu-id="a6229-267">Ensure that your Azure Redis Cache and hello client application are in hello same region in Azure.</span></span> <span data-ttu-id="a6229-268">Például akkor lehet, hogy lehet első időtúllépések Ha a gyorsítótár van USA keleti régiója, de hello ügyfél USA nyugati régiója és hello kérelem nem fejezi be hello belül `synctimeout` időköz, vagy előfordulhat, hogy lehet első időtúllépések Ha meg vannak hibakereséshez a következőből: a helyi fejlesztési számítógépén.</span><span class="sxs-lookup"><span data-stu-id="a6229-268">For example, you might be getting timeouts when your cache is in East US but hello client is in West US and hello request doesn't complete within hello `synctimeout` interval or you might be getting timeouts when you are debugging from your local development machine.</span></span> 
   
    <span data-ttu-id="a6229-269">Toohave hello gyorsítótár lehetőleg rendelkezik, és a hello ügyfelével hello azonos Azure-régiót.</span><span class="sxs-lookup"><span data-stu-id="a6229-269">It’s highly recommended toohave hello cache and in hello client in hello same Azure region.</span></span> <span data-ttu-id="a6229-270">Ha olyan forgatókönyvekben, amelyek több régióban hívások tartalmaz, célszerű hello `synctimeout` intervallum tooa értéke nagyobb, mint hello alapértelmezett 1000 ms-ot egy `synctimeout` tulajdonság hello kapcsolati karakterláncban.</span><span class="sxs-lookup"><span data-stu-id="a6229-270">If you have a scenario that includes cross region calls, you should set hello `synctimeout` interval tooa value higher than hello default 1000 ms interval by including a `synctimeout` property in hello connection string.</span></span> <span data-ttu-id="a6229-271">hello alábbi példa bemutatja a StackExchange.Redis gyorsítótár kapcsolati karakterlánc részlet rendelkező egy `synctimeout` 2000 MS.</span><span class="sxs-lookup"><span data-stu-id="a6229-271">hello following example shows a StackExchange.Redis cache connection string snippet with a `synctimeout` of 2000 ms.</span></span>
   
        synctimeout=2000,cachename.redis.cache.windows.net,abortConnect=false,ssl=true,password=...
2. <span data-ttu-id="a6229-272">Győződjön meg arról, hogy hello hello legújabb verzióját használja [StackExchange.Redis NuGet-csomag](https://www.nuget.org/packages/StackExchange.Redis/).</span><span class="sxs-lookup"><span data-stu-id="a6229-272">Ensure you using hello latest version of hello [StackExchange.Redis NuGet package](https://www.nuget.org/packages/StackExchange.Redis/).</span></span> <span data-ttu-id="a6229-273">Nincsenek hibák folyamatosan alatt kijavította a hello kód toomake robusztusabb tootimeouts hello legújabb verzióját, akkor fontos.</span><span class="sxs-lookup"><span data-stu-id="a6229-273">There are bugs constantly being fixed in hello code toomake it more robust tootimeouts so having hello latest version is important.</span></span>
3. <span data-ttu-id="a6229-274">Ha nincs sávszélességgel kapcsolatos korlátozásai hello kiszolgálón vagy az ügyfél által első kötött, tovább tart a számukra toocomplete, és ekkor időtúllépések.</span><span class="sxs-lookup"><span data-stu-id="a6229-274">If there are requests that are getting bound by bandwidth limitations on hello server or client, it will take longer for them toocomplete and thereby cause timeouts.</span></span> <span data-ttu-id="a6229-275">toosee Ha az időtúllépés miatt toonetwork sávszélesség hello kiszolgálón lásd [túllépte a kiszolgáló ügyféloldali sávszélesség](#server-side-bandwidth-exceeded).</span><span class="sxs-lookup"><span data-stu-id="a6229-275">toosee if your timeout is due toonetwork bandwidth on hello server, see [Server side bandwidth exceeded](#server-side-bandwidth-exceeded).</span></span> <span data-ttu-id="a6229-276">Ha az időtúllépés miatt tooclient hálózati sávszélesség, toosee lásd: [ügyfél oldalán sávszélesség túllépte](#client-side-bandwidth-exceeded).</span><span class="sxs-lookup"><span data-stu-id="a6229-276">toosee if your timeout is due tooclient network bandwidth, see [Client side bandwidth exceeded](#client-side-bandwidth-exceeded).</span></span>
4. <span data-ttu-id="a6229-277">Ön az első CPU kötött hello kiszolgálón vagy hello ügyfél?</span><span class="sxs-lookup"><span data-stu-id="a6229-277">Are you getting CPU bound on hello server or on hello client?</span></span>
   
   * <span data-ttu-id="a6229-278">Ellenőrizze, hogy Ön első kötött processzor az ügyfélen, így hello kérelem toonot hello végrehajtva `synctimeout` időköz, ami az időtúllépés miatt.</span><span class="sxs-lookup"><span data-stu-id="a6229-278">Check if you are getting bound by CPU on your client which could cause hello request toonot be processed within hello `synctimeout` interval, thus causing a timeout.</span></span> <span data-ttu-id="a6229-279">Hello terhelés érkezhetnek vagy tooa ügyfél méretének áthelyezése segítségével toocontrol ez.</span><span class="sxs-lookup"><span data-stu-id="a6229-279">Moving tooa larger client size or distributing hello load can help toocontrol this.</span></span> 
   * <span data-ttu-id="a6229-280">Hello figyelésével hello kiszolgálón kötött jelölőnégyzetet, ha a CPU `CPU` [teljesítmény metrika gyorsítótár](cache-how-to-monitor.md#available-metrics-and-reporting-intervals).</span><span class="sxs-lookup"><span data-stu-id="a6229-280">Check if you are getting CPU bound on hello server by monitoring hello `CPU` [cache performance metric](cache-how-to-monitor.md#available-metrics-and-reporting-intervals).</span></span> <span data-ttu-id="a6229-281">CPU kötött okozhat, amelyek a Redis pedig várható kérelmek tootimeout kérelmek.</span><span class="sxs-lookup"><span data-stu-id="a6229-281">Requests coming in while Redis is CPU bound can cause those requests tootimeout.</span></span> <span data-ttu-id="a6229-282">Ez hello terjeszthető betölteni a prémium szintű gyorsítótár több szilánkok között, vagy frissítse a tooa nagyobb méretű vagy IP-címek tooaddress.</span><span class="sxs-lookup"><span data-stu-id="a6229-282">tooaddress this you can distribute hello load across multiple shards in a premium cache, or upgrade tooa larger size or pricing tier.</span></span> <span data-ttu-id="a6229-283">További információkért lásd: [Server ügyféloldali sávszélesség túllépését](#server-side-bandwidth-exceeded).</span><span class="sxs-lookup"><span data-stu-id="a6229-283">For more information, see [Server Side Bandwidth Exceeded](#server-side-bandwidth-exceeded).</span></span>
5. <span data-ttu-id="a6229-284">Vannak-e véve a hosszú idő tooprocess hello kiszolgálón parancsok?</span><span class="sxs-lookup"><span data-stu-id="a6229-284">Are there commands taking long time tooprocess on hello server?</span></span> <span data-ttu-id="a6229-285">Hosszú ideig futó parancsokat, amelyek hosszú ideig tooprocess hello redis-kiszolgáló tart időtúllépések okozhatják.</span><span class="sxs-lookup"><span data-stu-id="a6229-285">Long running commands that are taking long time tooprocess on hello redis-server can cause timeouts.</span></span> <span data-ttu-id="a6229-286">Néhány példa a hosszú ideig futó parancsok `mget` kulcsok, ha sok felhasználóval rendelkező `keys *` vagy rosszul írt lua parancsfájlok.</span><span class="sxs-lookup"><span data-stu-id="a6229-286">Some examples of long running commands are `mget` with large numbers of keys, `keys *` or poorly written lua scripts.</span></span> <span data-ttu-id="a6229-287">Csatlakozás tooyour Azure Redis Cache példány hello redis-cli ügyfélprogrammal, vagy hello használata [Redis konzol](cache-configure.md#redis-console) és futtatási hello [SlowLog](http://redis.io/commands/slowlog) toosee parancs, ha a kérelem a vártnál tovább tart.</span><span class="sxs-lookup"><span data-stu-id="a6229-287">You can connect tooyour Azure Redis Cache instance using hello redis-cli client or use hello [Redis Console](cache-configure.md#redis-console) and run hello [SlowLog](http://redis.io/commands/slowlog) command toosee if there are requests taking longer than expected.</span></span> <span data-ttu-id="a6229-288">A redis-kiszolgáló és a StackExchange.Redis kevesebb nagy kérelmek helyett a sok kisméretű kérelem vannak optimalizálva.</span><span class="sxs-lookup"><span data-stu-id="a6229-288">Redis Server and StackExchange.Redis are optimized for many small requests rather than fewer large requests.</span></span> <span data-ttu-id="a6229-289">Az adatok felosztása kisebb adattömbökbe javíthatja a dolgok itt.</span><span class="sxs-lookup"><span data-stu-id="a6229-289">Splitting your data into smaller chunks may improve things here.</span></span> 
   
    <span data-ttu-id="a6229-290">A redis-cli és stunnel toohello Azure Redis Cache SSL végpont csatlakozó információkért lásd: hello [bejelentése ASP.NET munkamenetállapot-szolgáltatóját a Redis előzetes](http://blogs.msdn.com/b/webdev/archive/2014/05/12/announcing-asp-net-session-state-provider-for-redis-preview-release.aspx) blogbejegyzést.</span><span class="sxs-lookup"><span data-stu-id="a6229-290">For information on connecting toohello Azure Redis Cache SSL endpoint using redis-cli and stunnel, see hello [Announcing ASP.NET Session State Provider for Redis Preview Release](http://blogs.msdn.com/b/webdev/archive/2014/05/12/announcing-asp-net-session-state-provider-for-redis-preview-release.aspx) blog post.</span></span> <span data-ttu-id="a6229-291">További információkért lásd: [SlowLog](http://redis.io/commands/slowlog).</span><span class="sxs-lookup"><span data-stu-id="a6229-291">For more information, see [SlowLog](http://redis.io/commands/slowlog).</span></span>
6. <span data-ttu-id="a6229-292">Magas Redis-kiszolgáló terhelése okozhatja időtúllépések.</span><span class="sxs-lookup"><span data-stu-id="a6229-292">High Redis server load can cause timeouts.</span></span> <span data-ttu-id="a6229-293">Hello kiszolgálóterhelés figyelheti hello figyelésével `Redis Server Load` [teljesítmény metrika gyorsítótár](cache-how-to-monitor.md#available-metrics-and-reporting-intervals).</span><span class="sxs-lookup"><span data-stu-id="a6229-293">You can monitor hello server load by monitoring hello `Redis Server Load` [cache performance metric](cache-how-to-monitor.md#available-metrics-and-reporting-intervals).</span></span> <span data-ttu-id="a6229-294">A kiszolgáló terhelését, 100 (maximális érték) azt jelzi, hogy adott hello redis megtörtént a kiszolgáló elfoglalt, nem üresjárati idő kérelmek feldolgozásához.</span><span class="sxs-lookup"><span data-stu-id="a6229-294">A server load of 100 (maximum value) signifies that hello redis server has been busy, with no idle time, processing requests.</span></span> <span data-ttu-id="a6229-295">toosee bizonyos kérések végzése összes hello képessége, ha paranccsal hello SlowLog, hello előző bekezdésben ismertetett módon.</span><span class="sxs-lookup"><span data-stu-id="a6229-295">toosee if certain requests are taking up all of hello server capability, run hello SlowLog command, as described in hello previous paragraph.</span></span> <span data-ttu-id="a6229-296">További információkért lásd: [magas CPU-használat / Server betöltési](#high-cpu-usage-server-load).</span><span class="sxs-lookup"><span data-stu-id="a6229-296">For more information, see [High CPU usage / Server Load](#high-cpu-usage-server-load).</span></span>
7. <span data-ttu-id="a6229-297">Történt más esemény egy hálózati blip okozhatta hello ügyféloldalon?</span><span class="sxs-lookup"><span data-stu-id="a6229-297">Was there any other event on hello client side that could have caused a network blip?</span></span> <span data-ttu-id="a6229-298">Tanulmányozza az hello ügyfél (web-, feldolgozói szerepkör vagy egy infrastruktúra-szolgáltatási virtuális Gépre), ha hiba történt az esemény, például az ügyfél-példányok száma hello skálázás felfelé vagy lefelé, illetve hello ügyfél új verziójának telepítése, vagy automatikus skálázása engedélyezve van? A találtunk, amelyeknek, hogy az automatikus skálázás vagy fel/le skálázás okozhat tesztelés során kimenő hálózati kapcsolat elveszhet néhány másodpercig.</span><span class="sxs-lookup"><span data-stu-id="a6229-298">Check on hello client (web, worker role or an Iaas VM) if there was an event like scaling hello number of client instances up or down, or deploying a new version of hello client or auto-scale is enabled?In our testing we have found that autoscale or scaling up/down can cause outbound network connectivity can be lost for several seconds.</span></span> <span data-ttu-id="a6229-299">StackExchange.Redis kód rugalmas toosuch eseményeket, és újra fognak csatlakozni.</span><span class="sxs-lookup"><span data-stu-id="a6229-299">StackExchange.Redis code is resilient toosuch events and will reconnect.</span></span> <span data-ttu-id="a6229-300">Ebben az időszakban újbóli kapcsolat hello várólistában lévő minden kérést is túllépi az időkorlátot.</span><span class="sxs-lookup"><span data-stu-id="a6229-300">During this time of re-connection any requests in hello queue can time out.</span></span>
8. <span data-ttu-id="a6229-301">Történt több kis kérelmek toohello Redis gyorsítótár, amely túllépte az időkorlátot megelőző nagy kérelmet? hello paraméter `qs` hello hibás üzenet közli, hogy hány kérésnek hello ügyfél toohello kiszolgálóról küldött, de még nem dolgozott választ.</span><span class="sxs-lookup"><span data-stu-id="a6229-301">Was there a big request preceding several small requests toohello Redis Cache that timed out? hello parameter `qs` in hello error message tells you how many requests were sent from hello client toohello server, but have not yet processed a response.</span></span> <span data-ttu-id="a6229-302">Ez az érték lehet egyre több adatra mert StackExchange.Redis egyetlen TCP-kapcsolatot használ, és csak olvasható egy válasz egyszerre.</span><span class="sxs-lookup"><span data-stu-id="a6229-302">This value can keep growing because StackExchange.Redis uses a single TCP connection and can only read one response at a time.</span></span> <span data-ttu-id="a6229-303">Annak ellenére, hogy hello első művelete túllépte az időkorlátot, akkor az nem hello küldött adatok mennyisége hello kiszolgáló és a, és más kérelmek le vannak tiltva, amíg ez befejeződött, ami időtúllépések.</span><span class="sxs-lookup"><span data-stu-id="a6229-303">Even though hello first operation timed out, it does not stop hello data being sent to/from hello server, and other requests are blocked until this is finished, causing time outs.</span></span> <span data-ttu-id="a6229-304">Egyik megoldást időtúllépések toominimize hello esélyét, hogy annak biztosítása, hogy a gyorsítótár elég nagy a terhelés, és nagy értékek felosztása kisebb adattömbökbe.</span><span class="sxs-lookup"><span data-stu-id="a6229-304">One solution is toominimize hello chance of timeouts by ensuring that your cache is large enough for your workload and splitting large values into smaller chunks.</span></span> <span data-ttu-id="a6229-305">Egy másik lehetséges megoldás, toouse készletét `ConnectionMultiplexer` az ügyfél objektumokat, majd válassza ki a legalább betöltött hello `ConnectionMultiplexer` új kérelem küldésekor.</span><span class="sxs-lookup"><span data-stu-id="a6229-305">Another possible solution is toouse a pool of `ConnectionMultiplexer` objects in your client, and choose hello least loaded `ConnectionMultiplexer` when sending a new request.</span></span> <span data-ttu-id="a6229-306">Egyetlen időtúllépés kell emiatt más kérelmek tooalso időtúllépés miatt.</span><span class="sxs-lookup"><span data-stu-id="a6229-306">This should prevent a single timeout from causing other requests tooalso timeout.</span></span>
9. <span data-ttu-id="a6229-307">Ha használ `RedisSessionStateprovider`, győződjön meg arról, hello újrapróbálkozási időtúllépés helyesen van beállítva.</span><span class="sxs-lookup"><span data-stu-id="a6229-307">If you are using `RedisSessionStateprovider`, ensure you have set hello retry timeout correctly.</span></span> <span data-ttu-id="a6229-308">`retrytimeoutInMilliseconds`nagyobbnak kell lennie `operationTimeoutinMilliseonds`, ellenkező esetben nem ismételt próbálkozás történik.</span><span class="sxs-lookup"><span data-stu-id="a6229-308">`retrytimeoutInMilliseconds` should be higher than `operationTimeoutinMilliseonds`, otherwise no retries will occur.</span></span> <span data-ttu-id="a6229-309">Az alábbi példa hello `retrytimeoutInMilliseconds` too3000 van beállítva.</span><span class="sxs-lookup"><span data-stu-id="a6229-309">In hello following example `retrytimeoutInMilliseconds` is set too3000.</span></span> <span data-ttu-id="a6229-310">További információkért lásd: [ASP.NET munkamenetállapot-szolgáltatóját az Azure Redis Cache](cache-aspnet-session-state-provider.md) és [hogyan toouse hello konfigurációs paraméterek munkamenetállapot-szolgáltatóját, és a kimeneti gyorsítótár-szolgáltató](https://github.com/Azure/aspnet-redis-providers/wiki/Configuration).</span><span class="sxs-lookup"><span data-stu-id="a6229-310">For more information, see [ASP.NET Session State Provider for Azure Redis Cache](cache-aspnet-session-state-provider.md) and [How toouse hello configuration parameters of Session State Provider and Output Cache Provider](https://github.com/Azure/aspnet-redis-providers/wiki/Configuration).</span></span>

    <add
      name="AFRedisCacheSessionStateProvider"
      type="Microsoft.Web.Redis.RedisSessionStateProvider"
      host="enbwcache.redis.cache.windows.net"
      port="6380"
      accessKey="…"
      ssl="true"
      databaseId="0"
      applicationName="AFRedisCacheSessionState"
      connectionTimeoutInMilliseconds = "5000"
      operationTimeoutInMilliseconds = "1000"
      retryTimeoutInMilliseconds="3000" />


1. <span data-ttu-id="a6229-311">Ellenőrizze a memóriahasználat a hello Azure Redis gyorsítótár-kiszolgáló [figyelési](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) `Used Memory RSS` és `Used Memory`.</span><span class="sxs-lookup"><span data-stu-id="a6229-311">Check memory usage on hello Azure Redis Cache server by [monitoring](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) `Used Memory RSS` and `Used Memory`.</span></span> <span data-ttu-id="a6229-312">Egy kiürítés házirend van beállítva, ha kezdődik-e a Redis való kulcsok mikor `Used_Memory` eléri hello gyorsítótár méretét.</span><span class="sxs-lookup"><span data-stu-id="a6229-312">If an eviction policy is in place, Redis starts evicting keys when `Used_Memory` reaches hello cache size.</span></span> <span data-ttu-id="a6229-313">Ideális esetben `Used Memory RSS` csak kell valamivel nagyobb, mint `Used memory`.</span><span class="sxs-lookup"><span data-stu-id="a6229-313">Ideally, `Used Memory RSS` should be only slightly higher than `Used memory`.</span></span> <span data-ttu-id="a6229-314">A nagy különbség jelenti, hogy a memória töredezettségét (belső vagy külső.</span><span class="sxs-lookup"><span data-stu-id="a6229-314">A large difference means there is memory fragmentation (internal or external.</span></span> <span data-ttu-id="a6229-315">Ha `Used Memory RSS` értéke kisebb, mint `Used Memory`, azt jelenti, hogy a gyorsítótár-memória hello részét rendelkezik lett cserélve hello operációs rendszer.</span><span class="sxs-lookup"><span data-stu-id="a6229-315">When `Used Memory RSS` is less than `Used Memory`, it means part of hello cache memory has been swapped  by hello operating system.</span></span> <span data-ttu-id="a6229-316">Ez akkor fordul elő, ha várhatóan néhány jelentős késések fordulnak elő.</span><span class="sxs-lookup"><span data-stu-id="a6229-316">If this occurs you can expect some significant latencies.</span></span> <span data-ttu-id="a6229-317">Mert Redis nincs vezérlő keresztül hogyan a hozzárendelések leképezve toomemory lapok, magas `Used Memory RSS` gyakran egy csúcs az igények memóriahasználat hello eredménye van.</span><span class="sxs-lookup"><span data-stu-id="a6229-317">Because Redis does not have control over how its allocations are mapped toomemory pages, high `Used Memory RSS` is often hello result of a spike in memory usage.</span></span> <span data-ttu-id="a6229-318">Amikor Redis felszabadítja a memória, hello memória vissza toohello foglaló kap, és nem hello foglaló előfordulhat, hogy nem adhat meg hello memória hátsó toohello rendszer.</span><span class="sxs-lookup"><span data-stu-id="a6229-318">When Redis frees memory, hello memory is given back toohello allocator, and hello allocator may or may not give hello memory back toohello system.</span></span> <span data-ttu-id="a6229-319">Lehet eltérést között hello `Used Memory` érték és a memória-felhasználás hello operációs rendszer által jelentett módon.</span><span class="sxs-lookup"><span data-stu-id="a6229-319">There may be a discrepancy between hello `Used Memory` value and memory consumption as reported by hello operating system.</span></span> <span data-ttu-id="a6229-320">Elképzelhető, hogy a esedékes toohello tény használt és a Redis, de nem adott vissza toohello rendszer, amely a memória.</span><span class="sxs-lookup"><span data-stu-id="a6229-320">It may be due toohello fact memory has been used and released by Redis, but not given back toohello system.</span></span> <span data-ttu-id="a6229-321">toohelp hajthat végre a lépéseket követve hello memória problémák elhárítása érdekében.</span><span class="sxs-lookup"><span data-stu-id="a6229-321">toohelp mitigate memory issues you can perform hello following steps.</span></span>
   
   * <span data-ttu-id="a6229-322">Frissítés hello tooa nagyobb gyorsítótárméret, hogy nem futtatja találkoznak memóriakorlátozások hello rendszeren.</span><span class="sxs-lookup"><span data-stu-id="a6229-322">Upgrade hello cache tooa larger size so that you are not running up against memory limitations on hello system.</span></span>
   * <span data-ttu-id="a6229-323">Hello kulcsok lejárati idejének beállítására, hogy a régebbi értékek proaktív ki vannak zárva.</span><span class="sxs-lookup"><span data-stu-id="a6229-323">Set expiration times on hello keys so that older values are evicted proactively.</span></span>
   * <span data-ttu-id="a6229-324">A figyelő hello hello `used_memory_rss` metrika gyorsítótárazza.</span><span class="sxs-lookup"><span data-stu-id="a6229-324">Monitor hello hello `used_memory_rss` cache metric.</span></span> <span data-ttu-id="a6229-325">Ez az érték megközelíti a gyorsítótár méretének hello, valószínűleg toostart teljesítmény problémákba elkülönítésével.</span><span class="sxs-lookup"><span data-stu-id="a6229-325">When this value approaches hello size of their cache, you are likely toostart seeing performance issues.</span></span> <span data-ttu-id="a6229-326">Ha prémium szintű gyorsítótárat használ, vagy frissíti a tooa a gyorsítótár mérete nagyobb elosztása több szegmensben osztják hello adatokat.</span><span class="sxs-lookup"><span data-stu-id="a6229-326">Distribute hello data across multiple shards if you are using a premium cache, or upgrade tooa larger cache size.</span></span>
   
   <span data-ttu-id="a6229-327">További információkért lásd: [Memóriaterhelést hello kiszolgálón](#memory-pressure-on-the-server).</span><span class="sxs-lookup"><span data-stu-id="a6229-327">For more information, see [Memory Pressure on hello server](#memory-pressure-on-the-server).</span></span>

## <a name="additional-information"></a><span data-ttu-id="a6229-328">További információ</span><span class="sxs-lookup"><span data-stu-id="a6229-328">Additional information</span></span>
* [<span data-ttu-id="a6229-329">Melyik Redis Cache-ajánlatot és -méretet használjam?</span><span class="sxs-lookup"><span data-stu-id="a6229-329">What Redis Cache offering and size should I use?</span></span>](cache-faq.md#what-redis-cache-offering-and-size-should-i-use)
* [<span data-ttu-id="a6229-330">Hogyan elvégez egy teljesítménytesztet és tesztelése a gyorsítótár teljesítményének hello?</span><span class="sxs-lookup"><span data-stu-id="a6229-330">How can I benchmark and test hello performance of my cache?</span></span>](cache-faq.md#how-can-i-benchmark-and-test-the-performance-of-my-cache)
* [<span data-ttu-id="a6229-331">Hogyan futtathatom Redis parancsok?</span><span class="sxs-lookup"><span data-stu-id="a6229-331">How can I run Redis commands?</span></span>](cache-faq.md#how-can-i-run-redis-commands)
* [<span data-ttu-id="a6229-332">Hogyan toomonitor Azure Redis Cache-gyorsítótár</span><span class="sxs-lookup"><span data-stu-id="a6229-332">How toomonitor Azure Redis Cache</span></span>](cache-how-to-monitor.md)

