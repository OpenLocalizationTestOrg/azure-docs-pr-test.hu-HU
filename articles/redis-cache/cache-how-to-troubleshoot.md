---
title: "Azure Redis Cache hibaelhárítása |} Microsoft Docs"
description: "Útmutató az Azure Redis Cache gyakori problémák megoldásában."
services: redis-cache
documentationcenter: 
author: steved0x
manager: douge
editor: 
ms.assetid: 928b9b9c-d64f-4252-884f-af7ba8309af6
ms.service: cache
ms.workload: tbd
ms.tgt_pltfrm: cache-redis
ms.devlang: na
ms.topic: article
ms.date: 01/06/2017
ms.author: sdanie
ms.openlocfilehash: 2e9d1b644f1e80c7d916a261a6c47fcc11a1ffe0
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 07/11/2017
---
# <a name="how-to-troubleshoot-azure-redis-cache"></a><span data-ttu-id="dd817-103">Azure Redis Cache hibaelhárítása</span><span class="sxs-lookup"><span data-stu-id="dd817-103">How to troubleshoot Azure Redis Cache</span></span>
<span data-ttu-id="dd817-104">Ez a cikk a következő kategóriákba tartozó Azure Redis Cache problémák iránymutatásokat tartalmaz.</span><span class="sxs-lookup"><span data-stu-id="dd817-104">This article provides guidance for troubleshooting the following categories of Azure Redis Cache issues.</span></span>

* <span data-ttu-id="dd817-105">[Ügyfél oldal hibaelhárítási](#client-side-troubleshooting) – Ez a szakasz útmutatást nyújt azonosító és az alkalmazás csatlakoztatása az Azure Redis Cache által okozott problémák elhárításához.</span><span class="sxs-lookup"><span data-stu-id="dd817-105">[Client side troubleshooting](#client-side-troubleshooting) - This section provides guidelines on identifying and resolving issues caused by the application connecting to Azure Redis Cache.</span></span>
* <span data-ttu-id="dd817-106">[Kiszolgáló oldal hibaelhárítási](#server-side-troubleshooting) – Ez a szakasz útmutatást nyújt azonosító és az Azure Redis Cache kiszolgálóoldalon okozott problémák megoldása.</span><span class="sxs-lookup"><span data-stu-id="dd817-106">[Server side troubleshooting](#server-side-troubleshooting) - This section provides guidelines on identifying and resolving issues caused on the Azure Redis Cache server side.</span></span>
* <span data-ttu-id="dd817-107">[Időtúllépési kivételek StackExchange.Redis](#stackexchangeredis-timeout-exceptions) – Ez a szakasz tájékoztatást nyújt a StackExchange.Redis-ügyféllel kapcsolatos hibák elhárítása.</span><span class="sxs-lookup"><span data-stu-id="dd817-107">[StackExchange.Redis timeout exceptions](#stackexchangeredis-timeout-exceptions) - This section provides information on troubleshooting issues when using the StackExchange.Redis client.</span></span>

> [!NOTE]
> <span data-ttu-id="dd817-108">Ez az útmutató a hibaelhárítási lépéseket számos tartalmaz a Redis-parancsok futtathatja és figyelheti a teljesítménymutatók vonatkozó utasításokat.</span><span class="sxs-lookup"><span data-stu-id="dd817-108">Several of the troubleshooting steps in this guide include instructions to run Redis commands and monitor various performance metrics.</span></span> <span data-ttu-id="dd817-109">További információt és útmutatást lásd: a cikkek a [további információt](#additional-information) szakasz.</span><span class="sxs-lookup"><span data-stu-id="dd817-109">For more information and instructions, see the articles in the [Additional information](#additional-information) section.</span></span>
> 
> 

## <a name="client-side-troubleshooting"></a><span data-ttu-id="dd817-110">Ügyfél oldali hibaelhárítása</span><span class="sxs-lookup"><span data-stu-id="dd817-110">Client side troubleshooting</span></span>
<span data-ttu-id="dd817-111">Ez a szakasz ismerteti, amelyek a hibaelhárítási problémák, amelyek miatt az ügyfélalkalmazás vonatkozó feltétellel.</span><span class="sxs-lookup"><span data-stu-id="dd817-111">This section discusses troubleshooting issues that occur because of a condition on the client application.</span></span>

* [<span data-ttu-id="dd817-112">Memóriaprobléma az ügyfélen</span><span class="sxs-lookup"><span data-stu-id="dd817-112">Memory pressure on the client</span></span>](#memory-pressure-on-the-client)
* [<span data-ttu-id="dd817-113">A forgalom kapacitásnövelés</span><span class="sxs-lookup"><span data-stu-id="dd817-113">Burst of traffic</span></span>](#burst-of-traffic)
* [<span data-ttu-id="dd817-114">Magas ügyfél CPU-használat</span><span class="sxs-lookup"><span data-stu-id="dd817-114">High client CPU usage</span></span>](#high-client-cpu-usage)
* [<span data-ttu-id="dd817-115">Ügyfél oldali sávszélesség túllépve</span><span class="sxs-lookup"><span data-stu-id="dd817-115">Client Side Bandwidth Exceeded</span></span>](#client-side-bandwidth-exceeded)
* [<span data-ttu-id="dd817-116">Nagy méretű kérelem/válasz mérete</span><span class="sxs-lookup"><span data-stu-id="dd817-116">Large Request/Response Size</span></span>](#large-requestresponse-size)
* [<span data-ttu-id="dd817-117">Mi történt a Redis-adataimhoz?</span><span class="sxs-lookup"><span data-stu-id="dd817-117">What happened to my data in Redis?</span></span>](#what-happened-to-my-data-in-redis)

### <a name="memory-pressure-on-the-client"></a><span data-ttu-id="dd817-118">Memóriaprobléma az ügyfélen</span><span class="sxs-lookup"><span data-stu-id="dd817-118">Memory pressure on the client</span></span>
#### <a name="problem"></a><span data-ttu-id="dd817-119">Probléma</span><span class="sxs-lookup"><span data-stu-id="dd817-119">Problem</span></span>
<span data-ttu-id="dd817-120">Az ügyfélszámítógépen Memóriaterhelést teljesítménnyel kapcsolatos problémákat, amelyek késleltetheti-e a Redis-példány késedelem nélkül által küldött adatok feldolgozása különböző vezet.</span><span class="sxs-lookup"><span data-stu-id="dd817-120">Memory pressure on the client machine leads to all kinds of performance problems that can delay processing of data that was sent by the Redis instance without any delay.</span></span> <span data-ttu-id="dd817-121">Memóriaprobléma találatok, amikor a rendszer általában ki lap adatokat a fizikai memória, a virtuális memória, amely a lemezen.</span><span class="sxs-lookup"><span data-stu-id="dd817-121">When memory pressure hits, the system typically has to page data from physical memory to virtual memory which is on disk.</span></span> <span data-ttu-id="dd817-122">Ez *lap hibás* jelentősen lassítsa le a rendszer.</span><span class="sxs-lookup"><span data-stu-id="dd817-122">This *page faulting* causes the system to slow down significantly.</span></span>

#### <a name="measurement"></a><span data-ttu-id="dd817-123">Mérési</span><span class="sxs-lookup"><span data-stu-id="dd817-123">Measurement</span></span>
1. <span data-ttu-id="dd817-124">Győződjön meg arról, hogy azt nem haladja meg a rendelkezésre álló memória gép figyelése.</span><span class="sxs-lookup"><span data-stu-id="dd817-124">Monitor memory usage on machine to make sure that it does not exceed available memory.</span></span> 
2. <span data-ttu-id="dd817-125">A figyelő a `Page Faults/Sec` teljesítményszámláló.</span><span class="sxs-lookup"><span data-stu-id="dd817-125">Monitor the `Page Faults/Sec` performance counter.</span></span> <span data-ttu-id="dd817-126">Rendszerek többsége fog néhány laphibák normál működés során, akkor is, a teljesítményt a lapon hibák teljesítményszámláló időtúllépések, amely így figyelendő.</span><span class="sxs-lookup"><span data-stu-id="dd817-126">Most systems will have some page faults even during normal operation, so watch for spikes in this page faults performance counter which correspond with timeouts.</span></span>

#### <a name="resolution"></a><span data-ttu-id="dd817-127">Megoldás:</span><span class="sxs-lookup"><span data-stu-id="dd817-127">Resolution</span></span>
<span data-ttu-id="dd817-128">Az ügyfél frissítése a Virtuálisgép-méretet több memória nagyobb ügyfél számára, vagy a memória használati mintáinak memória consuption csökkentése érdekében a dig.</span><span class="sxs-lookup"><span data-stu-id="dd817-128">Upgrade your client to a larger client VM size with more memory or dig into your memory usage patterns to reduce memory consuption.</span></span>

### <a name="burst-of-traffic"></a><span data-ttu-id="dd817-129">A forgalom kapacitásnövelés</span><span class="sxs-lookup"><span data-stu-id="dd817-129">Burst of traffic</span></span>
#### <a name="problem"></a><span data-ttu-id="dd817-130">Probléma</span><span class="sxs-lookup"><span data-stu-id="dd817-130">Problem</span></span>
<span data-ttu-id="dd817-131">A forgalom felszakadásáig gyenge együtt `ThreadPool` beállítások adatfeldolgozás már a Redis-kiszolgáló által küldött, de még nem használt ügyféloldali késést okozhat.</span><span class="sxs-lookup"><span data-stu-id="dd817-131">Bursts of traffic combined with poor `ThreadPool` settings can result in delays in processing data already sent by the Redis Server but not yet consumed on the client side.</span></span>

#### <a name="measurement"></a><span data-ttu-id="dd817-132">Mérési</span><span class="sxs-lookup"><span data-stu-id="dd817-132">Measurement</span></span>
<span data-ttu-id="dd817-133">A figyelő hogyan a `ThreadPool` statisztika kóddal időbeli változását [, például a](https://github.com/JonCole/SampleCode/blob/master/ThreadPoolMonitor/ThreadPoolLogger.cs).</span><span class="sxs-lookup"><span data-stu-id="dd817-133">Monitor how your `ThreadPool` statistics change over time using code [like this](https://github.com/JonCole/SampleCode/blob/master/ThreadPoolMonitor/ThreadPoolLogger.cs).</span></span> <span data-ttu-id="dd817-134">Is megtalálhatja a `TimeoutException` StackExchange.Redis üzenetét.</span><span class="sxs-lookup"><span data-stu-id="dd817-134">You can also look at the `TimeoutException` message from StackExchange.Redis.</span></span> <span data-ttu-id="dd817-135">Íme egy példa:</span><span class="sxs-lookup"><span data-stu-id="dd817-135">Here is an example :</span></span>

    System.TimeoutException: Timeout performing EVAL, inst: 8, mgr: Inactive, queue: 0, qu: 0, qs: 0, qc: 0, wr: 0, wq: 0, in: 64221, ar: 0, 
    IOCP: (Busy=6,Free=999,Min=2,Max=1000), WORKER: (Busy=7,Free=8184,Min=2,Max=8191)

<span data-ttu-id="dd817-136">A fenti üzenet van több problémákra, amelyek a érdekes:</span><span class="sxs-lookup"><span data-stu-id="dd817-136">In the above message, there are several issues that are interesting:</span></span>

1. <span data-ttu-id="dd817-137">Figyelje meg, hogy az a `IOCP` szakasz és a `WORKER` szakasz rendelkezik egy `Busy` érték, amely nagyobb, mint a `Min` érték.</span><span class="sxs-lookup"><span data-stu-id="dd817-137">Notice that in the `IOCP` section and the `WORKER` section you have a `Busy` value that is greater than the `Min` value.</span></span> <span data-ttu-id="dd817-138">Ez azt jelenti, hogy a `ThreadPool` beállításait kell hangolását.</span><span class="sxs-lookup"><span data-stu-id="dd817-138">This means that your `ThreadPool` settings need adjusting.</span></span>
2. <span data-ttu-id="dd817-139">Azt is láthatja, `in: 64221`.</span><span class="sxs-lookup"><span data-stu-id="dd817-139">You can also see `in: 64221`.</span></span> <span data-ttu-id="dd817-140">Ez azt jelzi, hogy 64211 bájt a kernel szoftvercsatorna-réteg nem érkezett, de az alkalmazás (pl. StackExchange.Redis) még nem még olvasni.</span><span class="sxs-lookup"><span data-stu-id="dd817-140">This indicates that 64211 bytes have been received at the kernel socket layer but haven't yet been read by the application (e.g. StackExchange.Redis).</span></span> <span data-ttu-id="dd817-141">Ez általában azt jelenti, hogy az alkalmazás nem adatok beolvasása a hálózati gyorsan, ahogy az a kiszolgáló küld az Ön számára.</span><span class="sxs-lookup"><span data-stu-id="dd817-141">This typically means that your application isn't reading data from the network as quickly as the server is sending it to you.</span></span>

#### <a name="resolution"></a><span data-ttu-id="dd817-142">Megoldás:</span><span class="sxs-lookup"><span data-stu-id="dd817-142">Resolution</span></span>
<span data-ttu-id="dd817-143">Konfigurálja a [ThreadPool beállítások](https://gist.github.com/JonCole/e65411214030f0d823cb) győződjön meg arról, hogy a szálkészlet gyorsan, a rendszer növelheti kapacitásnövelés a forgatókönyveket.</span><span class="sxs-lookup"><span data-stu-id="dd817-143">Configure your [ThreadPool Settings](https://gist.github.com/JonCole/e65411214030f0d823cb) to make sure that your thread pool will scale up quickly under burst scenarios.</span></span>

### <a name="high-client-cpu-usage"></a><span data-ttu-id="dd817-144">Magas ügyfél CPU-használat</span><span class="sxs-lookup"><span data-stu-id="dd817-144">High client CPU usage</span></span>
#### <a name="problem"></a><span data-ttu-id="dd817-145">Probléma</span><span class="sxs-lookup"><span data-stu-id="dd817-145">Problem</span></span>
<span data-ttu-id="dd817-146">Az ügyfél magas CPU-használat utal, hogy a rendszer nem tud lépést tartani, amelyek elvégzéséhez kérték munkájába.</span><span class="sxs-lookup"><span data-stu-id="dd817-146">High CPU usage on the client is an indication that the system cannot keep up with the work that it has been asked to perform.</span></span> <span data-ttu-id="dd817-147">Ennek következménye, hogy az ügyfél Redis válaszára időben feldolgozni, annak ellenére, hogy a Redis nagyon gyorsan a választ küldött.</span><span class="sxs-lookup"><span data-stu-id="dd817-147">This means that the client may fail to process a response from Redis in a timely fashion even though Redis sent the response very quickly.</span></span>

#### <a name="measurement"></a><span data-ttu-id="dd817-148">Mérési</span><span class="sxs-lookup"><span data-stu-id="dd817-148">Measurement</span></span>
<span data-ttu-id="dd817-149">A rendszer nagy CPU-használat a társított teljesítményszámláló vagy az Azure portálon keresztül figyelheti.</span><span class="sxs-lookup"><span data-stu-id="dd817-149">Monitor the System Wide CPU usage through the Azure Portal or through the associated performance counter.</span></span> <span data-ttu-id="dd817-150">Ügyeljen arra, hogy figyelje *folyamat* mivel egyetlen folyamat CPU-használat alacsony lehet egy időben, hogy a rendszer általános CPU Processzor magas lehet.</span><span class="sxs-lookup"><span data-stu-id="dd817-150">Be careful not to monitor *process* CPU because a single process can have low CPU usage at the same time that overall system CPU can be high.</span></span> <span data-ttu-id="dd817-151">A CPU-használat teljesítményt, amelyek megfelelnek a időtúllépések figyelje.</span><span class="sxs-lookup"><span data-stu-id="dd817-151">Watch for spikes in CPU usage that correspond with timeouts.</span></span> <span data-ttu-id="dd817-152">Magas CPU miatt is találkozhat magas `in: XXX` értékei `TimeoutException` hibaüzenet leírtak szerint a [forgalom kapacitásnövelés](#burst-of-traffic) szakasz.</span><span class="sxs-lookup"><span data-stu-id="dd817-152">As a result of high CPU, you may also see high `in: XXX` values in `TimeoutException` error messages as described in the [Burst of traffic](#burst-of-traffic) section.</span></span>

> [!NOTE]
> <span data-ttu-id="dd817-153">StackExchange.Redis 1.1.603, és később tartalmazza a `local-cpu` a metrika `TimeoutException` hibaüzenetek.</span><span class="sxs-lookup"><span data-stu-id="dd817-153">StackExchange.Redis 1.1.603 and later includes the `local-cpu` metric in `TimeoutException` error messages.</span></span> <span data-ttu-id="dd817-154">Győződjön meg arról, hogy a legújabb verzióját használja a [StackExchange.Redis NuGet-csomag](https://www.nuget.org/packages/StackExchange.Redis/).</span><span class="sxs-lookup"><span data-stu-id="dd817-154">Ensure you using the latest version of the [StackExchange.Redis NuGet package](https://www.nuget.org/packages/StackExchange.Redis/).</span></span> <span data-ttu-id="dd817-155">Nincsenek abba, hogy sokkal hatékonyabban időtúllépések számára a legújabb verzióra, akkor fontos, a kódban folyamatosan javított hibák.</span><span class="sxs-lookup"><span data-stu-id="dd817-155">There are bugs constantly being fixed in the code to make it more robust to timeouts so having the latest version is important.</span></span>
> 
> 

#### <a name="resolution"></a><span data-ttu-id="dd817-156">Megoldás:</span><span class="sxs-lookup"><span data-stu-id="dd817-156">Resolution</span></span>
<span data-ttu-id="dd817-157">Használjon további CPU-kapacitás nagyobb Virtuálisgép-méretet, vagy vizsgálja meg, mi okozza a CPU teljesítményt.</span><span class="sxs-lookup"><span data-stu-id="dd817-157">Upgrade to a larger VM size with more CPU capacity or investigate what is causing CPU spikes.</span></span> 

### <a name="client-side-bandwidth-exceeded"></a><span data-ttu-id="dd817-158">Ügyfél oldali sávszélesség túllépve</span><span class="sxs-lookup"><span data-stu-id="dd817-158">Client side bandwidth exceeded</span></span>
#### <a name="problem"></a><span data-ttu-id="dd817-159">Probléma</span><span class="sxs-lookup"><span data-stu-id="dd817-159">Problem</span></span>
<span data-ttu-id="dd817-160">Különböző méretű ügyfélgépek korlátozásokkal rendelkezik mekkora hálózati sávszélességre gyakorolt rendelkeznek érhető el.</span><span class="sxs-lookup"><span data-stu-id="dd817-160">Different sized client machines have limitations on how much network bandwidth they have available.</span></span> <span data-ttu-id="dd817-161">Ha az ügyfél meghaladja a rendelkezésre álló sávszélességet, majd adatok nem dolgoz fel az ügyféloldalon gyorsan, ahogy az a kiszolgáló küld.</span><span class="sxs-lookup"><span data-stu-id="dd817-161">If the client exceeds the available bandwidth, then data will not be processed on the client side as quickly as the server is sending it.</span></span> <span data-ttu-id="dd817-162">Ez időtúllépések vezethet.</span><span class="sxs-lookup"><span data-stu-id="dd817-162">This can lead to timeouts.</span></span>

#### <a name="measurement"></a><span data-ttu-id="dd817-163">Mérési</span><span class="sxs-lookup"><span data-stu-id="dd817-163">Measurement</span></span>
<span data-ttu-id="dd817-164">Figyelje meg, hogyan a sávszélesség-használat idővel kód használatával módosítani [, például a](https://github.com/JonCole/SampleCode/blob/master/BandWidthMonitor/BandwidthLogger.cs).</span><span class="sxs-lookup"><span data-stu-id="dd817-164">Monitor how your Bandwidth usage change over time using code [like this](https://github.com/JonCole/SampleCode/blob/master/BandWidthMonitor/BandwidthLogger.cs).</span></span> <span data-ttu-id="dd817-165">Vegye figyelembe, hogy ez a kód nem futtatható az sikeresen bizonyos környezetekben (például az Azure webhelyek) korlátozott engedélyekkel.</span><span class="sxs-lookup"><span data-stu-id="dd817-165">Note that this code may not run successfully in some environments with restricted permissions (like Azure web sites).</span></span>

#### <a name="resolution"></a><span data-ttu-id="dd817-166">Megoldás:</span><span class="sxs-lookup"><span data-stu-id="dd817-166">Resolution</span></span>
<span data-ttu-id="dd817-167">Növelje az ügyfél virtuális gép méretét, vagy csökkentse a hálózati sávszélességet.</span><span class="sxs-lookup"><span data-stu-id="dd817-167">Increase Client VM size or reduce network bandwidth consumption.</span></span>

### <a name="large-requestresponse-size"></a><span data-ttu-id="dd817-168">Nagy méretű kérelem/válasz mérete</span><span class="sxs-lookup"><span data-stu-id="dd817-168">Large Request/Response Size</span></span>
#### <a name="problem"></a><span data-ttu-id="dd817-169">Probléma</span><span class="sxs-lookup"><span data-stu-id="dd817-169">Problem</span></span>
<span data-ttu-id="dd817-170">A nagy méretű kérelem/válasz időtúllépések okozhat.</span><span class="sxs-lookup"><span data-stu-id="dd817-170">A large request/response can cause timeouts.</span></span> <span data-ttu-id="dd817-171">Tegyük fel tegyük fel, hogy az időkorlát az ügyfélhez konfigurált értéke 1 másodperc.</span><span class="sxs-lookup"><span data-stu-id="dd817-171">As an example, Suppose your timeout value configured on your client is 1 second.</span></span> <span data-ttu-id="dd817-172">Az alkalmazás (pl. kér két kulcs "A" és "B") egy időben (ugyanazt a fizikai hálózati kapcsolatot használja).</span><span class="sxs-lookup"><span data-stu-id="dd817-172">Your application requests two keys (e.g. 'A' and 'B') at the same time (using the same physical network connection).</span></span> <span data-ttu-id="dd817-173">A legtöbb ügyfelek támogatják a "Pipelining" kérelmek, úgy, hogy mindkét kérelmek "A" és "B" nélkül küldi el a keresztülhaladnak a hálózaton a kiszolgálóra, egy a Várakozás a válaszra.</span><span class="sxs-lookup"><span data-stu-id="dd817-173">Most clients support "Pipelining" of requests, such that both requests 'A' and 'B' are sent on the wire to the server one after the other without waiting for the responses.</span></span> <span data-ttu-id="dd817-174">A kiszolgáló vissza ugyanabban a sorrendben küldi a válaszokat.</span><span class="sxs-lookup"><span data-stu-id="dd817-174">The server will send the responses back in the same order.</span></span> <span data-ttu-id="dd817-175">Ha a válasz "A" nagy elég azt is keleti-afrikai leggyakrabban kérelmeknél időtúllépés.</span><span class="sxs-lookup"><span data-stu-id="dd817-175">If response 'A' is large enough it can eat up most of the timeout for subsequent requests.</span></span> 

<span data-ttu-id="dd817-176">A következő példa bemutatja, ebben a forgatókönyvben.</span><span class="sxs-lookup"><span data-stu-id="dd817-176">The following example demonstrates this scenario.</span></span> <span data-ttu-id="dd817-177">Ebben a forgatókönyvben gyorsan küldött kérelem "A" és "B", a kiszolgáló elkezdi gyors küldése válaszok "A" és "B", de miatt adatátviteli idők, "B" elakadnak kérelem és időtúllépést mögött annak ellenére, hogy a kiszolgáló válasza gyorsan.</span><span class="sxs-lookup"><span data-stu-id="dd817-177">In this scenario, Request 'A' and 'B' are sent quickly, the server starts sending responses 'A' and 'B' quickly, but because of data transfer times, 'B' get stuck behind the other request and times out even though the server responded quickly.</span></span>

    |-------- 1 Second Timeout (A)----------|
    |-Request A-|
         |-------- 1 Second Timeout (B) ----------|
         |-Request B-|
                |- Read Response A --------|
                                           |- Read Response B-| (**TIMEOUT**)



#### <a name="measurement"></a><span data-ttu-id="dd817-178">Mérési</span><span class="sxs-lookup"><span data-stu-id="dd817-178">Measurement</span></span>
<span data-ttu-id="dd817-179">Ez a mérésére nehéz egy.</span><span class="sxs-lookup"><span data-stu-id="dd817-179">This is a difficult one to measure.</span></span> <span data-ttu-id="dd817-180">Alapvetően kell állíthatnak be az Ügyfélkód nyomon követéséhez nagy kérelmeit és válaszait.</span><span class="sxs-lookup"><span data-stu-id="dd817-180">You basically have to instrument your client code to track large requests and responses.</span></span> 

#### <a name="resolution"></a><span data-ttu-id="dd817-181">Megoldás:</span><span class="sxs-lookup"><span data-stu-id="dd817-181">Resolution</span></span>
1. <span data-ttu-id="dd817-182">A redis nagyszámú kis értékek ahelyett, hogy néhány nagy értékek van optimalizálva.</span><span class="sxs-lookup"><span data-stu-id="dd817-182">Redis is optimized for a large number of small values, rather than a few large values.</span></span> <span data-ttu-id="dd817-183">Az előnyben részesített megoldás, hogy a kapcsolódó a kisebb értékek adatimportáláshoz feloszthatja.</span><span class="sxs-lookup"><span data-stu-id="dd817-183">The preferred solution is to break up your data into related smaller values.</span></span> <span data-ttu-id="dd817-184">Tekintse meg a [Mi az az ideális méretét értéktartománya a redis? Túl nagy érték 100KB? ](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ) utáni körül Miért ajánlott a kisebb értékek részleteiről.</span><span class="sxs-lookup"><span data-stu-id="dd817-184">See the [What is the ideal value size range for redis? Is 100KB too large?](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ) post for details around why smaller values are recommended.</span></span>
2. <span data-ttu-id="dd817-185">(Az ügyfél és a Redis gyorsítótár-kiszolgáló), a virtuális gép méretének növelése nagyobb sávszélesség lehetőségek, csökkenti a nagyobb válaszok adatátviteli idők elérése.</span><span class="sxs-lookup"><span data-stu-id="dd817-185">Increase the size of your VM (for client and Redis Cache Server), to get higher bandwidth capabilities, reducing data transfer times for larger responses.</span></span> <span data-ttu-id="dd817-186">Előfordulhat, hogy további sávszélesség csak a kiszolgálón vagy csak az első az ügyfél nem elegendő.</span><span class="sxs-lookup"><span data-stu-id="dd817-186">Note that getting more bandwidth on just the server or just on the client may not be enough.</span></span> <span data-ttu-id="dd817-187">A sávszélesség mérését, és hasonlítsa össze azokat a funkciókat a virtuális gép jelenleg a mérete.</span><span class="sxs-lookup"><span data-stu-id="dd817-187">Measure your bandwidth usage and compare it to the capabilities of the size of VM you currently have.</span></span>
3. <span data-ttu-id="dd817-188">Az értéknek a növelésével `ConnectionMultiplexer` meg különböző kapcsolatokon keresztül objektumokat használatát és ciklikus multiplexelés kérelmeket.</span><span class="sxs-lookup"><span data-stu-id="dd817-188">Increase the number of `ConnectionMultiplexer` objects you use and round-robin requests over different connections.</span></span>

### <a name="what-happened-to-my-data-in-redis"></a><span data-ttu-id="dd817-189">Mi történt a Redis-adataimhoz?</span><span class="sxs-lookup"><span data-stu-id="dd817-189">What happened to my data in Redis?</span></span>
#### <a name="problem"></a><span data-ttu-id="dd817-190">Probléma</span><span class="sxs-lookup"><span data-stu-id="dd817-190">Problem</span></span>
<span data-ttu-id="dd817-191">Bizonyos adatok a saját Azure Redis Cache példányt várt, de nem tűnik, hogy létezik.</span><span class="sxs-lookup"><span data-stu-id="dd817-191">I expected for certain data to be in my Azure Redis Cache instance but it didn't seem to be there.</span></span>

#### <a name="resolution"></a><span data-ttu-id="dd817-192">Megoldás:</span><span class="sxs-lookup"><span data-stu-id="dd817-192">Resolution</span></span>
<span data-ttu-id="dd817-193">Lásd: [Mi történt a Redis-adataimhoz?](https://gist.github.com/JonCole/b6354d92a2d51c141490f10142884ea4#file-whathappenedtomydatainredis-md) a lehetséges okokért és megoldásokért.</span><span class="sxs-lookup"><span data-stu-id="dd817-193">See [What happened to my data in Redis?](https://gist.github.com/JonCole/b6354d92a2d51c141490f10142884ea4#file-whathappenedtomydatainredis-md) for possible causes and resolutions.</span></span>

## <a name="server-side-troubleshooting"></a><span data-ttu-id="dd817-194">Kiszolgáló oldalán hibaelhárítása</span><span class="sxs-lookup"><span data-stu-id="dd817-194">Server side troubleshooting</span></span>
<span data-ttu-id="dd817-195">Ez a szakasz ismerteti, amelyek a hibaelhárítási problémák, amelyek miatt egy feltétel, a gyorsítótár-kiszolgálón.</span><span class="sxs-lookup"><span data-stu-id="dd817-195">This section discusses troubleshooting issues that occur because of a condition on the cache server.</span></span>

* [<span data-ttu-id="dd817-196">A kiszolgáló Memóriaterhelése</span><span class="sxs-lookup"><span data-stu-id="dd817-196">Memory Pressure on the server</span></span>](#memory-pressure-on-the-server)
* [<span data-ttu-id="dd817-197">Magas CPU-használatot / Server betöltése</span><span class="sxs-lookup"><span data-stu-id="dd817-197">High CPU usage / Server Load</span></span>](#high-cpu-usage-server-load)
* [<span data-ttu-id="dd817-198">Túllépte a kiszolgáló ügyféloldali sávszélesség</span><span class="sxs-lookup"><span data-stu-id="dd817-198">Server Side Bandwidth Exceeded</span></span>](#server-side-bandwidth-exceeded)

### <a name="memory-pressure-on-the-server"></a><span data-ttu-id="dd817-199">A kiszolgáló Memóriaterhelése</span><span class="sxs-lookup"><span data-stu-id="dd817-199">Memory Pressure on the server</span></span>
#### <a name="problem"></a><span data-ttu-id="dd817-200">Probléma</span><span class="sxs-lookup"><span data-stu-id="dd817-200">Problem</span></span>
<span data-ttu-id="dd817-201">A kiszolgáló oldalán Memóriaterhelést teljesítménnyel kapcsolatos problémákat, amelyek késleltetheti-e a kérelmek feldolgozásának különböző vezet.</span><span class="sxs-lookup"><span data-stu-id="dd817-201">Memory pressure on the server side leads to all kinds of performance problems that can delay processing of requests.</span></span> <span data-ttu-id="dd817-202">Memóriaprobléma találatok, amikor a rendszer általában ki lap adatokat a fizikai memória, a virtuális memória, amely a lemezen.</span><span class="sxs-lookup"><span data-stu-id="dd817-202">When memory pressure hits, the system typically has to page data from physical memory to virtual memory which is on disk.</span></span> <span data-ttu-id="dd817-203">Ez *lap hibás* jelentősen lassítsa le a rendszer.</span><span class="sxs-lookup"><span data-stu-id="dd817-203">This *page faulting* causes the system to slow down significantly.</span></span> <span data-ttu-id="dd817-204">Nincsenek a memóriaterhelése lehetséges okai:</span><span class="sxs-lookup"><span data-stu-id="dd817-204">There are several possible causes of this memory pressure:</span></span> 

1. <span data-ttu-id="dd817-205">A gyorsítótár teljes kapacitás töltötte adatokkal.</span><span class="sxs-lookup"><span data-stu-id="dd817-205">You have filled the cache to full capacity with data.</span></span> 
2. <span data-ttu-id="dd817-206">A redis kapja a nagy a memória töredezettségét - leggyakrabban okozta nagy objektumok tárolására (Redis úgy optimalizálták, hogy egy kis objektumok – tekintse meg a [Mi az az ideális méretét értéktartománya a redis? Túl nagy érték 100KB? ](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ) részletes post).</span><span class="sxs-lookup"><span data-stu-id="dd817-206">Redis is seeing high memory fragmentation - most often caused by storing large objects (Redis is optimized for a small objects - See the [What is the ideal value size range for redis? Is 100KB too large?](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ) post for details).</span></span> 

#### <a name="measurement"></a><span data-ttu-id="dd817-207">Mérési</span><span class="sxs-lookup"><span data-stu-id="dd817-207">Measurement</span></span>
<span data-ttu-id="dd817-208">Redis mutatja meg, amelyek segítenek azonosítani azokat a probléma két metrikákat.</span><span class="sxs-lookup"><span data-stu-id="dd817-208">Redis exposes two metrics that can help you identify this issue.</span></span> <span data-ttu-id="dd817-209">Az első `used_memory` , a másik `used_memory_rss`.</span><span class="sxs-lookup"><span data-stu-id="dd817-209">The first is `used_memory` and the other is `used_memory_rss`.</span></span> <span data-ttu-id="dd817-210">[A metrikák](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) az Azure portál vagy azon keresztül elérhető a [Redis INFO](http://redis.io/commands/info) parancsot.</span><span class="sxs-lookup"><span data-stu-id="dd817-210">[These metrics](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) are available in the Azure Portal or through the [Redis INFO](http://redis.io/commands/info) command.</span></span>

#### <a name="resolution"></a><span data-ttu-id="dd817-211">Megoldás:</span><span class="sxs-lookup"><span data-stu-id="dd817-211">Resolution</span></span>
<span data-ttu-id="dd817-212">Van több lehetséges módosítások, amelyek biztosíthatják a memóriahasználat kifogástalan tehet:</span><span class="sxs-lookup"><span data-stu-id="dd817-212">There are several possible changes that you can make to help keep memory usage healthy:</span></span>

1. <span data-ttu-id="dd817-213">[Memória-házirendet konfigurálhat](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) és a kulcsok lejárati idejének beállítására.</span><span class="sxs-lookup"><span data-stu-id="dd817-213">[Configure a memory policy](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) and set expiration times on your keys.</span></span> <span data-ttu-id="dd817-214">Előfordulhat, hogy ez nem elegendő, ha töredezettsége rendelkezik.</span><span class="sxs-lookup"><span data-stu-id="dd817-214">Note that this may not be sufficient if you have fragmentation.</span></span>
2. <span data-ttu-id="dd817-215">[Maxmemory fenntartott érték](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) , hogy elég nagy a memória töredezettségét kártalanítja.</span><span class="sxs-lookup"><span data-stu-id="dd817-215">[Configure a maxmemory-reserved value](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) that is large enough to compensate for memory fragmentation.</span></span>
3. <span data-ttu-id="dd817-216">Szakítsa meg a nagy a gyorsítótárazott objektumok kisebb kapcsolódó objektumot.</span><span class="sxs-lookup"><span data-stu-id="dd817-216">Break up your large cached objects into smaller related objects.</span></span>
4. <span data-ttu-id="dd817-217">[Skála](cache-how-to-scale.md) a gyorsítótár méretének.</span><span class="sxs-lookup"><span data-stu-id="dd817-217">[Scale](cache-how-to-scale.md) to a larger cache size.</span></span>
5. <span data-ttu-id="dd817-218">Használatakor a [prémium gyorsítótár engedélyezve van a Redis-fürt](cache-how-to-premium-clustering.md) is [szilánkok számának növelése](cache-how-to-premium-clustering.md#change-the-cluster-size-on-a-running-premium-cache).</span><span class="sxs-lookup"><span data-stu-id="dd817-218">If you are using a [premium cache with Redis cluster enabled](cache-how-to-premium-clustering.md) you can [increase the number of shards](cache-how-to-premium-clustering.md#change-the-cluster-size-on-a-running-premium-cache).</span></span>

### <a name="high-cpu-usage--server-load"></a><span data-ttu-id="dd817-219">Magas CPU-használatot / Server betöltése</span><span class="sxs-lookup"><span data-stu-id="dd817-219">High CPU usage / Server Load</span></span>
#### <a name="problem"></a><span data-ttu-id="dd817-220">Probléma</span><span class="sxs-lookup"><span data-stu-id="dd817-220">Problem</span></span>
<span data-ttu-id="dd817-221">Magas CPU-használatot azt, hogy az ügyféloldali meghiúsulhat, ha a Redis válaszára időben feldolgozni, annak ellenére, hogy a Redis nagyon gyorsan a választ küldött.</span><span class="sxs-lookup"><span data-stu-id="dd817-221">High CPU usage can mean that the client side can fail to process a response from Redis in a timely fashion even though Redis sent the response very quickly.</span></span>

#### <a name="measurement"></a><span data-ttu-id="dd817-222">Mérési</span><span class="sxs-lookup"><span data-stu-id="dd817-222">Measurement</span></span>
<span data-ttu-id="dd817-223">A rendszer nagy CPU-használat a társított teljesítményszámláló vagy az Azure portálon keresztül figyelheti.</span><span class="sxs-lookup"><span data-stu-id="dd817-223">Monitor the System Wide CPU usage through the Azure Portal or through the associated performance counter.</span></span> <span data-ttu-id="dd817-224">Ügyeljen arra, hogy figyelje *folyamat* mivel egyetlen folyamat CPU-használat alacsony lehet egy időben, hogy a rendszer általános CPU Processzor magas lehet.</span><span class="sxs-lookup"><span data-stu-id="dd817-224">Be careful not to monitor *process* CPU because a single process can have low CPU usage at the same time that overall system CPU can be high.</span></span> <span data-ttu-id="dd817-225">A CPU-használat teljesítményt, amelyek megfelelnek a időtúllépések figyelje.</span><span class="sxs-lookup"><span data-stu-id="dd817-225">Watch for spikes in CPU usage that correspond with timeouts.</span></span>

#### <a name="resolution"></a><span data-ttu-id="dd817-226">Megoldás:</span><span class="sxs-lookup"><span data-stu-id="dd817-226">Resolution</span></span>
<span data-ttu-id="dd817-227">[Skála](cache-how-to-scale.md) nagyobb gyorsítótárhoz réteg további CPU-kapacitással rendelkező átjáróeszközt, vagy meg kell vizsgálnia, mi okozza a CPU teljesítményt.</span><span class="sxs-lookup"><span data-stu-id="dd817-227">[Scale](cache-how-to-scale.md) to a larger cache tier with more CPU capacity or investigate what is causing CPU spikes.</span></span> 

### <a name="server-side-bandwidth-exceeded"></a><span data-ttu-id="dd817-228">Túllépte a kiszolgáló ügyféloldali sávszélesség</span><span class="sxs-lookup"><span data-stu-id="dd817-228">Server Side Bandwidth Exceeded</span></span>
#### <a name="problem"></a><span data-ttu-id="dd817-229">Probléma</span><span class="sxs-lookup"><span data-stu-id="dd817-229">Problem</span></span>
<span data-ttu-id="dd817-230">Különböző méretű gyorsítótár célpéldánynál korlátozások mekkora hálózati sávszélességre gyakorolt rendelkeznek érhető el.</span><span class="sxs-lookup"><span data-stu-id="dd817-230">Different sized cache instances have limitations on how much network bandwidth they have available.</span></span> <span data-ttu-id="dd817-231">Ha a kiszolgáló meghaladja a rendelkezésre álló sávszélességet, majd adatok nem küldhetők gyorsan, az ügyfélnek.</span><span class="sxs-lookup"><span data-stu-id="dd817-231">If the server exceeds the available bandwidth, then data will not be sent to the client as quickly.</span></span> <span data-ttu-id="dd817-232">Ez időtúllépések vezethet.</span><span class="sxs-lookup"><span data-stu-id="dd817-232">This can lead to timeouts.</span></span>

#### <a name="measurement"></a><span data-ttu-id="dd817-233">Mérési</span><span class="sxs-lookup"><span data-stu-id="dd817-233">Measurement</span></span>
<span data-ttu-id="dd817-234">Figyelheti a `Cache Read` metrika, amely adatok mennyisége gyorsítótárából olvasta be a megabájt / másodperc (MB/s) a megadott jelentési időszak során.</span><span class="sxs-lookup"><span data-stu-id="dd817-234">You can monitor the `Cache Read` metric, which is the amount of data read from the cache in Megabytes per second (MB/s) during the specified reporting interval.</span></span> <span data-ttu-id="dd817-235">Ennek az értéknek felel meg a gyorsítótár által használt hálózati sávszélesség.</span><span class="sxs-lookup"><span data-stu-id="dd817-235">This value corresponds to the network bandwidth used by this cache.</span></span> <span data-ttu-id="dd817-236">Ha azt szeretné, a kiszolgáló oldalán hálózati sávszélesség korlátja riasztások beállítása, ennek segítségével létrehozhat `Cache Read` számláló.</span><span class="sxs-lookup"><span data-stu-id="dd817-236">If you want to set up alerts for server side network bandwidth limits, you can create them using this `Cache Read` counter.</span></span> <span data-ttu-id="dd817-237">Hasonlítsa össze az értékek a értékkel rendelkező [ezt a táblázatot](cache-faq.md#cache-performance) különböző árképzési szinteket, és méretű gyorsítótár megfigyelt sávszélesség korlátait.</span><span class="sxs-lookup"><span data-stu-id="dd817-237">Compare your readings with the values in [this table](cache-faq.md#cache-performance) for the observed bandwidth limits for various cache pricing tiers and sizes.</span></span>

#### <a name="resolution"></a><span data-ttu-id="dd817-238">Megoldás:</span><span class="sxs-lookup"><span data-stu-id="dd817-238">Resolution</span></span>
<span data-ttu-id="dd817-239">Ha következetesen közelében a megfigyelt maximális sávszélesség a árképzési szint és a gyorsítótár méretét, fontolja meg [skálázás](cache-how-to-scale.md) árképzési szint és mérete nagyobb hálózati sávszélesség álljon, az értékekkel a [ezt a táblázatot](cache-faq.md#cache-performance)útmutatóként.</span><span class="sxs-lookup"><span data-stu-id="dd817-239">If you are consistently near the observed maximum bandwidth for your pricing tier and cache size, consider [scaling](cache-how-to-scale.md) to a pricing tier or size that has greater network bandwidth, using the values in [this table](cache-faq.md#cache-performance) as a guide.</span></span>

## <a name="stackexchangeredis-timeout-exceptions"></a><span data-ttu-id="dd817-240">StackExchange.Redis időtúllépési kivétel</span><span class="sxs-lookup"><span data-stu-id="dd817-240">StackExchange.Redis timeout exceptions</span></span>
<span data-ttu-id="dd817-241">StackExchange.Redis nevű konfigurációs beállítást használja `synctimeout` szinkron műveletekhez, amely 1000 ms alapértelmezett értéke.</span><span class="sxs-lookup"><span data-stu-id="dd817-241">StackExchange.Redis uses a configuration setting named `synctimeout` for synchronous operations which has a default value  of 1000 ms.</span></span> <span data-ttu-id="dd817-242">Ha egy aszinkron hívás nem fejezi be a meghatározott időben, a StackExchange.Redis ügyfél jelez az alábbi példához hasonló időtúllépési hiba.</span><span class="sxs-lookup"><span data-stu-id="dd817-242">If a synchronous call doesn’t complete in the stipulated time, the StackExchange.Redis client throws a timeout error similar to the following example.</span></span>

    System.TimeoutException: Timeout performing MGET 2728cc84-58ae-406b-8ec8-3f962419f641, inst: 1,mgr: Inactive, queue: 73, qu=6, qs=67, qc=0, wr=1/1, in=0/0 IOCP: (Busy=6, Free=999, Min=2,Max=1000), WORKER (Busy=7,Free=8184,Min=2,Max=8191)


<span data-ttu-id="dd817-243">Ez a hibaüzenet, amely segíthet a probléma okát és lehetséges megoldás, mutasson metrikák tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="dd817-243">This error message contains metrics that can help point you to the cause and possible resolution of the issue.</span></span> <span data-ttu-id="dd817-244">A következő táblázat tartalmazza a hiba üzenet metrikák részleteit.</span><span class="sxs-lookup"><span data-stu-id="dd817-244">The following table contains details about the error message metrics.</span></span>

| <span data-ttu-id="dd817-245">Hiba történt a üzenet metrika</span><span class="sxs-lookup"><span data-stu-id="dd817-245">Error message metric</span></span> | <span data-ttu-id="dd817-246">Részletek</span><span class="sxs-lookup"><span data-stu-id="dd817-246">Details</span></span> |
| --- | --- |
| <span data-ttu-id="dd817-247">INST</span><span class="sxs-lookup"><span data-stu-id="dd817-247">inst</span></span> |<span data-ttu-id="dd817-248">Az utolsó időszelet: 0 parancsok kiállították.</span><span class="sxs-lookup"><span data-stu-id="dd817-248">In the last time slice: 0 commands have been issued</span></span> |
| <span data-ttu-id="dd817-249">kezelője</span><span class="sxs-lookup"><span data-stu-id="dd817-249">mgr</span></span> |<span data-ttu-id="dd817-250">A szoftvercsatorna-kezelő hajt végre `socket.select` ami azt jelenti, hogy azt kéri, az operációs rendszer annak jelzésére, amelynek valami; ehhez szoftvercsatorna alapvetően: az olvasó értéke nem aktívan olvasása a hálózatról, mert az nem gondolja bármilyen formában</span><span class="sxs-lookup"><span data-stu-id="dd817-250">The socket manager is performing `socket.select` which means it is asking the OS to indicate a socket that has something to do; basically: the reader is not actively reading from the network because it doesn't think there is anything to do</span></span> |
| <span data-ttu-id="dd817-251">Várólista</span><span class="sxs-lookup"><span data-stu-id="dd817-251">queue</span></span> |<span data-ttu-id="dd817-252">73 összes folyamatban lévő műveletek</span><span class="sxs-lookup"><span data-stu-id="dd817-252">There are 73 total in-progress operations</span></span> |
| <span data-ttu-id="dd817-253">qu</span><span class="sxs-lookup"><span data-stu-id="dd817-253">qu</span></span> |<span data-ttu-id="dd817-254">a folyamatban lévő műveletek 6 az el nem küldött várólistájuk, és még nem írt a kimenő hálózati</span><span class="sxs-lookup"><span data-stu-id="dd817-254">6 of the in-progress operations are in the unsent queue and have not yet been written to the outbound network</span></span> |
| <span data-ttu-id="dd817-255">QS</span><span class="sxs-lookup"><span data-stu-id="dd817-255">qs</span></span> |<span data-ttu-id="dd817-256">67-es helykiszolgálójához folyamatban lévő műveletek a kiszolgáló által elküldött, de a választ még nem érhető el.</span><span class="sxs-lookup"><span data-stu-id="dd817-256">67 of he in-progress operations have been sent to the server but a response is not yet available.</span></span> <span data-ttu-id="dd817-257">A válasz lehet `Not yet sent by the server` vagy`sent by the server but not yet processed by the client.`</span><span class="sxs-lookup"><span data-stu-id="dd817-257">The response could be `Not yet sent by the server` or `sent by the server but not yet processed by the client.`</span></span> |
| <span data-ttu-id="dd817-258">QC</span><span class="sxs-lookup"><span data-stu-id="dd817-258">qc</span></span> |<span data-ttu-id="dd817-259">a folyamatban lévő műveletek 0 választ láthatta, de rendelkezik nincs megjelölve, Várakozás a befejezési hurok miatt befejeződött</span><span class="sxs-lookup"><span data-stu-id="dd817-259">0 of the in-progress operations have seen replies but have not yet been marked as complete due to waiting on the completion loop</span></span> |
| <span data-ttu-id="dd817-260">wR</span><span class="sxs-lookup"><span data-stu-id="dd817-260">wr</span></span> |<span data-ttu-id="dd817-261">Nincs egy aktív írási (ami azt jelenti, a 6 el nem küldött kérelmek nem lesznek mellőzve) bájt/activewriters</span><span class="sxs-lookup"><span data-stu-id="dd817-261">There is an active writer (meaning the 6 unsent requests are not being ignored) bytes/activewriters</span></span> |
| <span data-ttu-id="dd817-262">A</span><span class="sxs-lookup"><span data-stu-id="dd817-262">in</span></span> |<span data-ttu-id="dd817-263">Nincs aktív olvasó és elérhető legyen a hálózati bájtok/activereaders nulla bájt</span><span class="sxs-lookup"><span data-stu-id="dd817-263">There are no active readers and zero bytes are available to be read on the NIC bytes/activereaders</span></span> |

### <a name="steps-to-investigate"></a><span data-ttu-id="dd817-264">Vizsgálja meg lépései</span><span class="sxs-lookup"><span data-stu-id="dd817-264">Steps to investigate</span></span>
1. <span data-ttu-id="dd817-265">Gondoskodjon arról, hogy az ajánlott eljárás segítségével végzi a következő mintát csatlakozás, ha a StackExchange.Redis-ügyfélprogrammal.</span><span class="sxs-lookup"><span data-stu-id="dd817-265">As a best practice make sure you are using the following pattern to connect when using the StackExchange.Redis client.</span></span>

    ```c#
    private static Lazy<ConnectionMultiplexer> lazyConnection = new Lazy<ConnectionMultiplexer>(() =>
    {
        return ConnectionMultiplexer.Connect("cachename.redis.cache.windows.net,abortConnect=false,ssl=true,password=...");
    
    });
    
    public static ConnectionMultiplexer Connection
    {
        get
        {
            return lazyConnection.Value;
        }
    }
    ````

    <span data-ttu-id="dd817-266">További információkért lásd: [csatlakozás a gyorsítótárhoz StackExchange.Redis használatával](cache-dotnet-how-to-use-azure-redis-cache.md#connect-to-the-cache).</span><span class="sxs-lookup"><span data-stu-id="dd817-266">For more information, see [Connect to the cache using StackExchange.Redis](cache-dotnet-how-to-use-azure-redis-cache.md#connect-to-the-cache).</span></span>

1. <span data-ttu-id="dd817-267">Ellenőrizze, hogy az Azure Redis Cache és az ügyfélalkalmazás az Azure-ban ugyanabban a régióban.</span><span class="sxs-lookup"><span data-stu-id="dd817-267">Ensure that your Azure Redis Cache and the client application are in the same region in Azure.</span></span> <span data-ttu-id="dd817-268">Például akkor lehet, hogy lehet első időtúllépések Ha a gyorsítótár USA keleti régiója, de az ügyfél csatlakozik az USA nyugati régiója és a kérelem nem fejezi be belül a `synctimeout` időköz, vagy előfordulhat, hogy lehet első időtúllépések Ha meg vannak hibakereséshez a következőből: a helyi fejlesztési számítógépén.</span><span class="sxs-lookup"><span data-stu-id="dd817-268">For example, you might be getting timeouts when your cache is in East US but the client is in West US and the request doesn't complete within the `synctimeout` interval or you might be getting timeouts when you are debugging from your local development machine.</span></span> 
   
    <span data-ttu-id="dd817-269">Rendelkezik a gyorsítótár rendelkezik erősen ajánlott és az ügyfél azonos Azure-régióban.</span><span class="sxs-lookup"><span data-stu-id="dd817-269">It’s highly recommended to have the cache and in the client in the same Azure region.</span></span> <span data-ttu-id="dd817-270">Ha olyan forgatókönyvekben, amelyek több régióban hívások tartalmaz, célszerű a `synctimeout` időköz értéke nagyobb, mint az alapértelmezett 1000 ms-ot egy `synctimeout` tulajdonság a kapcsolati karakterláncban.</span><span class="sxs-lookup"><span data-stu-id="dd817-270">If you have a scenario that includes cross region calls, you should set the `synctimeout` interval to a value higher than the default 1000 ms interval by including a `synctimeout` property in the connection string.</span></span> <span data-ttu-id="dd817-271">A következő példa bemutatja a StackExchange.Redis gyorsítótár kapcsolati karakterlánc részlet rendelkező egy `synctimeout` 2000 MS.</span><span class="sxs-lookup"><span data-stu-id="dd817-271">The following example shows a StackExchange.Redis cache connection string snippet with a `synctimeout` of 2000 ms.</span></span>
   
        synctimeout=2000,cachename.redis.cache.windows.net,abortConnect=false,ssl=true,password=...
2. <span data-ttu-id="dd817-272">Győződjön meg arról, hogy a legújabb verzióját használja a [StackExchange.Redis NuGet-csomag](https://www.nuget.org/packages/StackExchange.Redis/).</span><span class="sxs-lookup"><span data-stu-id="dd817-272">Ensure you using the latest version of the [StackExchange.Redis NuGet package](https://www.nuget.org/packages/StackExchange.Redis/).</span></span> <span data-ttu-id="dd817-273">Nincsenek abba, hogy sokkal hatékonyabban időtúllépések számára a legújabb verzióra, akkor fontos, a kódban folyamatosan javított hibák.</span><span class="sxs-lookup"><span data-stu-id="dd817-273">There are bugs constantly being fixed in the code to make it more robust to timeouts so having the latest version is important.</span></span>
3. <span data-ttu-id="dd817-274">Ha nincs sávszélességgel kapcsolatos korlátozásai a kiszolgálón vagy az ügyfél által első kötött, végezze el, és ekkor időtúllépések, hogy tovább tart.</span><span class="sxs-lookup"><span data-stu-id="dd817-274">If there are requests that are getting bound by bandwidth limitations on the server or client, it will take longer for them to complete and thereby cause timeouts.</span></span> <span data-ttu-id="dd817-275">Ha az időtúllépés okozza-e a kiszolgálón a hálózati sávszélesség, olvassa el [túllépte a kiszolgáló ügyféloldali sávszélesség](#server-side-bandwidth-exceeded).</span><span class="sxs-lookup"><span data-stu-id="dd817-275">To see if your timeout is due to network bandwidth on the server, see [Server side bandwidth exceeded](#server-side-bandwidth-exceeded).</span></span> <span data-ttu-id="dd817-276">Ha az időtúllépés okozza-e ügyfél hálózati sávszélesség, olvassa el [ügyfél oldalán sávszélesség túllépte](#client-side-bandwidth-exceeded).</span><span class="sxs-lookup"><span data-stu-id="dd817-276">To see if your timeout is due to client network bandwidth, see [Client side bandwidth exceeded](#client-side-bandwidth-exceeded).</span></span>
4. <span data-ttu-id="dd817-277">Ön az első CPU kötött a kiszolgálón, vagy az ügyfél?</span><span class="sxs-lookup"><span data-stu-id="dd817-277">Are you getting CPU bound on the server or on the client?</span></span>
   
   * <span data-ttu-id="dd817-278">Ellenőrizze, hogy ha Ön első kötött processzor az ügyfélen, amelyek miatt a kérelem feldolgozása nem lehetséges belül a `synctimeout` időköz, ami az időtúllépés miatt.</span><span class="sxs-lookup"><span data-stu-id="dd817-278">Check if you are getting bound by CPU on your client which could cause the request to not be processed within the `synctimeout` interval, thus causing a timeout.</span></span> <span data-ttu-id="dd817-279">Ügyfél nagyobb méretű áthelyezése vagy a terhelés elosztása segíthet szabályozza ezt.</span><span class="sxs-lookup"><span data-stu-id="dd817-279">Moving to a larger client size or distributing the load can help to control this.</span></span> 
   * <span data-ttu-id="dd817-280">Figyeli a kiszolgálón kötött jelölőnégyzetet, ha a Processzor a `CPU` [teljesítmény metrika gyorsítótár](cache-how-to-monitor.md#available-metrics-and-reporting-intervals).</span><span class="sxs-lookup"><span data-stu-id="dd817-280">Check if you are getting CPU bound on the server by monitoring the `CPU` [cache performance metric](cache-how-to-monitor.md#available-metrics-and-reporting-intervals).</span></span> <span data-ttu-id="dd817-281">Amíg Redis kötött Processzor várható okozhatják időtúllépési ezeket a kérelmeket.</span><span class="sxs-lookup"><span data-stu-id="dd817-281">Requests coming in while Redis is CPU bound can cause those requests to timeout.</span></span> <span data-ttu-id="dd817-282">Megoldható ez a terhelés szétosztását a prémium szintű gyorsítótár több szilánkok, vagy váltson egy nagyobb méretű vagy tarifacsomagot.</span><span class="sxs-lookup"><span data-stu-id="dd817-282">To address this you can distribute the load across multiple shards in a premium cache, or upgrade to a larger size or pricing tier.</span></span> <span data-ttu-id="dd817-283">További információkért lásd: [Server ügyféloldali sávszélesség túllépését](#server-side-bandwidth-exceeded).</span><span class="sxs-lookup"><span data-stu-id="dd817-283">For more information, see [Server Side Bandwidth Exceeded](#server-side-bandwidth-exceeded).</span></span>
5. <span data-ttu-id="dd817-284">Vannak-e a kiszolgálón feldolgozása hosszú ideig tart parancsok?</span><span class="sxs-lookup"><span data-stu-id="dd817-284">Are there commands taking long time to process on the server?</span></span> <span data-ttu-id="dd817-285">Hosszú ideig futó parancsokat, amelyek a redis-kiszolgáló feldolgozása hosszú ideig tart, időtúllépések okozhat.</span><span class="sxs-lookup"><span data-stu-id="dd817-285">Long running commands that are taking long time to process on the redis-server can cause timeouts.</span></span> <span data-ttu-id="dd817-286">Néhány példa a hosszú ideig futó parancsok `mget` kulcsok, ha sok felhasználóval rendelkező `keys *` vagy rosszul írt lua parancsfájlok.</span><span class="sxs-lookup"><span data-stu-id="dd817-286">Some examples of long running commands are `mget` with large numbers of keys, `keys *` or poorly written lua scripts.</span></span> <span data-ttu-id="dd817-287">Csatlakozás az Azure Redis Cache példány a redis-cli ügyfélprogrammal, vagy használja a [Redis konzol](cache-configure.md#redis-console) , és futtassa a [SlowLog](http://redis.io/commands/slowlog) parancs, ha van-e kérelmeket a vártnál tovább tart.</span><span class="sxs-lookup"><span data-stu-id="dd817-287">You can connect to your Azure Redis Cache instance using the redis-cli client or use the [Redis Console](cache-configure.md#redis-console) and run the [SlowLog](http://redis.io/commands/slowlog) command to see if there are requests taking longer than expected.</span></span> <span data-ttu-id="dd817-288">A redis-kiszolgáló és a StackExchange.Redis kevesebb nagy kérelmek helyett a sok kisméretű kérelem vannak optimalizálva.</span><span class="sxs-lookup"><span data-stu-id="dd817-288">Redis Server and StackExchange.Redis are optimized for many small requests rather than fewer large requests.</span></span> <span data-ttu-id="dd817-289">Az adatok felosztása kisebb adattömbökbe javíthatja a dolgok itt.</span><span class="sxs-lookup"><span data-stu-id="dd817-289">Splitting your data into smaller chunks may improve things here.</span></span> 
   
    <span data-ttu-id="dd817-290">A redis-cli és stunnel Azure Redis Cache SSL végpontjához csatlakozó információkért lásd: a [bejelentése ASP.NET munkamenetállapot-szolgáltatóját a Redis előzetes](http://blogs.msdn.com/b/webdev/archive/2014/05/12/announcing-asp-net-session-state-provider-for-redis-preview-release.aspx) blogbejegyzést.</span><span class="sxs-lookup"><span data-stu-id="dd817-290">For information on connecting to the Azure Redis Cache SSL endpoint using redis-cli and stunnel, see the [Announcing ASP.NET Session State Provider for Redis Preview Release](http://blogs.msdn.com/b/webdev/archive/2014/05/12/announcing-asp-net-session-state-provider-for-redis-preview-release.aspx) blog post.</span></span> <span data-ttu-id="dd817-291">További információkért lásd: [SlowLog](http://redis.io/commands/slowlog).</span><span class="sxs-lookup"><span data-stu-id="dd817-291">For more information, see [SlowLog](http://redis.io/commands/slowlog).</span></span>
6. <span data-ttu-id="dd817-292">Magas Redis-kiszolgáló terhelése okozhatja időtúllépések.</span><span class="sxs-lookup"><span data-stu-id="dd817-292">High Redis server load can cause timeouts.</span></span> <span data-ttu-id="dd817-293">A kiszolgáló terhelését figyeli a figyelheti a `Redis Server Load` [teljesítmény metrika gyorsítótár](cache-how-to-monitor.md#available-metrics-and-reporting-intervals).</span><span class="sxs-lookup"><span data-stu-id="dd817-293">You can monitor the server load by monitoring the `Redis Server Load` [cache performance metric](cache-how-to-monitor.md#available-metrics-and-reporting-intervals).</span></span> <span data-ttu-id="dd817-294">A kiszolgáló terhelését, 100 (maximális érték) azt jelzi, hogy a, a redis-kiszolgáló már foglalt, nem üresjárati idő a kérelmek feldolgozásához.</span><span class="sxs-lookup"><span data-stu-id="dd817-294">A server load of 100 (maximum value) signifies that the redis server has been busy, with no idle time, processing requests.</span></span> <span data-ttu-id="dd817-295">Ha bizonyos kérések a képesség másolatot tart megtekintéséhez futtassa a SlowLog parancsot az előző bekezdésben ismertetett módon.</span><span class="sxs-lookup"><span data-stu-id="dd817-295">To see if certain requests are taking up all of the server capability, run the SlowLog command, as described in the previous paragraph.</span></span> <span data-ttu-id="dd817-296">További információkért lásd: [magas CPU-használat / Server betöltési](#high-cpu-usage-server-load).</span><span class="sxs-lookup"><span data-stu-id="dd817-296">For more information, see [High CPU usage / Server Load](#high-cpu-usage-server-load).</span></span>
7. <span data-ttu-id="dd817-297">Történt más esemény, amely egy hálózati blip okozhatta ügyféloldali?</span><span class="sxs-lookup"><span data-stu-id="dd817-297">Was there any other event on the client side that could have caused a network blip?</span></span> <span data-ttu-id="dd817-298">Ha például az ügyfél-példányok száma skálázás felfelé vagy lefelé esemény történt, vagy az ügyfél vagy automatikus skálázása új verziójának telepítése nincs engedélyezve, ellenőrizze az ügyfélen (web-, feldolgozói szerepkör vagy egy infrastruktúra-szolgáltatási virtuális gép)? A találtunk, amelyeknek, hogy az automatikus skálázás vagy fel/le skálázás okozhat tesztelés során kimenő hálózati kapcsolat elveszhet néhány másodpercig.</span><span class="sxs-lookup"><span data-stu-id="dd817-298">Check on the client (web, worker role or an Iaas VM) if there was an event like scaling the number of client instances up or down, or deploying a new version of the client or auto-scale is enabled?In our testing we have found that autoscale or scaling up/down can cause outbound network connectivity can be lost for several seconds.</span></span> <span data-ttu-id="dd817-299">StackExchange.Redis kódot is lehetséges, hogy ezek az események, és újra fognak csatlakozni.</span><span class="sxs-lookup"><span data-stu-id="dd817-299">StackExchange.Redis code is resilient to such events and will reconnect.</span></span> <span data-ttu-id="dd817-300">Ebben az időszakban újbóli kapcsolat a várólistán lévő minden kérést is túllépi az időkorlátot.</span><span class="sxs-lookup"><span data-stu-id="dd817-300">During this time of re-connection any requests in the queue can time out.</span></span>
8. <span data-ttu-id="dd817-301">A Redis gyorsítótár, amely túllépte az időkorlátot a több kis kérelmek megelőző nagy kérés történt?</span><span class="sxs-lookup"><span data-stu-id="dd817-301">Was there a big request preceding several small requests to the Redis Cache that timed out?</span></span> <span data-ttu-id="dd817-302">A paraméter `qs` a hibás üzenet közli, hogy hány kérésnek az ügyféltől a kiszolgáló küldtek, de még nem dolgozott választ.</span><span class="sxs-lookup"><span data-stu-id="dd817-302">The parameter `qs` in the error message tells you how many requests were sent from the client to the server, but have not yet processed a response.</span></span> <span data-ttu-id="dd817-303">Ez az érték lehet egyre több adatra mert StackExchange.Redis egyetlen TCP-kapcsolatot használ, és csak olvasható egy válasz egyszerre.</span><span class="sxs-lookup"><span data-stu-id="dd817-303">This value can keep growing because StackExchange.Redis uses a single TCP connection and can only read one response at a time.</span></span> <span data-ttu-id="dd817-304">Annak ellenére, hogy az első művelet túllépte az időkorlátot, nem állítja le a küldött adatok mennyisége belőle a kiszolgáló, és más kérelmek le vannak tiltva, amíg ez befejeződött, ami időtúllépések.</span><span class="sxs-lookup"><span data-stu-id="dd817-304">Even though the first operation timed out, it does not stop the data being sent to/from the server, and other requests are blocked until this is finished, causing time outs.</span></span> <span data-ttu-id="dd817-305">Egy megoldás, időtúllépések a valószínűsége annak biztosítása, hogy a gyorsítótár mérete elegendő a számítási feladatok és a nagy értékek felosztása kisebb adattömbökbe minimalizálása érdekében.</span><span class="sxs-lookup"><span data-stu-id="dd817-305">One solution is to minimize the chance of timeouts by ensuring that your cache is large enough for your workload and splitting large values into smaller chunks.</span></span> <span data-ttu-id="dd817-306">Egy másik lehetséges megoldás, hogy készletét használja `ConnectionMultiplexer` az ügyfél objektumokat, és válassza a legalább betöltött `ConnectionMultiplexer` új kérelem küldésekor.</span><span class="sxs-lookup"><span data-stu-id="dd817-306">Another possible solution is to use a pool of `ConnectionMultiplexer` objects in your client, and choose the least loaded `ConnectionMultiplexer` when sending a new request.</span></span> <span data-ttu-id="dd817-307">Emiatt érdemes egyetlen időtúllépés küldött egyéb kérések számára is időtúllépés miatt.</span><span class="sxs-lookup"><span data-stu-id="dd817-307">This should prevent a single timeout from causing other requests to also timeout.</span></span>
9. <span data-ttu-id="dd817-308">Ha használ `RedisSessionStateprovider`, győződjön meg arról, az újrapróbálkozási időtúllépés helyesen van beállítva.</span><span class="sxs-lookup"><span data-stu-id="dd817-308">If you are using `RedisSessionStateprovider`, ensure you have set the retry timeout correctly.</span></span> <span data-ttu-id="dd817-309">`retrytimeoutInMilliseconds`nagyobbnak kell lennie `operationTimeoutinMilliseonds`, ellenkező esetben nem ismételt próbálkozás történik.</span><span class="sxs-lookup"><span data-stu-id="dd817-309">`retrytimeoutInMilliseconds` should be higher than `operationTimeoutinMilliseonds`, otherwise no retries will occur.</span></span> <span data-ttu-id="dd817-310">Az alábbi példában `retrytimeoutInMilliseconds` 3000 értékre van állítva.</span><span class="sxs-lookup"><span data-stu-id="dd817-310">In the following example `retrytimeoutInMilliseconds` is set to 3000.</span></span> <span data-ttu-id="dd817-311">További információkért lásd: [ASP.NET munkamenetállapot-szolgáltatóját az Azure Redis Cache](cache-aspnet-session-state-provider.md) és [a konfigurációs paraméterek munkamenetállapot-szolgáltatóját, és a kimeneti gyorsítótár-szolgáltató használatával](https://github.com/Azure/aspnet-redis-providers/wiki/Configuration).</span><span class="sxs-lookup"><span data-stu-id="dd817-311">For more information, see [ASP.NET Session State Provider for Azure Redis Cache](cache-aspnet-session-state-provider.md) and [How to use the configuration parameters of Session State Provider and Output Cache Provider](https://github.com/Azure/aspnet-redis-providers/wiki/Configuration).</span></span>

    <add
      name="AFRedisCacheSessionStateProvider"
      type="Microsoft.Web.Redis.RedisSessionStateProvider"
      host="enbwcache.redis.cache.windows.net"
      port="6380"
      accessKey="…"
      ssl="true"
      databaseId="0"
      applicationName="AFRedisCacheSessionState"
      connectionTimeoutInMilliseconds = "5000"
      operationTimeoutInMilliseconds = "1000"
      retryTimeoutInMilliseconds="3000" />


1. <span data-ttu-id="dd817-312">Ellenőrizze a memóriahasználat az Azure Redis gyorsítótár-kiszolgáló a [figyelési](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) `Used Memory RSS` és `Used Memory`.</span><span class="sxs-lookup"><span data-stu-id="dd817-312">Check memory usage on the Azure Redis Cache server by [monitoring](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) `Used Memory RSS` and `Used Memory`.</span></span> <span data-ttu-id="dd817-313">Egy kiürítés házirend van beállítva, ha kezdődik-e a Redis való kulcsok mikor `Used_Memory` eléri a gyorsítótár méretét.</span><span class="sxs-lookup"><span data-stu-id="dd817-313">If an eviction policy is in place, Redis starts evicting keys when `Used_Memory` reaches the cache size.</span></span> <span data-ttu-id="dd817-314">Ideális esetben `Used Memory RSS` csak kell valamivel nagyobb, mint `Used memory`.</span><span class="sxs-lookup"><span data-stu-id="dd817-314">Ideally, `Used Memory RSS` should be only slightly higher than `Used memory`.</span></span> <span data-ttu-id="dd817-315">A nagy különbség jelenti, hogy a memória töredezettségét (belső vagy külső.</span><span class="sxs-lookup"><span data-stu-id="dd817-315">A large difference means there is memory fragmentation (internal or external.</span></span> <span data-ttu-id="dd817-316">Ha `Used Memory RSS` értéke kisebb, mint `Used Memory`, az azt jelenti, hogy a gyorsítótár-memória részét rendelkezik lett cserélve az operációs rendszer.</span><span class="sxs-lookup"><span data-stu-id="dd817-316">When `Used Memory RSS` is less than `Used Memory`, it means part of the cache memory has been swapped  by the operating system.</span></span> <span data-ttu-id="dd817-317">Ez akkor fordul elő, ha várhatóan néhány jelentős késések fordulnak elő.</span><span class="sxs-lookup"><span data-stu-id="dd817-317">If this occurs you can expect some significant latencies.</span></span> <span data-ttu-id="dd817-318">A Redis nincs szabályozhatják, hogyan a hozzárendelések vannak leképezve memórialapokat, magas `Used Memory RSS` oka általában egy csúcs az igények memória használata.</span><span class="sxs-lookup"><span data-stu-id="dd817-318">Because Redis does not have control over how its allocations are mapped to memory pages, high `Used Memory RSS` is often the result of a spike in memory usage.</span></span> <span data-ttu-id="dd817-319">Amikor Redis felszabadítja a memória, a memória rendelkezésére áll vissza a foglaló és a foglaló is, vagy előfordulhat, hogy nem biztosítják a memória vissza a rendszer.</span><span class="sxs-lookup"><span data-stu-id="dd817-319">When Redis frees memory, the memory is given back to the allocator, and the allocator may or may not give the memory back to the system.</span></span> <span data-ttu-id="dd817-320">Előfordulhat, hogy közötti ellentmondás a `Used Memory` érték és a memória-felhasználás az operációs rendszer által jelentett módon.</span><span class="sxs-lookup"><span data-stu-id="dd817-320">There may be a discrepancy between the `Used Memory` value and memory consumption as reported by the operating system.</span></span> <span data-ttu-id="dd817-321">Lehet, hogy az a tény miatt memória használt és megtörtént, amely a Redis, de nem adott vissza, a rendszer.</span><span class="sxs-lookup"><span data-stu-id="dd817-321">It may be due to the fact memory has been used and released by Redis, but not given back to the system.</span></span> <span data-ttu-id="dd817-322">Memória problémák csökkentése érdekében a következőket végezheti el.</span><span class="sxs-lookup"><span data-stu-id="dd817-322">To help mitigate memory issues you can perform the following steps.</span></span>
   
   * <span data-ttu-id="dd817-323">A gyorsítótár frissítése nagyobb méretűre, hogy nem használ találkoznak memóriahasználatra vonatkozó korlátozásai a rendszer.</span><span class="sxs-lookup"><span data-stu-id="dd817-323">Upgrade the cache to a larger size so that you are not running up against memory limitations on the system.</span></span>
   * <span data-ttu-id="dd817-324">A kulcsok lejárati idejének beállítására, hogy a régebbi értékek proaktív ki vannak zárva.</span><span class="sxs-lookup"><span data-stu-id="dd817-324">Set expiration times on the keys so that older values are evicted proactively.</span></span>
   * <span data-ttu-id="dd817-325">A figyelő a a `used_memory_rss` metrika gyorsítótárazza.</span><span class="sxs-lookup"><span data-stu-id="dd817-325">Monitor the the `used_memory_rss` cache metric.</span></span> <span data-ttu-id="dd817-326">Ha ez az érték megközelíti a gyorsítótár méretét, akkor valószínűleg teljesítményproblémák kezdenek el.</span><span class="sxs-lookup"><span data-stu-id="dd817-326">When this value approaches the size of their cache, you are likely to start seeing performance issues.</span></span> <span data-ttu-id="dd817-327">Ha a prémium szintű gyorsítótárazással, vagy váltson a gyorsítótár méretének az adatok szét több szegmensben osztják.</span><span class="sxs-lookup"><span data-stu-id="dd817-327">Distribute the data across multiple shards if you are using a premium cache, or upgrade to a larger cache size.</span></span>
   
   <span data-ttu-id="dd817-328">További információkért lásd: [a kiszolgáló Memóriaterhelése](#memory-pressure-on-the-server).</span><span class="sxs-lookup"><span data-stu-id="dd817-328">For more information, see [Memory Pressure on the server](#memory-pressure-on-the-server).</span></span>

## <a name="additional-information"></a><span data-ttu-id="dd817-329">További információ</span><span class="sxs-lookup"><span data-stu-id="dd817-329">Additional information</span></span>
* [<span data-ttu-id="dd817-330">Melyik Redis Cache-ajánlatot és -méretet használjam?</span><span class="sxs-lookup"><span data-stu-id="dd817-330">What Redis Cache offering and size should I use?</span></span>](cache-faq.md#what-redis-cache-offering-and-size-should-i-use)
* [<span data-ttu-id="dd817-331">Hogyan elvégez egy teljesítménytesztet és a gyorsítótár teljesítményének a tesztelésére?</span><span class="sxs-lookup"><span data-stu-id="dd817-331">How can I benchmark and test the performance of my cache?</span></span>](cache-faq.md#how-can-i-benchmark-and-test-the-performance-of-my-cache)
* [<span data-ttu-id="dd817-332">Hogyan futtathatom Redis parancsok?</span><span class="sxs-lookup"><span data-stu-id="dd817-332">How can I run Redis commands?</span></span>](cache-faq.md#how-can-i-run-redis-commands)
* [<span data-ttu-id="dd817-333">Azure Redis Cache figyelése</span><span class="sxs-lookup"><span data-stu-id="dd817-333">How to monitor Azure Redis Cache</span></span>](cache-how-to-monitor.md)

